{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/data.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/data.ts"],"sourcesContent":["import { BaseContentBlock } from \"./base.js\";\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type ImageDetail = \"auto\" | \"low\" | \"high\";\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type MessageContentText = {\n  type: \"text\";\n  text: string;\n};\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type MessageContentImageUrl = {\n  type: \"image_url\";\n  image_url: string | { url: string; detail?: ImageDetail };\n};\n\n/**\n * @deprecated\n * Use {@link ContentBlock} instead.\n */\nexport type MessageContentComplex =\n  | MessageContentText\n  | MessageContentImageUrl\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | (Record<string, any> & { type?: \"text\" | \"image_url\" | string })\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | (Record<string, any> & { type?: never });\n\nexport type Data = never;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Data {\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface BaseDataContentBlock extends BaseContentBlock {\n    mime_type?: string;\n    metadata?: Record<string, unknown>;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface URLContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"url\";\n    url: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface Base64ContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"base64\";\n    data: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface PlainTextContentBlock extends BaseDataContentBlock {\n    type: \"file\" | \"text\";\n    source_type: \"text\";\n    text: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface IDContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"id\";\n    id: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type DataContentBlock =\n    | URLContentBlock\n    | Base64ContentBlock\n    | PlainTextContentBlock\n    | IDContentBlock;\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardImageBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n  ) & {\n    type: \"image\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardAudioBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n  ) & {\n    type: \"audio\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardFileBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n    | PlainTextContentBlock\n  ) & {\n    type: \"file\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardTextBlock = PlainTextContentBlock & {\n    type: \"text\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export type DataContentBlockType = DataContentBlock[\"type\"];\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isDataContentBlock(\n  content_block: object\n): content_block is Data.DataContentBlock {\n  return (\n    typeof content_block === \"object\" &&\n    content_block !== null &&\n    \"type\" in content_block &&\n    typeof content_block.type === \"string\" &&\n    \"source_type\" in content_block &&\n    (content_block.source_type === \"url\" ||\n      content_block.source_type === \"base64\" ||\n      content_block.source_type === \"text\" ||\n      content_block.source_type === \"id\")\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isURLContentBlock(\n  content_block: object\n): content_block is Data.URLContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"url\" &&\n    \"url\" in content_block &&\n    typeof content_block.url === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isBase64ContentBlock(\n  content_block: object\n): content_block is Data.Base64ContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"base64\" &&\n    \"data\" in content_block &&\n    typeof content_block.data === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isPlainTextContentBlock(\n  content_block: object\n): content_block is Data.PlainTextContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"text\" &&\n    \"text\" in content_block &&\n    typeof content_block.text === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isIDContentBlock(\n  content_block: object\n): content_block is Data.IDContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"id\" &&\n    \"id\" in content_block &&\n    typeof content_block.id === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function convertToOpenAIImageBlock(\n  content_block: Data.URLContentBlock | Data.Base64ContentBlock\n) {\n  if (isDataContentBlock(content_block)) {\n    if (content_block.source_type === \"url\") {\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: content_block.url,\n        },\n      };\n    }\n    if (content_block.source_type === \"base64\") {\n      if (!content_block.mime_type) {\n        throw new Error(\"mime_type key is required for base64 data.\");\n      }\n      const mime_type = content_block.mime_type;\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: `data:${mime_type};base64,${content_block.data}`,\n        },\n      };\n    }\n  }\n  throw new Error(\n    \"Unsupported source type. Only 'url' and 'base64' are supported.\"\n  );\n}\n\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseMimeType(mime_type: string): {\n  type: string;\n  subtype: string;\n  parameters: Record<string, string>;\n} {\n  const parts = mime_type.split(\";\")[0].split(\"/\");\n  if (parts.length !== 2) {\n    throw new Error(\n      `Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`\n    );\n  }\n\n  const type = parts[0].trim();\n  const subtype = parts[1].trim();\n\n  if (type === \"\" || subtype === \"\") {\n    throw new Error(\n      `Invalid mime type: \"${mime_type}\" - type or subtype is empty.`\n    );\n  }\n\n  const parameters: Record<string, string> = {};\n\n  for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n    const parameterParts = parameterKvp.split(\"=\");\n    if (parameterParts.length !== 2) {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n    const key = parameterParts[0].trim();\n    const value = parameterParts[1].trim();\n    if (key === \"\") {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n\n    parameters[key] = value;\n  }\n\n  return {\n    type,\n    subtype,\n    parameters,\n  };\n}\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns An object containing the parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl,\n  asTypedArray,\n}: {\n  dataUrl: string;\n  asTypedArray: true;\n}): { data: Uint8Array; mime_type: string } | undefined;\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl,\n  asTypedArray,\n}: {\n  dataUrl: string;\n  asTypedArray?: false;\n}): { data: string; mime_type: string } | undefined;\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl: data_url,\n  asTypedArray = false,\n}: {\n  dataUrl: string;\n  asTypedArray?: boolean;\n}): { data: string | Uint8Array; mime_type: string } | undefined {\n  const formatMatch = data_url.match(\n    /^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/\n  );\n  let mime_type: string | undefined;\n\n  if (formatMatch) {\n    mime_type = formatMatch[1].toLowerCase();\n    const data = asTypedArray\n      ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0))\n      : formatMatch[2];\n    return {\n      mime_type,\n      data,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * A bag of provider-specific content block types.\n *\n * Allows implementations of {@link StandardContentBlockConverter} and related to be defined only in\n * terms of the types they support. Also allows for forward compatibility as the set of known\n * standard types grows, as the set of types can be extended without breaking existing\n * implementations of the aforementioned interfaces.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type ProviderFormatTypes<\n  TextFormat = unknown,\n  ImageFormat = unknown,\n  AudioFormat = unknown,\n  FileFormat = unknown,\n  VideoFormat = unknown\n> = {\n  text: TextFormat;\n  image: ImageFormat;\n  audio: AudioFormat;\n  file: FileFormat;\n  video: VideoFormat;\n};\n\n/**\n * Utility interface for converting between standard and provider-specific data content blocks, to be\n * used when implementing chat model providers.\n *\n * Meant to be used with {@link convertToProviderContentBlock} and\n * {@link convertToStandardContentBlock} rather than being consumed directly.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport interface StandardContentBlockConverter<\n  Formats extends Partial<ProviderFormatTypes>\n> {\n  /**\n   * The name of the provider type that corresponds to the provider-specific content block types\n   * that this converter supports.\n   */\n  providerName: string;\n\n  /**\n   * Convert from a standard image block to a provider's proprietary image block format.\n   * @param block - The standard image block to convert.\n   * @returns The provider image block.\n   */\n  fromStandardImageBlock?(block: Data.StandardImageBlock): Formats[\"image\"];\n\n  /**\n   * Convert from a standard audio block to a provider's proprietary audio block format.\n   * @param block - The standard audio block to convert.\n   * @returns The provider audio block.\n   */\n  fromStandardAudioBlock?(block: Data.StandardAudioBlock): Formats[\"audio\"];\n\n  /**\n   * Convert from a standard file block to a provider's proprietary file block format.\n   * @param block - The standard file block to convert.\n   * @returns The provider file block.\n   */\n  fromStandardFileBlock?(block: Data.StandardFileBlock): Formats[\"file\"];\n\n  /**\n   * Convert from a standard text block to a provider's proprietary text block format.\n   * @param block - The standard text block to convert.\n   * @returns The provider text block.\n   */\n  fromStandardTextBlock?(block: Data.StandardTextBlock): Formats[\"text\"];\n}\n\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function convertToProviderContentBlock<\n  Formats extends Partial<ProviderFormatTypes>\n>(\n  block: Data.DataContentBlock,\n  converter: StandardContentBlockConverter<Formats>\n): Formats[keyof Formats] {\n  if (block.type === \"text\") {\n    if (!converter.fromStandardTextBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`\n      );\n    }\n    return converter.fromStandardTextBlock(block as Data.StandardTextBlock);\n  }\n  if (block.type === \"image\") {\n    if (!converter.fromStandardImageBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`\n      );\n    }\n    return converter.fromStandardImageBlock(block as Data.StandardImageBlock);\n  }\n  if (block.type === \"audio\") {\n    if (!converter.fromStandardAudioBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`\n      );\n    }\n    return converter.fromStandardAudioBlock(block as Data.StandardAudioBlock);\n  }\n  if (block.type === \"file\") {\n    if (!converter.fromStandardFileBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`\n      );\n    }\n    return converter.fromStandardFileBlock(block as Data.StandardFileBlock);\n  }\n  throw new Error(\n    `Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`\n  );\n}\n"],"names":["content_block: object","content_block: Data.URLContentBlock | Data.Base64ContentBlock","mime_type: string","parameters: Record<string, string>","mime_type: string | undefined","block: Data.DataContentBlock","converter: StandardContentBlockConverter<Formats>"],"mappings":"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"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/utils.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/utils.ts"],"sourcesContent":["import type { ContentBlock } from \"../content/index.js\";\n\nexport function _isContentBlock<T extends string>(\n  block: unknown,\n  type: T\n): block is ContentBlock & { type: T } {\n  return _isObject(block) && block.type === type;\n}\n\nexport function _isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null;\n}\n\nexport function _isArray<T>(value: unknown): value is T[] {\n  return Array.isArray(value);\n}\n\nexport function _isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function _isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\nexport function _isBytesArray(value: unknown): value is Uint8Array {\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  return value instanceof Uint8Array;\n}\n\nexport function safeParseJson<T = unknown>(value: string): T | undefined {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return undefined;\n  }\n}\n\nexport const iife = <T>(fn: () => T): T => fn();\n"],"names":["block: unknown","type: T","value: unknown","value: string","fn: () => T"],"mappings":";AAEA,SAAgB,gBACdA,KAAAA,EACAC,IAAAA,EACqC;IACrC,OAAO,UAAU,MAAM,IAAI,MAAM,IAAA,KAAS;AAC3C;AAED,SAAgB,UAAUC,KAAAA,EAAkD;IAC1E,OAAO,OAAO,UAAU,YAAY,UAAU;AAC/C;AAED,SAAgB,SAAYA,KAAAA,EAA8B;IACxD,OAAO,MAAM,OAAA,CAAQ,MAAM;AAC5B;AAED,SAAgB,UAAUA,KAAAA,EAAiC;IACzD,OAAO,OAAO,UAAU;AACzB;AAED,SAAgB,UAAUA,KAAAA,EAAiC;IACzD,OAAO,OAAO,UAAU;AACzB;AAED,SAAgB,cAAcA,KAAAA,EAAqC;IAEjE,OAAO,iBAAiB;AACzB;AAED,SAAgB,cAA2BC,KAAAA,EAA8B;IACvE,IAAI;QACF,OAAO,KAAK,KAAA,CAAM,MAAM;IACzB,EAAA,OAAO;QACN,OAAO,KAAA;IACR;AACF;AAED,MAAa,OAAO,CAAIC,KAAmB,IAAI"}},
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/anthropic.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/anthropic.ts"],"sourcesContent":["import type { StandardContentBlockTranslator } from \"./index.js\";\nimport type { ContentBlock } from \"../content/index.js\";\nimport type { AIMessageChunk, AIMessage } from \"../ai.js\";\nimport type { BaseMessage, BaseMessageChunk } from \"../base.js\";\nimport {\n  _isArray,\n  _isContentBlock,\n  _isNumber,\n  _isObject,\n  _isString,\n  safeParseJson,\n  iife,\n} from \"./utils.js\";\n\nfunction convertAnthropicAnnotation(\n  citation: ContentBlock\n): ContentBlock.Citation | undefined {\n  if (\n    citation.type === \"char_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_char_index) &&\n    _isNumber(citation.end_char_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_char_index,\n      end_char_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"char\",\n      title: document_title ?? undefined,\n      startIndex: start_char_index,\n      endIndex: end_char_index,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"page_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_page_number) &&\n    _isNumber(citation.end_page_number) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_page_number,\n      end_page_number,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"page\",\n      title: document_title ?? undefined,\n      startIndex: start_page_number,\n      endIndex: end_page_number,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"content_block_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_block_index) &&\n    _isNumber(citation.end_block_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_block_index,\n      end_block_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"block\",\n      title: document_title ?? undefined,\n      startIndex: start_block_index,\n      endIndex: end_block_index,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"web_search_result_location\" &&\n    _isString(citation.url) &&\n    _isString(citation.title) &&\n    _isString(citation.encrypted_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const { url, title, encrypted_index, cited_text, ...rest } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"url\",\n      url,\n      title,\n      startIndex: Number(encrypted_index),\n      endIndex: Number(encrypted_index),\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"search_result_location\" &&\n    _isString(citation.source) &&\n    _isString(citation.title) &&\n    _isNumber(citation.start_block_index) &&\n    _isNumber(citation.end_block_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      source,\n      title,\n      start_block_index,\n      end_block_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"search\",\n      url: source,\n      title: title ?? undefined,\n      startIndex: start_block_index,\n      endIndex: end_block_index,\n      citedText: cited_text,\n    };\n  }\n  return undefined;\n}\n\n/**\n * Converts an Anthropic content block to a standard V1 content block.\n *\n * This function handles the conversion of Anthropic-specific content blocks\n * (document and image blocks) to the standardized V1 format. It supports\n * various source types including base64 data, URLs, file IDs, and text data.\n *\n * @param block - The Anthropic content block to convert\n * @returns A standard V1 content block if conversion is successful, undefined otherwise\n *\n * @example\n * ```typescript\n * const anthropicBlock = {\n *   type: \"image\",\n *   source: {\n *     type: \"base64\",\n *     media_type: \"image/png\",\n *     data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==\"\n *   }\n * };\n *\n * const standardBlock = convertToV1FromAnthropicContentBlock(anthropicBlock);\n * // Returns: { type: \"image\", mimeType: \"image/png\", data: \"...\" }\n * ```\n */\nexport function convertToV1FromAnthropicContentBlock(\n  block: ContentBlock\n): ContentBlock.Standard | undefined {\n  if (\n    _isContentBlock(block, \"document\") &&\n    _isObject(block.source) &&\n    \"type\" in block.source\n  ) {\n    if (\n      block.source.type === \"base64\" &&\n      _isString(block.source.media_type) &&\n      _isString(block.source.data)\n    ) {\n      return {\n        type: \"file\",\n        mimeType: block.source.media_type,\n        data: block.source.data,\n      };\n    } else if (block.source.type === \"url\" && _isString(block.source.url)) {\n      return {\n        type: \"file\",\n        url: block.source.url,\n      };\n    } else if (\n      block.source.type === \"file\" &&\n      _isString(block.source.file_id)\n    ) {\n      return {\n        type: \"file\",\n        fileId: block.source.file_id,\n      };\n    } else if (block.source.type === \"text\" && _isString(block.source.data)) {\n      return {\n        type: \"file\",\n        mimeType: String(block.source.media_type ?? \"text/plain\"),\n        data: block.source.data,\n      };\n    }\n  } else if (\n    _isContentBlock(block, \"image\") &&\n    _isObject(block.source) &&\n    \"type\" in block.source\n  ) {\n    if (\n      block.source.type === \"base64\" &&\n      _isString(block.source.media_type) &&\n      _isString(block.source.data)\n    ) {\n      return {\n        type: \"image\",\n        mimeType: block.source.media_type,\n        data: block.source.data,\n      };\n    } else if (block.source.type === \"url\" && _isString(block.source.url)) {\n      return {\n        type: \"image\",\n        url: block.source.url,\n      };\n    } else if (\n      block.source.type === \"file\" &&\n      _isString(block.source.file_id)\n    ) {\n      return {\n        type: \"image\",\n        fileId: block.source.file_id,\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Converts an array of content blocks from Anthropic format to v1 standard format.\n *\n * This function processes each content block in the input array, attempting to convert\n * Anthropic-specific block formats (like image blocks with source objects, document blocks, etc.)\n * to the standardized v1 content block format. If a block cannot be converted, it is\n * passed through as-is with a type assertion to ContentBlock.Standard.\n *\n * @param content - Array of content blocks in Anthropic format to be converted\n * @returns Array of content blocks in v1 standard format\n */\nexport function convertToV1FromAnthropicInput(\n  content: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    for (const block of content) {\n      const stdBlock = convertToV1FromAnthropicContentBlock(block);\n      if (stdBlock) {\n        yield stdBlock;\n      } else {\n        yield block as ContentBlock.Standard;\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\n/**\n * Converts an Anthropic AI message to an array of v1 standard content blocks.\n *\n * This function processes an AI message containing Anthropic-specific content blocks\n * and converts them to the standardized v1 content block format.\n *\n * @param message - The AI message containing Anthropic-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage([\n *   { type: \"text\", text: \"Hello world\" },\n *   { type: \"thinking\", text: \"Let me think about this...\" },\n *   { type: \"tool_use\", id: \"123\", name: \"calculator\", input: { a: 1, b: 2 } }\n * ]);\n *\n * const standardBlocks = convertToV1FromAnthropicMessage(message);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello world\" },\n * //   { type: \"reasoning\", reasoning: \"Let me think about this...\" },\n * //   { type: \"tool_call\", id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * // ]\n * ```\n */\nexport function convertToV1FromAnthropicMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      // TextBlock\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        const { text, citations, ...rest } = block;\n        if (_isArray(citations) && citations.length) {\n          const _citations = citations.reduce<ContentBlock.Citation[]>(\n            (acc, item) => {\n              const citation = convertAnthropicAnnotation(item as ContentBlock);\n              if (citation) {\n                return [...acc, citation];\n              }\n              return acc;\n            },\n            []\n          );\n          yield {\n            ...rest,\n            type: \"text\",\n            text,\n            annotations: _citations,\n          };\n          continue;\n        } else {\n          yield {\n            ...rest,\n            type: \"text\",\n            text,\n          };\n          continue;\n        }\n      }\n      // ThinkingBlock\n      else if (\n        _isContentBlock(block, \"thinking\") &&\n        _isString(block.thinking)\n      ) {\n        const { thinking, signature, ...rest } = block;\n        yield {\n          ...rest,\n          type: \"reasoning\",\n          reasoning: thinking,\n          signature,\n        };\n        continue;\n      }\n      // RedactedThinkingBlock\n      else if (_isContentBlock(block, \"redacted_thinking\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      }\n      // ToolUseBlock\n      else if (\n        _isContentBlock(block, \"tool_use\") &&\n        _isString(block.name) &&\n        _isString(block.id)\n      ) {\n        yield {\n          type: \"tool_call\",\n          id: block.id,\n          name: block.name,\n          args: block.input,\n        };\n        continue;\n      }\n      // message chunks can have input_json_delta contents\n      else if (_isContentBlock(block, \"input_json_delta\")) {\n        if (_isAIMessageChunk(message) && message.tool_call_chunks?.length) {\n          const tool_call_chunk = message.tool_call_chunks[0];\n          yield {\n            type: \"tool_call_chunk\",\n            id: tool_call_chunk.id,\n            name: tool_call_chunk.name,\n            args: tool_call_chunk.args,\n            index: tool_call_chunk.index,\n          };\n          continue;\n        }\n      }\n      // ServerToolUseBlock\n      else if (\n        _isContentBlock(block, \"server_tool_use\") &&\n        _isString(block.name) &&\n        _isString(block.id)\n      ) {\n        const { name, id } = block;\n        if (name === \"web_search\") {\n          const query = iife(() => {\n            if (typeof block.input === \"string\") {\n              return block.input;\n            } else if (_isObject(block.input) && _isString(block.input.query)) {\n              return block.input.query;\n            } else if (_isString(block.partial_json)) {\n              const json = safeParseJson<{ query?: string }>(\n                block.partial_json\n              );\n              if (json?.query) {\n                return json.query;\n              }\n            }\n            return \"\";\n          });\n          yield {\n            id,\n            type: \"server_tool_call\",\n            name: \"web_search\",\n            args: { query },\n          };\n          continue;\n        } else if (block.name === \"code_execution\") {\n          const code = iife(() => {\n            if (typeof block.input === \"string\") {\n              return block.input;\n            } else if (_isObject(block.input) && _isString(block.input.code)) {\n              return block.input.code;\n            } else if (_isString(block.partial_json)) {\n              const json = safeParseJson<{ code?: string }>(block.partial_json);\n              if (json?.code) {\n                return json.code;\n              }\n            }\n            return \"\";\n          });\n          yield {\n            id,\n            type: \"server_tool_call\",\n            name: \"code_execution\",\n            args: { code },\n          };\n          continue;\n        }\n      }\n      // WebSearchToolResultBlock\n      else if (\n        _isContentBlock(block, \"web_search_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isArray(block.content)\n      ) {\n        const { content, tool_use_id } = block;\n        const urls = content.reduce<string[]>((acc, content) => {\n          if (_isContentBlock(content, \"web_search_result\")) {\n            return [...acc, content.url as string];\n          }\n          return acc;\n        }, []);\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"web_search\",\n          toolCallId: tool_use_id,\n          status: \"success\",\n          output: {\n            urls,\n          },\n        };\n        continue;\n      }\n      // CodeExecutionToolResultBlock\n      else if (\n        _isContentBlock(block, \"code_execution_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isObject(block.content)\n      ) {\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"code_execution\",\n          toolCallId: block.tool_use_id,\n          status: \"success\",\n          output: block.content,\n        };\n        continue;\n      }\n      // MCPToolUseBlock\n      else if (_isContentBlock(block, \"mcp_tool_use\")) {\n        yield {\n          id: block.id,\n          type: \"server_tool_call\",\n          name: \"mcp_tool_use\",\n          args: block.input,\n        };\n        continue;\n      }\n      // MCPToolResultBlock\n      else if (\n        _isContentBlock(block, \"mcp_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isObject(block.content)\n      ) {\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"mcp_tool_use\",\n          toolCallId: block.tool_use_id,\n          status: \"success\",\n          output: block.content,\n        };\n        continue;\n      }\n      // ContainerUploadBlock\n      else if (_isContentBlock(block, \"container_upload\")) {\n        yield {\n          type: \"server_tool_call\",\n          name: \"container_upload\",\n          args: block.input,\n        };\n        continue;\n      }\n      // SearchResultBlockParam\n      else if (_isContentBlock(block, \"search_result\")) {\n        yield { id: block.id, type: \"non_standard\", value: block };\n        continue;\n      }\n      // ToolResultBlockParam\n      else if (_isContentBlock(block, \"tool_result\")) {\n        yield { id: block.id, type: \"non_standard\", value: block };\n        continue;\n      } else {\n        // For all other blocks, we try to convert them to a standard block\n        const stdBlock = convertToV1FromAnthropicContentBlock(block);\n        if (stdBlock) {\n          yield stdBlock;\n          continue;\n        }\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatAnthropicTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromAnthropicMessage,\n  translateContentChunk: convertToV1FromAnthropicMessage,\n};\n\nfunction _isAIMessageChunk(message: unknown): message is AIMessageChunk {\n  return (\n    typeof (message as BaseMessage)?._getType === \"function\" &&\n    typeof (message as BaseMessageChunk).concat === \"function\" &&\n    (message as BaseMessageChunk)._getType() === \"ai\"\n  );\n}\n"],"names":["citation: ContentBlock","_isString","_isNumber","block: ContentBlock","_isContentBlock","_isObject","content: Array<ContentBlock>","message: AIMessage","_isArray","iife","safeParseJson","content","ChatAnthropicTranslator: StandardContentBlockTranslator","message: unknown"],"mappings":"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"}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/data.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/data.ts"],"sourcesContent":["import {\n  parseBase64DataUrl,\n  isBase64ContentBlock,\n  isIDContentBlock,\n  isURLContentBlock,\n} from \"../content/data.js\";\nimport type { ContentBlock } from \"../content/index.js\";\nimport { _isContentBlock, _isObject, _isString } from \"./utils.js\";\n\nexport function convertToV1FromDataContentBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (isURLContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type,\n      url: block.url,\n      metadata: block.metadata,\n    };\n  }\n  if (isBase64ContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type ?? \"application/octet-stream\",\n      data: block.data,\n      metadata: block.metadata,\n    };\n  }\n  if (isIDContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type,\n      fileId: block.id,\n      metadata: block.metadata,\n    };\n  }\n  return block as ContentBlock.Standard;\n}\n\nexport function convertToV1FromDataContent(\n  content: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  return content.map(convertToV1FromDataContentBlock);\n}\n\nexport function isOpenAIDataBlock(block: ContentBlock): boolean {\n  if (_isContentBlock(block, \"image_url\") && _isObject(block.image_url)) {\n    return true;\n  }\n  if (_isContentBlock(block, \"input_audio\") && _isObject(block.input_audio)) {\n    return true;\n  }\n  if (_isContentBlock(block, \"file\") && _isObject(block.file)) {\n    return true;\n  }\n  return false;\n}\n\nexport function convertToV1FromOpenAIDataBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (\n    _isContentBlock(block, \"image_url\") &&\n    _isObject(block.image_url) &&\n    _isString(block.image_url.url)\n  ) {\n    const parsed = parseBase64DataUrl({ dataUrl: block.image_url.url });\n    if (parsed) {\n      return {\n        type: \"image\",\n        mimeType: parsed.mime_type,\n        data: parsed.data,\n      };\n    } else {\n      return {\n        type: \"image\",\n        url: block.image_url.url,\n      };\n    }\n  } else if (\n    _isContentBlock(block, \"input_audio\") &&\n    _isObject(block.input_audio) &&\n    _isString(block.input_audio.data) &&\n    _isString(block.input_audio.format)\n  ) {\n    return {\n      type: \"audio\",\n      data: block.input_audio.data,\n      mimeType: `audio/${block.input_audio.format}`,\n    };\n  } else if (\n    _isContentBlock(block, \"file\") &&\n    _isObject(block.file) &&\n    _isString(block.file.data)\n  ) {\n    const parsed = parseBase64DataUrl({ dataUrl: block.file.data });\n    if (parsed) {\n      return {\n        type: \"file\",\n        data: parsed.data,\n        mimeType: parsed.mime_type,\n      };\n    } else if (_isString(block.file.file_id)) {\n      return {\n        type: \"file\",\n        fileId: block.file.file_id,\n      };\n    }\n  }\n  return block as ContentBlock.Standard;\n}\n"],"names":["block: ContentBlock","isURLContentBlock","isBase64ContentBlock","isIDContentBlock","content: Array<ContentBlock>","_isContentBlock","_isObject","_isString","parseBase64DataUrl"],"mappings":";;;AASA,SAAgB,gCACdA,KAAAA,EACuB;IACvB,IAAIC,aAAAA,iBAAAA,CAAkB,MAAM,CAC1B,CAAA,OAAO;QACL,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,SAAA;QAChB,KAAK,MAAM,GAAA;QACX,UAAU,MAAM,QAAA;IACjB;IAEH,IAAIC,aAAAA,oBAAAA,CAAqB,MAAM,CAC7B,CAAA,OAAO;QACL,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,SAAA,IAAa;QAC7B,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,QAAA;IACjB;IAEH,IAAIC,aAAAA,gBAAAA,CAAiB,MAAM,CACzB,CAAA,OAAO;QACL,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,SAAA;QAChB,QAAQ,MAAM,EAAA;QACd,UAAU,MAAM,QAAA;IACjB;IAEH,OAAO;AACR;AAED,SAAgB,2BACdC,OAAAA,EAC8B;IAC9B,OAAO,QAAQ,GAAA,CAAI,gCAAgC;AACpD;AAED,SAAgB,kBAAkBJ,KAAAA,EAA8B;IAC9D,IAAIK,cAAAA,eAAAA,CAAgB,OAAO,YAAY,IAAIC,cAAAA,SAAAA,CAAU,MAAM,SAAA,CAAU,CACnE,CAAA,OAAO;IAET,IAAID,cAAAA,eAAAA,CAAgB,OAAO,cAAc,IAAIC,cAAAA,SAAAA,CAAU,MAAM,WAAA,CAAY,CACvE,CAAA,OAAO;IAET,IAAID,cAAAA,eAAAA,CAAgB,OAAO,OAAO,IAAIC,cAAAA,SAAAA,CAAU,MAAM,IAAA,CAAK,CACzD,CAAA,OAAO;IAET,OAAO;AACR;AAED,SAAgB,+BACdN,KAAAA,EACuB;IACvB,IACEK,cAAAA,eAAAA,CAAgB,OAAO,YAAY,IACnCC,cAAAA,SAAAA,CAAU,MAAM,SAAA,CAAU,IAC1BC,cAAAA,SAAAA,CAAU,MAAM,SAAA,CAAU,GAAA,CAAI,EAC9B;QACA,MAAM,SAASC,aAAAA,kBAAAA,CAAmB;YAAE,SAAS,MAAM,SAAA,CAAU,GAAA;QAAK,EAAC;QACnE,IAAI,OACF,CAAA,OAAO;YACL,MAAM;YACN,UAAU,OAAO,SAAA;YACjB,MAAM,OAAO,IAAA;QACd;aAED,OAAO;YACL,MAAM;YACN,KAAK,MAAM,SAAA,CAAU,GAAA;QACtB;IAEJ,OAAA,IACCH,cAAAA,eAAAA,CAAgB,OAAO,cAAc,IACrCC,cAAAA,SAAAA,CAAU,MAAM,WAAA,CAAY,IAC5BC,cAAAA,SAAAA,CAAU,MAAM,WAAA,CAAY,IAAA,CAAK,IACjCA,cAAAA,SAAAA,CAAU,MAAM,WAAA,CAAY,MAAA,CAAO,CAEnC,CAAA,OAAO;QACL,MAAM;QACN,MAAM,MAAM,WAAA,CAAY,IAAA;QACxB,UAAU,CAAC,MAAM,EAAE,MAAM,WAAA,CAAY,MAAA,EAAQ;IAC9C;aAEDF,cAAAA,eAAAA,CAAgB,OAAO,OAAO,IAC9BC,cAAAA,SAAAA,CAAU,MAAM,IAAA,CAAK,IACrBC,cAAAA,SAAAA,CAAU,MAAM,IAAA,CAAK,IAAA,CAAK,EAC1B;QACA,MAAM,SAASC,aAAAA,kBAAAA,CAAmB;YAAE,SAAS,MAAM,IAAA,CAAK,IAAA;QAAM,EAAC;QAC/D,IAAI,OACF,CAAA,OAAO;YACL,MAAM;YACN,MAAM,OAAO,IAAA;YACb,UAAU,OAAO,SAAA;QAClB;iBACQD,cAAAA,SAAAA,CAAU,MAAM,IAAA,CAAK,OAAA,CAAQ,CACtC,CAAA,OAAO;YACL,MAAM;YACN,QAAQ,MAAM,IAAA,CAAK,OAAA;QACpB;IAEJ;IACD,OAAO;AACR"}},
    {"offset": {"line": 636, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/openai.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/openai.ts"],"sourcesContent":["import type { ContentBlock } from \"../content/index.js\";\nimport type { AIMessageChunk, AIMessage } from \"../ai.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { convertToV1FromOpenAIDataBlock, isOpenAIDataBlock } from \"./data.js\";\nimport {\n  _isArray,\n  _isContentBlock,\n  _isObject,\n  _isString,\n  iife,\n} from \"./utils.js\";\n\n/**\n * Converts a ChatOpenAICompletions message to an array of v1 standard content blocks.\n *\n * This function processes an AI message from ChatOpenAICompletions API format\n * and converts it to the standardized v1 content block format. It handles both\n * string content and structured content blocks, as well as tool calls.\n *\n * @param message - The AI message containing ChatOpenAICompletions formatted content\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage(\"Hello world\");\n * const standardBlocks = convertToV1FromChatCompletions(message);\n * // Returns: [{ type: \"text\", text: \"Hello world\" }]\n * ```\n *\n * @example\n * ```typescript\n * const message = new AIMessage([\n *   { type: \"text\", text: \"Hello\" },\n *   { type: \"image_url\", image_url: { url: \"https://example.com/image.png\" } }\n * ]);\n * message.tool_calls = [\n *   { id: \"call_123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletions(message);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello\" },\n * //   { type: \"image\", url: \"https://example.com/image.png\" },\n * //   { type: \"tool_call\", id: \"call_123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletions(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  const blocks: Array<ContentBlock.Standard> = [];\n  if (typeof message.content === \"string\") {\n    blocks.push({\n      type: \"text\",\n      text: message.content,\n    });\n  } else {\n    blocks.push(...convertToV1FromChatCompletionsInput(message.content));\n  }\n  for (const toolCall of message.tool_calls ?? []) {\n    blocks.push({\n      type: \"tool_call\",\n      id: toolCall.id,\n      name: toolCall.name,\n      args: toolCall.args,\n    });\n  }\n  return blocks;\n}\n\n/**\n * Converts a ChatOpenAICompletions message chunk to an array of v1 standard content blocks.\n *\n * This function processes an AI message chunk from OpenAI's chat completions API and converts\n * it to the standardized v1 content block format. It handles both string and array content,\n * as well as tool calls that may be present in the chunk.\n *\n * @param message - The AI message chunk containing OpenAI-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const chunk = new AIMessage(\"Hello\");\n * const standardBlocks = convertToV1FromChatCompletionsChunk(chunk);\n * // Returns: [{ type: \"text\", text: \"Hello\" }]\n * ```\n *\n * @example\n * ```typescript\n * const chunk = new AIMessage([\n *   { type: \"text\", text: \"Processing...\" }\n * ]);\n * chunk.tool_calls = [\n *   { id: \"call_456\", name: \"search\", args: { query: \"test\" } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletionsChunk(chunk);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Processing...\" },\n * //   { type: \"tool_call\", id: \"call_456\", name: \"search\", args: { query: \"test\" } }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletionsChunk(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  const blocks: Array<ContentBlock.Standard> = [];\n  if (typeof message.content === \"string\") {\n    blocks.push({\n      type: \"text\",\n      text: message.content,\n    });\n  } else {\n    blocks.push(...convertToV1FromChatCompletionsInput(message.content));\n  }\n\n  // TODO: parse chunk position information\n  for (const toolCall of message.tool_calls ?? []) {\n    blocks.push({\n      type: \"tool_call\",\n      id: toolCall.id,\n      name: toolCall.name,\n      args: toolCall.args,\n    });\n  }\n  return blocks;\n}\n\n/**\n * Converts an array of ChatOpenAICompletions content blocks to v1 standard content blocks.\n *\n * This function processes content blocks from OpenAI's Chat Completions API format\n * and converts them to the standardized v1 content block format. It handles both\n * OpenAI-specific data blocks (which require conversion) and standard blocks\n * (which are passed through with type assertion).\n *\n * @param blocks - Array of content blocks in ChatOpenAICompletions format\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const openaiBlocks = [\n *   { type: \"text\", text: \"Hello world\" },\n *   { type: \"image_url\", image_url: { url: \"https://example.com/image.png\" } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletionsInput(openaiBlocks);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello world\" },\n * //   { type: \"image\", url: \"https://example.com/image.png\" }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletionsInput(\n  blocks: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  const convertedBlocks: Array<ContentBlock.Standard> = [];\n  for (const block of blocks) {\n    if (isOpenAIDataBlock(block)) {\n      convertedBlocks.push(convertToV1FromOpenAIDataBlock(block));\n    } else {\n      convertedBlocks.push(block as ContentBlock.Standard);\n    }\n  }\n  return convertedBlocks;\n}\n\nfunction convertResponsesAnnotation(\n  annotation: ContentBlock\n): ContentBlock | ContentBlock.Citation {\n  if (annotation.type === \"url_citation\") {\n    const { url, title, start_index, end_index } = annotation;\n    return {\n      type: \"citation\",\n      url,\n      title,\n      startIndex: start_index,\n      endIndex: end_index,\n    };\n  }\n  if (annotation.type === \"file_citation\") {\n    const { file_id, filename, index } = annotation;\n    return {\n      type: \"citation\",\n      title: filename,\n      startIndex: index,\n      endIndex: index,\n      fileId: file_id,\n    };\n  }\n  return annotation;\n}\n\n/**\n * Converts a ChatOpenAIResponses message to an array of v1 standard content blocks.\n *\n * This function processes an AI message containing OpenAI Responses-specific content blocks\n * and converts them to the standardized v1 content block format. It handles reasoning summaries,\n * text content with annotations, tool calls, and various tool outputs including code interpreter,\n * web search, file search, computer calls, and MCP-related blocks.\n *\n * @param message - The AI message containing OpenAI Responses-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage({\n *   content: [{ type: \"text\", text: \"Hello world\", annotations: [] }],\n *   tool_calls: [{ id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } }],\n *   additional_kwargs: {\n *     reasoning: { summary: [{ text: \"Let me calculate this...\" }] },\n *     tool_outputs: [\n *       {\n *         type: \"code_interpreter_call\",\n *         code: \"print('hello')\",\n *         outputs: [{ type: \"logs\", logs: \"hello\" }]\n *       }\n *     ]\n *   }\n * });\n *\n * const standardBlocks = convertToV1FromResponses(message);\n * // Returns:\n * // [\n * //   { type: \"reasoning\", reasoning: \"Let me calculate this...\" },\n * //   { type: \"text\", text: \"Hello world\", annotations: [] },\n * //   { type: \"tool_call\", id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } },\n * //   { type: \"code_interpreter_call\", code: \"print('hello')\" },\n * //   { type: \"code_interpreter_result\", output: [{ type: \"code_interpreter_output\", returnCode: 0, stdout: \"hello\" }] }\n * // ]\n * ```\n */\nexport function convertToV1FromResponses(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    if (\n      _isObject(message.additional_kwargs?.reasoning) &&\n      _isArray(message.additional_kwargs.reasoning.summary)\n    ) {\n      const summary =\n        message.additional_kwargs.reasoning.summary.reduce<string>(\n          (acc, item) => {\n            if (_isObject(item) && _isString(item.text)) {\n              return `${acc}${item.text}`;\n            }\n            return acc;\n          },\n          \"\"\n        );\n      yield {\n        type: \"reasoning\",\n        reasoning: summary,\n      };\n    }\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"text\")) {\n        const { text, annotations, ...rest } = block;\n        if (Array.isArray(annotations)) {\n          yield {\n            ...rest,\n            type: \"text\",\n            text: String(text),\n            annotations: annotations.map(convertResponsesAnnotation),\n          };\n        } else {\n          yield {\n            ...rest,\n            type: \"text\",\n            text: String(text),\n          };\n        }\n      }\n    }\n    for (const toolCall of message.tool_calls ?? []) {\n      yield {\n        type: \"tool_call\",\n        id: toolCall.id,\n        name: toolCall.name,\n        args: toolCall.args,\n      };\n    }\n    if (\n      _isObject(message.additional_kwargs) &&\n      _isArray(message.additional_kwargs.tool_outputs)\n    ) {\n      for (const toolOutput of message.additional_kwargs.tool_outputs) {\n        if (_isContentBlock(toolOutput, \"web_search_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"web_search\",\n            args: { query: toolOutput.query },\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"file_search_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"file_search\",\n            args: { query: toolOutput.query },\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"computer_call\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"code_interpreter_call\")) {\n          if (_isString(toolOutput.code)) {\n            yield {\n              id: toolOutput.id,\n              type: \"server_tool_call\",\n              name: \"code_interpreter\",\n              args: { code: toolOutput.code },\n            };\n          }\n          if (_isArray(toolOutput.outputs)) {\n            const returnCode = iife(() => {\n              if (toolOutput.status === \"in_progress\") return undefined;\n              if (toolOutput.status === \"completed\") return 0;\n              if (toolOutput.status === \"incomplete\") return 127;\n              if (toolOutput.status === \"interpreting\") return undefined;\n              if (toolOutput.status === \"failed\") return 1;\n              return undefined;\n            });\n            for (const output of toolOutput.outputs) {\n              if (_isContentBlock(output, \"logs\")) {\n                yield {\n                  type: \"server_tool_call_result\",\n                  toolCallId: toolOutput.id ?? \"\",\n                  status: \"success\",\n                  output: {\n                    type: \"code_interpreter_output\",\n                    returnCode: returnCode ?? 0,\n                    stderr: [0, undefined].includes(returnCode)\n                      ? undefined\n                      : String(output.logs),\n                    stdout: [0, undefined].includes(returnCode)\n                      ? String(output.logs)\n                      : undefined,\n                  },\n                };\n                continue;\n              }\n            }\n          }\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"mcp_call\",\n            args: toolOutput.input,\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_list_tools\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"mcp_list_tools\",\n            args: toolOutput.input,\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_approval_request\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"image_generation_call\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        }\n        if (_isObject(toolOutput)) {\n          yield { type: \"non_standard\", value: toolOutput };\n        }\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\n/**\n * Converts a ChatOpenAIResponses message chunk to an array of v1 standard content blocks.\n *\n * This function processes an AI message chunk containing OpenAI-specific content blocks\n * and converts them to the standardized v1 content block format. It handles both the\n * regular message content and tool call chunks that are specific to streaming responses.\n *\n * @param message - The AI message chunk containing OpenAI-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const messageChunk = new AIMessageChunk({\n *   content: [{ type: \"text\", text: \"Hello\" }],\n *   tool_call_chunks: [\n *     { id: \"call_123\", name: \"calculator\", args: '{\"a\": 1' }\n *   ]\n * });\n *\n * const standardBlocks = convertToV1FromResponsesChunk(messageChunk);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello\" },\n * //   { type: \"tool_call_chunk\", id: \"call_123\", name: \"calculator\", args: '{\"a\": 1' }\n * // ]\n * ```\n */\nexport function convertToV1FromResponsesChunk(\n  message: AIMessageChunk\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    yield* convertToV1FromResponses(message);\n    for (const toolCallChunk of message.tool_call_chunks ?? []) {\n      yield {\n        type: \"tool_call_chunk\",\n        id: toolCallChunk.id,\n        name: toolCallChunk.name,\n        args: toolCallChunk.args,\n      };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatOpenAITranslator: StandardContentBlockTranslator = {\n  translateContent: (message) => {\n    if (typeof message.content === \"string\") {\n      return convertToV1FromChatCompletions(message);\n    }\n    return convertToV1FromResponses(message);\n  },\n  translateContentChunk: (message) => {\n    if (typeof message.content === \"string\") {\n      return convertToV1FromChatCompletionsChunk(message);\n    }\n    return convertToV1FromResponsesChunk(message);\n  },\n};\n"],"names":["message: AIMessage","blocks: Array<ContentBlock.Standard>","blocks: Array<ContentBlock>","convertedBlocks: Array<ContentBlock.Standard>","isOpenAIDataBlock","convertToV1FromOpenAIDataBlock","annotation: ContentBlock","_isObject","_isArray","_isString","_isContentBlock","iife","message: AIMessageChunk","ChatOpenAITranslator: StandardContentBlockTranslator"],"mappings":"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"}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/message.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/message.ts"],"sourcesContent":["import type { ContentBlock } from \"./content/index.js\";\nimport type { ResponseMetadata, UsageMetadata } from \"./metadata.js\";\nimport type { $MergeDiscriminatedUnion, $MergeObjects } from \"./utils.js\";\n\n/**\n * Represents the possible types of messages in the system.\n * Includes standard message types (\"ai\", \"human\", \"tool\", \"system\")\n * and allows for custom string types that are non-null.\n *\n * @example\n * ```ts\n * // Standard message types\n * const messageType1: MessageType = \"ai\";\n * const messageType2: MessageType = \"human\";\n *\n * // Custom message type\n * const messageType3: MessageType = \"custom_type\";\n * ```\n */\nexport type MessageType =\n  | \"ai\"\n  | \"human\"\n  | \"tool\"\n  | \"system\"\n  | (string & NonNullable<unknown>);\n\n/**\n * Represents the output version format for message content.\n *\n * This type determines how the content field is structured in a message:\n * - \"v0\": Content is represented as a simple string or array of content blocks\n *   - provides backward compatibility with simpler content representations\n * - \"v1\": Content follows the structured ContentBlock format with typed discriminated unions\n *   - enables full type safety and structured content block handling\n *\n * @example\n * ```ts\n * // v0 format - simple content representation\n * const v0Message: Message<{ outputVersion: \"v0\", content: ... }> = {\n *   type: \"human\",\n *   content: \"Hello world\" // string | Array<ContentBlock | ContentBlock.Text>\n * };\n *\n * // v1 format - structured content blocks\n * const v1Message: Message<{ outputVersion: \"v1\", content: ... }> = {\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello world\" },\n *     { type: \"image\", image_url: \"...\" }\n *   ] // Array<ContentBlock | ...> (determined by the structure)\n * };\n * ```\n */\nexport type MessageOutputVersion = \"v0\" | \"v1\";\n\n/**\n * Represents the input and output types of a tool that can be used in messages.\n *\n * @template TInput - The type of input the tool accepts.\n * @template TOutput - The type of output the tool produces.\n *\n * @example\n * ```ts\n * // Tool that takes a string input and returns a number\n * interface StringToNumberTool extends MessageToolDefinition<string, number> {\n *   input: string;\n *   output: number;\n * }\n * ```\n */\nexport interface MessageToolDefinition<TInput = unknown, TOutput = unknown> {\n  input: TInput;\n  output: TOutput;\n}\n\n/**\n * Represents a structured set of tools by mapping tool names to definitions\n * that can be used in messages.\n *\n * @example\n * ```ts\n * interface MyToolSet extends MessageToolSet {\n *   calculator: MessageToolDefinition<\n *     { operation: string; numbers: number[] },\n *     number\n *   >;\n *   translator: MessageToolDefinition<\n *     { text: string; targetLanguage: string },\n *     string\n *   >;\n * }\n * ```\n */\nexport interface MessageToolSet {\n  [key: string]: MessageToolDefinition;\n}\n\n/**\n * Represents a tool call block within a message structure by mapping tool names to their\n * corresponding tool call formats, including the input arguments and an optional identifier.\n *\n * @template TStructure - A message structure type that may contain tool definitions\n *\n * @example\n * ```ts\n * // Given a message structure with a calculator tool:\n * interface MyStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<{ operation: string, numbers: number[] }, number>\n *   }\n * }\n *\n * // The tool call block would be:\n * type CalcToolCall = $MessageToolCallBlock<MyStructure>;\n * // Resolves to:\n * // {\n * //   type: \"tool_call\";\n * //   name: \"calculator\";\n * //   args: { operation: string, numbers: number[] };\n * //   id?: string;\n * // }\n * ```\n */\nexport type $MessageToolCallBlock<TStructure extends MessageStructure> =\n  TStructure[\"tools\"] extends MessageToolSet\n    ? {\n        [K in keyof TStructure[\"tools\"]]: K extends string\n          ? TStructure[\"tools\"][K] extends MessageToolDefinition\n            ? ContentBlock.Tools.ToolCall<K, TStructure[\"tools\"][K][\"input\"]>\n            : never\n          : never;\n      }[keyof TStructure[\"tools\"]]\n    : never;\n\n/**\n * Core interface that defines the structure of messages.\n *\n * @example\n * ```ts\n * // Basic message structure with just content blocks\n * interface SimpleMessageStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     // allows for text + reasoning blocks in ai messages\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   }\n * }\n *\n * // Message structure with tools and properties\n * interface AdvancedMessageStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<\n *       { operation: string; numbers: number[] },\n *       number\n *     >;\n *   };\n *   content: {\n *     // allows for text + image blocks in human messages\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *     // only allows for text blocks in ai messages\n *     ai: ContentBlock.Text;\n *   };\n *   properties: {\n *     // pins properties to ai messages\n *     ai: {\n *       response_metadata: {\n *         confidence: number;\n *         model: string;\n *       };\n *     };\n *   }\n * }\n *\n * // Using with $MergeMessageStructure to combine structures\n * // The resulting type when passed into BaseMessage will have a calculator tool,\n * // allow for text + image blocks in human messages,\n * // and text + reasoning blocks + additional arbitrary properties in ai messages.\n * type CombinedStructure = $MergeMessageStructure<\n *   SimpleMessageStructure,\n *   AdvancedMessageStructure\n * >;\n *\n * // Using in a Message object\n * const message: Message<CombinedStructure> = {\n *   id: \"msg-123\",\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" }\n *     { type: \"image\", mimeType: \"image/jpeg\", url: \"https://example.com/image.jpg\" }\n *     // this block will throw an error because it's not defined in the structure\n *     { type: \"reasoning\", reasoning: \"The answer is 42\" }\n *   ]\n * };\n * ```\n */\nexport interface MessageStructure {\n  /**\n   * Optional output version for the message structure.\n   * If not provided, defaults to \"v0\".\n   */\n  readonly outputVersion?: MessageOutputVersion;\n  /**\n   * Optional set of tool definitions that can be used in messages.\n   * Each tool is defined with input/output types and can be referenced in tool messages.\n   */\n  readonly tools?: MessageToolSet;\n  /**\n   * Optional mapping of message types to their allowed content blocks.\n   * Each message type can specify what content block types it supports (text, images, etc).\n   */\n  readonly content?: Partial<{\n    [key in MessageType]: ContentBlock;\n  }>;\n  /**\n   * Optional mapping of message types to arbitrary property objects.\n   * Allows attaching custom metadata or other information to specific message types.\n   */\n  readonly properties?: Partial<{\n    [key in MessageType]: Record<string, unknown>;\n  }>;\n}\n\n/**\n * Normalizes an arbitrary type to a message output version or undefined.\n * Accepts unknown and narrows to a valid MessageOutputVersion if present.\n */\ntype $NormalizeMessageOutputVersion<T> =\n  | Extract<T, MessageOutputVersion>\n  | undefined;\n\n/**\n * Merges two output version types from message structures.\n *\n * This utility type determines the resulting output version when combining two message structures.\n * The merge logic follows these rules:\n *\n * - If both T and U are undefined, defaults to \"v0\" for backwards compatibility\n * - If T is undefined but U is defined, uses U's version\n * - If U is undefined but T is defined, uses T's version\n * - If both T and U are defined, U takes precedence (later structure wins)\n *\n * @template T - The output version from the first message structure\n * @template U - The output version from the second message structure\n *\n * @example\n * ```ts\n * // Both undefined - defaults to \"v0\"\n * type Result1 = $MergeOutputVersion<undefined, undefined>; // \"v0\"\n *\n * // One defined - uses the defined version\n * type Result2 = $MergeOutputVersion<undefined, \"v1\">; // \"v1\"\n * type Result3 = $MergeOutputVersion<\"v0\", undefined>; // \"v0\"\n *\n * // Both defined - second takes precedence\n * type Result4 = $MergeOutputVersion<\"v0\", \"v1\">; // \"v1\"\n * ```\n */\nexport type $MergeOutputVersion<T, U> =\n  $NormalizeMessageOutputVersion<T> extends infer TV\n    ? $NormalizeMessageOutputVersion<U> extends infer UV\n      ? [TV, UV] extends [undefined, undefined]\n        ? \"v0\"\n        : [TV] extends [undefined]\n        ? Exclude<UV, undefined>\n        : [UV] extends [undefined]\n        ? Exclude<TV, undefined>\n        : UV\n      : never\n    : never;\n\n/**\n * Merges two content definition objects from message structures.\n *\n * This utility type combines content definitions from two message structures, handling\n * the merging of content block types for each message type. The merge logic follows\n * these rules:\n *\n * - For keys that exist in both T and U: Merges the content blocks using discriminated\n *   union merging based on the \"type\" property. This allows combining different content\n *   block types (e.g., text + image) for the same message type.\n * - For keys that exist only in T: Uses T's content definition as-is\n * - For keys that exist only in U: Uses U's content definition as-is\n *\n * @template T - The content definition from the first message structure\n * @template U - The content definition from the second message structure\n *\n * @example\n * ```ts\n * // T allows text content for human messages\n * type ContentA = {\n *   human: ContentBlock.Text;\n * };\n *\n * // U allows image content for human messages and text for AI messages\n * type ContentB = {\n *   human: ContentBlock.Multimodal.Image;\n *   ai: ContentBlock.Text;\n * };\n *\n * // Merged result allows both text and images for human messages, text for AI\n * type Merged = $MergeContentDefinition<ContentA, ContentB>;\n * // Result: {\n * //   human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n * //   ai: ContentBlock.Text;\n * // }\n * ```\n */\nexport type $MergeContentDefinition<T, U> = {\n  [K in keyof T | keyof U as Extract<\n    (K extends keyof T ? T[K] : never) | (K extends keyof U ? U[K] : never),\n    ContentBlock\n  > extends never\n    ? never\n    : K]: K extends keyof T\n    ? K extends keyof U\n      ? $MergeDiscriminatedUnion<\n          Extract<T[K], ContentBlock>,\n          Extract<U[K], ContentBlock>,\n          \"type\"\n        >\n      : Extract<T[K], ContentBlock>\n    : K extends keyof U\n    ? Extract<U[K], ContentBlock>\n    : never;\n};\n\n/**\n * Merges two message structures A and B into a combined structure.\n * This is a type utility that handles merging of tools, content blocks, and properties\n * from two message structures. The resulting type is usable as its own message structure.\n *\n * @example\n * ```ts\n * // Structure A allows text in human messages and has a confidence property on AI messages\n * interface StructureA extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *   };\n *   properties: {\n *     ai: { confidence: number };\n *   }\n * }\n *\n * // Structure B allows images in human messages and has a model property on AI messages\n * interface StructureB extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Multimodal.Image;\n *   };\n *   properties: {\n *     ai: { model: string };\n *   }\n * }\n *\n * // Merged structure allows both text and images in human messages\n * // AI messages have both confidence and model properties\n * type Merged = $MergeMessageStructure<StructureA, StructureB>;\n * ```\n *\n * @template A - First message structure to merge\n * @template B - Second message structure to merge (takes precedence over A)\n */\nexport type $MergeMessageStructure<\n  T extends MessageStructure,\n  U extends MessageStructure\n> = {\n  outputVersion: $MergeOutputVersion<T[\"outputVersion\"], U[\"outputVersion\"]>;\n  tools: $MergeObjects<T[\"tools\"], U[\"tools\"]>;\n  content: $MergeContentDefinition<T[\"content\"], U[\"content\"]>;\n  properties: $MergeObjects<T[\"properties\"], U[\"properties\"]>;\n};\n\n/**\n * Standard message structured used to define the most basic message structure that's\n * used throughout the library.\n *\n * This is also the message structure that's used when a message structure is not provided.\n */\nexport interface StandardMessageStructure extends MessageStructure {\n  content: {\n    /** Text content for AI messages */\n    ai: ContentBlock.Text;\n    /** Text content for human messages */\n    human: ContentBlock.Text;\n    /** Text content for system messages */\n    system: ContentBlock.Text;\n    /** Text content for tool messages */\n    tool: ContentBlock.Text;\n  };\n  properties: {\n    /** Properties specific to AI messages */\n    ai: {\n      /** Metadata about the AI model response */\n      response_metadata: ResponseMetadata;\n      /** Usage statistics for the AI response */\n      usage_metadata: UsageMetadata;\n    };\n    human: {\n      /** Metadata about the human message */\n      response_metadata: Record<string, unknown>;\n    };\n    system: {\n      /** Metadata about the system message */\n      response_metadata: Record<string, unknown>;\n    };\n    tool: {\n      /** Metadata about the tool message */\n      response_metadata: Record<string, unknown>;\n    };\n  };\n}\n\n/**\n * Takes a message structure type T and normalizes it by merging it with the standard message structure.\n * If T is already a standard message structure, returns T unchanged.\n *\n * This ensures that any custom message structure includes all the standard message structure fields\n * by default while allowing overrides and extensions.\n *\n * @template T - The message structure type to normalize, must extend MessageStructure\n * @returns Either T if it's already a standard structure, or the merged result of T with standard structure\n */\nexport type $NormalizedMessageStructure<T extends MessageStructure> =\n  T extends StandardMessageStructure\n    ? T\n    : $MergeMessageStructure<StandardMessageStructure, T>;\n\n/**\n * Infers the content blocks for a specific message type in a message structure.\n *\n * This utility type extracts the content block type that corresponds to a given message type\n * from the message structure's content definition.\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content block type for the specified type, or never if its not defined in the structure\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContent = $InferMessageContentBlocks<MyStructure, \"human\">;\n * // HumanContent = ContentBlock.Text\n *\n * type AIContent = $InferMessageContentBlocks<MyStructure, \"ai\">;\n * // AIContent = ContentBlock.Text | ContentBlock.ToolCall\n * ```\n */\nexport type $InferMessageContentBlocks<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $NormalizedMessageStructure<TStructure> extends infer S\n  ? S extends MessageStructure\n    ? S[\"content\"] extends infer C\n      ? C extends Record<PropertyKey, ContentBlock>\n        ? TRole extends keyof C\n          ? [$MessageToolCallBlock<TStructure>] extends [never]\n            ? C[TRole]\n            : $MergeDiscriminatedUnion<\n                NonNullable<C[TRole]>,\n                $MessageToolCallBlock<TStructure>,\n                \"type\"\n              >\n          : never\n        : never\n      : never\n    : never\n  : never;\n\n/**\n * Infers the content type for a specific message type from a message structure.\n *\n * This utility type determines the appropriate content type based on the message structure's\n * output version and the specified message type. The content type varies depending on the\n * output version (see {@link MessageOutputVersion})\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content type for the specified role based on the output version\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   outputVersion: \"v0\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContentV0 = $InferMessageContent<MyStructure, \"human\">;\n * // HumanContentV0 = string | Array<ContentBlock | ContentBlock.Text>\n *\n * interface MyStructureV1 extends MessageStructure {\n *   outputVersion: \"v1\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   };\n * }\n *\n * type HumanContentV1 = $InferMessageContent<MyStructureV1, \"human\">;\n * // HumanContentV1 = ContentBlock.Text\n *\n * type AIContentV1 = $InferMessageContent<MyStructureV1, \"ai\">;\n * // AIContentV1 = ContentBlock.Text | ContentBlock.Reasoning\n * ```\n */\nexport type $InferMessageContent<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = TStructure[\"outputVersion\"] extends \"v1\"\n  ? Array<$InferMessageContentBlocks<TStructure, TRole>>\n  : string | Array<ContentBlock | ContentBlock.Text>;\n\n/**\n * Infers the properties for a specific message type from a message structure.\n *\n * This utility type extracts the properties object that corresponds to a given message type\n * from the message structure's properties definition, and excludes the reserved\n * \"content\" and \"type\" properties to avoid conflicts with the core message structure.\n *\n * If the specified type is not defined in the message structure's properties, it returns\n * a generic Record<string, unknown> type to allow for arbitrary properties.\n *\n * @template TStructure - The message structure to infer properties from\n * @template TRole - The message type/role to get properties for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The properties object type for the specified type, excluding \"content\" and \"type\"\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string };\n *       usage_metadata: { tokens: number };\n *       content: string; // This will be omitted\n *       type: string;    // This will be omitted\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIProperties = $InferMessageProperties<MyStructure, \"ai\">;\n * // AIProperties = { response_metadata: { model: string }; usage_metadata: { tokens: number } }\n *\n * type HumanProperties = $InferMessageProperties<MyStructure, \"human\">;\n * // HumanProperties = { metadata: Record<string, unknown> }\n *\n * type SystemProperties = $InferMessageProperties<MyStructure, \"system\">;\n * // SystemProperties = Record<string, unknown> (fallback for undefined role)\n * ```\n */\nexport type $InferMessageProperties<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $NormalizedMessageStructure<TStructure> extends infer S\n  ? S extends MessageStructure\n    ? S[\"properties\"] extends infer P | undefined\n      ? P extends Record<PropertyKey, unknown>\n        ? TRole extends keyof P\n          ? Omit<P[TRole], \"content\" | \"type\">\n          : Record<string, unknown>\n        : Record<string, unknown>\n      : Record<string, unknown>\n    : never\n  : never;\n\n/**\n * Infers the type of a specific property for a message type from a message structure.\n *\n * This utility type extracts the type of a single property by name from the properties\n * object that corresponds to a given message type. If the specified property key does\n * not exist in the type's properties, it returns `never`.\n *\n * @template TStructure - The message structure to infer the property from\n * @template TRole - The message type/role to get the property for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @template K - The property key to extract the type for\n * @returns The type of the specified property, or `never` if the property doesn't exist\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number };\n *       usage_metadata: { input_tokens: number; output_tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type ResponseMetadata = $InferMessageProperty<MyStructure, \"ai\", \"response_metadata\">;\n * // ResponseMetadata = { model: string; temperature: number }\n *\n * type UsageMetadata = $InferMessageProperty<MyStructure, \"ai\", \"usage_metadata\">;\n * // UsageMetadata = { input_tokens: number; output_tokens: number }\n *\n * type NonExistentProperty = $InferMessageProperty<MyStructure, \"ai\", \"nonExistent\">;\n * // NonExistentProperty = Record<string, unknown>\n *\n * type HumanMetadata = $InferMessageProperty<MyStructure, \"human\", \"metadata\">;\n * // HumanMetadata = Record<string, unknown>\n * ```\n */\nexport type $InferMessageProperty<\n  TStructure extends MessageStructure,\n  TRole extends MessageType,\n  K extends string\n> = K extends keyof $InferMessageProperties<TStructure, TRole>\n  ? $InferMessageProperties<TStructure, TRole>[K]\n  : never;\n\n/**\n * Infers the response metadata type for a specific message type from a message structure.\n *\n * This utility type extracts the `response_metadata` property type for a given message type.\n *\n * @template TStructure - The message structure to infer the response metadata from\n * @template TRole - The message type/role to get the response metadata for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The type of the response_metadata property, or `Record<string, unknown>` as fallback\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number; tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIResponseMetadata = $InferResponseMetadata<MyStructure, \"ai\">;\n * // AIResponseMetadata = { model: string; temperature: number; tokens: number }\n *\n * type HumanResponseMetadata = $InferResponseMetadata<MyStructure, \"human\">;\n * // HumanResponseMetadata = Record<string, unknown> (fallback since not defined)\n * ```\n */\nexport type $InferResponseMetadata<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $InferMessageProperty<\n  TStructure,\n  TRole,\n  \"response_metadata\"\n> extends infer P\n  ? [P] extends [never]\n    ? Record<string, unknown>\n    : P\n  : never;\n\n/**\n * Represents a message object that organizes context for an LLM.\n *\n * @example\n * ```ts\n * // Basic message with text content\n * const message: Message = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"human\",\n *   content: [{ type: \"text\", text: \"Hello!\" }]\n * };\n *\n * // Basic ai message interface extension\n * interface MyMessage extends Message<StandardMessageStructure, \"ai\"> {\n *   // Additional AI-specific properties can be added here\n * }\n *`\n * // Custom message structure\n * interface CustomStructure extends MessageStructure {\n *   content: {\n *     ai: ContentBlock.Text | ContentBlock.ToolCall<\"search\", { query: string }>;\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *   };\n * }\n *\n * // Create a message with custom structure\n * const message: Message<CustomStructure> = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"ai\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" },\n *     {\n *       type: \"tool_call\",\n *       name: \"search\",\n *       args: { query: \"What is the capital of France?\" }\n *     }\n *   ]\n * };\n * ```\n */\nexport interface Message<\n  TStructure extends MessageStructure = StandardMessageStructure,\n  TRole extends MessageType = MessageType\n> {\n  /** The message type/role */\n  readonly type: TRole;\n  /** Unique identifier for this message */\n  id?: string;\n  /** Optional name/identifier for the entity that created this message */\n  name?: string;\n  /** Array of content blocks that make up the message content */\n  content: $InferMessageContent<TStructure, TRole>;\n  /** Metadata about the message */\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n}\n\n/**\n * Type guard to check if a value is a valid Message object.\n *\n * @param message - The value to check\n * @returns true if the value is a valid Message object, false otherwise\n */\nexport function isMessage(message: unknown): message is Message {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"type\" in message &&\n    \"content\" in message &&\n    (typeof message.content === \"string\" || Array.isArray(message.content))\n  );\n}\n"],"names":["message: unknown"],"mappings":";;;;;;GAitBA,SAAgB,UAAUA,OAAAA,EAAsC;IAC9D,OACE,OAAO,YAAY,YACnB,YAAY,QACZ,UAAU,WACV,aAAa,WAAA,CACZ,OAAO,QAAQ,OAAA,KAAY,YAAY,MAAM,OAAA,CAAQ,QAAQ,OAAA,CAAQ;AAEzE"}},
    {"offset": {"line": 1039, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/format.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/format.ts"],"sourcesContent":["import { type BaseMessage } from \"./base.js\";\nimport { type AIMessage } from \"./ai.js\";\nimport { type ToolMessage } from \"./tool.js\";\n\nexport type MessageStringFormat = \"pretty\";\n\nexport function convertToFormattedString(\n  message: BaseMessage,\n  format: MessageStringFormat = \"pretty\"\n): string {\n  if (format === \"pretty\") return convertToPrettyString(message);\n  return JSON.stringify(message);\n}\n\nfunction convertToPrettyString(message: BaseMessage): string {\n  const lines: string[] = [];\n  const title = ` ${\n    message.type.charAt(0).toUpperCase() + message.type.slice(1)\n  } Message `;\n  const sepLen = Math.floor((80 - title.length) / 2);\n  const sep = \"=\".repeat(sepLen);\n  const secondSep = title.length % 2 === 0 ? sep : `${sep}=`;\n  lines.push(`${sep}${title}${secondSep}`);\n\n  // Add message type specific details\n  if (message.type === \"ai\") {\n    const aiMessage = message as AIMessage;\n    if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {\n      lines.push(\"Tool Calls:\");\n      for (const tc of aiMessage.tool_calls) {\n        lines.push(`  ${tc.name} (${tc.id})`);\n        lines.push(` Call ID: ${tc.id}`);\n        lines.push(\"  Args:\");\n        for (const [key, value] of Object.entries(tc.args)) {\n          lines.push(`    ${key}: ${value}`);\n        }\n      }\n    }\n  }\n  if (message.type === \"tool\") {\n    const toolMessage = message as ToolMessage;\n    if (toolMessage.name) {\n      lines.push(`Name: ${toolMessage.name}`);\n    }\n  }\n\n  // Add content if it's a string and not empty\n  if (typeof message.content === \"string\" && message.content.trim()) {\n    if (lines.length > 1) {\n      lines.push(\"\"); // blank line before content\n    }\n    lines.push(message.content);\n  }\n\n  return lines.join(\"\\n\");\n}\n"],"names":["message: BaseMessage","format: MessageStringFormat","lines: string[]"],"mappings":";AAMA,SAAgB,yBACdA,OAAAA,EACAC,SAA8B,QAAA,EACtB;IACR,IAAI,WAAW,SAAU,CAAA,OAAO,sBAAsB,QAAQ;IAC9D,OAAO,KAAK,SAAA,CAAU,QAAQ;AAC/B;AAED,SAAS,sBAAsBD,OAAAA,EAA8B;IAC3D,MAAME,QAAkB,CAAE,CAAA;IAC1B,MAAM,QAAQ,CAAC,CAAC,EACd,QAAQ,IAAA,CAAK,MAAA,CAAO,EAAE,CAAC,WAAA,EAAa,GAAG,QAAQ,IAAA,CAAK,KAAA,CAAM,EAAE,CAC7D,SAAS,CAAC;IACX,MAAM,SAAS,KAAK,KAAA,CAAA,CAAO,KAAK,MAAM,MAAA,IAAU,EAAE;IAClD,MAAM,MAAM,IAAI,MAAA,CAAO,OAAO;IAC9B,MAAM,YAAY,MAAM,MAAA,GAAS,MAAM,IAAI,MAAM,GAAG,IAAI,CAAC,CAAC;IAC1D,MAAM,IAAA,CAAK,GAAG,MAAM,QAAQ,WAAW,CAAC;IAGxC,IAAI,QAAQ,IAAA,KAAS,MAAM;QACzB,MAAM,YAAY;QAClB,IAAI,UAAU,UAAA,IAAc,UAAU,UAAA,CAAW,MAAA,GAAS,GAAG;YAC3D,MAAM,IAAA,CAAK,cAAc;YACzB,KAAK,MAAM,MAAM,UAAU,UAAA,CAAY;gBACrC,MAAM,IAAA,CAAK,CAAC,EAAE,EAAE,GAAG,IAAA,CAAK,EAAE,EAAE,GAAG,EAAA,CAAG,CAAC,CAAC,CAAC;gBACrC,MAAM,IAAA,CAAK,CAAC,UAAU,EAAE,GAAG,EAAA,EAAI,CAAC;gBAChC,MAAM,IAAA,CAAK,UAAU;gBACrB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAA,CAAQ,GAAG,IAAA,CAAK,CAChD,MAAM,IAAA,CAAK,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,OAAO,CAAC;YAErC;QACF;IACF;IACD,IAAI,QAAQ,IAAA,KAAS,QAAQ;QAC3B,MAAM,cAAc;QACpB,IAAI,YAAY,IAAA,EACd,MAAM,IAAA,CAAK,CAAC,MAAM,EAAE,YAAY,IAAA,EAAM,CAAC;IAE1C;IAGD,IAAI,OAAO,QAAQ,OAAA,KAAY,YAAY,QAAQ,OAAA,CAAQ,IAAA,EAAM,EAAE;QACjE,IAAI,MAAM,MAAA,GAAS,GACjB,MAAM,IAAA,CAAK,GAAG;QAEhB,MAAM,IAAA,CAAK,QAAQ,OAAA,CAAQ;IAC5B;IAED,OAAO,MAAM,IAAA,CAAK,KAAK;AACxB"}},
    {"offset": {"line": 1078, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/base.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/base.ts"],"sourcesContent":["import { Serializable, SerializedConstructor } from \"../load/serializable.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport { isDataContentBlock } from \"./content/data.js\";\nimport { convertToV1FromAnthropicInput } from \"./block_translators/anthropic.js\";\nimport { convertToV1FromDataContent } from \"./block_translators/data.js\";\nimport { convertToV1FromChatCompletionsInput } from \"./block_translators/openai.js\";\nimport {\n  $InferMessageContent,\n  $InferResponseMetadata,\n  MessageStructure,\n  MessageType,\n  isMessage,\n  Message,\n} from \"./message.js\";\nimport {\n  convertToFormattedString,\n  type MessageStringFormat,\n} from \"./format.js\";\n\n/** @internal */\nconst MESSAGE_SYMBOL = Symbol.for(\"langchain.message\");\n\nexport interface StoredMessageData {\n  content: string;\n  role: string | undefined;\n  name: string | undefined;\n  tool_call_id: string | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  additional_kwargs?: Record<string, any>;\n  /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response_metadata?: Record<string, any>;\n  id?: string;\n}\n\nexport interface StoredMessage {\n  type: string;\n  data: StoredMessageData;\n}\n\nexport interface StoredGeneration {\n  text: string;\n  message?: StoredMessage;\n}\n\nexport interface StoredMessageV1 {\n  type: string;\n  role: string | undefined;\n  text: string;\n}\n\nexport type MessageContent = string | Array<ContentBlock>;\n\nexport interface FunctionCall {\n  /**\n   * The arguments to call the function with, as generated by the model in JSON\n   * format. Note that the model does not always generate valid JSON, and may\n   * hallucinate parameters not defined by your function schema. Validate the\n   * arguments in your code before calling your function.\n   */\n  arguments: string;\n\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\nexport type BaseMessageFields<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType\n> = {\n  id?: string;\n  name?: string;\n  content?: $InferMessageContent<TStructure, TRole>;\n  contentBlocks?: Array<ContentBlock.Standard>;\n  /** @deprecated */\n  additional_kwargs?: {\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    function_call?: FunctionCall;\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    tool_calls?: OpenAIToolCall[];\n    [key: string]: unknown;\n  };\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n};\n\nexport function mergeContent(\n  firstContent: MessageContent,\n  secondContent: MessageContent\n): MessageContent {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (firstContent === \"\") {\n      return secondContent;\n    }\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else if (Array.isArray(secondContent) && secondContent.length === 0) {\n      return firstContent;\n    } else if (\n      Array.isArray(secondContent) &&\n      secondContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        {\n          type: \"text\",\n          source_type: \"text\",\n          text: firstContent,\n        },\n        ...secondContent,\n      ];\n    } else {\n      return [{ type: \"text\", text: firstContent }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return (\n      _mergeLists(firstContent, secondContent) ?? [\n        ...firstContent,\n        ...secondContent,\n      ]\n    );\n  } else {\n    if (secondContent === \"\") {\n      return firstContent;\n    } else if (\n      Array.isArray(firstContent) &&\n      firstContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        ...firstContent,\n        {\n          type: \"file\",\n          source_type: \"text\",\n          text: secondContent,\n        },\n      ];\n    } else {\n      return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n  }\n}\n\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nexport function _mergeStatus(\n  left?: \"success\" | \"error\",\n  right?: \"success\" | \"error\"\n): \"success\" | \"error\" | undefined {\n  if (left === \"error\" || right === \"error\") {\n    return \"error\";\n  }\n  return \"success\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj: any, depthLimit: number): string {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function helper(obj: any, currentDepth: number): any {\n    if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n      return obj;\n    }\n    if (currentDepth >= depthLimit) {\n      if (Array.isArray(obj)) {\n        return \"[Array]\";\n      }\n      return \"[Object]\";\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map((item) => helper(item, currentDepth + 1));\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const key of Object.keys(obj)) {\n      result[key] = helper(obj[key], currentDepth + 1);\n    }\n    return result;\n  }\n\n  return JSON.stringify(helper(obj, 0), null, 2);\n}\n\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport abstract class BaseMessage<\n    TStructure extends MessageStructure = MessageStructure,\n    TRole extends MessageType = MessageType\n  >\n  extends Serializable\n  implements Message<TStructure, TRole>\n{\n  lc_namespace = [\"langchain_core\", \"messages\"];\n\n  lc_serializable = true;\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\",\n      response_metadata: \"response_metadata\",\n    };\n  }\n\n  readonly [MESSAGE_SYMBOL] = true as const;\n\n  abstract readonly type: TRole;\n\n  id?: string;\n\n  name?: string;\n\n  content: $InferMessageContent<TStructure, TRole>;\n\n  additional_kwargs: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"additional_kwargs\"]\n  >;\n\n  response_metadata: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"response_metadata\"]\n  >;\n\n  /**\n   * @deprecated Use .getType() instead or import the proper typeguard.\n   * For example:\n   *\n   * ```ts\n   * import { isAIMessage } from \"@langchain/core/messages\";\n   *\n   * const message = new AIMessage(\"Hello!\");\n   * isAIMessage(message); // true\n   * ```\n   */\n  _getType(): MessageType {\n    return this.type;\n  }\n\n  /**\n   * @deprecated Use .type instead\n   * The type of the message.\n   */\n  getType(): MessageType {\n    return this._getType();\n  }\n\n  constructor(\n    arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>\n  ) {\n    const fields: BaseMessageFields<TStructure, TRole> =\n      typeof arg === \"string\" || Array.isArray(arg) ? { content: arg } : arg;\n    if (!fields.additional_kwargs) {\n      fields.additional_kwargs = {};\n    }\n    if (!fields.response_metadata) {\n      fields.response_metadata = {};\n    }\n    super(fields);\n    this.name = fields.name;\n    if (fields.content === undefined && fields.contentBlocks !== undefined) {\n      this.content = fields.contentBlocks as $InferMessageContent<\n        TStructure,\n        TRole\n      >;\n      this.response_metadata = {\n        output_version: \"v1\",\n        ...fields.response_metadata,\n      };\n    } else if (fields.content !== undefined) {\n      this.content = fields.content ?? [];\n      this.response_metadata = fields.response_metadata;\n    } else {\n      this.content = [] as $InferMessageContent<TStructure, TRole>;\n      this.response_metadata = fields.response_metadata;\n    }\n    this.additional_kwargs = fields.additional_kwargs;\n    this.id = fields.id;\n  }\n\n  /** Get text content of the message. */\n  get text(): string {\n    if (typeof this.content === \"string\") {\n      return this.content;\n    }\n    if (!Array.isArray(this.content)) return \"\";\n    return this.content\n      .map((c) => {\n        if (typeof c === \"string\") return c;\n        if (c.type === \"text\") return c.text;\n        return \"\";\n      })\n      .join(\"\");\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    const blocks: Array<ContentBlock> =\n      typeof this.content === \"string\"\n        ? [{ type: \"text\", text: this.content }]\n        : this.content;\n    const parsingSteps = [\n      convertToV1FromDataContent,\n      convertToV1FromChatCompletionsInput,\n      convertToV1FromAnthropicInput,\n    ];\n    const parsedBlocks = parsingSteps.reduce(\n      (blocks, step) => step(blocks),\n      blocks\n    );\n    return parsedBlocks as Array<ContentBlock.Standard>;\n  }\n\n  toDict(): StoredMessage {\n    return {\n      type: this.getType(),\n      data: (this.toJSON() as SerializedConstructor)\n        .kwargs as StoredMessageData,\n    };\n  }\n\n  static lc_name() {\n    return \"BaseMessage\";\n  }\n\n  // Can't be protected for silly reasons\n  get _printableFields(): Record<string, unknown> {\n    return {\n      id: this.id,\n      content: this.content,\n      name: this.name,\n      additional_kwargs: this.additional_kwargs,\n      response_metadata: this.response_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is BaseMessage {\n    return (\n      typeof obj === \"object\" &&\n      obj !== null &&\n      MESSAGE_SYMBOL in obj &&\n      obj[MESSAGE_SYMBOL] === true &&\n      isMessage(obj)\n    );\n  }\n\n  // this private method is used to update the ID for the runtime\n  // value as well as in lc_kwargs for serialisation\n  _updateId(value: string | undefined) {\n    this.id = value;\n\n    // lc_attributes wouldn't work here, because jest compares the\n    // whole object\n    this.lc_kwargs.id = value;\n  }\n\n  get [Symbol.toStringTag]() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.constructor as any).lc_name();\n  }\n\n  // Override the default behavior of console.log\n  [Symbol.for(\"nodejs.util.inspect.custom\")](depth: number | null) {\n    if (depth === null) {\n      return this;\n    }\n    const printable = stringifyWithDepthLimit(\n      this._printableFields,\n      Math.max(4, depth)\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return `${(this.constructor as any).lc_name()} ${printable}`;\n  }\n\n  toFormattedString(format: MessageStringFormat = \"pretty\"): string {\n    return convertToFormattedString(this, format);\n  }\n}\n\n/**\n * @deprecated Use \"tool_calls\" field on AIMessages instead\n */\nexport type OpenAIToolCall = {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The function that the model called.\n   */\n  function: FunctionCall;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: \"function\";\n\n  index?: number;\n};\n\nexport function isOpenAIToolCallArray(\n  value?: unknown\n): value is OpenAIToolCall[] {\n  return (\n    Array.isArray(value) &&\n    value.every((v) => typeof (v as OpenAIToolCall).index === \"number\")\n  );\n}\n\nexport function _mergeDicts(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  left: Record<string, any> = {},\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  right: Record<string, any> = {}\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> {\n  const merged = { ...left };\n  for (const [key, value] of Object.entries(right)) {\n    if (merged[key] == null) {\n      merged[key] = value;\n    } else if (value == null) {\n      continue;\n    } else if (\n      typeof merged[key] !== typeof value ||\n      Array.isArray(merged[key]) !== Array.isArray(value)\n    ) {\n      throw new Error(\n        `field[${key}] already exists in the message chunk, but with a different type.`\n      );\n    } else if (typeof merged[key] === \"string\") {\n      if (key === \"type\") {\n        // Do not merge 'type' fields\n        continue;\n      } else if (\n        [\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)\n      ) {\n        // Keep the incoming value for these fields\n        merged[key] = value;\n      } else {\n        merged[key] += value;\n      }\n    } else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n      merged[key] = _mergeDicts(merged[key], value);\n    } else if (Array.isArray(merged[key])) {\n      merged[key] = _mergeLists(merged[key], value);\n    } else if (merged[key] === value) {\n      continue;\n    } else {\n      console.warn(\n        `field[${key}] already exists in this message chunk and value has unsupported type.`\n      );\n    }\n  }\n  return merged;\n}\n\nexport function _mergeLists<Content extends ContentBlock>(\n  left?: Content[],\n  right?: Content[]\n): Content[] | undefined {\n  if (left === undefined && right === undefined) {\n    return undefined;\n  } else if (left === undefined || right === undefined) {\n    return left || right;\n  } else {\n    const merged = [...left];\n    for (const item of right) {\n      if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"index\" in item &&\n        typeof item.index === \"number\"\n      ) {\n        const toMerge = merged.findIndex((leftItem) => {\n          const isObject = typeof leftItem === \"object\";\n          const indiciesMatch =\n            \"index\" in leftItem && leftItem.index === item.index;\n          const idsMatch =\n            \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n          const eitherItemMissingID =\n            !(\"id\" in leftItem) ||\n            !leftItem?.id ||\n            !(\"id\" in item) ||\n            !item?.id;\n          return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n        });\n        if (\n          toMerge !== -1 &&\n          typeof merged[toMerge] === \"object\" &&\n          merged[toMerge] !== null\n        ) {\n          merged[toMerge] = _mergeDicts(\n            merged[toMerge] as Record<string, unknown>,\n            item as Record<string, unknown>\n          ) as Content;\n        } else {\n          merged.push(item);\n        }\n      } else if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"text\" in item &&\n        item.text === \"\"\n      ) {\n        // No-op - skip empty text blocks\n        continue;\n      } else {\n        merged.push(item);\n      }\n    }\n    return merged;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _mergeObj<T = any>(\n  left: T | undefined,\n  right: T | undefined\n): T {\n  if (!left && !right) {\n    throw new Error(\"Cannot merge two undefined objects.\");\n  }\n  if (!left || !right) {\n    return left || (right as T);\n  } else if (typeof left !== typeof right) {\n    throw new Error(\n      `Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`\n    );\n  } else if (typeof left === \"string\" && typeof right === \"string\") {\n    return (left + right) as T;\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    return _mergeLists(left, right) as T;\n  } else if (typeof left === \"object\" && typeof right === \"object\") {\n    return _mergeDicts(left, right) as T;\n  } else if (left === right) {\n    return left;\n  } else {\n    throw new Error(\n      `Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`\n    );\n  }\n}\n\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport abstract class BaseMessageChunk<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType\n> extends BaseMessage<TStructure, TRole> {\n  abstract concat(chunk: BaseMessageChunk): BaseMessageChunk<TStructure, TRole>;\n\n  static isInstance(obj: unknown): obj is BaseMessageChunk {\n    if (!super.isInstance(obj)) {\n      return false;\n    }\n    // Check if obj is an instance of BaseMessageChunk by traversing the prototype chain\n    let proto = Object.getPrototypeOf(obj);\n    while (proto !== null) {\n      if (proto === BaseMessageChunk.prototype) {\n        return true;\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n    return false;\n  }\n}\n\nexport type MessageFieldWithRole = {\n  role: MessageType;\n  content: MessageContent;\n  name?: string;\n} & Record<string, unknown>;\n\nexport function _isMessageFieldWithRole(\n  x: BaseMessageLike\n): x is MessageFieldWithRole {\n  return typeof (x as MessageFieldWithRole).role === \"string\";\n}\n\nexport type BaseMessageLike =\n  | BaseMessage\n  | MessageFieldWithRole\n  | [MessageType, MessageContent]\n  | string\n  /**\n   * @deprecated Specifying \"type\" is deprecated and will be removed in 0.4.0.\n   */\n  | ({\n      type: MessageType | \"user\" | \"assistant\" | \"placeholder\";\n    } & BaseMessageFields &\n      Record<string, unknown>)\n  | SerializedConstructor;\n\n/**\n * @deprecated Use {@link BaseMessage.isInstance} instead\n */\nexport function isBaseMessage(\n  messageLike?: unknown\n): messageLike is BaseMessage {\n  return typeof (messageLike as BaseMessage)?._getType === \"function\";\n}\n\n/**\n * @deprecated Use {@link BaseMessageChunk.isInstance} instead\n */\nexport function isBaseMessageChunk(\n  messageLike?: unknown\n): messageLike is BaseMessageChunk {\n  return BaseMessageChunk.isInstance(messageLike);\n}\n"],"names":["firstContent: MessageContent","secondContent: MessageContent","isDataContentBlock","left?: \"success\" | \"error\"","right?: \"success\" | \"error\"","obj: any","depthLimit: number","currentDepth: number","obj","result: Record<string, unknown>","Serializable","arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>","fields: BaseMessageFields<TStructure, TRole>","blocks: Array<ContentBlock>","convertToV1FromDataContent","convertToV1FromChatCompletionsInput","convertToV1FromAnthropicInput","blocks","obj: unknown","isMessage","value: string | undefined","depth: number | null","format: MessageStringFormat","convertToFormattedString","value?: unknown","left: Record<string, any>","right: Record<string, any>","left?: Content[]","right?: Content[]","left: T | undefined","right: T | undefined","x: BaseMessageLike","messageLike?: unknown"],"mappings":"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"}},
    {"offset": {"line": 1380, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/bedrock_converse.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/bedrock_converse.ts"],"sourcesContent":["import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport { KNOWN_BLOCK_TYPES } from \"../content/tools.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport {\n  _isArray,\n  _isBytesArray,\n  _isContentBlock,\n  _isNumber,\n  _isObject,\n  _isString,\n  iife,\n} from \"./utils.js\";\n\n// see `/libs/providers/langchain-aws/src/utils/compat.ts:convertFileFormatToMimeType`\nfunction convertFileFormatToMimeType(format: string): string {\n  switch (format) {\n    // DocumentBlock\n    case \"csv\":\n      return \"text/csv\";\n    case \"doc\":\n      return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n    case \"docx\":\n      return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n    case \"html\":\n      return \"text/html\";\n    case \"md\":\n      return \"text/markdown\";\n    case \"pdf\":\n      return \"application/pdf\";\n    case \"txt\":\n      return \"text/plain\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    // ImageBlock\n    case \"gif\":\n      return \"image/gif\";\n    case \"jpeg\":\n      return \"image/jpeg\";\n    case \"jpg\":\n      return \"image/jpeg\";\n    case \"png\":\n      return \"image/png\";\n    case \"webp\":\n      return \"image/webp\";\n    // VideoBlock\n    case \"flv\":\n      return \"video/flv\";\n    case \"mkv\":\n      return \"video/mkv\";\n    case \"mov\":\n      return \"video/mov\";\n    case \"mp4\":\n      return \"video/mp4\";\n    case \"mpeg\":\n      return \"video/mpeg\";\n    case \"mpg\":\n      return \"video/mpg\";\n    case \"three_gp\":\n      return \"video/three_gp\";\n    case \"webm\":\n      return \"video/webm\";\n    case \"wmv\":\n      return \"video/wmv\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\n\nfunction convertConverseDocumentBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (_isObject(block.document) && _isObject(block.document.source)) {\n    const format =\n      _isObject(block.document) && _isString(block.document.format)\n        ? block.document.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.document.source)) {\n      if (\n        _isObject(block.document.source.s3Location) &&\n        _isString(block.document.source.s3Location.uri)\n      ) {\n        return {\n          type: \"file\",\n          mimeType,\n          fileId: block.document.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.document.source.bytes)) {\n        return {\n          type: \"file\",\n          mimeType,\n          data: block.document.source.bytes,\n        };\n      }\n      if (_isString(block.document.source.text)) {\n        return {\n          type: \"file\",\n          mimeType,\n          data: Buffer.from(block.document.source.text).toString(\"base64\"),\n        };\n      }\n      if (_isArray(block.document.source.content)) {\n        const data = block.document.source.content.reduce(\n          (acc: string, item) => {\n            if (_isObject(item) && _isString(item.text)) {\n              return acc + item.text;\n            }\n            return acc;\n          },\n          \"\"\n        );\n        return {\n          type: \"file\",\n          mimeType,\n          data,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nfunction convertConverseImageBlock(block: ContentBlock): ContentBlock.Standard {\n  if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n    const format =\n      _isObject(block.image) && _isString(block.image.format)\n        ? block.image.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.image.source)) {\n      if (\n        _isObject(block.image.source.s3Location) &&\n        _isString(block.image.source.s3Location.uri)\n      ) {\n        return {\n          type: \"image\",\n          mimeType,\n          fileId: block.image.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.image.source.bytes)) {\n        return {\n          type: \"image\",\n          mimeType,\n          data: block.image.source.bytes,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nfunction convertConverseVideoBlock(block: ContentBlock): ContentBlock.Standard {\n  if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n    const format =\n      _isObject(block.video) && _isString(block.video.format)\n        ? block.video.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.video.source)) {\n      if (\n        _isObject(block.video.source.s3Location) &&\n        _isString(block.video.source.s3Location.uri)\n      ) {\n        return {\n          type: \"video\",\n          mimeType,\n          fileId: block.video.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.video.source.bytes)) {\n        return {\n          type: \"video\",\n          mimeType,\n          data: block.video.source.bytes,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nexport function convertToV1FromChatBedrockConverseInput(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    const blocks = content.map((block) => {\n      if (_isContentBlock(block, \"non_standard\") && \"value\" in block) {\n        return block.value as ContentBlock;\n      }\n      return block;\n    });\n    for (const block of blocks) {\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (\n        _isContentBlock(block, \"document\") &&\n        _isObject(block.document)\n      ) {\n        yield convertConverseDocumentBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n        yield convertConverseImageBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n        yield convertConverseVideoBlock(block);\n        continue;\n      }\n      if (KNOWN_BLOCK_TYPES.includes(block.type)) {\n        yield block as ContentBlock.Standard;\n      } else {\n        yield { type: \"non_standard\", value: block };\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nfunction convertToV1FromChatBedrockConverseMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `/libs/providers/langchain-aws/src/utils/message_outputs.ts:convertConverseMessageToLangChainMessage`\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"cache_point\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (\n        _isContentBlock(block, \"citations_content\") &&\n        _isObject(block.citationsContent)\n      ) {\n        const text = _isArray(block.citationsContent.content)\n          ? block.citationsContent.content.reduce((acc: string, item) => {\n              if (_isObject(item) && _isString(item.text)) {\n                return acc + item.text;\n              }\n              return acc;\n            }, \"\")\n          : \"\";\n        const annotations = _isArray(block.citationsContent.citations)\n          ? block.citationsContent.citations.reduce(\n              (acc: Array<ContentBlock.Citation>, item) => {\n                if (_isObject(item)) {\n                  const citedText = _isArray(item.sourceContent)\n                    ? item.sourceContent.reduce((acc: string, item) => {\n                        if (_isObject(item) && _isString(item.text)) {\n                          return acc + item.text;\n                        }\n                        return acc;\n                      }, \"\")\n                    : \"\";\n                  const properties = iife(() => {\n                    if (_isObject(item.location)) {\n                      const location =\n                        item.location.documentChar ||\n                        item.location.documentPage ||\n                        item.location.documentChunk;\n                      if (_isObject(location)) {\n                        return {\n                          source: _isNumber(location.documentIndex)\n                            ? location.documentIndex.toString()\n                            : undefined,\n                          startIndex: _isNumber(location.start)\n                            ? location.start\n                            : undefined,\n                          endIndex: _isNumber(location.end)\n                            ? location.end\n                            : undefined,\n                        };\n                      }\n                    }\n                    return {};\n                  });\n                  acc.push({ type: \"citation\", citedText, ...properties });\n                }\n                return acc;\n              },\n              []\n            )\n          : [];\n        yield { type: \"text\", text, annotations };\n        continue;\n      } else if (\n        _isContentBlock(block, \"document\") &&\n        _isObject(block.document)\n      ) {\n        yield convertConverseDocumentBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"guard_content\")) {\n        yield {\n          type: \"non_standard\",\n          value: block,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n        yield convertConverseImageBlock(block);\n        continue;\n      } else if (\n        _isContentBlock(block, \"reasoning_content\") &&\n        _isString(block.reasoningText)\n      ) {\n        yield {\n          type: \"reasoning\",\n          reasoning: block.reasoningText,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (_isContentBlock(block, \"tool_result\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (_isContentBlock(block, \"tool_call\")) {\n        // no-op - filtered to tools\n        continue;\n      } else if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n        yield convertConverseVideoBlock(block);\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatBedrockConverseTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatBedrockConverseMessage,\n  translateContentChunk: convertToV1FromChatBedrockConverseMessage,\n};\n"],"names":["format: string","block: ContentBlock","_isObject","_isString","_isBytesArray","_isArray","acc: string","_isContentBlock","message: AIMessage","acc: Array<ContentBlock.Citation>","item","acc","iife","_isNumber","ChatBedrockConverseTranslator: StandardContentBlockTranslator"],"mappings":"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"}},
    {"offset": {"line": 1619, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/google_genai.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/google_genai.ts"],"sourcesContent":["import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { _isContentBlock, _isObject, _isString } from \"./utils.js\";\n\nfunction convertToV1FromChatGoogleMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `libs/providers/langchain-google-genai/src/utils/common.ts:mapGenerateContentResultToChatResult\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (\n        _isContentBlock(block, \"inlineData\") &&\n        _isObject(block.inlineData) &&\n        _isString(block.inlineData.mimeType) &&\n        _isString(block.inlineData.data)\n      ) {\n        yield {\n          type: \"file\",\n          mimeType: block.inlineData.mimeType,\n          data: block.inlineData.data,\n        };\n        continue;\n      } else if (\n        _isContentBlock(block, \"functionCall\") &&\n        _isObject(block.functionCall) &&\n        _isString(block.functionCall.name) &&\n        _isObject(block.functionCall.args)\n      ) {\n        yield {\n          type: \"tool_call\",\n          id: message.id,\n          name: block.functionCall.name,\n          args: block.functionCall.args,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"functionResponse\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (\n        _isContentBlock(block, \"fileData\") &&\n        _isObject(block.fileData) &&\n        _isString(block.fileData.mimeType) &&\n        _isString(block.fileData.fileUri)\n      ) {\n        yield {\n          type: \"file\",\n          mimeType: block.fileData.mimeType,\n          fileId: block.fileData.fileUri,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"executableCode\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (_isContentBlock(block, \"codeExecutionResult\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatGoogleGenAITranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatGoogleMessage,\n  translateContentChunk: convertToV1FromChatGoogleMessage,\n};\n"],"names":["message: AIMessage","_isContentBlock","_isString","_isObject","ChatGoogleGenAITranslator: StandardContentBlockTranslator"],"mappings":";;AAKA,SAAS,iCACPA,OAAAA,EAC8B;IAE9B,UAAU,iBAAkD;QAC1D,MAAM,UACJ,OAAO,QAAQ,OAAA,KAAY,WACvB;YAAC;gBAAE,MAAM;gBAAQ,MAAM,QAAQ,OAAA;YAAS,CAAC;SAAA,GACzC,QAAQ,OAAA;QACd,KAAK,MAAM,SAAS,QAAS;YAC3B,IAAIC,cAAAA,eAAAA,CAAgB,OAAO,OAAO,IAAIC,cAAAA,SAAAA,CAAU,MAAM,IAAA,CAAK,EAAE;gBAC3D,MAAM;oBAAE,MAAM;oBAAQ,MAAM,MAAM,IAAA;gBAAM;gBACxC;YACD,OAAA,IACCD,cAAAA,eAAAA,CAAgB,OAAO,aAAa,IACpCE,cAAAA,SAAAA,CAAU,MAAM,UAAA,CAAW,IAC3BD,cAAAA,SAAAA,CAAU,MAAM,UAAA,CAAW,QAAA,CAAS,IACpCA,cAAAA,SAAAA,CAAU,MAAM,UAAA,CAAW,IAAA,CAAK,EAChC;gBACA,MAAM;oBACJ,MAAM;oBACN,UAAU,MAAM,UAAA,CAAW,QAAA;oBAC3B,MAAM,MAAM,UAAA,CAAW,IAAA;gBACxB;gBACD;YACD,OAAA,IACCD,cAAAA,eAAAA,CAAgB,OAAO,eAAe,IACtCE,cAAAA,SAAAA,CAAU,MAAM,YAAA,CAAa,IAC7BD,cAAAA,SAAAA,CAAU,MAAM,YAAA,CAAa,IAAA,CAAK,IAClCC,cAAAA,SAAAA,CAAU,MAAM,YAAA,CAAa,IAAA,CAAK,EAClC;gBACA,MAAM;oBACJ,MAAM;oBACN,IAAI,QAAQ,EAAA;oBACZ,MAAM,MAAM,YAAA,CAAa,IAAA;oBACzB,MAAM,MAAM,YAAA,CAAa,IAAA;gBAC1B;gBACD;YACD,OAAA,IAAUF,cAAAA,eAAAA,CAAgB,OAAO,mBAAmB,EAAE;gBACrD,MAAM;oBAAE,MAAM;oBAAgB,OAAO;gBAAO;gBAC5C;YACD,OAAA,IACCA,cAAAA,eAAAA,CAAgB,OAAO,WAAW,IAClCE,cAAAA,SAAAA,CAAU,MAAM,QAAA,CAAS,IACzBD,cAAAA,SAAAA,CAAU,MAAM,QAAA,CAAS,QAAA,CAAS,IAClCA,cAAAA,SAAAA,CAAU,MAAM,QAAA,CAAS,OAAA,CAAQ,EACjC;gBACA,MAAM;oBACJ,MAAM;oBACN,UAAU,MAAM,QAAA,CAAS,QAAA;oBACzB,QAAQ,MAAM,QAAA,CAAS,OAAA;gBACxB;gBACD;YACD,OAAA,IAAUD,cAAAA,eAAAA,CAAgB,OAAO,iBAAiB,EAAE;gBACnD,MAAM;oBAAE,MAAM;oBAAgB,OAAO;gBAAO;gBAC5C;YACD,OAAA,IAAUA,cAAAA,eAAAA,CAAgB,OAAO,sBAAsB,EAAE;gBACxD,MAAM;oBAAE,MAAM;oBAAgB,OAAO;gBAAO;gBAC5C;YACD;YACD,MAAM;gBAAE,MAAM;gBAAgB,OAAO;YAAO;QAC7C;IACF;IACD,OAAO,MAAM,IAAA,CAAK,gBAAgB,CAAC;AACpC;AAED,MAAaG,4BAA4D;IACvE,kBAAkB;IAClB,uBAAuB;AACxB"}},
    {"offset": {"line": 1694, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/google_vertexai.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/google_vertexai.ts"],"sourcesContent":["import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { _isArray, _isContentBlock, _isString, iife } from \"./utils.js\";\n\nfunction convertToV1FromChatVertexMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `/libs/providers/langchain-google-common/src/utils/gemini.ts:partsToMessageContent`\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"reasoning\") && _isString(block.reasoning)) {\n        const signature = iife(() => {\n          const reasoningIndex = content.indexOf(block);\n          if (\n            _isArray(message.additional_kwargs?.signatures) &&\n            reasoningIndex >= 0\n          ) {\n            return message.additional_kwargs.signatures.at(reasoningIndex);\n          }\n          return undefined;\n        });\n        if (_isString(signature)) {\n          yield {\n            type: \"reasoning\",\n            reasoning: block.reasoning,\n            signature,\n          };\n        } else {\n          yield {\n            type: \"reasoning\",\n            reasoning: block.reasoning,\n          };\n        }\n        continue;\n      } else if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (_isContentBlock(block, \"image_url\")) {\n        if (_isString(block.image_url)) {\n          if (block.image_url.startsWith(\"data:\")) {\n            const dataUrlRegex = /^data:([^;]+);base64,(.+)$/;\n            const match = block.image_url.match(dataUrlRegex);\n            if (match) {\n              yield { type: \"image\", data: match[2], mimeType: match[1] };\n            } else {\n              yield { type: \"image\", url: block.image_url };\n            }\n          } else {\n            yield { type: \"image\", url: block.image_url };\n          }\n        }\n        continue;\n      } else if (\n        _isContentBlock(block, \"media\") &&\n        _isString(block.mimeType) &&\n        _isString(block.data)\n      ) {\n        yield { type: \"file\", mimeType: block.mimeType, data: block.data };\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatVertexTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatVertexMessage,\n  translateContentChunk: convertToV1FromChatVertexMessage,\n};\n"],"names":["message: AIMessage","_isContentBlock","_isString","iife","_isArray","ChatVertexTranslator: StandardContentBlockTranslator"],"mappings":";;AAKA,SAAS,iCACPA,OAAAA,EAC8B;IAE9B,UAAU,iBAAkD;QAC1D,MAAM,UACJ,OAAO,QAAQ,OAAA,KAAY,WACvB;YAAC;gBAAE,MAAM;gBAAQ,MAAM,QAAQ,OAAA;YAAS,CAAC;SAAA,GACzC,QAAQ,OAAA;QACd,KAAK,MAAM,SAAS,QAAS;YAC3B,IAAIC,cAAAA,eAAAA,CAAgB,OAAO,YAAY,IAAIC,cAAAA,SAAAA,CAAU,MAAM,SAAA,CAAU,EAAE;gBACrE,MAAM,YAAYC,cAAAA,IAAAA,CAAK,MAAM;oBAC3B,MAAM,iBAAiB,QAAQ,OAAA,CAAQ,MAAM;oBAC7C,IACEC,cAAAA,QAAAA,CAAS,QAAQ,iBAAA,EAAmB,WAAW,IAC/C,kBAAkB,EAElB,CAAA,OAAO,QAAQ,iBAAA,CAAkB,UAAA,CAAW,EAAA,CAAG,eAAe;oBAEhE,OAAO,KAAA;gBACR,EAAC;gBACF,IAAIF,cAAAA,SAAAA,CAAU,UAAU,EACtB,MAAM;oBACJ,MAAM;oBACN,WAAW,MAAM,SAAA;oBACjB;gBACD;qBAED,MAAM;oBACJ,MAAM;oBACN,WAAW,MAAM,SAAA;gBAClB;gBAEH;YACD,OAAA,IAAUD,cAAAA,eAAAA,CAAgB,OAAO,OAAO,IAAIC,cAAAA,SAAAA,CAAU,MAAM,IAAA,CAAK,EAAE;gBAClE,MAAM;oBAAE,MAAM;oBAAQ,MAAM,MAAM,IAAA;gBAAM;gBACxC;YACD,OAAA,IAAUD,cAAAA,eAAAA,CAAgB,OAAO,YAAY,EAAE;gBAC9C,IAAIC,cAAAA,SAAAA,CAAU,MAAM,SAAA,CAAU,CAC5B,CAAA,IAAI,MAAM,SAAA,CAAU,UAAA,CAAW,QAAQ,EAAE;oBACvC,MAAM,eAAe;oBACrB,MAAM,QAAQ,MAAM,SAAA,CAAU,KAAA,CAAM,aAAa;oBACjD,IAAI,OACF,MAAM;wBAAE,MAAM;wBAAS,MAAM,KAAA,CAAM,EAAA;wBAAI,UAAU,KAAA,CAAM,EAAA;oBAAI;yBAE3D,MAAM;wBAAE,MAAM;wBAAS,KAAK,MAAM,SAAA;oBAAW;gBAEhD,OACC,MAAM;oBAAE,MAAM;oBAAS,KAAK,MAAM,SAAA;gBAAW;gBAGjD;YACD,OAAA,IACCD,cAAAA,eAAAA,CAAgB,OAAO,QAAQ,IAC/BC,cAAAA,SAAAA,CAAU,MAAM,QAAA,CAAS,IACzBA,cAAAA,SAAAA,CAAU,MAAM,IAAA,CAAK,EACrB;gBACA,MAAM;oBAAE,MAAM;oBAAQ,UAAU,MAAM,QAAA;oBAAU,MAAM,MAAM,IAAA;gBAAM;gBAClE;YACD;YACD,MAAM;gBAAE,MAAM;gBAAgB,OAAO;YAAO;QAC7C;IACF;IACD,OAAO,MAAM,IAAA,CAAK,gBAAgB,CAAC;AACpC;AAED,MAAaG,uBAAuD;IAClE,kBAAkB;IAClB,uBAAuB;AACxB"}},
    {"offset": {"line": 1770, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/index.ts"],"sourcesContent":["import type { AIMessage, AIMessageChunk } from \"../ai.js\";\nimport type { ContentBlock } from \"../content/index.js\";\n\nimport { ChatAnthropicTranslator } from \"./anthropic.js\";\nimport { ChatBedrockConverseTranslator } from \"./bedrock_converse.js\";\nimport { ChatGoogleGenAITranslator } from \"./google_genai.js\";\nimport { ChatVertexTranslator } from \"./google_vertexai.js\";\nimport { ChatOpenAITranslator } from \"./openai.js\";\n\nexport interface StandardContentBlockTranslator {\n  translateContent(message: AIMessage): Array<ContentBlock.Standard>;\n  translateContentChunk(chunk: AIMessageChunk): Array<ContentBlock.Standard>;\n}\n\ntype TranslatorRegistry = Map<string, StandardContentBlockTranslator>;\n\ndeclare global {\n  var lc_block_translators_registry: TranslatorRegistry;\n}\n\nglobalThis.lc_block_translators_registry ??= new Map([\n  [\"anthropic\", ChatAnthropicTranslator],\n  [\"bedrock-converse\", ChatBedrockConverseTranslator],\n  [\"google-genai\", ChatGoogleGenAITranslator],\n  [\"google-vertexai\", ChatVertexTranslator],\n  [\"openai\", ChatOpenAITranslator],\n]);\n\nexport function registerTranslator(\n  modelProvider: string,\n  translator: StandardContentBlockTranslator\n) {\n  globalThis.lc_block_translators_registry.set(modelProvider, translator);\n}\n\nexport function getTranslator(\n  modelProvider: string\n): StandardContentBlockTranslator | undefined {\n  return globalThis.lc_block_translators_registry.get(modelProvider);\n}\n"],"names":["ChatAnthropicTranslator","ChatBedrockConverseTranslator","ChatGoogleGenAITranslator","ChatVertexTranslator","ChatOpenAITranslator","modelProvider: string"],"mappings":";;;;;;AAoBA,WAAW,6BAAA,KAAkC,IAAI,IAAI;IACnD;QAAC;QAAaA,kBAAAA,uBAAwB;KAAA;IACtC;QAAC;QAAoBC,yBAAAA,6BAA8B;KAAA;IACnD;QAAC;QAAgBC,qBAAAA,yBAA0B;KAAA;IAC3C;QAAC;QAAmBC,wBAAAA,oBAAqB;KAAA;IACzC;QAAC;QAAUC,eAAAA,oBAAqB;KAAA;CACjC;AASD,SAAgB,cACdC,aAAAA,EAC4C;IAC5C,OAAO,WAAW,6BAAA,CAA8B,GAAA,CAAI,cAAc;AACnE"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/metadata.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/metadata.ts"],"sourcesContent":["import { _mergeDicts } from \"./base.js\";\nimport type { MessageOutputVersion } from \"./message.js\";\n\nexport type ResponseMetadata = {\n  model_provider?: string;\n  model_name?: string;\n  output_version?: MessageOutputVersion;\n  [key: string]: unknown;\n};\n\nexport function mergeResponseMetadata(\n  a?: ResponseMetadata,\n  b?: ResponseMetadata\n): ResponseMetadata {\n  const output: ResponseMetadata = _mergeDicts(a ?? {}, b ?? {});\n  return output;\n}\n\nexport type ModalitiesTokenDetails = {\n  /**\n   * Text tokens.\n   * Does not need to be reported, but some models will do so.\n   */\n  text?: number;\n\n  /**\n   * Image (non-video) tokens.\n   */\n  image?: number;\n\n  /**\n   * Audio tokens.\n   */\n  audio?: number;\n\n  /**\n   * Video tokens.\n   */\n  video?: number;\n\n  /**\n   * Document tokens.\n   * e.g. PDF\n   */\n  document?: number;\n};\n\nfunction mergeModalitiesTokenDetails(\n  a?: ModalitiesTokenDetails,\n  b?: ModalitiesTokenDetails\n): ModalitiesTokenDetails {\n  const output: ModalitiesTokenDetails = {};\n  if (a?.audio !== undefined || b?.audio !== undefined) {\n    output.audio = (a?.audio ?? 0) + (b?.audio ?? 0);\n  }\n  if (a?.image !== undefined || b?.image !== undefined) {\n    output.image = (a?.image ?? 0) + (b?.image ?? 0);\n  }\n  if (a?.video !== undefined || b?.video !== undefined) {\n    output.video = (a?.video ?? 0) + (b?.video ?? 0);\n  }\n  if (a?.document !== undefined || b?.document !== undefined) {\n    output.document = (a?.document ?? 0) + (b?.document ?? 0);\n  }\n  if (a?.text !== undefined || b?.text !== undefined) {\n    output.text = (a?.text ?? 0) + (b?.text ?? 0);\n  }\n  return output;\n}\n\n/**\n * Breakdown of input token counts.\n *\n * Does not *need* to sum to full input token count. Does *not* need to have all keys.\n */\nexport type InputTokenDetails = ModalitiesTokenDetails & {\n  /**\n   * Input tokens that were cached and there was a cache hit.\n   *\n   * Since there was a cache hit, the tokens were read from the cache.\n   * More precisely, the model state given these tokens was read from the cache.\n   */\n  cache_read?: number;\n\n  /**\n   * Input tokens that were cached and there was a cache miss.\n   *\n   * Since there was a cache miss, the cache was created from these tokens.\n   */\n  cache_creation?: number;\n};\n\nfunction mergeInputTokenDetails(\n  a?: InputTokenDetails,\n  b?: InputTokenDetails\n): InputTokenDetails {\n  const output: InputTokenDetails = {\n    ...mergeModalitiesTokenDetails(a, b),\n  };\n  if (a?.cache_read !== undefined || b?.cache_read !== undefined) {\n    output.cache_read = (a?.cache_read ?? 0) + (b?.cache_read ?? 0);\n  }\n  if (a?.cache_creation !== undefined || b?.cache_creation !== undefined) {\n    output.cache_creation = (a?.cache_creation ?? 0) + (b?.cache_creation ?? 0);\n  }\n  return output;\n}\n\n/**\n * Breakdown of output token counts.\n *\n * Does *not* need to sum to full output token count. Does *not* need to have all keys.\n */\nexport type OutputTokenDetails = ModalitiesTokenDetails & {\n  /**\n   * Reasoning output tokens.\n   *\n   * Tokens generated by the model in a chain of thought process (i.e. by\n   * OpenAI's o1 models) that are not returned as part of model output.\n   */\n  reasoning?: number;\n};\n\nfunction mergeOutputTokenDetails(\n  a?: OutputTokenDetails,\n  b?: OutputTokenDetails\n): OutputTokenDetails {\n  const output: OutputTokenDetails = {\n    ...mergeModalitiesTokenDetails(a, b),\n  };\n  if (a?.reasoning !== undefined || b?.reasoning !== undefined) {\n    output.reasoning = (a?.reasoning ?? 0) + (b?.reasoning ?? 0);\n  }\n  return output;\n}\n\n/**\n * Usage metadata for a message, such as token counts.\n */\nexport type UsageMetadata = {\n  /**\n   * Count of input (or prompt) tokens. Sum of all input token types.\n   */\n  input_tokens: number;\n  /**\n   * Count of output (or completion) tokens. Sum of all output token types.\n   */\n  output_tokens: number;\n  /**\n   * Total token count. Sum of input_tokens + output_tokens.\n   */\n  total_tokens: number;\n\n  /**\n   * Breakdown of input token counts.\n   *\n   * Does *not* need to sum to full input token count. Does *not* need to have all keys.\n   */\n  input_token_details?: InputTokenDetails;\n\n  /**\n   * Breakdown of output token counts.\n   *\n   * Does *not* need to sum to full output token count. Does *not* need to have all keys.\n   */\n  output_token_details?: OutputTokenDetails;\n};\n\nexport function mergeUsageMetadata(\n  a?: UsageMetadata,\n  b?: UsageMetadata\n): UsageMetadata {\n  return {\n    input_tokens: (a?.input_tokens ?? 0) + (b?.input_tokens ?? 0),\n    output_tokens: (a?.output_tokens ?? 0) + (b?.output_tokens ?? 0),\n    total_tokens: (a?.total_tokens ?? 0) + (b?.total_tokens ?? 0),\n    input_token_details: mergeInputTokenDetails(\n      a?.input_token_details,\n      b?.input_token_details\n    ),\n    output_token_details: mergeOutputTokenDetails(\n      a?.output_token_details,\n      b?.output_token_details\n    ),\n  };\n}\n"],"names":["a?: ResponseMetadata","b?: ResponseMetadata","output: ResponseMetadata","_mergeDicts","a?: ModalitiesTokenDetails","b?: ModalitiesTokenDetails","output: ModalitiesTokenDetails","a?: InputTokenDetails","b?: InputTokenDetails","output: InputTokenDetails","a?: OutputTokenDetails","b?: OutputTokenDetails","output: OutputTokenDetails","a?: UsageMetadata","b?: UsageMetadata"],"mappings":";;AAUA,SAAgB,sBACdA,CAAAA,EACAC,CAAAA,EACkB;IAClB,MAAMC,SAA2BC,aAAAA,WAAAA,CAAY,KAAK,CAAE,GAAE,KAAK,CAAE,EAAC;IAC9D,OAAO;AACR;AA+BD,SAAS,4BACPC,CAAAA,EACAC,CAAAA,EACwB;IACxB,MAAMC,SAAiC,CAAE;IACzC,IAAI,GAAG,UAAU,KAAA,KAAa,GAAG,UAAU,KAAA,GACzC,OAAO,KAAA,GAAA,CAAS,GAAG,SAAS,CAAA,IAAA,CAAM,GAAG,SAAS,CAAA;IAEhD,IAAI,GAAG,UAAU,KAAA,KAAa,GAAG,UAAU,KAAA,GACzC,OAAO,KAAA,GAAA,CAAS,GAAG,SAAS,CAAA,IAAA,CAAM,GAAG,SAAS,CAAA;IAEhD,IAAI,GAAG,UAAU,KAAA,KAAa,GAAG,UAAU,KAAA,GACzC,OAAO,KAAA,GAAA,CAAS,GAAG,SAAS,CAAA,IAAA,CAAM,GAAG,SAAS,CAAA;IAEhD,IAAI,GAAG,aAAa,KAAA,KAAa,GAAG,aAAa,KAAA,GAC/C,OAAO,QAAA,GAAA,CAAY,GAAG,YAAY,CAAA,IAAA,CAAM,GAAG,YAAY,CAAA;IAEzD,IAAI,GAAG,SAAS,KAAA,KAAa,GAAG,SAAS,KAAA,GACvC,OAAO,IAAA,GAAA,CAAQ,GAAG,QAAQ,CAAA,IAAA,CAAM,GAAG,QAAQ,CAAA;IAE7C,OAAO;AACR;AAwBD,SAAS,uBACPC,CAAAA,EACAC,CAAAA,EACmB;IACnB,MAAMC,SAA4B;QAChC,GAAG,4BAA4B,GAAG,EAAE;IACrC;IACD,IAAI,GAAG,eAAe,KAAA,KAAa,GAAG,eAAe,KAAA,GACnD,OAAO,UAAA,GAAA,CAAc,GAAG,cAAc,CAAA,IAAA,CAAM,GAAG,cAAc,CAAA;IAE/D,IAAI,GAAG,mBAAmB,KAAA,KAAa,GAAG,mBAAmB,KAAA,GAC3D,OAAO,cAAA,GAAA,CAAkB,GAAG,kBAAkB,CAAA,IAAA,CAAM,GAAG,kBAAkB,CAAA;IAE3E,OAAO;AACR;AAiBD,SAAS,wBACPC,CAAAA,EACAC,CAAAA,EACoB;IACpB,MAAMC,SAA6B;QACjC,GAAG,4BAA4B,GAAG,EAAE;IACrC;IACD,IAAI,GAAG,cAAc,KAAA,KAAa,GAAG,cAAc,KAAA,GACjD,OAAO,SAAA,GAAA,CAAa,GAAG,aAAa,CAAA,IAAA,CAAM,GAAG,aAAa,CAAA;IAE5D,OAAO;AACR;AAkCD,SAAgB,mBACdC,CAAAA,EACAC,CAAAA,EACe;IACf,OAAO;QACL,cAAA,CAAe,GAAG,gBAAgB,CAAA,IAAA,CAAM,GAAG,gBAAgB,CAAA;QAC3D,eAAA,CAAgB,GAAG,iBAAiB,CAAA,IAAA,CAAM,GAAG,iBAAiB,CAAA;QAC9D,cAAA,CAAe,GAAG,gBAAgB,CAAA,IAAA,CAAM,GAAG,gBAAgB,CAAA;QAC3D,qBAAqB,uBACnB,GAAG,qBACH,GAAG,oBACJ;QACD,sBAAsB,wBACpB,GAAG,sBACH,GAAG,qBACJ;IACF;AACF"}},
    {"offset": {"line": 1851, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/tool.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/tool.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n  _mergeObj,\n  _mergeStatus,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface ToolMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"tool\"> {\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n  tool_call_id: string;\n  status?: \"success\" | \"error\";\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Marker parameter for objects that tools can return directly.\n *\n * If a custom BaseTool is invoked with a ToolCall and the output of custom code is\n * not an instance of DirectToolOutput, the output will automatically be coerced to\n * a string and wrapped in a ToolMessage.\n */\nexport interface DirectToolOutput {\n  readonly lc_direct_tool_output: true;\n}\n\nexport function isDirectToolOutput(x: unknown): x is DirectToolOutput {\n  return (\n    x != null &&\n    typeof x === \"object\" &&\n    \"lc_direct_tool_output\" in x &&\n    x.lc_direct_tool_output === true\n  );\n}\n\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"tool\">\n  implements DirectToolOutput\n{\n  static lc_name() {\n    return \"ToolMessage\";\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return { tool_call_id: \"tool_call_id\" };\n  }\n\n  lc_direct_tool_output = true as const;\n\n  readonly type = \"tool\" as const;\n\n  /**\n   * Status of the tool invocation.\n   * @version 0.2.19\n   */\n  status?: \"success\" | \"error\";\n\n  tool_call_id: string;\n\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"tool\"> | ToolMessageFields,\n    tool_call_id: string,\n    name?: string\n  );\n\n  constructor(fields: ToolMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"tool\">\n      | ToolMessageFields<TStructure>,\n    tool_call_id?: string,\n    name?: string\n  ) {\n    const toolMessageFields: ToolMessageFields<TStructure> =\n      typeof fields === \"string\" || Array.isArray(fields)\n        ? { content: fields, name, tool_call_id: tool_call_id! }\n        : fields;\n    super(toolMessageFields);\n    this.tool_call_id = toolMessageFields.tool_call_id;\n    this.artifact = toolMessageFields.artifact;\n    this.status = toolMessageFields.status;\n    this.metadata = toolMessageFields.metadata;\n  }\n\n  static isInstance(message: unknown): message is ToolMessage {\n    return super.isInstance(message) && message.type === \"tool\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_call_id: this.tool_call_id,\n      artifact: this.artifact,\n    };\n  }\n}\n\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"tool\"> {\n  readonly type = \"tool\" as const;\n\n  tool_call_id: string;\n\n  /**\n   * Status of the tool invocation.\n   * @version 0.2.19\n   */\n  status?: \"success\" | \"error\";\n\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n\n  constructor(fields: ToolMessageFields<TStructure>) {\n    super(fields);\n    this.tool_call_id = fields.tool_call_id;\n    this.artifact = fields.artifact;\n    this.status = fields.status;\n  }\n\n  static lc_name() {\n    return \"ToolMessageChunk\";\n  }\n\n  concat(chunk: ToolMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      artifact: _mergeObj(this.artifact, chunk.artifact),\n      tool_call_id: this.tool_call_id,\n      id: this.id ?? chunk.id,\n      status: _mergeStatus(this.status, chunk.status),\n    });\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_call_id: this.tool_call_id,\n      artifact: this.artifact,\n    };\n  }\n}\n\nexport interface ToolCall<\n  TName extends string = string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  TArgs extends Record<string, any> = Record<string, any>\n> {\n  readonly type?: \"tool_call\";\n  /**\n   * If provided, an identifier associated with the tool call\n   */\n  id?: string;\n  /**\n   * The name of the tool being called\n   */\n  name: TName;\n  /**\n   * The arguments to the tool call\n   */\n  args: TArgs;\n}\n\n/**\n * A chunk of a tool call (e.g., as part of a stream).\n * When merging ToolCallChunks (e.g., via AIMessageChunk.__add__),\n * all string attributes are concatenated. Chunks are only merged if their\n * values of `index` are equal and not None.\n *\n * @example\n * ```ts\n * const leftChunks = [\n *   {\n *     name: \"foo\",\n *     args: '{\"a\":',\n *     index: 0\n *   }\n * ];\n *\n * const leftAIMessageChunk = new AIMessageChunk({\n *   content: \"\",\n *   tool_call_chunks: leftChunks\n * });\n *\n * const rightChunks = [\n *   {\n *     name: undefined,\n *     args: '1}',\n *     index: 0\n *   }\n * ];\n *\n * const rightAIMessageChunk = new AIMessageChunk({\n *   content: \"\",\n *   tool_call_chunks: rightChunks\n * });\n *\n * const result = leftAIMessageChunk.concat(rightAIMessageChunk);\n * // result.tool_call_chunks is equal to:\n * // [\n * //   {\n * //     name: \"foo\",\n * //     args: '{\"a\":1}'\n * //     index: 0\n * //   }\n * // ]\n * ```\n */\nexport interface ToolCallChunk<TName extends string = string> {\n  readonly type?: \"tool_call_chunk\";\n  /**\n   * If provided, a substring of an identifier for the tool call\n   */\n  id?: string;\n  /**\n   * If provided, a substring of the name of the tool to be called\n   */\n  name?: TName;\n  /**\n   * If provided, a JSON substring of the arguments to the tool call\n   */\n  args?: string;\n  /**\n   * If provided, the index of the tool call in a sequence\n   */\n  index?: number;\n}\n\nexport interface InvalidToolCall<TName extends string = string> {\n  readonly type?: \"invalid_tool_call\";\n  /**\n   * If provided, an identifier associated with the tool call\n   */\n  id?: string;\n  /**\n      /**\n     * The name of the tool being called\n     */\n  name?: TName;\n  /**\n   * The arguments to the tool call\n   */\n  args?: string;\n  /**\n   * An error message associated with the tool call\n   */\n  error?: string;\n  /**\n   * Index of block in aggregate response\n   */\n  index?: string | number;\n}\n\nexport function defaultToolCallParser(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCalls: Record<string, any>[]\n): [ToolCall[], InvalidToolCall[]] {\n  const toolCalls: ToolCall[] = [];\n  const invalidToolCalls: InvalidToolCall[] = [];\n  for (const toolCall of rawToolCalls) {\n    if (!toolCall.function) {\n      continue;\n    } else {\n      const functionName = toolCall.function.name;\n      try {\n        const functionArgs = JSON.parse(toolCall.function.arguments);\n        toolCalls.push({\n          name: functionName || \"\",\n          args: functionArgs || {},\n          id: toolCall.id,\n        });\n      } catch {\n        invalidToolCalls.push({\n          name: functionName,\n          args: toolCall.function.arguments,\n          id: toolCall.id,\n          error: \"Malformed args.\",\n        });\n      }\n    }\n  }\n  return [toolCalls, invalidToolCalls];\n}\n\n/**\n * @deprecated Use {@link ToolMessage.isInstance} instead\n */\nexport function isToolMessage(x: unknown): x is ToolMessage {\n  return (\n    typeof x === \"object\" &&\n    x !== null &&\n    \"getType\" in x &&\n    typeof x.getType === \"function\" &&\n    x.getType() === \"tool\"\n  );\n}\n\n/**\n * @deprecated Use {@link ToolMessageChunk.isInstance} instead\n */\nexport function isToolMessageChunk(x: BaseMessageChunk): x is ToolMessageChunk {\n  return x._getType() === \"tool\";\n}\n"],"names":["x: unknown","BaseMessage","fields:\n      | $InferMessageContent<TStructure, \"tool\">\n      | ToolMessageFields<TStructure>","tool_call_id?: string","name?: string","toolMessageFields: ToolMessageFields<TStructure>","message: unknown","BaseMessageChunk","fields: ToolMessageFields<TStructure>","chunk: ToolMessageChunk<TStructure>","mergeContent","_mergeDicts","_mergeObj","_mergeStatus","rawToolCalls: Record<string, any>[]","toolCalls: ToolCall[]","invalidToolCalls: InvalidToolCall[]","x: BaseMessageChunk"],"mappings":"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"}},
    {"offset": {"line": 2014, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/ai.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/ai.ts"],"sourcesContent":["import { parsePartialJson } from \"../utils/json.js\";\nimport {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  _mergeLists,\n  BaseMessageFields,\n} from \"./base.js\";\nimport { getTranslator } from \"./block_translators/index.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport {\n  $InferMessageContent,\n  $InferMessageProperty,\n  MessageStructure,\n} from \"./message.js\";\nimport { mergeResponseMetadata, mergeUsageMetadata } from \"./metadata.js\";\nimport {\n  InvalidToolCall,\n  ToolCall,\n  ToolCallChunk,\n  defaultToolCallParser,\n} from \"./tool.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface AIMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"ai\"> {\n  tool_calls?: ToolCall[];\n  invalid_tool_calls?: InvalidToolCall[];\n  usage_metadata?: $InferMessageProperty<TStructure, \"ai\", \"usage_metadata\">;\n}\n\nexport class AIMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"ai\">\n  implements AIMessageFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  usage_metadata?: AIMessageFields<TStructure>[\"usage_metadata\"];\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n    };\n  }\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>\n  ) {\n    let initParams: AIMessageFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        additional_kwargs: {},\n      };\n    } else {\n      initParams = fields;\n      const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n      const toolCalls = initParams.tool_calls;\n      if (\n        !(rawToolCalls == null) &&\n        rawToolCalls.length > 0 &&\n        (toolCalls === undefined || toolCalls.length === 0)\n      ) {\n        console.warn(\n          [\n            \"New LangChain packages are available that more efficiently handle\",\n            \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n            \"message tool calls. e.g., `pnpm install @langchain/anthropic`,\",\n            \"pnpm install @langchain/openai`, etc.\",\n          ].join(\" \")\n        );\n      }\n      try {\n        if (!(rawToolCalls == null) && toolCalls === undefined) {\n          const [toolCalls, invalidToolCalls] =\n            defaultToolCallParser(rawToolCalls);\n          initParams.tool_calls = toolCalls ?? [];\n          initParams.invalid_tool_calls = invalidToolCalls ?? [];\n        } else {\n          initParams.tool_calls = initParams.tool_calls ?? [];\n          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n        }\n      } catch {\n        // Do nothing if parsing fails\n        initParams.tool_calls = [];\n        initParams.invalid_tool_calls = [];\n      }\n\n      // Convert content to content blocks if output version is v1\n      if (\n        initParams.response_metadata !== undefined &&\n        \"output_version\" in initParams.response_metadata &&\n        initParams.response_metadata.output_version === \"v1\"\n      ) {\n        initParams.contentBlocks =\n          initParams.content as Array<ContentBlock.Standard>;\n        initParams.content = undefined;\n      }\n\n      if (initParams.contentBlocks !== undefined) {\n        // Add constructor tool calls as content blocks\n        initParams.contentBlocks.push(\n          ...initParams.tool_calls.map((toolCall) => ({\n            type: \"tool_call\" as const,\n            id: toolCall.id,\n            name: toolCall.name,\n            args: toolCall.args,\n          }))\n        );\n        // Add content block tool calls that aren't in the constructor tool calls\n        const missingToolCalls = initParams.contentBlocks\n          .filter<ContentBlock.Tools.ToolCall>(\n            (block): block is ContentBlock.Tools.ToolCall =>\n              block.type === \"tool_call\"\n          )\n          .filter(\n            (block) =>\n              !initParams.tool_calls?.some(\n                (toolCall) =>\n                  toolCall.id === block.id && toolCall.name === block.name\n              )\n          );\n        if (missingToolCalls.length > 0) {\n          initParams.tool_calls = missingToolCalls.map((block) => ({\n            type: \"tool_call\" as const,\n            id: block.id!,\n            name: block.name,\n            args: block.args as Record<string, unknown>,\n          }));\n        }\n      }\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    if (typeof initParams !== \"string\") {\n      this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n      this.invalid_tool_calls =\n        initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  static lc_name() {\n    return \"AIMessage\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      const missingToolCalls = this.tool_calls.filter(\n        (block) =>\n          !blocks.some((b) => b.id === block.id && b.name === block.name)\n      );\n      blocks.push(\n        ...missingToolCalls.map((block) => ({\n          ...block,\n          type: \"tool_call\" as const,\n          id: block.id,\n          name: block.name,\n          args: block.args,\n        }))\n      );\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is AIMessage {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n\n/**\n * @deprecated Use {@link AIMessage.isInstance} instead\n */\nexport function isAIMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is AIMessage<TStructure> {\n  return x._getType() === \"ai\";\n}\n\n/**\n * @deprecated Use {@link AIMessageChunk.isInstance} instead\n */\nexport function isAIMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is AIMessageChunk<TStructure> {\n  return x._getType() === \"ai\";\n}\n\nexport type AIMessageChunkFields<\n  TStructure extends MessageStructure = MessageStructure\n> = AIMessageFields<TStructure> & {\n  tool_call_chunks?: ToolCallChunk[];\n};\n\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessageChunk<TStructure, \"ai\">\n  implements AIMessage<TStructure>, AIMessageChunkFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  tool_call_chunks?: ToolCallChunk[] = [];\n\n  usage_metadata?: AIMessageChunkFields<TStructure>[\"usage_metadata\"];\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>\n  ) {\n    let initParams: AIMessageChunkFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n      };\n    } else if (\n      fields.tool_call_chunks === undefined ||\n      fields.tool_call_chunks.length === 0\n    ) {\n      initParams = {\n        ...fields,\n        tool_calls: fields.tool_calls ?? [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    } else {\n      const toolCallChunks = fields.tool_call_chunks ?? [];\n      const groupedToolCallChunks = toolCallChunks.reduce((acc, chunk) => {\n        const matchedChunkIndex = acc.findIndex(([match]) => {\n          // If chunk has an id and index, match if both are present\n          if (\n            \"id\" in chunk &&\n            chunk.id &&\n            \"index\" in chunk &&\n            chunk.index !== undefined\n          ) {\n            return chunk.id === match.id && chunk.index === match.index;\n          }\n          // If chunk has an id, we match on id\n          if (\"id\" in chunk && chunk.id) {\n            return chunk.id === match.id;\n          }\n          // If chunk has an index, we match on index\n          if (\"index\" in chunk && chunk.index !== undefined) {\n            return chunk.index === match.index;\n          }\n          return false;\n        });\n        if (matchedChunkIndex !== -1) {\n          acc[matchedChunkIndex].push(chunk);\n        } else {\n          acc.push([chunk]);\n        }\n        return acc;\n      }, [] as ToolCallChunk[][]);\n\n      const toolCalls: ToolCall[] = [];\n      const invalidToolCalls: InvalidToolCall[] = [];\n      for (const chunks of groupedToolCallChunks) {\n        let parsedArgs: Record<string, unknown> | null = null;\n        const name = chunks[0]?.name ?? \"\";\n        const joinedArgs = chunks.map((c) => c.args || \"\").join(\"\");\n        const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n        const id = chunks[0]?.id;\n        try {\n          parsedArgs = parsePartialJson(argsStr);\n          if (\n            !id ||\n            parsedArgs === null ||\n            typeof parsedArgs !== \"object\" ||\n            Array.isArray(parsedArgs)\n          ) {\n            throw new Error(\"Malformed tool call chunk args.\");\n          }\n          toolCalls.push({\n            name,\n            args: parsedArgs,\n            id,\n            type: \"tool_call\",\n          });\n        } catch {\n          invalidToolCalls.push({\n            name,\n            args: argsStr,\n            id,\n            error: \"Malformed args.\",\n            type: \"invalid_tool_call\",\n          });\n        }\n      }\n      initParams = {\n        ...fields,\n        tool_calls: toolCalls,\n        invalid_tool_calls: invalidToolCalls,\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    this.tool_call_chunks =\n      initParams.tool_call_chunks ?? this.tool_call_chunks;\n    this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n    this.invalid_tool_calls =\n      initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n      tool_call_chunks: \"tool_call_chunks\",\n    };\n  }\n\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      if (typeof this.content !== \"string\") {\n        const contentToolCalls = this.content\n          .filter((block) => block.type === \"tool_call\")\n          .map((block) => block.id);\n        for (const toolCall of this.tool_calls) {\n          if (toolCall.id && !contentToolCalls.includes(toolCall.id)) {\n            blocks.push({\n              ...toolCall,\n              type: \"tool_call\",\n              id: toolCall.id,\n              name: toolCall.name,\n              args: toolCall.args,\n            });\n          }\n        }\n      }\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      tool_call_chunks: this.tool_call_chunks,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  concat(chunk: AIMessageChunk<TStructure>) {\n    const combinedFields: AIMessageChunkFields = {\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: mergeResponseMetadata(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      tool_call_chunks: [],\n      id: this.id ?? chunk.id,\n    };\n    if (\n      this.tool_call_chunks !== undefined ||\n      chunk.tool_call_chunks !== undefined\n    ) {\n      const rawToolCalls = _mergeLists(\n        this.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[],\n        chunk.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[]\n      );\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_call_chunks = rawToolCalls;\n      }\n    }\n    if (\n      this.usage_metadata !== undefined ||\n      chunk.usage_metadata !== undefined\n    ) {\n      combinedFields.usage_metadata = mergeUsageMetadata(\n        this.usage_metadata,\n        chunk.usage_metadata\n      );\n    }\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls(combinedFields);\n  }\n\n  static isInstance(obj: unknown): obj is AIMessageChunk {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n"],"names":["BaseMessage","fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>","initParams: AIMessageFields<TStructure>","toolCalls","defaultToolCallParser","getTranslator","obj: unknown","x: BaseMessage","x: BaseMessageChunk","BaseMessageChunk","fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>","initParams: AIMessageChunkFields<TStructure>","toolCalls: ToolCall[]","invalidToolCalls: InvalidToolCall[]","parsedArgs: Record<string, unknown> | null","parsePartialJson","chunk: AIMessageChunk<TStructure>","combinedFields: AIMessageChunkFields","mergeContent","_mergeDicts","mergeResponseMetadata","_mergeLists","mergeUsageMetadata"],"mappings":";;;;;;AAiCA,IAAa,YAAb,cACUA,aAAAA,WAAAA,CAEV;IACW,OAAO,KAAA;IAEhB,aAA0B,CAAE,CAAA,CAAA;IAE5B,qBAAyC,CAAE,CAAA,CAAA;IAE3C,eAAA;IAEA,IAAI,aAAqC;QAEvC,OAAO;YACL,GAAG,KAAA,CAAM,UAAA;YACT,YAAY;YACZ,oBAAoB;QACrB;IACF;IAED,YACEC,MAAAA,CACA;QACA,IAAIC;QACJ,IAAI,OAAO,WAAW,YAAY,MAAM,OAAA,CAAQ,OAAO,EACrD,aAAa;YACX,SAAS;YACT,YAAY,CAAE,CAAA;YACd,oBAAoB,CAAE,CAAA;YACtB,mBAAmB,CAAE;QACtB;aACI;YACL,aAAa;YACb,MAAM,eAAe,WAAW,iBAAA,EAAmB;YACnD,MAAM,YAAY,WAAW,UAAA;YAC7B,IACE,CAAA,CAAE,gBAAgB,IAAA,KAClB,aAAa,MAAA,GAAS,KAAA,CACrB,cAAc,KAAA,KAAa,UAAU,MAAA,KAAW,CAAA,GAEjD,QAAQ,IAAA,CACN;gBACE;gBACA;gBACA;gBACA;aACD,CAAC,IAAA,CAAK,IAAI,CACZ;YAEH,IAAI;gBACF,IAAI,CAAA,CAAE,gBAAgB,IAAA,KAAS,cAAc,KAAA,GAAW;oBACtD,MAAM,CAACC,aAAW,iBAAiB,GACjCC,sBAAAA,qBAAAA,CAAsB,aAAa;oBACrC,WAAW,UAAA,GAAaD,eAAa,CAAE,CAAA;oBACvC,WAAW,kBAAA,GAAqB,oBAAoB,CAAE,CAAA;gBACvD,OAAM;oBACL,WAAW,UAAA,GAAa,WAAW,UAAA,IAAc,CAAE,CAAA;oBACnD,WAAW,kBAAA,GAAqB,WAAW,kBAAA,IAAsB,CAAE,CAAA;gBACpE;YACF,EAAA,OAAO;gBAEN,WAAW,UAAA,GAAa,CAAE,CAAA;gBAC1B,WAAW,kBAAA,GAAqB,CAAE,CAAA;YACnC;YAGD,IACE,WAAW,iBAAA,KAAsB,KAAA,KACjC,oBAAoB,WAAW,iBAAA,IAC/B,WAAW,iBAAA,CAAkB,cAAA,KAAmB,MAChD;gBACA,WAAW,aAAA,GACT,WAAW,OAAA;gBACb,WAAW,OAAA,GAAU,KAAA;YACtB;YAED,IAAI,WAAW,aAAA,KAAkB,KAAA,GAAW;gBAE1C,WAAW,aAAA,CAAc,IAAA,CACvB,GAAG,WAAW,UAAA,CAAW,GAAA,CAAI,CAAC,WAAA,CAAc;wBAC1C,MAAM;wBACN,IAAI,SAAS,EAAA;wBACb,MAAM,SAAS,IAAA;wBACf,MAAM,SAAS,IAAA;oBAChB,CAAA,EAAE,CACJ;gBAED,MAAM,mBAAmB,WAAW,aAAA,CACjC,MAAA,CACC,CAAC,QACC,MAAM,IAAA,KAAS,YAClB,CACA,MAAA,CACC,CAAC,QACC,CAAC,WAAW,UAAA,EAAY,KACtB,CAAC,WACC,SAAS,EAAA,KAAO,MAAM,EAAA,IAAM,SAAS,IAAA,KAAS,MAAM,IAAA,CACvD,CACJ;gBACH,IAAI,iBAAiB,MAAA,GAAS,GAC5B,WAAW,UAAA,GAAa,iBAAiB,GAAA,CAAI,CAAC,QAAA,CAAW;wBACvD,MAAM;wBACN,IAAI,MAAM,EAAA;wBACV,MAAM,MAAM,IAAA;wBACZ,MAAM,MAAM,IAAA;oBACb,CAAA,EAAE;YAEN;QACF;QAGD,KAAA,CAAM,WAAW;QACjB,IAAI,OAAO,eAAe,UAAU;YAClC,IAAA,CAAK,UAAA,GAAa,WAAW,UAAA,IAAc,IAAA,CAAK,UAAA;YAChD,IAAA,CAAK,kBAAA,GACH,WAAW,kBAAA,IAAsB,IAAA,CAAK,kBAAA;QACzC;QACD,IAAA,CAAK,cAAA,GAAiB,WAAW,cAAA;IAClC;IAED,OAAO,UAAU;QACf,OAAO;IACR;IAED,IAAI,gBAA8C;QAChD,IACE,IAAA,CAAK,iBAAA,IACL,oBAAoB,IAAA,CAAK,iBAAA,IACzB,IAAA,CAAK,iBAAA,CAAkB,cAAA,KAAmB,KAE1C,CAAA,OAAO,IAAA,CAAK,OAAA;QAGd,IACE,IAAA,CAAK,iBAAA,IACL,oBAAoB,IAAA,CAAK,iBAAA,IACzB,OAAO,IAAA,CAAK,iBAAA,CAAkB,cAAA,KAAmB,UACjD;YACA,MAAM,aAAaE,cAAAA,aAAAA,CAAc,IAAA,CAAK,iBAAA,CAAkB,cAAA,CAAe;YACvE,IAAI,WACF,CAAA,OAAO,WAAW,gBAAA,CAAiB,IAAA,CAAK;QAE3C;QAED,MAAM,SAAS,KAAA,CAAM;QAErB,IAAI,IAAA,CAAK,UAAA,EAAY;YACnB,MAAM,mBAAmB,IAAA,CAAK,UAAA,CAAW,MAAA,CACvC,CAAC,QACC,CAAC,OAAO,IAAA,CAAK,CAAC,IAAM,EAAE,EAAA,KAAO,MAAM,EAAA,IAAM,EAAE,IAAA,KAAS,MAAM,IAAA,CAAK,CAClE;YACD,OAAO,IAAA,CACL,GAAG,iBAAiB,GAAA,CAAI,CAAC,QAAA,CAAW;oBAClC,GAAG,KAAA;oBACH,MAAM;oBACN,IAAI,MAAM,EAAA;oBACV,MAAM,MAAM,IAAA;oBACZ,MAAM,MAAM,IAAA;gBACb,CAAA,EAAE,CACJ;QACF;QAED,OAAO;IACR;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,YAAY,IAAA,CAAK,UAAA;YACjB,oBAAoB,IAAA,CAAK,kBAAA;YACzB,gBAAgB,IAAA,CAAK,cAAA;QACtB;IACF;IAED,OAAO,WAAWC,GAAAA,EAAgC;QAChD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;GAKD,SAAgB,YACdC,CAAAA,EAC4B;IAC5B,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;;;GAKD,SAAgB,iBACdC,CAAAA,EACiC;IACjC,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;;;;GAYD,IAAa,iBAAb,cAGUC,aAAAA,gBAAAA,CAEV;IACW,OAAO,KAAA;IAEhB,aAA0B,CAAE,CAAA,CAAA;IAE5B,qBAAyC,CAAE,CAAA,CAAA;IAE3C,mBAAqC,CAAE,CAAA,CAAA;IAEvC,eAAA;IAEA,YACEC,MAAAA,CAGA;QACA,IAAIC;QACJ,IAAI,OAAO,WAAW,YAAY,MAAM,OAAA,CAAQ,OAAO,EACrD,aAAa;YACX,SAAS;YACT,YAAY,CAAE,CAAA;YACd,oBAAoB,CAAE,CAAA;YACtB,kBAAkB,CAAE,CAAA;QACrB;iBAED,OAAO,gBAAA,KAAqB,KAAA,KAC5B,OAAO,gBAAA,CAAiB,MAAA,KAAW,GAEnC,aAAa;YACX,GAAG,MAAA;YACH,YAAY,OAAO,UAAA,IAAc,CAAE,CAAA;YACnC,oBAAoB,CAAE,CAAA;YACtB,kBAAkB,CAAE,CAAA;YACpB,gBACE,OAAO,cAAA,KAAmB,KAAA,IACtB,OAAO,cAAA,GACP,KAAA;QACP;aACI;YACL,MAAM,iBAAiB,OAAO,gBAAA,IAAoB,CAAE,CAAA;YACpD,MAAM,wBAAwB,eAAe,MAAA,CAAO,CAAC,KAAK,UAAU;gBAClE,MAAM,oBAAoB,IAAI,SAAA,CAAU,CAAC,CAAC,MAAM,KAAK;oBAEnD,IACE,QAAQ,SACR,MAAM,EAAA,IACN,WAAW,SACX,MAAM,KAAA,KAAU,KAAA,EAEhB,CAAA,OAAO,MAAM,EAAA,KAAO,MAAM,EAAA,IAAM,MAAM,KAAA,KAAU,MAAM,KAAA;oBAGxD,IAAI,QAAQ,SAAS,MAAM,EAAA,CACzB,CAAA,OAAO,MAAM,EAAA,KAAO,MAAM,EAAA;oBAG5B,IAAI,WAAW,SAAS,MAAM,KAAA,KAAU,KAAA,EACtC,CAAA,OAAO,MAAM,KAAA,KAAU,MAAM,KAAA;oBAE/B,OAAO;gBACR,EAAC;gBACF,IAAI,sBAAsB,CAAA,GACxB,GAAA,CAAI,kBAAA,CAAmB,IAAA,CAAK,MAAM;qBAElC,IAAI,IAAA,CAAK;oBAAC,KAAM;iBAAA,CAAC;gBAEnB,OAAO;YACR,GAAE,CAAE,CAAA,CAAsB;YAE3B,MAAMC,YAAwB,CAAE,CAAA;YAChC,MAAMC,mBAAsC,CAAE,CAAA;YAC9C,KAAK,MAAM,UAAU,sBAAuB;gBAC1C,IAAIC,aAA6C;gBACjD,MAAM,OAAO,MAAA,CAAO,EAAA,EAAI,QAAQ;gBAChC,MAAM,aAAa,OAAO,GAAA,CAAI,CAAC,IAAM,EAAE,IAAA,IAAQ,GAAG,CAAC,IAAA,CAAK,GAAG;gBAC3D,MAAM,UAAU,WAAW,MAAA,GAAS,aAAa;gBACjD,MAAM,KAAK,MAAA,CAAO,EAAA,EAAI;gBACtB,IAAI;oBACF,aAAaC,aAAAA,gBAAAA,CAAiB,QAAQ;oBACtC,IACE,CAAC,MACD,eAAe,QACf,OAAO,eAAe,YACtB,MAAM,OAAA,CAAQ,WAAW,CAEzB,CAAA,MAAM,IAAI,MAAM;oBAElB,UAAU,IAAA,CAAK;wBACb;wBACA,MAAM;wBACN;wBACA,MAAM;oBACP,EAAC;gBACH,EAAA,OAAO;oBACN,iBAAiB,IAAA,CAAK;wBACpB;wBACA,MAAM;wBACN;wBACA,OAAO;wBACP,MAAM;oBACP,EAAC;gBACH;YACF;YACD,aAAa;gBACX,GAAG,MAAA;gBACH,YAAY;gBACZ,oBAAoB;gBACpB,gBACE,OAAO,cAAA,KAAmB,KAAA,IACtB,OAAO,cAAA,GACP,KAAA;YACP;QACF;QAGD,KAAA,CAAM,WAAW;QACjB,IAAA,CAAK,gBAAA,GACH,WAAW,gBAAA,IAAoB,IAAA,CAAK,gBAAA;QACtC,IAAA,CAAK,UAAA,GAAa,WAAW,UAAA,IAAc,IAAA,CAAK,UAAA;QAChD,IAAA,CAAK,kBAAA,GACH,WAAW,kBAAA,IAAsB,IAAA,CAAK,kBAAA;QACxC,IAAA,CAAK,cAAA,GAAiB,WAAW,cAAA;IAClC;IAED,IAAI,aAAqC;QAEvC,OAAO;YACL,GAAG,KAAA,CAAM,UAAA;YACT,YAAY;YACZ,oBAAoB;YACpB,kBAAkB;QACnB;IACF;IAED,OAAO,UAAU;QACf,OAAO;IACR;IAED,IAAI,gBAA8C;QAChD,IACE,IAAA,CAAK,iBAAA,IACL,oBAAoB,IAAA,CAAK,iBAAA,IACzB,IAAA,CAAK,iBAAA,CAAkB,cAAA,KAAmB,KAE1C,CAAA,OAAO,IAAA,CAAK,OAAA;QAGd,IACE,IAAA,CAAK,iBAAA,IACL,oBAAoB,IAAA,CAAK,iBAAA,IACzB,OAAO,IAAA,CAAK,iBAAA,CAAkB,cAAA,KAAmB,UACjD;YACA,MAAM,aAAaV,cAAAA,aAAAA,CAAc,IAAA,CAAK,iBAAA,CAAkB,cAAA,CAAe;YACvE,IAAI,WACF,CAAA,OAAO,WAAW,gBAAA,CAAiB,IAAA,CAAK;QAE3C;QAED,MAAM,SAAS,KAAA,CAAM;QAErB,IAAI,IAAA,CAAK,UAAA,EACP;gBAAI,OAAO,IAAA,CAAK,OAAA,KAAY,UAAU;gBACpC,MAAM,mBAAmB,IAAA,CAAK,OAAA,CAC3B,MAAA,CAAO,CAAC,QAAU,MAAM,IAAA,KAAS,YAAY,CAC7C,GAAA,CAAI,CAAC,QAAU,MAAM,EAAA,CAAG;gBAC3B,KAAK,MAAM,YAAY,IAAA,CAAK,UAAA,CAC1B,IAAI,SAAS,EAAA,IAAM,CAAC,iBAAiB,QAAA,CAAS,SAAS,EAAA,CAAG,EACxD,OAAO,IAAA,CAAK;oBACV,GAAG,QAAA;oBACH,MAAM;oBACN,IAAI,SAAS,EAAA;oBACb,MAAM,SAAS,IAAA;oBACf,MAAM,SAAS,IAAA;gBAChB,EAAC;YAGP;;QAGH,OAAO;IACR;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,YAAY,IAAA,CAAK,UAAA;YACjB,kBAAkB,IAAA,CAAK,gBAAA;YACvB,oBAAoB,IAAA,CAAK,kBAAA;YACzB,gBAAgB,IAAA,CAAK,cAAA;QACtB;IACF;IAED,OAAOW,KAAAA,EAAmC;QACxC,MAAMC,iBAAuC;YAC3C,SAASC,aAAAA,YAAAA,CAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,mBAAmBC,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,mBAAmBC,iBAAAA,qBAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,kBAAkB,CAAE,CAAA;YACpB,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;QACD,IACE,IAAA,CAAK,gBAAA,KAAqB,KAAA,KAC1B,MAAM,gBAAA,KAAqB,KAAA,GAC3B;YACA,MAAM,eAAeC,aAAAA,WAAAA,CACnB,IAAA,CAAK,gBAAA,EACL,MAAM,gBAAA,CACP;YACD,IAAI,iBAAiB,KAAA,KAAa,aAAa,MAAA,GAAS,GACtD,eAAe,gBAAA,GAAmB;QAErC;QACD,IACE,IAAA,CAAK,cAAA,KAAmB,KAAA,KACxB,MAAM,cAAA,KAAmB,KAAA,GAEzB,eAAe,cAAA,GAAiBC,iBAAAA,kBAAAA,CAC9B,IAAA,CAAK,cAAA,EACL,MAAM,cAAA,CACP;QAEH,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;IAChB;IAED,OAAO,WAAWhB,GAAAA,EAAqC;QACrD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF"}},
    {"offset": {"line": 2282, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/chat.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/chat.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface ChatMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"generic\"> {\n  role: string;\n}\n\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"generic\">\n  implements ChatMessageFields<TStructure>\n{\n  static lc_name() {\n    return \"ChatMessage\";\n  }\n\n  readonly type = \"generic\" as const;\n\n  role: string;\n\n  static _chatMessageClass(): typeof ChatMessage {\n    return ChatMessage;\n  }\n\n  constructor(\n    content: $InferMessageContent<TStructure, \"generic\">,\n    role: string\n  );\n\n  constructor(fields: ChatMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>,\n    role?: string\n  ) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = { content: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  static isInstance(obj: unknown): obj is ChatMessage {\n    return super.isInstance(obj) && obj.type === \"generic\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      role: this.role,\n    };\n  }\n}\n\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"generic\"> {\n  static lc_name() {\n    return \"ChatMessageChunk\";\n  }\n\n  readonly type = \"generic\" as const;\n\n  role: string;\n\n  constructor(\n    content: $InferMessageContent<TStructure, \"generic\">,\n    role: string\n  );\n\n  constructor(fields: ChatMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>,\n    role?: string\n  ) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = { content: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  concat(chunk: ChatMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      role: this.role,\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is ChatMessageChunk {\n    return super.isInstance(obj) && obj.type === \"generic\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      role: this.role,\n    };\n  }\n}\n\n/**\n * @deprecated Use {@link ChatMessage.isInstance} instead\n */\nexport function isChatMessage(x: BaseMessage): x is ChatMessage {\n  return x._getType() === \"generic\";\n}\n\n/**\n * @deprecated Use {@link ChatMessageChunk.isInstance} instead\n */\nexport function isChatMessageChunk(x: BaseMessageChunk): x is ChatMessageChunk {\n  return x._getType() === \"generic\";\n}\n"],"names":["BaseMessage","fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>","role?: string","obj: unknown","BaseMessageChunk","chunk: ChatMessageChunk<TStructure>","mergeContent","_mergeDicts","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;GAmBA,IAAa,cAAb,MAAa,oBACHA,aAAAA,WAAAA,CAEV;IACE,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,UAAA;IAEhB,KAAA;IAEA,OAAO,oBAAwC;QAC7C,OAAO;IACR;IASD,YACEC,MAAAA,EAGAC,IAAAA,CACA;QACA,IAAI,OAAO,WAAW,YAAY,MAAM,OAAA,CAAQ,OAAO,EAErD,SAAS;YAAE,SAAS;YAAc;QAAO;QAE3C,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IACpB;IAED,OAAO,WAAWC,GAAAA,EAAkC;QAClD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,MAAM,IAAA,CAAK,IAAA;QACZ;IACF;AACF;;;;GAMD,IAAa,mBAAb,cAEUC,aAAAA,gBAAAA,CAAwC;IAChD,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,UAAA;IAEhB,KAAA;IASA,YACEH,MAAAA,EAGAC,IAAAA,CACA;QACA,IAAI,OAAO,WAAW,YAAY,MAAM,OAAA,CAAQ,OAAO,EAErD,SAAS;YAAE,SAAS;YAAc;QAAO;QAE3C,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IACpB;IAED,OAAOG,KAAAA,EAAqC;QAC1C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,SAASC,aAAAA,YAAAA,CAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,mBAAmBC,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,mBAAmBA,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,MAAM,IAAA,CAAK,IAAA;YACX,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;IAED,OAAO,WAAWJ,GAAAA,EAAuC;QACvD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,MAAM,IAAA,CAAK,IAAA;QACZ;IACF;AACF;;;GAKD,SAAgB,cAAcK,CAAAA,EAAkC;IAC9D,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;;;GAKD,SAAgB,mBAAmBC,CAAAA,EAA4C;IAC7E,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB"}},
    {"offset": {"line": 2368, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/function.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/function.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n} from \"./base.js\";\nimport { MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface FunctionMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"function\"> {\n  name: string;\n}\n\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessage<TStructure, \"function\">\n  implements FunctionMessageFields<TStructure>\n{\n  static lc_name() {\n    return \"FunctionMessage\";\n  }\n\n  readonly type = \"function\" as const;\n\n  name: string;\n\n  constructor(fields: FunctionMessageFields<TStructure>) {\n    super(fields);\n    this.name = fields.name;\n  }\n}\n\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"function\"> {\n  static lc_name() {\n    return \"FunctionMessageChunk\";\n  }\n\n  readonly type = \"function\" as const;\n\n  concat(chunk: FunctionMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      name: this.name ?? \"\",\n      id: this.id ?? chunk.id,\n    });\n  }\n}\n\nexport function isFunctionMessage(x: BaseMessage): x is FunctionMessage {\n  return x._getType() === \"function\";\n}\n\nexport function isFunctionMessageChunk(\n  x: BaseMessageChunk\n): x is FunctionMessageChunk {\n  return x._getType() === \"function\";\n}\n"],"names":["BaseMessage","fields: FunctionMessageFields<TStructure>","BaseMessageChunk","chunk: FunctionMessageChunk<TStructure>","mergeContent","_mergeDicts","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;GAmBA,IAAa,kBAAb,cAGUA,aAAAA,WAAAA,CAEV;IACE,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,WAAA;IAEhB,KAAA;IAEA,YAAYC,MAAAA,CAA2C;QACrD,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IACpB;AACF;;;;GAMD,IAAa,uBAAb,cAEUC,aAAAA,gBAAAA,CAAyC;IACjD,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,WAAA;IAEhB,OAAOC,KAAAA,EAAyC;QAC9C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,SAASC,aAAAA,YAAAA,CAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,mBAAmBC,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,mBAAmBA,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,MAAM,IAAA,CAAK,IAAA,IAAQ;YACnB,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;AACF;AAED,SAAgB,kBAAkBC,CAAAA,EAAsC;IACtE,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;AAED,SAAgB,uBACdC,CAAAA,EAC2B;IAC3B,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB"}},
    {"offset": {"line": 2416, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/human.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/human.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  type BaseMessageFields,\n} from \"./base.js\";\nimport type { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface HumanMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"human\"> {}\n\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"human\"> {\n  static lc_name() {\n    return \"HumanMessage\";\n  }\n\n  readonly type = \"human\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  static isInstance(obj: unknown): obj is HumanMessage {\n    return super.isInstance(obj) && obj.type === \"human\";\n  }\n}\n\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"human\"> {\n  static lc_name() {\n    return \"HumanMessageChunk\";\n  }\n\n  readonly type = \"human\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  concat(chunk: HumanMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is HumanMessageChunk {\n    return super.isInstance(obj) && obj.type === \"human\";\n  }\n}\n\n/**\n * @deprecated Use {@link HumanMessage.isInstance} instead\n */\nexport function isHumanMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is HumanMessage<TStructure> {\n  return x.getType() === \"human\";\n}\n\n/**\n * @deprecated Use {@link HumanMessageChunk.isInstance} instead\n */\nexport function isHumanMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is HumanMessageChunk<TStructure> {\n  return x.getType() === \"human\";\n}\n"],"names":["BaseMessage","fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>","obj: unknown","BaseMessageChunk","chunk: HumanMessageChunk<TStructure>","mergeContent","_mergeDicts","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;GAiBA,IAAa,eAAb,cAEUA,aAAAA,WAAAA,CAAiC;IACzC,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,QAAA;IAEhB,YACEC,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;IAED,OAAO,WAAWC,GAAAA,EAAmC;QACnD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;;GAMD,IAAa,oBAAb,cAEUC,aAAAA,gBAAAA,CAAsC;IAC9C,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,QAAA;IAEhB,YACEF,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;IAED,OAAOG,KAAAA,EAAsC;QAC3C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,SAASC,aAAAA,YAAAA,CAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,mBAAmBC,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,mBAAmBA,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;IAED,OAAO,WAAWJ,GAAAA,EAAwC;QACxD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;GAKD,SAAgB,eACdK,CAAAA,EAC+B;IAC/B,OAAO,EAAE,OAAA,EAAS,KAAK;AACxB;;;GAKD,SAAgB,oBACdC,CAAAA,EACoC;IACpC,OAAO,EAAE,OAAA,EAAS,KAAK;AACxB"}},
    {"offset": {"line": 2474, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/system.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/system.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  type BaseMessageFields,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface SystemMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"system\"> {}\n\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"system\"> {\n  static lc_name() {\n    return \"SystemMessage\";\n  }\n\n  readonly type = \"system\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  /**\n   * Concatenates a string or another system message with the current system message.\n   * @param chunk - The chunk to concatenate with the system message.\n   * @returns A new system message with the concatenated content.\n   */\n  concat(chunk: string | SystemMessage) {\n    if (typeof chunk === \"string\") {\n      return new SystemMessage({\n        ...this,\n        content: mergeContent(this.content, chunk),\n      });\n    }\n\n    if (SystemMessage.isInstance(chunk)) {\n      return new SystemMessage({\n        ...this,\n        additional_kwargs: {\n          ...this.additional_kwargs,\n          ...chunk.additional_kwargs,\n        },\n        response_metadata: {\n          ...this.response_metadata,\n          ...chunk.response_metadata,\n        },\n        content: mergeContent(this.content, chunk.content),\n      });\n    }\n\n    throw new Error(\"Unexpected chunk type for system message\");\n  }\n\n  static isInstance(obj: unknown): obj is SystemMessage {\n    return super.isInstance(obj) && obj.type === \"system\";\n  }\n}\n\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"system\"> {\n  static lc_name() {\n    return \"SystemMessageChunk\";\n  }\n\n  readonly type = \"system\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  concat(chunk: SystemMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is SystemMessageChunk {\n    return super.isInstance(obj) && obj.type === \"system\";\n  }\n}\n\n/**\n * @deprecated Use {@link SystemMessage.isInstance} instead\n */\nexport function isSystemMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is SystemMessage<TStructure> {\n  return x._getType() === \"system\";\n}\n\n/**\n * @deprecated Use {@link SystemMessageChunk.isInstance} instead\n */\nexport function isSystemMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is SystemMessageChunk<TStructure> {\n  return x._getType() === \"system\";\n}\n"],"names":["BaseMessage","fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>","chunk: string | SystemMessage","mergeContent","obj: unknown","BaseMessageChunk","chunk: SystemMessageChunk<TStructure>","_mergeDicts","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;GAiBA,IAAa,gBAAb,MAAa,sBAEHA,aAAAA,WAAAA,CAAkC;IAC1C,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,SAAA;IAEhB,YACEC,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;;;;;IAOD,OAAOC,KAAAA,EAA+B;QACpC,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO,IAAI,cAAc;YACvB,GAAG,IAAA;YACH,SAASC,aAAAA,YAAAA,CAAa,IAAA,CAAK,OAAA,EAAS,MAAM;QAC3C;QAGH,IAAI,cAAc,UAAA,CAAW,MAAM,CACjC,CAAA,OAAO,IAAI,cAAc;YACvB,GAAG,IAAA;YACH,mBAAmB;gBACjB,GAAG,IAAA,CAAK,iBAAA;gBACR,GAAG,MAAM,iBAAA;YACV;YACD,mBAAmB;gBACjB,GAAG,IAAA,CAAK,iBAAA;gBACR,GAAG,MAAM,iBAAA;YACV;YACD,SAASA,aAAAA,YAAAA,CAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;QACnD;QAGH,MAAM,IAAI,MAAM;IACjB;IAED,OAAO,WAAWC,GAAAA,EAAoC;QACpD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;;GAMD,IAAa,qBAAb,cAEUC,aAAAA,gBAAAA,CAAuC;IAC/C,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,SAAA;IAEhB,YACEJ,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;IAED,OAAOK,KAAAA,EAAuC;QAC5C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,SAASH,aAAAA,YAAAA,CAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,mBAAmBI,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,mBAAmBA,aAAAA,WAAAA,CACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;IAED,OAAO,WAAWH,GAAAA,EAAyC;QACzD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;GAKD,SAAgB,gBACdI,CAAAA,EACgC;IAChC,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;;;GAKD,SAAgB,qBACdC,CAAAA,EACqC;IACrC,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB"}},
    {"offset": {"line": 2555, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/modifier.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/modifier.ts"],"sourcesContent":["import { BaseMessage, BaseMessageFields } from \"./base.js\";\nimport { MessageStructure } from \"./message.js\";\n\nexport interface RemoveMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends Omit<BaseMessageFields<TStructure, \"remove\">, \"content\"> {\n  /**\n   * The ID of the message to remove.\n   */\n  id: string;\n}\n\n/**\n * Message responsible for deleting other messages.\n */\nexport class RemoveMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"remove\"> {\n  readonly type = \"remove\" as const;\n\n  /**\n   * The ID of the message to remove.\n   */\n  id: string;\n\n  constructor(fields: RemoveMessageFields<TStructure>) {\n    super({\n      ...fields,\n      content: [],\n    });\n    this.id = fields.id;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      id: this.id,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is RemoveMessage {\n    return super.isInstance(obj) && obj.type === \"remove\";\n  }\n}\n"],"names":["BaseMessage","fields: RemoveMessageFields<TStructure>","obj: unknown"],"mappings":";;;;GAeA,IAAa,gBAAb,cAEUA,aAAAA,WAAAA,CAAkC;IACjC,OAAO,SAAA;;;IAKhB,GAAA;IAEA,YAAYC,MAAAA,CAAyC;QACnD,KAAA,CAAM;YACJ,GAAG,MAAA;YACH,SAAS,CAAE,CAAA;QACZ,EAAC;QACF,IAAA,CAAK,EAAA,GAAK,OAAO,EAAA;IAClB;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,IAAI,IAAA,CAAK,EAAA;QACV;IACF;IAED,OAAO,WAAWC,GAAAA,EAAoC;QACpD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF"}},
    {"offset": {"line": 2586, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/utils.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/utils.ts"],"sourcesContent":["import { addLangChainErrorFields } from \"../errors/index.js\";\nimport { SerializedConstructor } from \"../load/serializable.js\";\nimport { _isToolCall } from \"../tools/utils.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessageLike,\n  BaseMessage,\n  isBaseMessage,\n  StoredMessage,\n  StoredMessageV1,\n  BaseMessageFields,\n  _isMessageFieldWithRole,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageFields, ChatMessageChunk } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolCall, ToolMessage, ToolMessageFields } from \"./tool.js\";\n\nexport type $Expand<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = {\n  [K in keyof T]: string extends K\n    ? never\n    : number extends K\n    ? never\n    : symbol extends K\n    ? never\n    : K;\n}[keyof T];\n\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T\n  ? true\n  : number extends keyof T\n  ? true\n  : symbol extends keyof T\n  ? true\n  : false;\n\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> = $HasIndexSignature<T> extends true\n  ? [$KnownKeys<T>] extends [never]\n    ? true\n    : false\n  : false;\n\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\nexport type $MergeObjects<T, U> =\n  // If U is purely index-signature based, prefer U as a whole\n  $OnlyIndexSignatures<U> extends true\n    ? U\n    : // If T is purely index-signature based, prefer U as a whole (prevents leaking broad index signatures)\n    $OnlyIndexSignatures<T> extends true\n    ? U\n    : {\n        [K in keyof T | keyof U]: K extends keyof T\n          ? K extends keyof U\n            ? T[K] extends Record<string, unknown>\n              ? U[K] extends Record<string, unknown>\n                ? $MergeObjects<T[K], U[K]>\n                : U[K]\n              : U[K]\n            : T[K]\n          : K extends keyof U\n          ? U[K]\n          : never;\n      };\n\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\nexport type $MergeDiscriminatedUnion<\n  A extends Record<Key, PropertyKey>,\n  B extends Record<Key, PropertyKey>,\n  Key extends PropertyKey = \"type\"\n> = {\n  // Create a mapped type over all possible discriminator values from both A and B\n  [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] // Check if B has a member with this discriminator value\n    ? // If B doesn't have this discriminator value, use A's member\n      Extract<A, Record<Key, T>>\n    : // If B does have this discriminator value, merge A's and B's members (B takes precedence)\n    [Extract<A, Record<Key, T>>] extends [never]\n    ? Extract<B, Record<Key, T>>\n    : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>>;\n  // Index into the mapped type with all possible discriminator values\n  // This converts the mapped type back into a union\n}[A[Key] | B[Key]];\n\nexport type Constructor<T> = new (...args: unknown[]) => T;\n\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\nexport const iife = <T>(fn: () => T) => fn();\n\nfunction _coerceToolCall(\n  toolCall: ToolCall | Record<string, unknown>\n): ToolCall {\n  if (_isToolCall(toolCall)) {\n    return toolCall;\n  } else if (\n    typeof toolCall.id === \"string\" &&\n    toolCall.type === \"function\" &&\n    typeof toolCall.function === \"object\" &&\n    toolCall.function !== null &&\n    \"arguments\" in toolCall.function &&\n    typeof toolCall.function.arguments === \"string\" &&\n    \"name\" in toolCall.function &&\n    typeof toolCall.function.name === \"string\"\n  ) {\n    // Handle OpenAI tool call format\n    return {\n      id: toolCall.id,\n      args: JSON.parse(toolCall.function.arguments),\n      name: toolCall.function.name,\n      type: \"tool_call\",\n    };\n  } else {\n    // TODO: Throw an error?\n    return toolCall as unknown as ToolCall;\n  }\n}\n\nfunction isSerializedConstructor(x: unknown): x is SerializedConstructor {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    (x as SerializedConstructor).lc === 1 &&\n    Array.isArray((x as SerializedConstructor).id) &&\n    (x as SerializedConstructor).kwargs != null &&\n    typeof (x as SerializedConstructor).kwargs === \"object\"\n  );\n}\n\nfunction _constructMessageFromParams(\n  params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor\n) {\n  let type: string;\n  let rest: BaseMessageFields & Record<string, unknown>;\n  // Support serialized messages\n  if (isSerializedConstructor(params)) {\n    const className = params.id.at(-1);\n    if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n      type = \"user\";\n    } else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n      type = \"assistant\";\n    } else if (\n      className === \"SystemMessage\" ||\n      className === \"SystemMessageChunk\"\n    ) {\n      type = \"system\";\n    } else if (\n      className === \"FunctionMessage\" ||\n      className === \"FunctionMessageChunk\"\n    ) {\n      type = \"function\";\n    } else if (\n      className === \"ToolMessage\" ||\n      className === \"ToolMessageChunk\"\n    ) {\n      type = \"tool\";\n    } else {\n      type = \"unknown\";\n    }\n    rest = params.kwargs as BaseMessageFields;\n  } else {\n    const { type: extractedType, ...otherParams } = params;\n    type = extractedType;\n    rest = otherParams;\n  }\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage(rest);\n  } else if (type === \"ai\" || type === \"assistant\") {\n    const { tool_calls: rawToolCalls, ...other } = rest;\n    if (!Array.isArray(rawToolCalls)) {\n      return new AIMessage(rest);\n    }\n    const tool_calls = rawToolCalls.map(_coerceToolCall);\n    return new AIMessage({ ...other, tool_calls });\n  } else if (type === \"system\") {\n    return new SystemMessage(rest);\n  } else if (type === \"developer\") {\n    return new SystemMessage({\n      ...rest,\n      additional_kwargs: {\n        ...rest.additional_kwargs,\n        __openai_role__: \"developer\",\n      },\n    });\n  } else if (type === \"tool\" && \"tool_call_id\" in rest) {\n    return new ToolMessage({\n      ...rest,\n      content: rest.content,\n      tool_call_id: rest.tool_call_id as string,\n      name: rest.name,\n    });\n  } else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n    return new RemoveMessage({ ...rest, id: rest.id });\n  } else {\n    const error = addLangChainErrorFields(\n      new Error(\n        `Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(\n          params,\n          null,\n          2\n        )}`\n      ),\n      \"MESSAGE_COERCION_FAILURE\"\n    );\n    throw error;\n  }\n}\n\nexport function coerceMessageLikeToMessage(\n  messageLike: BaseMessageLike\n): BaseMessage {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  if (Array.isArray(messageLike)) {\n    const [type, content] = messageLike;\n    return _constructMessageFromParams({ type, content });\n  } else if (_isMessageFieldWithRole(messageLike)) {\n    const { role: type, ...rest } = messageLike;\n    return _constructMessageFromParams({ ...rest, type });\n  } else {\n    return _constructMessageFromParams(messageLike);\n  }\n}\n\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(\n  messages: BaseMessage[],\n  humanPrefix = \"Human\",\n  aiPrefix = \"AI\"\n): string {\n  const string_messages: string[] = [];\n  for (const m of messages) {\n    let role: string;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = (m as ChatMessage).role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    const readableContent =\n      typeof m.content === \"string\"\n        ? m.content\n        : JSON.stringify(m.content, null, 2);\n    string_messages.push(`${role}: ${nameStr}${readableContent}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(\n  message: StoredMessage | StoredMessageV1\n): StoredMessage {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if ((message as StoredMessage).data !== undefined) {\n    return message as StoredMessage;\n  } else {\n    const v1Message = message as StoredMessageV1;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined,\n      },\n    };\n  }\n}\n\nexport function mapStoredMessageToChatMessage(message: StoredMessage) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data as FunctionMessageFields);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data as ToolMessageFields);\n    case \"generic\": {\n      if (storedMessage.data.role === undefined) {\n        throw new Error(\"Role must be defined for chat messages\");\n      }\n      return new ChatMessage(storedMessage.data as ChatMessageFields);\n    }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(\n  messages: StoredMessage[]\n): BaseMessage[] {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(\n  messages: BaseMessage[]\n): StoredMessage[] {\n  return messages.map((message) => message.toDict());\n}\n\nexport function convertToChunk(message: BaseMessage) {\n  const type = message._getType();\n  if (type === \"human\") {\n    return new HumanMessageChunk({ ...message });\n  } else if (type === \"ai\") {\n    let aiChunkFields: AIMessageChunkFields = {\n      ...message,\n    };\n    if (\"tool_calls\" in aiChunkFields) {\n      aiChunkFields = {\n        ...aiChunkFields,\n        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n          ...tc,\n          type: \"tool_call_chunk\",\n          index: undefined,\n          args: JSON.stringify(tc.args),\n        })),\n      };\n    }\n    return new AIMessageChunk({ ...aiChunkFields });\n  } else if (type === \"system\") {\n    return new SystemMessageChunk({ ...message });\n  } else if (type === \"function\") {\n    return new FunctionMessageChunk({ ...message });\n  } else if (ChatMessage.isInstance(message)) {\n    return new ChatMessageChunk({ ...message });\n  } else {\n    throw new Error(\"Unknown message type.\");\n  }\n}\n"],"names":["fn: () => T","toolCall: ToolCall | Record<string, unknown>","_isToolCall","x: unknown","params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor","type: string","rest: BaseMessageFields & Record<string, unknown>","HumanMessage","AIMessage","SystemMessage","ToolMessage","RemoveMessage","addLangChainErrorFields","messageLike: BaseMessageLike","isBaseMessage","_isMessageFieldWithRole","messages: BaseMessage[]","string_messages: string[]","role: string","message: StoredMessage | StoredMessageV1","message: StoredMessage","FunctionMessage","ChatMessage","messages: StoredMessage[]","message: BaseMessage","HumanMessageChunk","aiChunkFields: AIMessageChunkFields","AIMessageChunk","SystemMessageChunk","FunctionMessageChunk","ChatMessageChunk"],"mappings":"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"}},
    {"offset": {"line": 2805, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/transformers.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/transformers.ts"],"sourcesContent":["import { BaseDocumentTransformer } from \"../documents/transformers.js\";\nimport { BaseLanguageModel } from \"../language_models/base.js\";\nimport { Runnable, RunnableLambda } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessage,\n  BaseMessageChunk,\n  BaseMessageFields,\n  isBaseMessageChunk,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk, ChatMessageFields } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { MessageType } from \"./message.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk, ToolMessageFields } from \"./tool.js\";\nimport { convertToChunk } from \"./utils.js\";\n\nexport type MessageUnion =\n  | typeof HumanMessage\n  | typeof AIMessage\n  | typeof SystemMessage\n  | typeof ChatMessage\n  | typeof FunctionMessage\n  | typeof ToolMessage\n  | typeof RemoveMessage;\nexport type MessageChunkUnion =\n  | typeof HumanMessageChunk\n  | typeof AIMessageChunk\n  | typeof SystemMessageChunk\n  | typeof FunctionMessageChunk\n  | typeof ToolMessageChunk\n  | typeof ChatMessageChunk\n  | typeof RemoveMessage; // RemoveMessage does not have a chunk class.\nexport type MessageTypeOrClass = MessageType | MessageUnion | MessageChunkUnion;\n\nconst _isMessageType = (msg: BaseMessage, types: MessageTypeOrClass[]) => {\n  const typesAsStrings = [\n    ...new Set<string>(\n      types?.map((t) => {\n        if (typeof t === \"string\") {\n          return t;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const instantiatedMsgClass = new (t as any)({});\n        if (\n          !(\"getType\" in instantiatedMsgClass) ||\n          typeof instantiatedMsgClass.getType !== \"function\"\n        ) {\n          throw new Error(\"Invalid type provided.\");\n        }\n        return instantiatedMsgClass.getType();\n      })\n    ),\n  ];\n  const msgType = msg.getType();\n  return typesAsStrings.some((t) => t === msgType);\n};\n\nexport interface FilterMessagesFields {\n  /**\n   * @param {string[] | undefined} includeNames Message names to include.\n   */\n  includeNames?: string[];\n  /**\n   * @param {string[] | undefined} excludeNames Messages names to exclude.\n   */\n  excludeNames?: string[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} includeTypes Message types to include. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  includeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} excludeTypes Message types to exclude. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  excludeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {string[] | undefined} includeIds Message IDs to include.\n   */\n  includeIds?: string[];\n  /**\n   * @param {string[] | undefined} excludeIds Message IDs to exclude.\n   */\n  excludeIds?: string[];\n}\n\n/**\n * Filter messages based on name, type or id.\n *\n * @param {BaseMessage[] | FilterMessagesFields} messagesOrOptions - Either an array of BaseMessage objects to filter or the filtering options. If an array is provided, the `options` parameter should also be supplied. If filtering options are provided, a RunnableLambda is returned.\n * @param {FilterMessagesFields} [options] - Optional filtering options. Should only be provided if `messagesOrOptions` is an array of BaseMessage objects.\n * @returns A list of Messages that meets at least one of the include conditions and none\n *     of the exclude conditions, or a RunnableLambda which does the same. If no include conditions are specified then\n *     anything that is not explicitly excluded will be included.\n * @throws {Error} If two incompatible arguments are provided.\n *\n * @example\n * ```typescript\n * import { filterMessages, AIMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n *   new AIMessage({ content: \"steve-o\", id: \"bar\", name: \"example_assistant\" }),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"baz\" }),\n *   new AIMessage({ content: \"silicon blue\" , id: \"blah\" }),\n * ];\n *\n * filterMessages(messages, {\n *   includeNames: [\"example_user\", \"example_assistant\"],\n *   includeTypes: [\"system\"],\n *   excludeIds: [\"bar\"],\n * });\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n * ]\n * ```\n */\nexport function filterMessages(\n  options?: FilterMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function filterMessages(\n  messages: BaseMessage[],\n  options?: FilterMessagesFields\n): BaseMessage[];\nexport function filterMessages(\n  messagesOrOptions?: BaseMessage[] | FilterMessagesFields,\n  options?: FilterMessagesFields\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    return _filterMessages(messagesOrOptions, options);\n  }\n  return RunnableLambda.from((input: BaseMessage[]): BaseMessage[] => {\n    return _filterMessages(input, messagesOrOptions);\n  });\n}\n\nfunction _filterMessages(\n  messages: BaseMessage[],\n  options: FilterMessagesFields = {}\n): BaseMessage[] {\n  const {\n    includeNames,\n    excludeNames,\n    includeTypes,\n    excludeTypes,\n    includeIds,\n    excludeIds,\n  } = options;\n\n  const filtered: BaseMessage[] = [];\n\n  for (const msg of messages) {\n    if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n      continue;\n    } else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n      continue;\n    } else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n      continue;\n    }\n\n    // default to inclusion when no inclusion criteria given.\n    if (!(includeTypes || includeIds || includeNames)) {\n      filtered.push(msg);\n    } else if (\n      includeNames &&\n      msg.name &&\n      includeNames.some((iName) => iName === msg.name)\n    ) {\n      filtered.push(msg);\n    } else if (includeTypes && _isMessageType(msg, includeTypes)) {\n      filtered.push(msg);\n    } else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n      filtered.push(msg);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Merge consecutive Messages of the same type.\n *\n * **NOTE**: ToolMessages are not merged, as each has a distinct tool call id that\n * can't be merged.\n *\n * @param {BaseMessage[] | undefined} messages Sequence of Message-like objects to merge. Optional. If not provided, a RunnableLambda is returned.\n * @returns List of BaseMessages with consecutive runs of message types merged into single\n *     messages, or a RunnableLambda which returns a list of BaseMessages If two messages being merged both have string contents, the merged\n *     content is a concatenation of the two strings with a new-line separator. If at\n *     least one of the messages has a list of content blocks, the merged content is a\n *     list of content blocks.\n *\n * @example\n * ```typescript\n * import { mergeMessageRuns, AIMessage, HumanMessage, SystemMessage, ToolCall } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"foo\" }),\n *   new HumanMessage({ content: \"wait your favorite food\", id: \"bar\" }),\n *   new AIMessage({\n *     content: \"my favorite colo\",\n *     tool_calls: [{ name: \"blah_tool\", args: { x: 2 }, id: \"123\" }],\n *     id: \"baz\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"my favorite dish is lasagna\" }],\n *     tool_calls: [{ name: \"blah_tool\", args: { x: -10 }, id: \"456\" }],\n *     id: \"blur\",\n *   }),\n * ];\n *\n * mergeMessageRuns(messages);\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({\n *     content: \"what's your favorite colorwait your favorite food\",\n *     id: \"foo\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"my favorite colo\" },\n *       { type: \"text\", text: \"my favorite dish is lasagna\" },\n *     ],\n *     tool_calls: [\n *       { name: \"blah_tool\", args: { x: 2 }, id: \"123\" },\n *       { name: \"blah_tool\", args: { x: -10 }, id: \"456\" },\n *     ],\n *     id: \"baz\",\n *   }),\n * ]\n * ```\n */\nexport function mergeMessageRuns(): Runnable<BaseMessage[], BaseMessage[]>;\nexport function mergeMessageRuns(messages: BaseMessage[]): BaseMessage[];\nexport function mergeMessageRuns(\n  messages?: BaseMessage[]\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messages)) {\n    return _mergeMessageRuns(messages);\n  }\n  return RunnableLambda.from(_mergeMessageRuns);\n}\n\nfunction _mergeMessageRuns(messages: BaseMessage[]): BaseMessage[] {\n  if (!messages.length) {\n    return [];\n  }\n  const merged: BaseMessage[] = [];\n  for (const msg of messages) {\n    const curr = msg;\n    const last = merged.pop();\n    if (!last) {\n      merged.push(curr);\n    } else if (\n      curr.getType() === \"tool\" ||\n      !(curr.getType() === last.getType())\n    ) {\n      merged.push(last, curr);\n    } else {\n      const lastChunk = convertToChunk(last) as BaseMessageChunk;\n      const currChunk = convertToChunk(curr) as BaseMessageChunk;\n      const mergedChunks = lastChunk.concat(currChunk);\n      if (\n        typeof lastChunk.content === \"string\" &&\n        typeof currChunk.content === \"string\"\n      ) {\n        mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n      }\n      merged.push(_chunkToMsg(mergedChunks));\n    }\n  }\n  return merged;\n}\n\n// Since we can not import from `@langchain/textsplitters` we need\n// to reconstruct the interface here.\ninterface _TextSplitterInterface extends BaseDocumentTransformer {\n  splitText(text: string): Promise<string[]>;\n}\n\nexport interface TrimMessagesFields {\n  /**\n   * @param {number} maxTokens Max token count of trimmed messages.\n   */\n  maxTokens: number;\n  /**\n   * @param {((messages: BaseMessage[]) => number) | ((messages: BaseMessage[]) => Promise<number>) | BaseLanguageModel} tokenCounter\n   * Function or LLM for counting tokens in an array of `BaseMessage`s.\n   * If a `BaseLanguageModel` is passed in then `BaseLanguageModel.getNumTokens()` will be used.\n   */\n  tokenCounter:\n    | ((messages: BaseMessage[]) => number)\n    | ((messages: BaseMessage[]) => Promise<number>)\n    | BaseLanguageModel;\n  /**\n   * @param {\"first\" | \"last\"} [strategy=\"last\"] Strategy for trimming.\n   * - \"first\": Keep the first <= n_count tokens of the messages.\n   * - \"last\": Keep the last <= n_count tokens of the messages.\n   * @default \"last\"\n   */\n  strategy?: \"first\" | \"last\";\n  /**\n   * @param {boolean} [allowPartial=false] Whether to split a message if only part of the message can be included.\n   * If `strategy: \"last\"` then the last partial contents of a message are included.\n   * If `strategy: \"first\"` then the first partial contents of a message are included.\n   * @default false\n   */\n  allowPartial?: boolean;\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [endOn] The message type to end on.\n   * If specified then every message after the last occurrence of this type is ignored.\n   * If `strategy === \"last\"` then this is done before we attempt to get the last `maxTokens`.\n   * If `strategy === \"first\"` then this is done after we get the first `maxTokens`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [startOn] The message type to start on.\n   * Should only be specified if `strategy: \"last\"`. If specified then every message before the first occurrence\n   * of this type is ignored. This is done after we trim the initial messages to the last `maxTokens`.\n   * Does not apply to a `SystemMessage` at index 0 if `includeSystem: true`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {boolean} [includeSystem=false] Whether to keep the `SystemMessage` if there is one at index 0.\n   * Should only be specified if `strategy: \"last\"`.\n   * @default false\n   */\n  includeSystem?: boolean;\n  /**\n   * @param {((text: string) => string[]) | BaseDocumentTransformer} [textSplitter] Function or `BaseDocumentTransformer` for\n   * splitting the string contents of a message. Only used if `allowPartial: true`.\n   * If `strategy: \"last\"` then the last split tokens from a partial message will be included.\n   * If `strategy: \"first\"` then the first split tokens from a partial message will be included.\n   * Token splitter assumes that separators are kept, so that split contents can be directly concatenated\n   * to recreate the original text. Defaults to splitting on newlines.\n   */\n  textSplitter?:\n    | ((text: string) => string[])\n    | ((text: string) => Promise<string[]>)\n    | _TextSplitterInterface;\n}\n\n/**\n * Trim messages to be below a token count.\n *\n * @param {BaseMessage[]} messages Array of `BaseMessage` instances to trim.\n * @param {TrimMessagesFields} options Trimming options.\n * @returns An array of trimmed `BaseMessage`s or a `Runnable` that takes a sequence of `BaseMessage`-like objects and returns\n *     an array of trimmed `BaseMessage`s.\n * @throws {Error} If two incompatible arguments are specified or an unrecognized `strategy` is specified.\n *\n * @example\n * ```typescript\n * import { trimMessages, AIMessage, BaseMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"This is a 4 token text. The full message is 10 tokens.\"),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"This is the FIRST 4 token block.\" },\n *       { type: \"text\", text: \"This is the SECOND 4 token block.\" },\n *     ],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ];\n *\n * function dummyTokenCounter(messages: BaseMessage[]): number {\n *   // treat each message like it adds 3 default tokens at the beginning\n *   // of the message and at the end of the message. 3 + 4 + 3 = 10 tokens\n *   // per message.\n *\n *   const defaultContentLen = 4;\n *   const defaultMsgPrefixLen = 3;\n *   const defaultMsgSuffixLen = 3;\n *\n *   let count = 0;\n *   for (const msg of messages) {\n *     if (typeof msg.content === \"string\") {\n *       count += defaultMsgPrefixLen + defaultContentLen + defaultMsgSuffixLen;\n *     }\n *     if (Array.isArray(msg.content)) {\n *       count +=\n *         defaultMsgPrefixLen +\n *         msg.content.length * defaultContentLen +\n *         defaultMsgSuffixLen;\n *     }\n *   }\n *   return count;\n * }\n * ```\n *\n * First 30 tokens, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages, have to end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n *   endOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   includeSystem: true,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   allowPartial: true,\n *   includeSystem: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, allowing partial messages, end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   endOn: \"human\",\n *   includeSystem: true,\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages, start on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   includeSystem: true,\n *   allowPartial: true,\n *   startOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n */\nexport function trimMessages(\n  options: TrimMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function trimMessages(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<BaseMessage[]>;\nexport function trimMessages(\n  messagesOrOptions: BaseMessage[] | TrimMessagesFields,\n  options?: TrimMessagesFields\n): Promise<BaseMessage[]> | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    const messages = messagesOrOptions;\n    if (!options) {\n      throw new Error(\"Options parameter is required when providing messages.\");\n    }\n    return _trimMessagesHelper(messages, options);\n  } else {\n    const trimmerOptions = messagesOrOptions;\n    return RunnableLambda.from((input: BaseMessage[]) =>\n      _trimMessagesHelper(input, trimmerOptions)\n    ).withConfig({\n      runName: \"trim_messages\",\n    });\n  }\n}\n\nasync function _trimMessagesHelper(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<Array<BaseMessage>> {\n  const {\n    maxTokens,\n    tokenCounter,\n    strategy = \"last\",\n    allowPartial = false,\n    endOn,\n    startOn,\n    includeSystem = false,\n    textSplitter,\n  } = options;\n  if (startOn && strategy === \"first\") {\n    throw new Error(\n      \"`startOn` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n  if (includeSystem && strategy === \"first\") {\n    throw new Error(\n      \"`includeSystem` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n\n  let listTokenCounter: (msgs: BaseMessage[]) => Promise<number>;\n  if (\"getNumTokens\" in tokenCounter) {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> => {\n      const tokenCounts = await Promise.all(\n        msgs.map((msg) => tokenCounter.getNumTokens(msg.content))\n      );\n      return tokenCounts.reduce((sum, count) => sum + count, 0);\n    };\n  } else {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> =>\n      tokenCounter(msgs);\n  }\n\n  let textSplitterFunc: (text: string) => Promise<string[]> =\n    defaultTextSplitter;\n  if (textSplitter) {\n    if (\"splitText\" in textSplitter) {\n      textSplitterFunc = textSplitter.splitText;\n    } else {\n      textSplitterFunc = async (text: string): Promise<string[]> =>\n        textSplitter(text);\n    }\n  }\n\n  if (strategy === \"first\") {\n    return _firstMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      partialStrategy: allowPartial ? \"first\" : undefined,\n      endOn,\n    });\n  } else if (strategy === \"last\") {\n    return _lastMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      allowPartial,\n      includeSystem,\n      startOn,\n      endOn,\n    });\n  } else {\n    throw new Error(\n      `Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`\n    );\n  }\n}\n\nasync function _firstMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    partialStrategy?: \"first\" | \"last\";\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } =\n    options;\n  let messagesCopy = [...messages];\n  let idx = 0;\n  for (let i = 0; i < messagesCopy.length; i += 1) {\n    const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n    if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n      idx = messagesCopy.length - i;\n      break;\n    }\n  }\n  if (idx < messagesCopy.length && partialStrategy) {\n    let includedPartial = false;\n    if (Array.isArray(messagesCopy[idx].content)) {\n      const excluded = messagesCopy[idx];\n      if (typeof excluded.content === \"string\") {\n        throw new Error(\"Expected content to be an array.\");\n      }\n\n      const numBlock = excluded.content.length;\n      const reversedContent =\n        partialStrategy === \"last\"\n          ? [...excluded.content].reverse()\n          : excluded.content;\n      for (let i = 1; i <= numBlock; i += 1) {\n        const partialContent =\n          partialStrategy === \"first\"\n            ? reversedContent.slice(0, i)\n            : reversedContent.slice(-i);\n        const fields = Object.fromEntries(\n          Object.entries(excluded).filter(\n            ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n          )\n        ) as BaseMessageFields;\n        const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n          ...fields,\n          content: partialContent,\n        });\n        const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n        if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n          messagesCopy = slicedMessages;\n          idx += 1;\n          includedPartial = true;\n        } else {\n          break;\n        }\n      }\n      if (includedPartial && partialStrategy === \"last\") {\n        excluded.content = [...reversedContent].reverse();\n      }\n    }\n    if (!includedPartial) {\n      const excluded = messagesCopy[idx];\n      let text: string | undefined;\n      if (\n        Array.isArray(excluded.content) &&\n        excluded.content.some(\n          (block) => typeof block === \"string\" || block.type === \"text\"\n        )\n      ) {\n        const textBlock = excluded.content.find(\n          (block) => block.type === \"text\" && block.text\n        ) as { type: \"text\"; text: string } | undefined;\n        text = textBlock?.text;\n      } else if (typeof excluded.content === \"string\") {\n        text = excluded.content;\n      }\n      if (text) {\n        const splitTexts = await textSplitter(text);\n        const numSplits = splitTexts.length;\n        if (partialStrategy === \"last\") {\n          splitTexts.reverse();\n        }\n        for (let _ = 0; _ < numSplits - 1; _ += 1) {\n          splitTexts.pop();\n          excluded.content = splitTexts.join(\"\");\n          if (\n            (await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n            maxTokens\n          ) {\n            if (partialStrategy === \"last\") {\n              excluded.content = [...splitTexts].reverse().join(\"\");\n            }\n            messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n            idx += 1;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n      idx -= 1;\n    }\n  }\n\n  return messagesCopy.slice(0, idx);\n}\n\nasync function _lastMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const {\n    allowPartial = false,\n    includeSystem = false,\n    endOn,\n    startOn,\n    ...rest\n  } = options;\n\n  // Create a copy of messages to avoid mutation\n  let messagesCopy = messages.map((message) => {\n    const fields = Object.fromEntries(\n      Object.entries(message).filter(\n        ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n      )\n    ) as BaseMessageFields;\n    return _switchTypeToMessage(\n      message.getType(),\n      fields,\n      isBaseMessageChunk(message)\n    );\n  });\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (\n      messagesCopy.length > 0 &&\n      !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)\n    ) {\n      messagesCopy = messagesCopy.slice(0, -1);\n    }\n  }\n\n  const swappedSystem =\n    includeSystem && messagesCopy[0]?.getType() === \"system\";\n  let reversed_ = swappedSystem\n    ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n    : messagesCopy.reverse();\n\n  reversed_ = await _firstMaxTokens(reversed_, {\n    ...rest,\n    partialStrategy: allowPartial ? \"last\" : undefined,\n    endOn: startOn,\n  });\n\n  if (swappedSystem) {\n    return [reversed_[0], ...reversed_.slice(1).reverse()];\n  } else {\n    return reversed_.reverse();\n  }\n}\n\nconst _MSG_CHUNK_MAP: Record<\n  MessageType,\n  {\n    message: MessageUnion;\n    messageChunk: MessageChunkUnion;\n  }\n> = {\n  human: {\n    message: HumanMessage,\n    messageChunk: HumanMessageChunk,\n  },\n  ai: {\n    message: AIMessage,\n    messageChunk: AIMessageChunk,\n  },\n  system: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  developer: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  tool: {\n    message: ToolMessage,\n    messageChunk: ToolMessageChunk,\n  },\n  function: {\n    message: FunctionMessage,\n    messageChunk: FunctionMessageChunk,\n  },\n  generic: {\n    message: ChatMessage,\n    messageChunk: ChatMessageChunk,\n  },\n  remove: {\n    message: RemoveMessage,\n    messageChunk: RemoveMessage, // RemoveMessage does not have a chunk class.\n  },\n};\n\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields\n): BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk: true\n): BaseMessageChunk;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage {\n  let chunk: BaseMessageChunk | undefined;\n  let msg: BaseMessage | undefined;\n\n  switch (messageType) {\n    case \"human\":\n      if (returnChunk) {\n        chunk = new HumanMessageChunk(fields);\n      } else {\n        msg = new HumanMessage(fields);\n      }\n      break;\n    case \"ai\":\n      if (returnChunk) {\n        let aiChunkFields: AIMessageChunkFields = {\n          ...fields,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n          aiChunkFields = {\n            ...aiChunkFields,\n            tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n              ...tc,\n              type: \"tool_call_chunk\",\n              index: undefined,\n              args: JSON.stringify(tc.args),\n            })),\n          };\n        }\n        chunk = new AIMessageChunk(aiChunkFields);\n      } else {\n        msg = new AIMessage(fields);\n      }\n      break;\n    case \"system\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk(fields);\n      } else {\n        msg = new SystemMessage(fields);\n      }\n      break;\n    case \"developer\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      } else {\n        msg = new SystemMessage({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      }\n      break;\n    case \"tool\":\n      if (\"tool_call_id\" in fields) {\n        if (returnChunk) {\n          chunk = new ToolMessageChunk(fields as ToolMessageFields);\n        } else {\n          msg = new ToolMessage(fields as ToolMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\"\n        );\n      }\n      break;\n    case \"function\":\n      if (returnChunk) {\n        chunk = new FunctionMessageChunk(fields as FunctionMessageFields);\n      } else {\n        if (!fields.name) {\n          throw new Error(\"FunctionMessage must have a 'name' field\");\n        }\n        msg = new FunctionMessage(fields as FunctionMessageFields);\n      }\n      break;\n    case \"generic\":\n      if (\"role\" in fields) {\n        if (returnChunk) {\n          chunk = new ChatMessageChunk(fields as ChatMessageFields);\n        } else {\n          msg = new ChatMessage(fields as ChatMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\"\n        );\n      }\n      break;\n    default:\n      throw new Error(`Unrecognized message type ${messageType}`);\n  }\n\n  if (returnChunk && chunk) {\n    return chunk;\n  }\n  if (msg) {\n    return msg;\n  }\n  throw new Error(`Unrecognized message type ${messageType}`);\n}\n\nfunction _chunkToMsg(chunk: BaseMessageChunk): BaseMessage {\n  const chunkType = chunk.getType();\n  let msg: BaseMessage | undefined;\n  const fields = Object.fromEntries(\n    Object.entries(chunk).filter(\n      ([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")\n    )\n  ) as BaseMessageFields;\n\n  if (chunkType in _MSG_CHUNK_MAP) {\n    msg = _switchTypeToMessage(chunkType, fields);\n  }\n\n  if (!msg) {\n    throw new Error(\n      `Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(\n        _MSG_CHUNK_MAP\n      )}`\n    );\n  }\n\n  return msg;\n}\n\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport function defaultTextSplitter(text: string): Promise<string[]> {\n  const splits = text.split(\"\\n\");\n  return Promise.resolve([\n    ...splits.slice(0, -1).map((s) => `${s}\\n`),\n    splits[splits.length - 1],\n  ]);\n}\n"],"names":["msg: BaseMessage","types: MessageTypeOrClass[]","messagesOrOptions?: BaseMessage[] | FilterMessagesFields","options?: FilterMessagesFields","RunnableLambda","input: BaseMessage[]","messages: BaseMessage[]","options: FilterMessagesFields","filtered: BaseMessage[]","messages?: BaseMessage[]","merged: BaseMessage[]","convertToChunk","messagesOrOptions: BaseMessage[] | TrimMessagesFields","options?: TrimMessagesFields","options: TrimMessagesFields","listTokenCounter: (msgs: BaseMessage[]) => Promise<number>","msgs: BaseMessage[]","textSplitterFunc: (text: string) => Promise<string[]>","text: string","options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    partialStrategy?: \"first\" | \"last\";\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }","text: string | undefined","options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }","isBaseMessageChunk","_MSG_CHUNK_MAP: Record<\n  MessageType,\n  {\n    message: MessageUnion;\n    messageChunk: MessageChunkUnion;\n  }\n>","HumanMessage","HumanMessageChunk","AIMessage","AIMessageChunk","SystemMessage","SystemMessageChunk","ToolMessage","ToolMessageChunk","FunctionMessage","FunctionMessageChunk","ChatMessage","ChatMessageChunk","RemoveMessage","messageType: MessageType","fields: BaseMessageFields","returnChunk?: boolean","chunk: BaseMessageChunk | undefined","msg: BaseMessage | undefined","aiChunkFields: AIMessageChunkFields","chunk: BaseMessageChunk"],"mappings":"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"}},
    {"offset": {"line": 3155, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/tools.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/tools.ts"],"sourcesContent":["import { BaseContentBlock } from \"./base.js\";\n\nexport type Tools = never;\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"tool_call\",\n  \"tool_call_chunk\",\n  \"invalid_tool_call\",\n  \"server_tool_call\",\n  \"server_tool_call_chunk\",\n  \"server_tool_call_result\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Tools {\n  /**\n   * Represents a request to call a tool.\n   *\n   * @example\n   * ```ts\n   * const toolCall: ToolCall = {\n   *     type: \"tool_call\",\n   *     name: \"foo\",\n   *     args: { a: 1 },\n   *     callId: \"123\"\n   * };\n   * ```\n   * This represents a request to call the tool named \"foo\" with arguments {\"a\": 1}\n   * and an identifier of \"123\".\n   */\n  export interface ToolCall<TName extends string = string, TArgs = unknown>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args: TArgs;\n  }\n\n  /** Content block to represent partial data of a tool call */\n  export interface ToolCallChunk<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"tool_call_chunk\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n    /**\n     * The index of the tool call chunk\n     */\n    index?: number;\n  }\n\n  /** Content block to represent an invalid tool call */\n  export interface InvalidToolCall<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"invalid_tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n    /**\n     * An error message associated with the tool call\n     */\n    error?: string;\n    /**\n     * Index of block in aggregate response\n     */\n    index?: string | number;\n  }\n\n  export interface ServerToolCall<\n    TName extends string = string,\n    TArgs = unknown\n  > extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args: TArgs;\n  }\n\n  export interface ServerToolCallChunk<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call_chunk\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n  }\n\n  export interface ServerToolCallResult<TOutput = Record<string, unknown>>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call_result\";\n    /**\n     * The unique identifier of the tool call that this result corresponds to\n     */\n    toolCallId: string;\n    /**\n     * The status of the server tool call\n     */\n    status: \"success\" | \"error\";\n    /**\n     * The output of the server tool call\n     */\n    output: TOutput;\n  }\n\n  export type Standard =\n    | ToolCall\n    | ToolCallChunk\n    | InvalidToolCall\n    | ServerToolCall\n    | ServerToolCallChunk\n    | ServerToolCallResult;\n}\n"],"names":[],"mappings":";AAIA,MAAa,oBAAoB;IAC/B;IACA;IACA;IACA;IACA;IACA;CACD"}},
    {"offset": {"line": 3169, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/multimodal.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/multimodal.ts"],"sourcesContent":["import { BaseContentBlock } from \"./base.js\";\n\nexport type Multimodal = never;\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"image\",\n  \"video\",\n  \"audio\",\n  \"text-plain\",\n  \"file\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Multimodal {\n  type BaseDataRecord = {\n    /**\n     * MIME type of the file.\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml#image\n     */\n    mimeType?: string | undefined;\n  };\n  type DataRecordFileId = BaseDataRecord & {\n    /**\n     * ID of the data file, e.g. from a provider's file api\n     */\n    fileId: string;\n    url?: never;\n    data?: never;\n  };\n  type DataRecordUrl = BaseDataRecord & {\n    fileId?: never;\n    /**\n     * URL of the data file\n     */\n    url: string;\n    data?: never;\n  };\n  type DataRecordBase64 = BaseDataRecord & {\n    fileId?: never;\n    url?: never;\n    /**\n     * MIME type of the file. Required for base64 encoding.\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml#image\n     */\n    mimeType: string;\n    /**\n     * Base64 encoded string or binary data of the data\n     */\n    data: string | Uint8Array;\n  };\n  type DataRecord = DataRecordFileId | DataRecordUrl | DataRecordBase64;\n\n  /** Content block for multimodal data */\n  export type Data<TMetadata = Record<string, unknown>> = BaseContentBlock &\n    DataRecord & {\n      /**\n       * MIME type of the file. Required for base64 encoding.\n       */\n      mimeType?: string;\n      /**\n       * Metadata of the file\n       */\n      metadata?: TMetadata;\n      /**\n       * Content block identifier for multimodal content, e.g. image, video, audio, file or plain text. This can be either:\n       *  - generated by the provider (e.g., an OpenAI block ID)\n       *  - generated by LangChain upon creation\n       */\n      id?: string;\n    };\n\n  /** Content block for image data */\n  export type Image = Data & {\n    /** Type of the content block */\n    readonly type: \"image\";\n  };\n  /** Content block for video data */\n  export type Video = Data & {\n    /** Type of the content block */\n    readonly type: \"video\";\n  };\n  /** Content block for audio data */\n  export type Audio = Data & {\n    /** Type of the content block */\n    readonly type: \"audio\";\n  };\n  /** Content block for plain text data */\n  export type PlainText = Data & {\n    /** Type of the content block */\n    readonly type: \"text-plain\";\n    /**\n     * Plaintext content. This is optional if the data is base64 encoded.\n     */\n    text?: string;\n    /**\n     * Title of the file, e.g. the title of a document\n     */\n    title?: string;\n    /**\n     * Context for the text, e.g. a description or a summary of the text's content\n     */\n    context?: string;\n  };\n\n  /** Content block for file data */\n  export type File = Data & {\n    /**\n     * Non-descript multimodal content block\n     *\n     * This block is intended for files that aren't covered by existing content block types.\n     */\n    readonly type: \"file\";\n  };\n\n  export type Standard = Image | Video | Audio | PlainText | File;\n}\n"],"names":[],"mappings":";AAIA,MAAa,oBAAoB;IAC/B;IACA;IACA;IACA;IACA;CACD"}},
    {"offset": {"line": 3182, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/index.ts"],"sourcesContent":["import type { BaseContentBlock } from \"./base.js\";\nimport {\n  KNOWN_BLOCK_TYPES as KNOWN_TOOL_BLOCK_TYPES,\n  type Tools,\n} from \"./tools.js\";\nimport {\n  KNOWN_BLOCK_TYPES as KNOWN_MULTIMODAL_BLOCK_TYPES,\n  type Multimodal,\n} from \"./multimodal.js\";\nimport { type Data } from \"./data.js\";\n\nexport interface ContentBlock extends BaseContentBlock {}\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"text\",\n  \"reasoning\",\n  ...KNOWN_TOOL_BLOCK_TYPES,\n  ...KNOWN_MULTIMODAL_BLOCK_TYPES,\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace ContentBlock {\n  /**\n   * Annotation for citing data from a document.\n   */\n  export interface Citation {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"citation\";\n    /**\n     * Source type for the citation.\n     */\n    source?: string;\n    /**\n     * URL of the document source\n     */\n    url?: string;\n    /**\n     * Source document title.\n     *\n     * For example, the page title for a web page or the title of a paper.\n     */\n    title?: string;\n    /**\n     * Start index of the **response text** for which the annotation applies.\n     *\n     * @see {Text}\n     */\n    startIndex?: number;\n    /**\n     * End index of the **response text** for which the annotation applies.\n     *\n     * @see {Text}\n     */\n    endIndex?: number;\n    /**\n     * Excerpt of source text being cited.\n     */\n    citedText?: string;\n  }\n\n  /**\n   * Text output from a LLM.\n   *\n   * This typically represents the main text content of a message, such as the response\n   * from a language model or the text of a user message.\n   */\n  export interface Text extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"text\";\n    /**\n     * Block text.\n     */\n    text: string;\n    /**\n     * Index of block in aggregate response. Used during streaming.\n     */\n    index?: number;\n    /**\n     * Citations and other annotations.\n     */\n    annotations?: Array<Citation | BaseContentBlock>;\n  }\n\n  /**\n   * Reasoning output from a LLM.\n   */\n  export interface Reasoning extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"reasoning\";\n    /**\n     * Reasoning text.\n     *\n     * Either the thought summary or the raw reasoning text itself.\n     * This is often parsed from `<think>` tags in the model's response.\n     */\n    reasoning: string;\n    /**\n     * Index of block in aggregate response. Used during streaming.\n     */\n    index?: number;\n  }\n\n  /**\n   * Provider-specific content block.\n   *\n   * This is used to represent content blocks that are not part of the standard LangChain content model.\n   * If a provider's non-standard output includes reasoning and tool calls, it should be\n   * the adapter's job to parse that payload and emit the corresponding standard reasoning and tool call blocks.\n   */\n  export interface NonStandard<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    TValue extends Record<string, any> = Record<string, any>\n  > extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    type: \"non_standard\";\n    /**\n     * Provider-specific data\n     */\n    value: TValue;\n  }\n\n  export { Tools };\n  export { Multimodal };\n  export { Data };\n\n  export type Standard =\n    | Text\n    | Reasoning\n    | NonStandard\n    | Tools.Standard\n    | Multimodal.Standard;\n}\n"],"names":["KNOWN_BLOCK_TYPES","KNOWN_TOOL_BLOCK_TYPES","KNOWN_MULTIMODAL_BLOCK_TYPES"],"mappings":";;;AAaA,MAAaA,sBAAoB;IAC/B;IACA;OACGC,cAAAA,iBAAAA;OACAC,mBAAAA,iBAAAA;CACJ"}},
    {"offset": {"line": 3196, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/index.ts"],"sourcesContent":["export * from \"./ai.js\";\nexport * from \"./base.js\";\nexport * from \"./chat.js\";\nexport * from \"./function.js\";\nexport * from \"./human.js\";\nexport * from \"./system.js\";\nexport * from \"./utils.js\";\nexport * from \"./transformers.js\";\nexport * from \"./metadata.js\";\nexport * from \"./message.js\";\nexport * from \"./modifier.js\";\nexport * from \"./tool.js\";\n\n// This is an old export for backwards compatibility with existing multimodal content blocks\n// TODO: remove this in v2\nexport * from \"./content/data.js\";\nexport * from \"./content/index.js\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 3350, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/data.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/data.ts"],"sourcesContent":["import { BaseContentBlock } from \"./base.js\";\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type ImageDetail = \"auto\" | \"low\" | \"high\";\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type MessageContentText = {\n  type: \"text\";\n  text: string;\n};\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type MessageContentImageUrl = {\n  type: \"image_url\";\n  image_url: string | { url: string; detail?: ImageDetail };\n};\n\n/**\n * @deprecated\n * Use {@link ContentBlock} instead.\n */\nexport type MessageContentComplex =\n  | MessageContentText\n  | MessageContentImageUrl\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | (Record<string, any> & { type?: \"text\" | \"image_url\" | string })\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | (Record<string, any> & { type?: never });\n\nexport type Data = never;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Data {\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface BaseDataContentBlock extends BaseContentBlock {\n    mime_type?: string;\n    metadata?: Record<string, unknown>;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface URLContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"url\";\n    url: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface Base64ContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"base64\";\n    data: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface PlainTextContentBlock extends BaseDataContentBlock {\n    type: \"file\" | \"text\";\n    source_type: \"text\";\n    text: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface IDContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"id\";\n    id: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type DataContentBlock =\n    | URLContentBlock\n    | Base64ContentBlock\n    | PlainTextContentBlock\n    | IDContentBlock;\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardImageBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n  ) & {\n    type: \"image\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardAudioBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n  ) & {\n    type: \"audio\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardFileBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n    | PlainTextContentBlock\n  ) & {\n    type: \"file\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardTextBlock = PlainTextContentBlock & {\n    type: \"text\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export type DataContentBlockType = DataContentBlock[\"type\"];\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isDataContentBlock(\n  content_block: object\n): content_block is Data.DataContentBlock {\n  return (\n    typeof content_block === \"object\" &&\n    content_block !== null &&\n    \"type\" in content_block &&\n    typeof content_block.type === \"string\" &&\n    \"source_type\" in content_block &&\n    (content_block.source_type === \"url\" ||\n      content_block.source_type === \"base64\" ||\n      content_block.source_type === \"text\" ||\n      content_block.source_type === \"id\")\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isURLContentBlock(\n  content_block: object\n): content_block is Data.URLContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"url\" &&\n    \"url\" in content_block &&\n    typeof content_block.url === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isBase64ContentBlock(\n  content_block: object\n): content_block is Data.Base64ContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"base64\" &&\n    \"data\" in content_block &&\n    typeof content_block.data === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isPlainTextContentBlock(\n  content_block: object\n): content_block is Data.PlainTextContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"text\" &&\n    \"text\" in content_block &&\n    typeof content_block.text === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isIDContentBlock(\n  content_block: object\n): content_block is Data.IDContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"id\" &&\n    \"id\" in content_block &&\n    typeof content_block.id === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function convertToOpenAIImageBlock(\n  content_block: Data.URLContentBlock | Data.Base64ContentBlock\n) {\n  if (isDataContentBlock(content_block)) {\n    if (content_block.source_type === \"url\") {\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: content_block.url,\n        },\n      };\n    }\n    if (content_block.source_type === \"base64\") {\n      if (!content_block.mime_type) {\n        throw new Error(\"mime_type key is required for base64 data.\");\n      }\n      const mime_type = content_block.mime_type;\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: `data:${mime_type};base64,${content_block.data}`,\n        },\n      };\n    }\n  }\n  throw new Error(\n    \"Unsupported source type. Only 'url' and 'base64' are supported.\"\n  );\n}\n\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseMimeType(mime_type: string): {\n  type: string;\n  subtype: string;\n  parameters: Record<string, string>;\n} {\n  const parts = mime_type.split(\";\")[0].split(\"/\");\n  if (parts.length !== 2) {\n    throw new Error(\n      `Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`\n    );\n  }\n\n  const type = parts[0].trim();\n  const subtype = parts[1].trim();\n\n  if (type === \"\" || subtype === \"\") {\n    throw new Error(\n      `Invalid mime type: \"${mime_type}\" - type or subtype is empty.`\n    );\n  }\n\n  const parameters: Record<string, string> = {};\n\n  for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n    const parameterParts = parameterKvp.split(\"=\");\n    if (parameterParts.length !== 2) {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n    const key = parameterParts[0].trim();\n    const value = parameterParts[1].trim();\n    if (key === \"\") {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n\n    parameters[key] = value;\n  }\n\n  return {\n    type,\n    subtype,\n    parameters,\n  };\n}\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns An object containing the parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl,\n  asTypedArray,\n}: {\n  dataUrl: string;\n  asTypedArray: true;\n}): { data: Uint8Array; mime_type: string } | undefined;\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl,\n  asTypedArray,\n}: {\n  dataUrl: string;\n  asTypedArray?: false;\n}): { data: string; mime_type: string } | undefined;\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl: data_url,\n  asTypedArray = false,\n}: {\n  dataUrl: string;\n  asTypedArray?: boolean;\n}): { data: string | Uint8Array; mime_type: string } | undefined {\n  const formatMatch = data_url.match(\n    /^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/\n  );\n  let mime_type: string | undefined;\n\n  if (formatMatch) {\n    mime_type = formatMatch[1].toLowerCase();\n    const data = asTypedArray\n      ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0))\n      : formatMatch[2];\n    return {\n      mime_type,\n      data,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * A bag of provider-specific content block types.\n *\n * Allows implementations of {@link StandardContentBlockConverter} and related to be defined only in\n * terms of the types they support. Also allows for forward compatibility as the set of known\n * standard types grows, as the set of types can be extended without breaking existing\n * implementations of the aforementioned interfaces.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type ProviderFormatTypes<\n  TextFormat = unknown,\n  ImageFormat = unknown,\n  AudioFormat = unknown,\n  FileFormat = unknown,\n  VideoFormat = unknown\n> = {\n  text: TextFormat;\n  image: ImageFormat;\n  audio: AudioFormat;\n  file: FileFormat;\n  video: VideoFormat;\n};\n\n/**\n * Utility interface for converting between standard and provider-specific data content blocks, to be\n * used when implementing chat model providers.\n *\n * Meant to be used with {@link convertToProviderContentBlock} and\n * {@link convertToStandardContentBlock} rather than being consumed directly.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport interface StandardContentBlockConverter<\n  Formats extends Partial<ProviderFormatTypes>\n> {\n  /**\n   * The name of the provider type that corresponds to the provider-specific content block types\n   * that this converter supports.\n   */\n  providerName: string;\n\n  /**\n   * Convert from a standard image block to a provider's proprietary image block format.\n   * @param block - The standard image block to convert.\n   * @returns The provider image block.\n   */\n  fromStandardImageBlock?(block: Data.StandardImageBlock): Formats[\"image\"];\n\n  /**\n   * Convert from a standard audio block to a provider's proprietary audio block format.\n   * @param block - The standard audio block to convert.\n   * @returns The provider audio block.\n   */\n  fromStandardAudioBlock?(block: Data.StandardAudioBlock): Formats[\"audio\"];\n\n  /**\n   * Convert from a standard file block to a provider's proprietary file block format.\n   * @param block - The standard file block to convert.\n   * @returns The provider file block.\n   */\n  fromStandardFileBlock?(block: Data.StandardFileBlock): Formats[\"file\"];\n\n  /**\n   * Convert from a standard text block to a provider's proprietary text block format.\n   * @param block - The standard text block to convert.\n   * @returns The provider text block.\n   */\n  fromStandardTextBlock?(block: Data.StandardTextBlock): Formats[\"text\"];\n}\n\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function convertToProviderContentBlock<\n  Formats extends Partial<ProviderFormatTypes>\n>(\n  block: Data.DataContentBlock,\n  converter: StandardContentBlockConverter<Formats>\n): Formats[keyof Formats] {\n  if (block.type === \"text\") {\n    if (!converter.fromStandardTextBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`\n      );\n    }\n    return converter.fromStandardTextBlock(block as Data.StandardTextBlock);\n  }\n  if (block.type === \"image\") {\n    if (!converter.fromStandardImageBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`\n      );\n    }\n    return converter.fromStandardImageBlock(block as Data.StandardImageBlock);\n  }\n  if (block.type === \"audio\") {\n    if (!converter.fromStandardAudioBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`\n      );\n    }\n    return converter.fromStandardAudioBlock(block as Data.StandardAudioBlock);\n  }\n  if (block.type === \"file\") {\n    if (!converter.fromStandardFileBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`\n      );\n    }\n    return converter.fromStandardFileBlock(block as Data.StandardFileBlock);\n  }\n  throw new Error(\n    `Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`\n  );\n}\n"],"names":["content_block: object","content_block: Data.URLContentBlock | Data.Base64ContentBlock","mime_type: string","parameters: Record<string, string>","mime_type: string | undefined","block: Data.DataContentBlock","converter: StandardContentBlockConverter<Formats>"],"mappings":"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"}},
    {"offset": {"line": 3504, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/message.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/message.ts"],"sourcesContent":["import type { ContentBlock } from \"./content/index.js\";\nimport type { ResponseMetadata, UsageMetadata } from \"./metadata.js\";\nimport type { $MergeDiscriminatedUnion, $MergeObjects } from \"./utils.js\";\n\n/**\n * Represents the possible types of messages in the system.\n * Includes standard message types (\"ai\", \"human\", \"tool\", \"system\")\n * and allows for custom string types that are non-null.\n *\n * @example\n * ```ts\n * // Standard message types\n * const messageType1: MessageType = \"ai\";\n * const messageType2: MessageType = \"human\";\n *\n * // Custom message type\n * const messageType3: MessageType = \"custom_type\";\n * ```\n */\nexport type MessageType =\n  | \"ai\"\n  | \"human\"\n  | \"tool\"\n  | \"system\"\n  | (string & NonNullable<unknown>);\n\n/**\n * Represents the output version format for message content.\n *\n * This type determines how the content field is structured in a message:\n * - \"v0\": Content is represented as a simple string or array of content blocks\n *   - provides backward compatibility with simpler content representations\n * - \"v1\": Content follows the structured ContentBlock format with typed discriminated unions\n *   - enables full type safety and structured content block handling\n *\n * @example\n * ```ts\n * // v0 format - simple content representation\n * const v0Message: Message<{ outputVersion: \"v0\", content: ... }> = {\n *   type: \"human\",\n *   content: \"Hello world\" // string | Array<ContentBlock | ContentBlock.Text>\n * };\n *\n * // v1 format - structured content blocks\n * const v1Message: Message<{ outputVersion: \"v1\", content: ... }> = {\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello world\" },\n *     { type: \"image\", image_url: \"...\" }\n *   ] // Array<ContentBlock | ...> (determined by the structure)\n * };\n * ```\n */\nexport type MessageOutputVersion = \"v0\" | \"v1\";\n\n/**\n * Represents the input and output types of a tool that can be used in messages.\n *\n * @template TInput - The type of input the tool accepts.\n * @template TOutput - The type of output the tool produces.\n *\n * @example\n * ```ts\n * // Tool that takes a string input and returns a number\n * interface StringToNumberTool extends MessageToolDefinition<string, number> {\n *   input: string;\n *   output: number;\n * }\n * ```\n */\nexport interface MessageToolDefinition<TInput = unknown, TOutput = unknown> {\n  input: TInput;\n  output: TOutput;\n}\n\n/**\n * Represents a structured set of tools by mapping tool names to definitions\n * that can be used in messages.\n *\n * @example\n * ```ts\n * interface MyToolSet extends MessageToolSet {\n *   calculator: MessageToolDefinition<\n *     { operation: string; numbers: number[] },\n *     number\n *   >;\n *   translator: MessageToolDefinition<\n *     { text: string; targetLanguage: string },\n *     string\n *   >;\n * }\n * ```\n */\nexport interface MessageToolSet {\n  [key: string]: MessageToolDefinition;\n}\n\n/**\n * Represents a tool call block within a message structure by mapping tool names to their\n * corresponding tool call formats, including the input arguments and an optional identifier.\n *\n * @template TStructure - A message structure type that may contain tool definitions\n *\n * @example\n * ```ts\n * // Given a message structure with a calculator tool:\n * interface MyStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<{ operation: string, numbers: number[] }, number>\n *   }\n * }\n *\n * // The tool call block would be:\n * type CalcToolCall = $MessageToolCallBlock<MyStructure>;\n * // Resolves to:\n * // {\n * //   type: \"tool_call\";\n * //   name: \"calculator\";\n * //   args: { operation: string, numbers: number[] };\n * //   id?: string;\n * // }\n * ```\n */\nexport type $MessageToolCallBlock<TStructure extends MessageStructure> =\n  TStructure[\"tools\"] extends MessageToolSet\n    ? {\n        [K in keyof TStructure[\"tools\"]]: K extends string\n          ? TStructure[\"tools\"][K] extends MessageToolDefinition\n            ? ContentBlock.Tools.ToolCall<K, TStructure[\"tools\"][K][\"input\"]>\n            : never\n          : never;\n      }[keyof TStructure[\"tools\"]]\n    : never;\n\n/**\n * Core interface that defines the structure of messages.\n *\n * @example\n * ```ts\n * // Basic message structure with just content blocks\n * interface SimpleMessageStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     // allows for text + reasoning blocks in ai messages\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   }\n * }\n *\n * // Message structure with tools and properties\n * interface AdvancedMessageStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<\n *       { operation: string; numbers: number[] },\n *       number\n *     >;\n *   };\n *   content: {\n *     // allows for text + image blocks in human messages\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *     // only allows for text blocks in ai messages\n *     ai: ContentBlock.Text;\n *   };\n *   properties: {\n *     // pins properties to ai messages\n *     ai: {\n *       response_metadata: {\n *         confidence: number;\n *         model: string;\n *       };\n *     };\n *   }\n * }\n *\n * // Using with $MergeMessageStructure to combine structures\n * // The resulting type when passed into BaseMessage will have a calculator tool,\n * // allow for text + image blocks in human messages,\n * // and text + reasoning blocks + additional arbitrary properties in ai messages.\n * type CombinedStructure = $MergeMessageStructure<\n *   SimpleMessageStructure,\n *   AdvancedMessageStructure\n * >;\n *\n * // Using in a Message object\n * const message: Message<CombinedStructure> = {\n *   id: \"msg-123\",\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" }\n *     { type: \"image\", mimeType: \"image/jpeg\", url: \"https://example.com/image.jpg\" }\n *     // this block will throw an error because it's not defined in the structure\n *     { type: \"reasoning\", reasoning: \"The answer is 42\" }\n *   ]\n * };\n * ```\n */\nexport interface MessageStructure {\n  /**\n   * Optional output version for the message structure.\n   * If not provided, defaults to \"v0\".\n   */\n  readonly outputVersion?: MessageOutputVersion;\n  /**\n   * Optional set of tool definitions that can be used in messages.\n   * Each tool is defined with input/output types and can be referenced in tool messages.\n   */\n  readonly tools?: MessageToolSet;\n  /**\n   * Optional mapping of message types to their allowed content blocks.\n   * Each message type can specify what content block types it supports (text, images, etc).\n   */\n  readonly content?: Partial<{\n    [key in MessageType]: ContentBlock;\n  }>;\n  /**\n   * Optional mapping of message types to arbitrary property objects.\n   * Allows attaching custom metadata or other information to specific message types.\n   */\n  readonly properties?: Partial<{\n    [key in MessageType]: Record<string, unknown>;\n  }>;\n}\n\n/**\n * Normalizes an arbitrary type to a message output version or undefined.\n * Accepts unknown and narrows to a valid MessageOutputVersion if present.\n */\ntype $NormalizeMessageOutputVersion<T> =\n  | Extract<T, MessageOutputVersion>\n  | undefined;\n\n/**\n * Merges two output version types from message structures.\n *\n * This utility type determines the resulting output version when combining two message structures.\n * The merge logic follows these rules:\n *\n * - If both T and U are undefined, defaults to \"v0\" for backwards compatibility\n * - If T is undefined but U is defined, uses U's version\n * - If U is undefined but T is defined, uses T's version\n * - If both T and U are defined, U takes precedence (later structure wins)\n *\n * @template T - The output version from the first message structure\n * @template U - The output version from the second message structure\n *\n * @example\n * ```ts\n * // Both undefined - defaults to \"v0\"\n * type Result1 = $MergeOutputVersion<undefined, undefined>; // \"v0\"\n *\n * // One defined - uses the defined version\n * type Result2 = $MergeOutputVersion<undefined, \"v1\">; // \"v1\"\n * type Result3 = $MergeOutputVersion<\"v0\", undefined>; // \"v0\"\n *\n * // Both defined - second takes precedence\n * type Result4 = $MergeOutputVersion<\"v0\", \"v1\">; // \"v1\"\n * ```\n */\nexport type $MergeOutputVersion<T, U> =\n  $NormalizeMessageOutputVersion<T> extends infer TV\n    ? $NormalizeMessageOutputVersion<U> extends infer UV\n      ? [TV, UV] extends [undefined, undefined]\n        ? \"v0\"\n        : [TV] extends [undefined]\n        ? Exclude<UV, undefined>\n        : [UV] extends [undefined]\n        ? Exclude<TV, undefined>\n        : UV\n      : never\n    : never;\n\n/**\n * Merges two content definition objects from message structures.\n *\n * This utility type combines content definitions from two message structures, handling\n * the merging of content block types for each message type. The merge logic follows\n * these rules:\n *\n * - For keys that exist in both T and U: Merges the content blocks using discriminated\n *   union merging based on the \"type\" property. This allows combining different content\n *   block types (e.g., text + image) for the same message type.\n * - For keys that exist only in T: Uses T's content definition as-is\n * - For keys that exist only in U: Uses U's content definition as-is\n *\n * @template T - The content definition from the first message structure\n * @template U - The content definition from the second message structure\n *\n * @example\n * ```ts\n * // T allows text content for human messages\n * type ContentA = {\n *   human: ContentBlock.Text;\n * };\n *\n * // U allows image content for human messages and text for AI messages\n * type ContentB = {\n *   human: ContentBlock.Multimodal.Image;\n *   ai: ContentBlock.Text;\n * };\n *\n * // Merged result allows both text and images for human messages, text for AI\n * type Merged = $MergeContentDefinition<ContentA, ContentB>;\n * // Result: {\n * //   human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n * //   ai: ContentBlock.Text;\n * // }\n * ```\n */\nexport type $MergeContentDefinition<T, U> = {\n  [K in keyof T | keyof U as Extract<\n    (K extends keyof T ? T[K] : never) | (K extends keyof U ? U[K] : never),\n    ContentBlock\n  > extends never\n    ? never\n    : K]: K extends keyof T\n    ? K extends keyof U\n      ? $MergeDiscriminatedUnion<\n          Extract<T[K], ContentBlock>,\n          Extract<U[K], ContentBlock>,\n          \"type\"\n        >\n      : Extract<T[K], ContentBlock>\n    : K extends keyof U\n    ? Extract<U[K], ContentBlock>\n    : never;\n};\n\n/**\n * Merges two message structures A and B into a combined structure.\n * This is a type utility that handles merging of tools, content blocks, and properties\n * from two message structures. The resulting type is usable as its own message structure.\n *\n * @example\n * ```ts\n * // Structure A allows text in human messages and has a confidence property on AI messages\n * interface StructureA extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *   };\n *   properties: {\n *     ai: { confidence: number };\n *   }\n * }\n *\n * // Structure B allows images in human messages and has a model property on AI messages\n * interface StructureB extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Multimodal.Image;\n *   };\n *   properties: {\n *     ai: { model: string };\n *   }\n * }\n *\n * // Merged structure allows both text and images in human messages\n * // AI messages have both confidence and model properties\n * type Merged = $MergeMessageStructure<StructureA, StructureB>;\n * ```\n *\n * @template A - First message structure to merge\n * @template B - Second message structure to merge (takes precedence over A)\n */\nexport type $MergeMessageStructure<\n  T extends MessageStructure,\n  U extends MessageStructure\n> = {\n  outputVersion: $MergeOutputVersion<T[\"outputVersion\"], U[\"outputVersion\"]>;\n  tools: $MergeObjects<T[\"tools\"], U[\"tools\"]>;\n  content: $MergeContentDefinition<T[\"content\"], U[\"content\"]>;\n  properties: $MergeObjects<T[\"properties\"], U[\"properties\"]>;\n};\n\n/**\n * Standard message structured used to define the most basic message structure that's\n * used throughout the library.\n *\n * This is also the message structure that's used when a message structure is not provided.\n */\nexport interface StandardMessageStructure extends MessageStructure {\n  content: {\n    /** Text content for AI messages */\n    ai: ContentBlock.Text;\n    /** Text content for human messages */\n    human: ContentBlock.Text;\n    /** Text content for system messages */\n    system: ContentBlock.Text;\n    /** Text content for tool messages */\n    tool: ContentBlock.Text;\n  };\n  properties: {\n    /** Properties specific to AI messages */\n    ai: {\n      /** Metadata about the AI model response */\n      response_metadata: ResponseMetadata;\n      /** Usage statistics for the AI response */\n      usage_metadata: UsageMetadata;\n    };\n    human: {\n      /** Metadata about the human message */\n      response_metadata: Record<string, unknown>;\n    };\n    system: {\n      /** Metadata about the system message */\n      response_metadata: Record<string, unknown>;\n    };\n    tool: {\n      /** Metadata about the tool message */\n      response_metadata: Record<string, unknown>;\n    };\n  };\n}\n\n/**\n * Takes a message structure type T and normalizes it by merging it with the standard message structure.\n * If T is already a standard message structure, returns T unchanged.\n *\n * This ensures that any custom message structure includes all the standard message structure fields\n * by default while allowing overrides and extensions.\n *\n * @template T - The message structure type to normalize, must extend MessageStructure\n * @returns Either T if it's already a standard structure, or the merged result of T with standard structure\n */\nexport type $NormalizedMessageStructure<T extends MessageStructure> =\n  T extends StandardMessageStructure\n    ? T\n    : $MergeMessageStructure<StandardMessageStructure, T>;\n\n/**\n * Infers the content blocks for a specific message type in a message structure.\n *\n * This utility type extracts the content block type that corresponds to a given message type\n * from the message structure's content definition.\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content block type for the specified type, or never if its not defined in the structure\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContent = $InferMessageContentBlocks<MyStructure, \"human\">;\n * // HumanContent = ContentBlock.Text\n *\n * type AIContent = $InferMessageContentBlocks<MyStructure, \"ai\">;\n * // AIContent = ContentBlock.Text | ContentBlock.ToolCall\n * ```\n */\nexport type $InferMessageContentBlocks<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $NormalizedMessageStructure<TStructure> extends infer S\n  ? S extends MessageStructure\n    ? S[\"content\"] extends infer C\n      ? C extends Record<PropertyKey, ContentBlock>\n        ? TRole extends keyof C\n          ? [$MessageToolCallBlock<TStructure>] extends [never]\n            ? C[TRole]\n            : $MergeDiscriminatedUnion<\n                NonNullable<C[TRole]>,\n                $MessageToolCallBlock<TStructure>,\n                \"type\"\n              >\n          : never\n        : never\n      : never\n    : never\n  : never;\n\n/**\n * Infers the content type for a specific message type from a message structure.\n *\n * This utility type determines the appropriate content type based on the message structure's\n * output version and the specified message type. The content type varies depending on the\n * output version (see {@link MessageOutputVersion})\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content type for the specified role based on the output version\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   outputVersion: \"v0\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContentV0 = $InferMessageContent<MyStructure, \"human\">;\n * // HumanContentV0 = string | Array<ContentBlock | ContentBlock.Text>\n *\n * interface MyStructureV1 extends MessageStructure {\n *   outputVersion: \"v1\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   };\n * }\n *\n * type HumanContentV1 = $InferMessageContent<MyStructureV1, \"human\">;\n * // HumanContentV1 = ContentBlock.Text\n *\n * type AIContentV1 = $InferMessageContent<MyStructureV1, \"ai\">;\n * // AIContentV1 = ContentBlock.Text | ContentBlock.Reasoning\n * ```\n */\nexport type $InferMessageContent<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = TStructure[\"outputVersion\"] extends \"v1\"\n  ? Array<$InferMessageContentBlocks<TStructure, TRole>>\n  : string | Array<ContentBlock | ContentBlock.Text>;\n\n/**\n * Infers the properties for a specific message type from a message structure.\n *\n * This utility type extracts the properties object that corresponds to a given message type\n * from the message structure's properties definition, and excludes the reserved\n * \"content\" and \"type\" properties to avoid conflicts with the core message structure.\n *\n * If the specified type is not defined in the message structure's properties, it returns\n * a generic Record<string, unknown> type to allow for arbitrary properties.\n *\n * @template TStructure - The message structure to infer properties from\n * @template TRole - The message type/role to get properties for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The properties object type for the specified type, excluding \"content\" and \"type\"\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string };\n *       usage_metadata: { tokens: number };\n *       content: string; // This will be omitted\n *       type: string;    // This will be omitted\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIProperties = $InferMessageProperties<MyStructure, \"ai\">;\n * // AIProperties = { response_metadata: { model: string }; usage_metadata: { tokens: number } }\n *\n * type HumanProperties = $InferMessageProperties<MyStructure, \"human\">;\n * // HumanProperties = { metadata: Record<string, unknown> }\n *\n * type SystemProperties = $InferMessageProperties<MyStructure, \"system\">;\n * // SystemProperties = Record<string, unknown> (fallback for undefined role)\n * ```\n */\nexport type $InferMessageProperties<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $NormalizedMessageStructure<TStructure> extends infer S\n  ? S extends MessageStructure\n    ? S[\"properties\"] extends infer P | undefined\n      ? P extends Record<PropertyKey, unknown>\n        ? TRole extends keyof P\n          ? Omit<P[TRole], \"content\" | \"type\">\n          : Record<string, unknown>\n        : Record<string, unknown>\n      : Record<string, unknown>\n    : never\n  : never;\n\n/**\n * Infers the type of a specific property for a message type from a message structure.\n *\n * This utility type extracts the type of a single property by name from the properties\n * object that corresponds to a given message type. If the specified property key does\n * not exist in the type's properties, it returns `never`.\n *\n * @template TStructure - The message structure to infer the property from\n * @template TRole - The message type/role to get the property for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @template K - The property key to extract the type for\n * @returns The type of the specified property, or `never` if the property doesn't exist\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number };\n *       usage_metadata: { input_tokens: number; output_tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type ResponseMetadata = $InferMessageProperty<MyStructure, \"ai\", \"response_metadata\">;\n * // ResponseMetadata = { model: string; temperature: number }\n *\n * type UsageMetadata = $InferMessageProperty<MyStructure, \"ai\", \"usage_metadata\">;\n * // UsageMetadata = { input_tokens: number; output_tokens: number }\n *\n * type NonExistentProperty = $InferMessageProperty<MyStructure, \"ai\", \"nonExistent\">;\n * // NonExistentProperty = Record<string, unknown>\n *\n * type HumanMetadata = $InferMessageProperty<MyStructure, \"human\", \"metadata\">;\n * // HumanMetadata = Record<string, unknown>\n * ```\n */\nexport type $InferMessageProperty<\n  TStructure extends MessageStructure,\n  TRole extends MessageType,\n  K extends string\n> = K extends keyof $InferMessageProperties<TStructure, TRole>\n  ? $InferMessageProperties<TStructure, TRole>[K]\n  : never;\n\n/**\n * Infers the response metadata type for a specific message type from a message structure.\n *\n * This utility type extracts the `response_metadata` property type for a given message type.\n *\n * @template TStructure - The message structure to infer the response metadata from\n * @template TRole - The message type/role to get the response metadata for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The type of the response_metadata property, or `Record<string, unknown>` as fallback\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number; tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIResponseMetadata = $InferResponseMetadata<MyStructure, \"ai\">;\n * // AIResponseMetadata = { model: string; temperature: number; tokens: number }\n *\n * type HumanResponseMetadata = $InferResponseMetadata<MyStructure, \"human\">;\n * // HumanResponseMetadata = Record<string, unknown> (fallback since not defined)\n * ```\n */\nexport type $InferResponseMetadata<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $InferMessageProperty<\n  TStructure,\n  TRole,\n  \"response_metadata\"\n> extends infer P\n  ? [P] extends [never]\n    ? Record<string, unknown>\n    : P\n  : never;\n\n/**\n * Represents a message object that organizes context for an LLM.\n *\n * @example\n * ```ts\n * // Basic message with text content\n * const message: Message = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"human\",\n *   content: [{ type: \"text\", text: \"Hello!\" }]\n * };\n *\n * // Basic ai message interface extension\n * interface MyMessage extends Message<StandardMessageStructure, \"ai\"> {\n *   // Additional AI-specific properties can be added here\n * }\n *`\n * // Custom message structure\n * interface CustomStructure extends MessageStructure {\n *   content: {\n *     ai: ContentBlock.Text | ContentBlock.ToolCall<\"search\", { query: string }>;\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *   };\n * }\n *\n * // Create a message with custom structure\n * const message: Message<CustomStructure> = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"ai\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" },\n *     {\n *       type: \"tool_call\",\n *       name: \"search\",\n *       args: { query: \"What is the capital of France?\" }\n *     }\n *   ]\n * };\n * ```\n */\nexport interface Message<\n  TStructure extends MessageStructure = StandardMessageStructure,\n  TRole extends MessageType = MessageType\n> {\n  /** The message type/role */\n  readonly type: TRole;\n  /** Unique identifier for this message */\n  id?: string;\n  /** Optional name/identifier for the entity that created this message */\n  name?: string;\n  /** Array of content blocks that make up the message content */\n  content: $InferMessageContent<TStructure, TRole>;\n  /** Metadata about the message */\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n}\n\n/**\n * Type guard to check if a value is a valid Message object.\n *\n * @param message - The value to check\n * @returns true if the value is a valid Message object, false otherwise\n */\nexport function isMessage(message: unknown): message is Message {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"type\" in message &&\n    \"content\" in message &&\n    (typeof message.content === \"string\" || Array.isArray(message.content))\n  );\n}\n"],"names":["message: unknown"],"mappings":";;;;;;;;;;AAitBA,SAAgB,UAAUA,OAAAA,EAAsC;IAC9D,OACE,OAAO,YAAY,YACnB,YAAY,QACZ,UAAU,WACV,aAAa,WAAA,CACZ,OAAO,QAAQ,OAAA,KAAY,YAAY,MAAM,OAAA,CAAQ,QAAQ,OAAA,CAAQ;AAEzE"}},
    {"offset": {"line": 3523, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/utils.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/utils.ts"],"sourcesContent":["import type { ContentBlock } from \"../content/index.js\";\n\nexport function _isContentBlock<T extends string>(\n  block: unknown,\n  type: T\n): block is ContentBlock & { type: T } {\n  return _isObject(block) && block.type === type;\n}\n\nexport function _isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null;\n}\n\nexport function _isArray<T>(value: unknown): value is T[] {\n  return Array.isArray(value);\n}\n\nexport function _isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function _isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\nexport function _isBytesArray(value: unknown): value is Uint8Array {\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  return value instanceof Uint8Array;\n}\n\nexport function safeParseJson<T = unknown>(value: string): T | undefined {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return undefined;\n  }\n}\n\nexport const iife = <T>(fn: () => T): T => fn();\n"],"names":["block: unknown","type: T","value: unknown","value: string","fn: () => T"],"mappings":";;;;;;;;;;;;;;;;;;;AAEA,SAAgB,gBACdA,KAAAA,EACAC,IAAAA,EACqC;IACrC,OAAO,UAAU,MAAM,IAAI,MAAM,IAAA,KAAS;AAC3C;AAED,SAAgB,UAAUC,KAAAA,EAAkD;IAC1E,OAAO,OAAO,UAAU,YAAY,UAAU;AAC/C;AAED,SAAgB,SAAYA,KAAAA,EAA8B;IACxD,OAAO,MAAM,OAAA,CAAQ,MAAM;AAC5B;AAED,SAAgB,UAAUA,KAAAA,EAAiC;IACzD,OAAO,OAAO,UAAU;AACzB;AAED,SAAgB,UAAUA,KAAAA,EAAiC;IACzD,OAAO,OAAO,UAAU;AACzB;AAED,SAAgB,cAAcA,KAAAA,EAAqC;IAEjE,OAAO,iBAAiB;AACzB;AAED,SAAgB,cAA2BC,KAAAA,EAA8B;IACvE,IAAI;QACF,OAAO,KAAK,KAAA,CAAM,MAAM;IACzB,EAAA,OAAO;QACN,OAAO,KAAA;IACR;AACF;AAED,MAAa,OAAO,CAAIC,KAAmB,IAAI"}},
    {"offset": {"line": 3574, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/anthropic.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/anthropic.ts"],"sourcesContent":["import type { StandardContentBlockTranslator } from \"./index.js\";\nimport type { ContentBlock } from \"../content/index.js\";\nimport type { AIMessageChunk, AIMessage } from \"../ai.js\";\nimport type { BaseMessage, BaseMessageChunk } from \"../base.js\";\nimport {\n  _isArray,\n  _isContentBlock,\n  _isNumber,\n  _isObject,\n  _isString,\n  safeParseJson,\n  iife,\n} from \"./utils.js\";\n\nfunction convertAnthropicAnnotation(\n  citation: ContentBlock\n): ContentBlock.Citation | undefined {\n  if (\n    citation.type === \"char_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_char_index) &&\n    _isNumber(citation.end_char_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_char_index,\n      end_char_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"char\",\n      title: document_title ?? undefined,\n      startIndex: start_char_index,\n      endIndex: end_char_index,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"page_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_page_number) &&\n    _isNumber(citation.end_page_number) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_page_number,\n      end_page_number,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"page\",\n      title: document_title ?? undefined,\n      startIndex: start_page_number,\n      endIndex: end_page_number,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"content_block_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_block_index) &&\n    _isNumber(citation.end_block_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_block_index,\n      end_block_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"block\",\n      title: document_title ?? undefined,\n      startIndex: start_block_index,\n      endIndex: end_block_index,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"web_search_result_location\" &&\n    _isString(citation.url) &&\n    _isString(citation.title) &&\n    _isString(citation.encrypted_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const { url, title, encrypted_index, cited_text, ...rest } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"url\",\n      url,\n      title,\n      startIndex: Number(encrypted_index),\n      endIndex: Number(encrypted_index),\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"search_result_location\" &&\n    _isString(citation.source) &&\n    _isString(citation.title) &&\n    _isNumber(citation.start_block_index) &&\n    _isNumber(citation.end_block_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      source,\n      title,\n      start_block_index,\n      end_block_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"search\",\n      url: source,\n      title: title ?? undefined,\n      startIndex: start_block_index,\n      endIndex: end_block_index,\n      citedText: cited_text,\n    };\n  }\n  return undefined;\n}\n\n/**\n * Converts an Anthropic content block to a standard V1 content block.\n *\n * This function handles the conversion of Anthropic-specific content blocks\n * (document and image blocks) to the standardized V1 format. It supports\n * various source types including base64 data, URLs, file IDs, and text data.\n *\n * @param block - The Anthropic content block to convert\n * @returns A standard V1 content block if conversion is successful, undefined otherwise\n *\n * @example\n * ```typescript\n * const anthropicBlock = {\n *   type: \"image\",\n *   source: {\n *     type: \"base64\",\n *     media_type: \"image/png\",\n *     data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==\"\n *   }\n * };\n *\n * const standardBlock = convertToV1FromAnthropicContentBlock(anthropicBlock);\n * // Returns: { type: \"image\", mimeType: \"image/png\", data: \"...\" }\n * ```\n */\nexport function convertToV1FromAnthropicContentBlock(\n  block: ContentBlock\n): ContentBlock.Standard | undefined {\n  if (\n    _isContentBlock(block, \"document\") &&\n    _isObject(block.source) &&\n    \"type\" in block.source\n  ) {\n    if (\n      block.source.type === \"base64\" &&\n      _isString(block.source.media_type) &&\n      _isString(block.source.data)\n    ) {\n      return {\n        type: \"file\",\n        mimeType: block.source.media_type,\n        data: block.source.data,\n      };\n    } else if (block.source.type === \"url\" && _isString(block.source.url)) {\n      return {\n        type: \"file\",\n        url: block.source.url,\n      };\n    } else if (\n      block.source.type === \"file\" &&\n      _isString(block.source.file_id)\n    ) {\n      return {\n        type: \"file\",\n        fileId: block.source.file_id,\n      };\n    } else if (block.source.type === \"text\" && _isString(block.source.data)) {\n      return {\n        type: \"file\",\n        mimeType: String(block.source.media_type ?? \"text/plain\"),\n        data: block.source.data,\n      };\n    }\n  } else if (\n    _isContentBlock(block, \"image\") &&\n    _isObject(block.source) &&\n    \"type\" in block.source\n  ) {\n    if (\n      block.source.type === \"base64\" &&\n      _isString(block.source.media_type) &&\n      _isString(block.source.data)\n    ) {\n      return {\n        type: \"image\",\n        mimeType: block.source.media_type,\n        data: block.source.data,\n      };\n    } else if (block.source.type === \"url\" && _isString(block.source.url)) {\n      return {\n        type: \"image\",\n        url: block.source.url,\n      };\n    } else if (\n      block.source.type === \"file\" &&\n      _isString(block.source.file_id)\n    ) {\n      return {\n        type: \"image\",\n        fileId: block.source.file_id,\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Converts an array of content blocks from Anthropic format to v1 standard format.\n *\n * This function processes each content block in the input array, attempting to convert\n * Anthropic-specific block formats (like image blocks with source objects, document blocks, etc.)\n * to the standardized v1 content block format. If a block cannot be converted, it is\n * passed through as-is with a type assertion to ContentBlock.Standard.\n *\n * @param content - Array of content blocks in Anthropic format to be converted\n * @returns Array of content blocks in v1 standard format\n */\nexport function convertToV1FromAnthropicInput(\n  content: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    for (const block of content) {\n      const stdBlock = convertToV1FromAnthropicContentBlock(block);\n      if (stdBlock) {\n        yield stdBlock;\n      } else {\n        yield block as ContentBlock.Standard;\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\n/**\n * Converts an Anthropic AI message to an array of v1 standard content blocks.\n *\n * This function processes an AI message containing Anthropic-specific content blocks\n * and converts them to the standardized v1 content block format.\n *\n * @param message - The AI message containing Anthropic-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage([\n *   { type: \"text\", text: \"Hello world\" },\n *   { type: \"thinking\", text: \"Let me think about this...\" },\n *   { type: \"tool_use\", id: \"123\", name: \"calculator\", input: { a: 1, b: 2 } }\n * ]);\n *\n * const standardBlocks = convertToV1FromAnthropicMessage(message);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello world\" },\n * //   { type: \"reasoning\", reasoning: \"Let me think about this...\" },\n * //   { type: \"tool_call\", id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * // ]\n * ```\n */\nexport function convertToV1FromAnthropicMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      // TextBlock\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        const { text, citations, ...rest } = block;\n        if (_isArray(citations) && citations.length) {\n          const _citations = citations.reduce<ContentBlock.Citation[]>(\n            (acc, item) => {\n              const citation = convertAnthropicAnnotation(item as ContentBlock);\n              if (citation) {\n                return [...acc, citation];\n              }\n              return acc;\n            },\n            []\n          );\n          yield {\n            ...rest,\n            type: \"text\",\n            text,\n            annotations: _citations,\n          };\n          continue;\n        } else {\n          yield {\n            ...rest,\n            type: \"text\",\n            text,\n          };\n          continue;\n        }\n      }\n      // ThinkingBlock\n      else if (\n        _isContentBlock(block, \"thinking\") &&\n        _isString(block.thinking)\n      ) {\n        const { thinking, signature, ...rest } = block;\n        yield {\n          ...rest,\n          type: \"reasoning\",\n          reasoning: thinking,\n          signature,\n        };\n        continue;\n      }\n      // RedactedThinkingBlock\n      else if (_isContentBlock(block, \"redacted_thinking\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      }\n      // ToolUseBlock\n      else if (\n        _isContentBlock(block, \"tool_use\") &&\n        _isString(block.name) &&\n        _isString(block.id)\n      ) {\n        yield {\n          type: \"tool_call\",\n          id: block.id,\n          name: block.name,\n          args: block.input,\n        };\n        continue;\n      }\n      // message chunks can have input_json_delta contents\n      else if (_isContentBlock(block, \"input_json_delta\")) {\n        if (_isAIMessageChunk(message) && message.tool_call_chunks?.length) {\n          const tool_call_chunk = message.tool_call_chunks[0];\n          yield {\n            type: \"tool_call_chunk\",\n            id: tool_call_chunk.id,\n            name: tool_call_chunk.name,\n            args: tool_call_chunk.args,\n            index: tool_call_chunk.index,\n          };\n          continue;\n        }\n      }\n      // ServerToolUseBlock\n      else if (\n        _isContentBlock(block, \"server_tool_use\") &&\n        _isString(block.name) &&\n        _isString(block.id)\n      ) {\n        const { name, id } = block;\n        if (name === \"web_search\") {\n          const query = iife(() => {\n            if (typeof block.input === \"string\") {\n              return block.input;\n            } else if (_isObject(block.input) && _isString(block.input.query)) {\n              return block.input.query;\n            } else if (_isString(block.partial_json)) {\n              const json = safeParseJson<{ query?: string }>(\n                block.partial_json\n              );\n              if (json?.query) {\n                return json.query;\n              }\n            }\n            return \"\";\n          });\n          yield {\n            id,\n            type: \"server_tool_call\",\n            name: \"web_search\",\n            args: { query },\n          };\n          continue;\n        } else if (block.name === \"code_execution\") {\n          const code = iife(() => {\n            if (typeof block.input === \"string\") {\n              return block.input;\n            } else if (_isObject(block.input) && _isString(block.input.code)) {\n              return block.input.code;\n            } else if (_isString(block.partial_json)) {\n              const json = safeParseJson<{ code?: string }>(block.partial_json);\n              if (json?.code) {\n                return json.code;\n              }\n            }\n            return \"\";\n          });\n          yield {\n            id,\n            type: \"server_tool_call\",\n            name: \"code_execution\",\n            args: { code },\n          };\n          continue;\n        }\n      }\n      // WebSearchToolResultBlock\n      else if (\n        _isContentBlock(block, \"web_search_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isArray(block.content)\n      ) {\n        const { content, tool_use_id } = block;\n        const urls = content.reduce<string[]>((acc, content) => {\n          if (_isContentBlock(content, \"web_search_result\")) {\n            return [...acc, content.url as string];\n          }\n          return acc;\n        }, []);\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"web_search\",\n          toolCallId: tool_use_id,\n          status: \"success\",\n          output: {\n            urls,\n          },\n        };\n        continue;\n      }\n      // CodeExecutionToolResultBlock\n      else if (\n        _isContentBlock(block, \"code_execution_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isObject(block.content)\n      ) {\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"code_execution\",\n          toolCallId: block.tool_use_id,\n          status: \"success\",\n          output: block.content,\n        };\n        continue;\n      }\n      // MCPToolUseBlock\n      else if (_isContentBlock(block, \"mcp_tool_use\")) {\n        yield {\n          id: block.id,\n          type: \"server_tool_call\",\n          name: \"mcp_tool_use\",\n          args: block.input,\n        };\n        continue;\n      }\n      // MCPToolResultBlock\n      else if (\n        _isContentBlock(block, \"mcp_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isObject(block.content)\n      ) {\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"mcp_tool_use\",\n          toolCallId: block.tool_use_id,\n          status: \"success\",\n          output: block.content,\n        };\n        continue;\n      }\n      // ContainerUploadBlock\n      else if (_isContentBlock(block, \"container_upload\")) {\n        yield {\n          type: \"server_tool_call\",\n          name: \"container_upload\",\n          args: block.input,\n        };\n        continue;\n      }\n      // SearchResultBlockParam\n      else if (_isContentBlock(block, \"search_result\")) {\n        yield { id: block.id, type: \"non_standard\", value: block };\n        continue;\n      }\n      // ToolResultBlockParam\n      else if (_isContentBlock(block, \"tool_result\")) {\n        yield { id: block.id, type: \"non_standard\", value: block };\n        continue;\n      } else {\n        // For all other blocks, we try to convert them to a standard block\n        const stdBlock = convertToV1FromAnthropicContentBlock(block);\n        if (stdBlock) {\n          yield stdBlock;\n          continue;\n        }\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatAnthropicTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromAnthropicMessage,\n  translateContentChunk: convertToV1FromAnthropicMessage,\n};\n\nfunction _isAIMessageChunk(message: unknown): message is AIMessageChunk {\n  return (\n    typeof (message as BaseMessage)?._getType === \"function\" &&\n    typeof (message as BaseMessageChunk).concat === \"function\" &&\n    (message as BaseMessageChunk)._getType() === \"ai\"\n  );\n}\n"],"names":["citation: ContentBlock","block: ContentBlock","content: Array<ContentBlock>","message: AIMessage","content","ChatAnthropicTranslator: StandardContentBlockTranslator","message: unknown"],"mappings":"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"}},
    {"offset": {"line": 3959, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/data.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/data.ts"],"sourcesContent":["import {\n  parseBase64DataUrl,\n  isBase64ContentBlock,\n  isIDContentBlock,\n  isURLContentBlock,\n} from \"../content/data.js\";\nimport type { ContentBlock } from \"../content/index.js\";\nimport { _isContentBlock, _isObject, _isString } from \"./utils.js\";\n\nexport function convertToV1FromDataContentBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (isURLContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type,\n      url: block.url,\n      metadata: block.metadata,\n    };\n  }\n  if (isBase64ContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type ?? \"application/octet-stream\",\n      data: block.data,\n      metadata: block.metadata,\n    };\n  }\n  if (isIDContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type,\n      fileId: block.id,\n      metadata: block.metadata,\n    };\n  }\n  return block as ContentBlock.Standard;\n}\n\nexport function convertToV1FromDataContent(\n  content: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  return content.map(convertToV1FromDataContentBlock);\n}\n\nexport function isOpenAIDataBlock(block: ContentBlock): boolean {\n  if (_isContentBlock(block, \"image_url\") && _isObject(block.image_url)) {\n    return true;\n  }\n  if (_isContentBlock(block, \"input_audio\") && _isObject(block.input_audio)) {\n    return true;\n  }\n  if (_isContentBlock(block, \"file\") && _isObject(block.file)) {\n    return true;\n  }\n  return false;\n}\n\nexport function convertToV1FromOpenAIDataBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (\n    _isContentBlock(block, \"image_url\") &&\n    _isObject(block.image_url) &&\n    _isString(block.image_url.url)\n  ) {\n    const parsed = parseBase64DataUrl({ dataUrl: block.image_url.url });\n    if (parsed) {\n      return {\n        type: \"image\",\n        mimeType: parsed.mime_type,\n        data: parsed.data,\n      };\n    } else {\n      return {\n        type: \"image\",\n        url: block.image_url.url,\n      };\n    }\n  } else if (\n    _isContentBlock(block, \"input_audio\") &&\n    _isObject(block.input_audio) &&\n    _isString(block.input_audio.data) &&\n    _isString(block.input_audio.format)\n  ) {\n    return {\n      type: \"audio\",\n      data: block.input_audio.data,\n      mimeType: `audio/${block.input_audio.format}`,\n    };\n  } else if (\n    _isContentBlock(block, \"file\") &&\n    _isObject(block.file) &&\n    _isString(block.file.data)\n  ) {\n    const parsed = parseBase64DataUrl({ dataUrl: block.file.data });\n    if (parsed) {\n      return {\n        type: \"file\",\n        data: parsed.data,\n        mimeType: parsed.mime_type,\n      };\n    } else if (_isString(block.file.file_id)) {\n      return {\n        type: \"file\",\n        fileId: block.file.file_id,\n      };\n    }\n  }\n  return block as ContentBlock.Standard;\n}\n"],"names":["block: ContentBlock","content: Array<ContentBlock>"],"mappings":";;;;;;;;;;;;;AASA,SAAgB,gCACdA,KAAAA,EACuB;IACvB,QAAI,iMAAA,EAAkB,MAAM,CAC1B,CAAA,OAAO;QACL,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,SAAA;QAChB,KAAK,MAAM,GAAA;QACX,UAAU,MAAM,QAAA;IACjB;IAEH,QAAI,oMAAA,EAAqB,MAAM,CAC7B,CAAA,OAAO;QACL,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,SAAA,IAAa;QAC7B,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,QAAA;IACjB;IAEH,QAAI,gMAAA,EAAiB,MAAM,CACzB,CAAA,OAAO;QACL,MAAM,MAAM,IAAA;QACZ,UAAU,MAAM,SAAA;QAChB,QAAQ,MAAM,EAAA;QACd,UAAU,MAAM,QAAA;IACjB;IAEH,OAAO;AACR;AAED,SAAgB,2BACdC,OAAAA,EAC8B;IAC9B,OAAO,QAAQ,GAAA,CAAI,gCAAgC;AACpD;AAED,SAAgB,kBAAkBD,KAAAA,EAA8B;IAC9D,QAAI,0MAAA,EAAgB,OAAO,YAAY,QAAI,oMAAA,EAAU,MAAM,SAAA,CAAU,CACnE,CAAA,OAAO;IAET,QAAI,0MAAA,EAAgB,OAAO,cAAc,QAAI,oMAAA,EAAU,MAAM,WAAA,CAAY,CACvE,CAAA,OAAO;IAET,QAAI,0MAAA,EAAgB,OAAO,OAAO,QAAI,oMAAA,EAAU,MAAM,IAAA,CAAK,CACzD,CAAA,OAAO;IAET,OAAO;AACR;AAED,SAAgB,+BACdA,KAAAA,EACuB;IACvB,QACE,0MAAA,EAAgB,OAAO,YAAY,QACnC,oMAAA,EAAU,MAAM,SAAA,CAAU,QAC1B,oMAAA,EAAU,MAAM,SAAA,CAAU,GAAA,CAAI,EAC9B;QACA,MAAM,aAAS,kMAAA,EAAmB;YAAE,SAAS,MAAM,SAAA,CAAU,GAAA;QAAK,EAAC;QACnE,IAAI,OACF,CAAA,OAAO;YACL,MAAM;YACN,UAAU,OAAO,SAAA;YACjB,MAAM,OAAO,IAAA;QACd;aAED,OAAO;YACL,MAAM;YACN,KAAK,MAAM,SAAA,CAAU,GAAA;QACtB;IAEJ,OAAA,QACC,0MAAA,EAAgB,OAAO,cAAc,QACrC,oMAAA,EAAU,MAAM,WAAA,CAAY,QAC5B,oMAAA,EAAU,MAAM,WAAA,CAAY,IAAA,CAAK,QACjC,oMAAA,EAAU,MAAM,WAAA,CAAY,MAAA,CAAO,CAEnC,CAAA,OAAO;QACL,MAAM;QACN,MAAM,MAAM,WAAA,CAAY,IAAA;QACxB,UAAU,CAAC,MAAM,EAAE,MAAM,WAAA,CAAY,MAAA,EAAQ;IAC9C;iBAED,0MAAA,EAAgB,OAAO,OAAO,QAC9B,oMAAA,EAAU,MAAM,IAAA,CAAK,QACrB,oMAAA,EAAU,MAAM,IAAA,CAAK,IAAA,CAAK,EAC1B;QACA,MAAM,aAAS,kMAAA,EAAmB;YAAE,SAAS,MAAM,IAAA,CAAK,IAAA;QAAM,EAAC;QAC/D,IAAI,OACF,CAAA,OAAO;YACL,MAAM;YACN,MAAM,OAAO,IAAA;YACb,UAAU,OAAO,SAAA;QAClB;qBACQ,oMAAA,EAAU,MAAM,IAAA,CAAK,OAAA,CAAQ,CACtC,CAAA,OAAO;YACL,MAAM;YACN,QAAQ,MAAM,IAAA,CAAK,OAAA;QACpB;IAEJ;IACD,OAAO;AACR"}},
    {"offset": {"line": 4043, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/openai.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/openai.ts"],"sourcesContent":["import type { ContentBlock } from \"../content/index.js\";\nimport type { AIMessageChunk, AIMessage } from \"../ai.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { convertToV1FromOpenAIDataBlock, isOpenAIDataBlock } from \"./data.js\";\nimport {\n  _isArray,\n  _isContentBlock,\n  _isObject,\n  _isString,\n  iife,\n} from \"./utils.js\";\n\n/**\n * Converts a ChatOpenAICompletions message to an array of v1 standard content blocks.\n *\n * This function processes an AI message from ChatOpenAICompletions API format\n * and converts it to the standardized v1 content block format. It handles both\n * string content and structured content blocks, as well as tool calls.\n *\n * @param message - The AI message containing ChatOpenAICompletions formatted content\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage(\"Hello world\");\n * const standardBlocks = convertToV1FromChatCompletions(message);\n * // Returns: [{ type: \"text\", text: \"Hello world\" }]\n * ```\n *\n * @example\n * ```typescript\n * const message = new AIMessage([\n *   { type: \"text\", text: \"Hello\" },\n *   { type: \"image_url\", image_url: { url: \"https://example.com/image.png\" } }\n * ]);\n * message.tool_calls = [\n *   { id: \"call_123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletions(message);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello\" },\n * //   { type: \"image\", url: \"https://example.com/image.png\" },\n * //   { type: \"tool_call\", id: \"call_123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletions(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  const blocks: Array<ContentBlock.Standard> = [];\n  if (typeof message.content === \"string\") {\n    blocks.push({\n      type: \"text\",\n      text: message.content,\n    });\n  } else {\n    blocks.push(...convertToV1FromChatCompletionsInput(message.content));\n  }\n  for (const toolCall of message.tool_calls ?? []) {\n    blocks.push({\n      type: \"tool_call\",\n      id: toolCall.id,\n      name: toolCall.name,\n      args: toolCall.args,\n    });\n  }\n  return blocks;\n}\n\n/**\n * Converts a ChatOpenAICompletions message chunk to an array of v1 standard content blocks.\n *\n * This function processes an AI message chunk from OpenAI's chat completions API and converts\n * it to the standardized v1 content block format. It handles both string and array content,\n * as well as tool calls that may be present in the chunk.\n *\n * @param message - The AI message chunk containing OpenAI-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const chunk = new AIMessage(\"Hello\");\n * const standardBlocks = convertToV1FromChatCompletionsChunk(chunk);\n * // Returns: [{ type: \"text\", text: \"Hello\" }]\n * ```\n *\n * @example\n * ```typescript\n * const chunk = new AIMessage([\n *   { type: \"text\", text: \"Processing...\" }\n * ]);\n * chunk.tool_calls = [\n *   { id: \"call_456\", name: \"search\", args: { query: \"test\" } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletionsChunk(chunk);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Processing...\" },\n * //   { type: \"tool_call\", id: \"call_456\", name: \"search\", args: { query: \"test\" } }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletionsChunk(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  const blocks: Array<ContentBlock.Standard> = [];\n  if (typeof message.content === \"string\") {\n    blocks.push({\n      type: \"text\",\n      text: message.content,\n    });\n  } else {\n    blocks.push(...convertToV1FromChatCompletionsInput(message.content));\n  }\n\n  // TODO: parse chunk position information\n  for (const toolCall of message.tool_calls ?? []) {\n    blocks.push({\n      type: \"tool_call\",\n      id: toolCall.id,\n      name: toolCall.name,\n      args: toolCall.args,\n    });\n  }\n  return blocks;\n}\n\n/**\n * Converts an array of ChatOpenAICompletions content blocks to v1 standard content blocks.\n *\n * This function processes content blocks from OpenAI's Chat Completions API format\n * and converts them to the standardized v1 content block format. It handles both\n * OpenAI-specific data blocks (which require conversion) and standard blocks\n * (which are passed through with type assertion).\n *\n * @param blocks - Array of content blocks in ChatOpenAICompletions format\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const openaiBlocks = [\n *   { type: \"text\", text: \"Hello world\" },\n *   { type: \"image_url\", image_url: { url: \"https://example.com/image.png\" } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletionsInput(openaiBlocks);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello world\" },\n * //   { type: \"image\", url: \"https://example.com/image.png\" }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletionsInput(\n  blocks: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  const convertedBlocks: Array<ContentBlock.Standard> = [];\n  for (const block of blocks) {\n    if (isOpenAIDataBlock(block)) {\n      convertedBlocks.push(convertToV1FromOpenAIDataBlock(block));\n    } else {\n      convertedBlocks.push(block as ContentBlock.Standard);\n    }\n  }\n  return convertedBlocks;\n}\n\nfunction convertResponsesAnnotation(\n  annotation: ContentBlock\n): ContentBlock | ContentBlock.Citation {\n  if (annotation.type === \"url_citation\") {\n    const { url, title, start_index, end_index } = annotation;\n    return {\n      type: \"citation\",\n      url,\n      title,\n      startIndex: start_index,\n      endIndex: end_index,\n    };\n  }\n  if (annotation.type === \"file_citation\") {\n    const { file_id, filename, index } = annotation;\n    return {\n      type: \"citation\",\n      title: filename,\n      startIndex: index,\n      endIndex: index,\n      fileId: file_id,\n    };\n  }\n  return annotation;\n}\n\n/**\n * Converts a ChatOpenAIResponses message to an array of v1 standard content blocks.\n *\n * This function processes an AI message containing OpenAI Responses-specific content blocks\n * and converts them to the standardized v1 content block format. It handles reasoning summaries,\n * text content with annotations, tool calls, and various tool outputs including code interpreter,\n * web search, file search, computer calls, and MCP-related blocks.\n *\n * @param message - The AI message containing OpenAI Responses-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage({\n *   content: [{ type: \"text\", text: \"Hello world\", annotations: [] }],\n *   tool_calls: [{ id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } }],\n *   additional_kwargs: {\n *     reasoning: { summary: [{ text: \"Let me calculate this...\" }] },\n *     tool_outputs: [\n *       {\n *         type: \"code_interpreter_call\",\n *         code: \"print('hello')\",\n *         outputs: [{ type: \"logs\", logs: \"hello\" }]\n *       }\n *     ]\n *   }\n * });\n *\n * const standardBlocks = convertToV1FromResponses(message);\n * // Returns:\n * // [\n * //   { type: \"reasoning\", reasoning: \"Let me calculate this...\" },\n * //   { type: \"text\", text: \"Hello world\", annotations: [] },\n * //   { type: \"tool_call\", id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } },\n * //   { type: \"code_interpreter_call\", code: \"print('hello')\" },\n * //   { type: \"code_interpreter_result\", output: [{ type: \"code_interpreter_output\", returnCode: 0, stdout: \"hello\" }] }\n * // ]\n * ```\n */\nexport function convertToV1FromResponses(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    if (\n      _isObject(message.additional_kwargs?.reasoning) &&\n      _isArray(message.additional_kwargs.reasoning.summary)\n    ) {\n      const summary =\n        message.additional_kwargs.reasoning.summary.reduce<string>(\n          (acc, item) => {\n            if (_isObject(item) && _isString(item.text)) {\n              return `${acc}${item.text}`;\n            }\n            return acc;\n          },\n          \"\"\n        );\n      yield {\n        type: \"reasoning\",\n        reasoning: summary,\n      };\n    }\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"text\")) {\n        const { text, annotations, ...rest } = block;\n        if (Array.isArray(annotations)) {\n          yield {\n            ...rest,\n            type: \"text\",\n            text: String(text),\n            annotations: annotations.map(convertResponsesAnnotation),\n          };\n        } else {\n          yield {\n            ...rest,\n            type: \"text\",\n            text: String(text),\n          };\n        }\n      }\n    }\n    for (const toolCall of message.tool_calls ?? []) {\n      yield {\n        type: \"tool_call\",\n        id: toolCall.id,\n        name: toolCall.name,\n        args: toolCall.args,\n      };\n    }\n    if (\n      _isObject(message.additional_kwargs) &&\n      _isArray(message.additional_kwargs.tool_outputs)\n    ) {\n      for (const toolOutput of message.additional_kwargs.tool_outputs) {\n        if (_isContentBlock(toolOutput, \"web_search_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"web_search\",\n            args: { query: toolOutput.query },\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"file_search_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"file_search\",\n            args: { query: toolOutput.query },\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"computer_call\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"code_interpreter_call\")) {\n          if (_isString(toolOutput.code)) {\n            yield {\n              id: toolOutput.id,\n              type: \"server_tool_call\",\n              name: \"code_interpreter\",\n              args: { code: toolOutput.code },\n            };\n          }\n          if (_isArray(toolOutput.outputs)) {\n            const returnCode = iife(() => {\n              if (toolOutput.status === \"in_progress\") return undefined;\n              if (toolOutput.status === \"completed\") return 0;\n              if (toolOutput.status === \"incomplete\") return 127;\n              if (toolOutput.status === \"interpreting\") return undefined;\n              if (toolOutput.status === \"failed\") return 1;\n              return undefined;\n            });\n            for (const output of toolOutput.outputs) {\n              if (_isContentBlock(output, \"logs\")) {\n                yield {\n                  type: \"server_tool_call_result\",\n                  toolCallId: toolOutput.id ?? \"\",\n                  status: \"success\",\n                  output: {\n                    type: \"code_interpreter_output\",\n                    returnCode: returnCode ?? 0,\n                    stderr: [0, undefined].includes(returnCode)\n                      ? undefined\n                      : String(output.logs),\n                    stdout: [0, undefined].includes(returnCode)\n                      ? String(output.logs)\n                      : undefined,\n                  },\n                };\n                continue;\n              }\n            }\n          }\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"mcp_call\",\n            args: toolOutput.input,\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_list_tools\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"mcp_list_tools\",\n            args: toolOutput.input,\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_approval_request\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"image_generation_call\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        }\n        if (_isObject(toolOutput)) {\n          yield { type: \"non_standard\", value: toolOutput };\n        }\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\n/**\n * Converts a ChatOpenAIResponses message chunk to an array of v1 standard content blocks.\n *\n * This function processes an AI message chunk containing OpenAI-specific content blocks\n * and converts them to the standardized v1 content block format. It handles both the\n * regular message content and tool call chunks that are specific to streaming responses.\n *\n * @param message - The AI message chunk containing OpenAI-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const messageChunk = new AIMessageChunk({\n *   content: [{ type: \"text\", text: \"Hello\" }],\n *   tool_call_chunks: [\n *     { id: \"call_123\", name: \"calculator\", args: '{\"a\": 1' }\n *   ]\n * });\n *\n * const standardBlocks = convertToV1FromResponsesChunk(messageChunk);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello\" },\n * //   { type: \"tool_call_chunk\", id: \"call_123\", name: \"calculator\", args: '{\"a\": 1' }\n * // ]\n * ```\n */\nexport function convertToV1FromResponsesChunk(\n  message: AIMessageChunk\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    yield* convertToV1FromResponses(message);\n    for (const toolCallChunk of message.tool_call_chunks ?? []) {\n      yield {\n        type: \"tool_call_chunk\",\n        id: toolCallChunk.id,\n        name: toolCallChunk.name,\n        args: toolCallChunk.args,\n      };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatOpenAITranslator: StandardContentBlockTranslator = {\n  translateContent: (message) => {\n    if (typeof message.content === \"string\") {\n      return convertToV1FromChatCompletions(message);\n    }\n    return convertToV1FromResponses(message);\n  },\n  translateContentChunk: (message) => {\n    if (typeof message.content === \"string\") {\n      return convertToV1FromChatCompletionsChunk(message);\n    }\n    return convertToV1FromResponsesChunk(message);\n  },\n};\n"],"names":["message: AIMessage","blocks: Array<ContentBlock.Standard>","blocks: Array<ContentBlock>","convertedBlocks: Array<ContentBlock.Standard>","annotation: ContentBlock","message: AIMessageChunk","ChatOpenAITranslator: StandardContentBlockTranslator"],"mappings":"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"}},
    {"offset": {"line": 4440, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/format.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/format.ts"],"sourcesContent":["import { type BaseMessage } from \"./base.js\";\nimport { type AIMessage } from \"./ai.js\";\nimport { type ToolMessage } from \"./tool.js\";\n\nexport type MessageStringFormat = \"pretty\";\n\nexport function convertToFormattedString(\n  message: BaseMessage,\n  format: MessageStringFormat = \"pretty\"\n): string {\n  if (format === \"pretty\") return convertToPrettyString(message);\n  return JSON.stringify(message);\n}\n\nfunction convertToPrettyString(message: BaseMessage): string {\n  const lines: string[] = [];\n  const title = ` ${\n    message.type.charAt(0).toUpperCase() + message.type.slice(1)\n  } Message `;\n  const sepLen = Math.floor((80 - title.length) / 2);\n  const sep = \"=\".repeat(sepLen);\n  const secondSep = title.length % 2 === 0 ? sep : `${sep}=`;\n  lines.push(`${sep}${title}${secondSep}`);\n\n  // Add message type specific details\n  if (message.type === \"ai\") {\n    const aiMessage = message as AIMessage;\n    if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {\n      lines.push(\"Tool Calls:\");\n      for (const tc of aiMessage.tool_calls) {\n        lines.push(`  ${tc.name} (${tc.id})`);\n        lines.push(` Call ID: ${tc.id}`);\n        lines.push(\"  Args:\");\n        for (const [key, value] of Object.entries(tc.args)) {\n          lines.push(`    ${key}: ${value}`);\n        }\n      }\n    }\n  }\n  if (message.type === \"tool\") {\n    const toolMessage = message as ToolMessage;\n    if (toolMessage.name) {\n      lines.push(`Name: ${toolMessage.name}`);\n    }\n  }\n\n  // Add content if it's a string and not empty\n  if (typeof message.content === \"string\" && message.content.trim()) {\n    if (lines.length > 1) {\n      lines.push(\"\"); // blank line before content\n    }\n    lines.push(message.content);\n  }\n\n  return lines.join(\"\\n\");\n}\n"],"names":["message: BaseMessage","format: MessageStringFormat","lines: string[]"],"mappings":";;;;;AAMA,SAAgB,yBACdA,OAAAA,EACAC,SAA8B,QAAA,EACtB;IACR,IAAI,WAAW,SAAU,CAAA,OAAO,sBAAsB,QAAQ;IAC9D,OAAO,KAAK,SAAA,CAAU,QAAQ;AAC/B;AAED,SAAS,sBAAsBD,OAAAA,EAA8B;IAC3D,MAAME,QAAkB,CAAE,CAAA;IAC1B,MAAM,QAAQ,CAAC,CAAC,EACd,QAAQ,IAAA,CAAK,MAAA,CAAO,EAAE,CAAC,WAAA,EAAa,GAAG,QAAQ,IAAA,CAAK,KAAA,CAAM,EAAE,CAC7D,SAAS,CAAC;IACX,MAAM,SAAS,KAAK,KAAA,CAAA,CAAO,KAAK,MAAM,MAAA,IAAU,EAAE;IAClD,MAAM,MAAM,IAAI,MAAA,CAAO,OAAO;IAC9B,MAAM,YAAY,MAAM,MAAA,GAAS,MAAM,IAAI,MAAM,GAAG,IAAI,CAAC,CAAC;IAC1D,MAAM,IAAA,CAAK,GAAG,MAAM,QAAQ,WAAW,CAAC;IAGxC,IAAI,QAAQ,IAAA,KAAS,MAAM;QACzB,MAAM,YAAY;QAClB,IAAI,UAAU,UAAA,IAAc,UAAU,UAAA,CAAW,MAAA,GAAS,GAAG;YAC3D,MAAM,IAAA,CAAK,cAAc;YACzB,KAAK,MAAM,MAAM,UAAU,UAAA,CAAY;gBACrC,MAAM,IAAA,CAAK,CAAC,EAAE,EAAE,GAAG,IAAA,CAAK,EAAE,EAAE,GAAG,EAAA,CAAG,CAAC,CAAC,CAAC;gBACrC,MAAM,IAAA,CAAK,CAAC,UAAU,EAAE,GAAG,EAAA,EAAI,CAAC;gBAChC,MAAM,IAAA,CAAK,UAAU;gBACrB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAA,CAAQ,GAAG,IAAA,CAAK,CAChD,MAAM,IAAA,CAAK,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,OAAO,CAAC;YAErC;QACF;IACF;IACD,IAAI,QAAQ,IAAA,KAAS,QAAQ;QAC3B,MAAM,cAAc;QACpB,IAAI,YAAY,IAAA,EACd,MAAM,IAAA,CAAK,CAAC,MAAM,EAAE,YAAY,IAAA,EAAM,CAAC;IAE1C;IAGD,IAAI,OAAO,QAAQ,OAAA,KAAY,YAAY,QAAQ,OAAA,CAAQ,IAAA,EAAM,EAAE;QACjE,IAAI,MAAM,MAAA,GAAS,GACjB,MAAM,IAAA,CAAK,GAAG;QAEhB,MAAM,IAAA,CAAK,QAAQ,OAAA,CAAQ;IAC5B;IAED,OAAO,MAAM,IAAA,CAAK,KAAK;AACxB"}},
    {"offset": {"line": 4484, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/base.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/base.ts"],"sourcesContent":["import { Serializable, SerializedConstructor } from \"../load/serializable.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport { isDataContentBlock } from \"./content/data.js\";\nimport { convertToV1FromAnthropicInput } from \"./block_translators/anthropic.js\";\nimport { convertToV1FromDataContent } from \"./block_translators/data.js\";\nimport { convertToV1FromChatCompletionsInput } from \"./block_translators/openai.js\";\nimport {\n  $InferMessageContent,\n  $InferResponseMetadata,\n  MessageStructure,\n  MessageType,\n  isMessage,\n  Message,\n} from \"./message.js\";\nimport {\n  convertToFormattedString,\n  type MessageStringFormat,\n} from \"./format.js\";\n\n/** @internal */\nconst MESSAGE_SYMBOL = Symbol.for(\"langchain.message\");\n\nexport interface StoredMessageData {\n  content: string;\n  role: string | undefined;\n  name: string | undefined;\n  tool_call_id: string | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  additional_kwargs?: Record<string, any>;\n  /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response_metadata?: Record<string, any>;\n  id?: string;\n}\n\nexport interface StoredMessage {\n  type: string;\n  data: StoredMessageData;\n}\n\nexport interface StoredGeneration {\n  text: string;\n  message?: StoredMessage;\n}\n\nexport interface StoredMessageV1 {\n  type: string;\n  role: string | undefined;\n  text: string;\n}\n\nexport type MessageContent = string | Array<ContentBlock>;\n\nexport interface FunctionCall {\n  /**\n   * The arguments to call the function with, as generated by the model in JSON\n   * format. Note that the model does not always generate valid JSON, and may\n   * hallucinate parameters not defined by your function schema. Validate the\n   * arguments in your code before calling your function.\n   */\n  arguments: string;\n\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\nexport type BaseMessageFields<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType\n> = {\n  id?: string;\n  name?: string;\n  content?: $InferMessageContent<TStructure, TRole>;\n  contentBlocks?: Array<ContentBlock.Standard>;\n  /** @deprecated */\n  additional_kwargs?: {\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    function_call?: FunctionCall;\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    tool_calls?: OpenAIToolCall[];\n    [key: string]: unknown;\n  };\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n};\n\nexport function mergeContent(\n  firstContent: MessageContent,\n  secondContent: MessageContent\n): MessageContent {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (firstContent === \"\") {\n      return secondContent;\n    }\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else if (Array.isArray(secondContent) && secondContent.length === 0) {\n      return firstContent;\n    } else if (\n      Array.isArray(secondContent) &&\n      secondContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        {\n          type: \"text\",\n          source_type: \"text\",\n          text: firstContent,\n        },\n        ...secondContent,\n      ];\n    } else {\n      return [{ type: \"text\", text: firstContent }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return (\n      _mergeLists(firstContent, secondContent) ?? [\n        ...firstContent,\n        ...secondContent,\n      ]\n    );\n  } else {\n    if (secondContent === \"\") {\n      return firstContent;\n    } else if (\n      Array.isArray(firstContent) &&\n      firstContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        ...firstContent,\n        {\n          type: \"file\",\n          source_type: \"text\",\n          text: secondContent,\n        },\n      ];\n    } else {\n      return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n  }\n}\n\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nexport function _mergeStatus(\n  left?: \"success\" | \"error\",\n  right?: \"success\" | \"error\"\n): \"success\" | \"error\" | undefined {\n  if (left === \"error\" || right === \"error\") {\n    return \"error\";\n  }\n  return \"success\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj: any, depthLimit: number): string {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function helper(obj: any, currentDepth: number): any {\n    if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n      return obj;\n    }\n    if (currentDepth >= depthLimit) {\n      if (Array.isArray(obj)) {\n        return \"[Array]\";\n      }\n      return \"[Object]\";\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map((item) => helper(item, currentDepth + 1));\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const key of Object.keys(obj)) {\n      result[key] = helper(obj[key], currentDepth + 1);\n    }\n    return result;\n  }\n\n  return JSON.stringify(helper(obj, 0), null, 2);\n}\n\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport abstract class BaseMessage<\n    TStructure extends MessageStructure = MessageStructure,\n    TRole extends MessageType = MessageType\n  >\n  extends Serializable\n  implements Message<TStructure, TRole>\n{\n  lc_namespace = [\"langchain_core\", \"messages\"];\n\n  lc_serializable = true;\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\",\n      response_metadata: \"response_metadata\",\n    };\n  }\n\n  readonly [MESSAGE_SYMBOL] = true as const;\n\n  abstract readonly type: TRole;\n\n  id?: string;\n\n  name?: string;\n\n  content: $InferMessageContent<TStructure, TRole>;\n\n  additional_kwargs: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"additional_kwargs\"]\n  >;\n\n  response_metadata: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"response_metadata\"]\n  >;\n\n  /**\n   * @deprecated Use .getType() instead or import the proper typeguard.\n   * For example:\n   *\n   * ```ts\n   * import { isAIMessage } from \"@langchain/core/messages\";\n   *\n   * const message = new AIMessage(\"Hello!\");\n   * isAIMessage(message); // true\n   * ```\n   */\n  _getType(): MessageType {\n    return this.type;\n  }\n\n  /**\n   * @deprecated Use .type instead\n   * The type of the message.\n   */\n  getType(): MessageType {\n    return this._getType();\n  }\n\n  constructor(\n    arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>\n  ) {\n    const fields: BaseMessageFields<TStructure, TRole> =\n      typeof arg === \"string\" || Array.isArray(arg) ? { content: arg } : arg;\n    if (!fields.additional_kwargs) {\n      fields.additional_kwargs = {};\n    }\n    if (!fields.response_metadata) {\n      fields.response_metadata = {};\n    }\n    super(fields);\n    this.name = fields.name;\n    if (fields.content === undefined && fields.contentBlocks !== undefined) {\n      this.content = fields.contentBlocks as $InferMessageContent<\n        TStructure,\n        TRole\n      >;\n      this.response_metadata = {\n        output_version: \"v1\",\n        ...fields.response_metadata,\n      };\n    } else if (fields.content !== undefined) {\n      this.content = fields.content ?? [];\n      this.response_metadata = fields.response_metadata;\n    } else {\n      this.content = [] as $InferMessageContent<TStructure, TRole>;\n      this.response_metadata = fields.response_metadata;\n    }\n    this.additional_kwargs = fields.additional_kwargs;\n    this.id = fields.id;\n  }\n\n  /** Get text content of the message. */\n  get text(): string {\n    if (typeof this.content === \"string\") {\n      return this.content;\n    }\n    if (!Array.isArray(this.content)) return \"\";\n    return this.content\n      .map((c) => {\n        if (typeof c === \"string\") return c;\n        if (c.type === \"text\") return c.text;\n        return \"\";\n      })\n      .join(\"\");\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    const blocks: Array<ContentBlock> =\n      typeof this.content === \"string\"\n        ? [{ type: \"text\", text: this.content }]\n        : this.content;\n    const parsingSteps = [\n      convertToV1FromDataContent,\n      convertToV1FromChatCompletionsInput,\n      convertToV1FromAnthropicInput,\n    ];\n    const parsedBlocks = parsingSteps.reduce(\n      (blocks, step) => step(blocks),\n      blocks\n    );\n    return parsedBlocks as Array<ContentBlock.Standard>;\n  }\n\n  toDict(): StoredMessage {\n    return {\n      type: this.getType(),\n      data: (this.toJSON() as SerializedConstructor)\n        .kwargs as StoredMessageData,\n    };\n  }\n\n  static lc_name() {\n    return \"BaseMessage\";\n  }\n\n  // Can't be protected for silly reasons\n  get _printableFields(): Record<string, unknown> {\n    return {\n      id: this.id,\n      content: this.content,\n      name: this.name,\n      additional_kwargs: this.additional_kwargs,\n      response_metadata: this.response_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is BaseMessage {\n    return (\n      typeof obj === \"object\" &&\n      obj !== null &&\n      MESSAGE_SYMBOL in obj &&\n      obj[MESSAGE_SYMBOL] === true &&\n      isMessage(obj)\n    );\n  }\n\n  // this private method is used to update the ID for the runtime\n  // value as well as in lc_kwargs for serialisation\n  _updateId(value: string | undefined) {\n    this.id = value;\n\n    // lc_attributes wouldn't work here, because jest compares the\n    // whole object\n    this.lc_kwargs.id = value;\n  }\n\n  get [Symbol.toStringTag]() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.constructor as any).lc_name();\n  }\n\n  // Override the default behavior of console.log\n  [Symbol.for(\"nodejs.util.inspect.custom\")](depth: number | null) {\n    if (depth === null) {\n      return this;\n    }\n    const printable = stringifyWithDepthLimit(\n      this._printableFields,\n      Math.max(4, depth)\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return `${(this.constructor as any).lc_name()} ${printable}`;\n  }\n\n  toFormattedString(format: MessageStringFormat = \"pretty\"): string {\n    return convertToFormattedString(this, format);\n  }\n}\n\n/**\n * @deprecated Use \"tool_calls\" field on AIMessages instead\n */\nexport type OpenAIToolCall = {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The function that the model called.\n   */\n  function: FunctionCall;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: \"function\";\n\n  index?: number;\n};\n\nexport function isOpenAIToolCallArray(\n  value?: unknown\n): value is OpenAIToolCall[] {\n  return (\n    Array.isArray(value) &&\n    value.every((v) => typeof (v as OpenAIToolCall).index === \"number\")\n  );\n}\n\nexport function _mergeDicts(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  left: Record<string, any> = {},\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  right: Record<string, any> = {}\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> {\n  const merged = { ...left };\n  for (const [key, value] of Object.entries(right)) {\n    if (merged[key] == null) {\n      merged[key] = value;\n    } else if (value == null) {\n      continue;\n    } else if (\n      typeof merged[key] !== typeof value ||\n      Array.isArray(merged[key]) !== Array.isArray(value)\n    ) {\n      throw new Error(\n        `field[${key}] already exists in the message chunk, but with a different type.`\n      );\n    } else if (typeof merged[key] === \"string\") {\n      if (key === \"type\") {\n        // Do not merge 'type' fields\n        continue;\n      } else if (\n        [\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)\n      ) {\n        // Keep the incoming value for these fields\n        merged[key] = value;\n      } else {\n        merged[key] += value;\n      }\n    } else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n      merged[key] = _mergeDicts(merged[key], value);\n    } else if (Array.isArray(merged[key])) {\n      merged[key] = _mergeLists(merged[key], value);\n    } else if (merged[key] === value) {\n      continue;\n    } else {\n      console.warn(\n        `field[${key}] already exists in this message chunk and value has unsupported type.`\n      );\n    }\n  }\n  return merged;\n}\n\nexport function _mergeLists<Content extends ContentBlock>(\n  left?: Content[],\n  right?: Content[]\n): Content[] | undefined {\n  if (left === undefined && right === undefined) {\n    return undefined;\n  } else if (left === undefined || right === undefined) {\n    return left || right;\n  } else {\n    const merged = [...left];\n    for (const item of right) {\n      if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"index\" in item &&\n        typeof item.index === \"number\"\n      ) {\n        const toMerge = merged.findIndex((leftItem) => {\n          const isObject = typeof leftItem === \"object\";\n          const indiciesMatch =\n            \"index\" in leftItem && leftItem.index === item.index;\n          const idsMatch =\n            \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n          const eitherItemMissingID =\n            !(\"id\" in leftItem) ||\n            !leftItem?.id ||\n            !(\"id\" in item) ||\n            !item?.id;\n          return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n        });\n        if (\n          toMerge !== -1 &&\n          typeof merged[toMerge] === \"object\" &&\n          merged[toMerge] !== null\n        ) {\n          merged[toMerge] = _mergeDicts(\n            merged[toMerge] as Record<string, unknown>,\n            item as Record<string, unknown>\n          ) as Content;\n        } else {\n          merged.push(item);\n        }\n      } else if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"text\" in item &&\n        item.text === \"\"\n      ) {\n        // No-op - skip empty text blocks\n        continue;\n      } else {\n        merged.push(item);\n      }\n    }\n    return merged;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _mergeObj<T = any>(\n  left: T | undefined,\n  right: T | undefined\n): T {\n  if (!left && !right) {\n    throw new Error(\"Cannot merge two undefined objects.\");\n  }\n  if (!left || !right) {\n    return left || (right as T);\n  } else if (typeof left !== typeof right) {\n    throw new Error(\n      `Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`\n    );\n  } else if (typeof left === \"string\" && typeof right === \"string\") {\n    return (left + right) as T;\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    return _mergeLists(left, right) as T;\n  } else if (typeof left === \"object\" && typeof right === \"object\") {\n    return _mergeDicts(left, right) as T;\n  } else if (left === right) {\n    return left;\n  } else {\n    throw new Error(\n      `Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`\n    );\n  }\n}\n\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport abstract class BaseMessageChunk<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType\n> extends BaseMessage<TStructure, TRole> {\n  abstract concat(chunk: BaseMessageChunk): BaseMessageChunk<TStructure, TRole>;\n\n  static isInstance(obj: unknown): obj is BaseMessageChunk {\n    if (!super.isInstance(obj)) {\n      return false;\n    }\n    // Check if obj is an instance of BaseMessageChunk by traversing the prototype chain\n    let proto = Object.getPrototypeOf(obj);\n    while (proto !== null) {\n      if (proto === BaseMessageChunk.prototype) {\n        return true;\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n    return false;\n  }\n}\n\nexport type MessageFieldWithRole = {\n  role: MessageType;\n  content: MessageContent;\n  name?: string;\n} & Record<string, unknown>;\n\nexport function _isMessageFieldWithRole(\n  x: BaseMessageLike\n): x is MessageFieldWithRole {\n  return typeof (x as MessageFieldWithRole).role === \"string\";\n}\n\nexport type BaseMessageLike =\n  | BaseMessage\n  | MessageFieldWithRole\n  | [MessageType, MessageContent]\n  | string\n  /**\n   * @deprecated Specifying \"type\" is deprecated and will be removed in 0.4.0.\n   */\n  | ({\n      type: MessageType | \"user\" | \"assistant\" | \"placeholder\";\n    } & BaseMessageFields &\n      Record<string, unknown>)\n  | SerializedConstructor;\n\n/**\n * @deprecated Use {@link BaseMessage.isInstance} instead\n */\nexport function isBaseMessage(\n  messageLike?: unknown\n): messageLike is BaseMessage {\n  return typeof (messageLike as BaseMessage)?._getType === \"function\";\n}\n\n/**\n * @deprecated Use {@link BaseMessageChunk.isInstance} instead\n */\nexport function isBaseMessageChunk(\n  messageLike?: unknown\n): messageLike is BaseMessageChunk {\n  return BaseMessageChunk.isInstance(messageLike);\n}\n"],"names":["firstContent: MessageContent","secondContent: MessageContent","left?: \"success\" | \"error\"","right?: \"success\" | \"error\"","obj: any","depthLimit: number","currentDepth: number","obj","result: Record<string, unknown>","arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>","fields: BaseMessageFields<TStructure, TRole>","blocks: Array<ContentBlock>","blocks","obj: unknown","value: string | undefined","depth: number | null","format: MessageStringFormat","value?: unknown","left: Record<string, any>","right: Record<string, any>","left?: Content[]","right?: Content[]","left: T | undefined","right: T | undefined","x: BaseMessageLike","messageLike?: unknown"],"mappings":"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"}},
    {"offset": {"line": 4808, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/metadata.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/metadata.ts"],"sourcesContent":["import { _mergeDicts } from \"./base.js\";\nimport type { MessageOutputVersion } from \"./message.js\";\n\nexport type ResponseMetadata = {\n  model_provider?: string;\n  model_name?: string;\n  output_version?: MessageOutputVersion;\n  [key: string]: unknown;\n};\n\nexport function mergeResponseMetadata(\n  a?: ResponseMetadata,\n  b?: ResponseMetadata\n): ResponseMetadata {\n  const output: ResponseMetadata = _mergeDicts(a ?? {}, b ?? {});\n  return output;\n}\n\nexport type ModalitiesTokenDetails = {\n  /**\n   * Text tokens.\n   * Does not need to be reported, but some models will do so.\n   */\n  text?: number;\n\n  /**\n   * Image (non-video) tokens.\n   */\n  image?: number;\n\n  /**\n   * Audio tokens.\n   */\n  audio?: number;\n\n  /**\n   * Video tokens.\n   */\n  video?: number;\n\n  /**\n   * Document tokens.\n   * e.g. PDF\n   */\n  document?: number;\n};\n\nfunction mergeModalitiesTokenDetails(\n  a?: ModalitiesTokenDetails,\n  b?: ModalitiesTokenDetails\n): ModalitiesTokenDetails {\n  const output: ModalitiesTokenDetails = {};\n  if (a?.audio !== undefined || b?.audio !== undefined) {\n    output.audio = (a?.audio ?? 0) + (b?.audio ?? 0);\n  }\n  if (a?.image !== undefined || b?.image !== undefined) {\n    output.image = (a?.image ?? 0) + (b?.image ?? 0);\n  }\n  if (a?.video !== undefined || b?.video !== undefined) {\n    output.video = (a?.video ?? 0) + (b?.video ?? 0);\n  }\n  if (a?.document !== undefined || b?.document !== undefined) {\n    output.document = (a?.document ?? 0) + (b?.document ?? 0);\n  }\n  if (a?.text !== undefined || b?.text !== undefined) {\n    output.text = (a?.text ?? 0) + (b?.text ?? 0);\n  }\n  return output;\n}\n\n/**\n * Breakdown of input token counts.\n *\n * Does not *need* to sum to full input token count. Does *not* need to have all keys.\n */\nexport type InputTokenDetails = ModalitiesTokenDetails & {\n  /**\n   * Input tokens that were cached and there was a cache hit.\n   *\n   * Since there was a cache hit, the tokens were read from the cache.\n   * More precisely, the model state given these tokens was read from the cache.\n   */\n  cache_read?: number;\n\n  /**\n   * Input tokens that were cached and there was a cache miss.\n   *\n   * Since there was a cache miss, the cache was created from these tokens.\n   */\n  cache_creation?: number;\n};\n\nfunction mergeInputTokenDetails(\n  a?: InputTokenDetails,\n  b?: InputTokenDetails\n): InputTokenDetails {\n  const output: InputTokenDetails = {\n    ...mergeModalitiesTokenDetails(a, b),\n  };\n  if (a?.cache_read !== undefined || b?.cache_read !== undefined) {\n    output.cache_read = (a?.cache_read ?? 0) + (b?.cache_read ?? 0);\n  }\n  if (a?.cache_creation !== undefined || b?.cache_creation !== undefined) {\n    output.cache_creation = (a?.cache_creation ?? 0) + (b?.cache_creation ?? 0);\n  }\n  return output;\n}\n\n/**\n * Breakdown of output token counts.\n *\n * Does *not* need to sum to full output token count. Does *not* need to have all keys.\n */\nexport type OutputTokenDetails = ModalitiesTokenDetails & {\n  /**\n   * Reasoning output tokens.\n   *\n   * Tokens generated by the model in a chain of thought process (i.e. by\n   * OpenAI's o1 models) that are not returned as part of model output.\n   */\n  reasoning?: number;\n};\n\nfunction mergeOutputTokenDetails(\n  a?: OutputTokenDetails,\n  b?: OutputTokenDetails\n): OutputTokenDetails {\n  const output: OutputTokenDetails = {\n    ...mergeModalitiesTokenDetails(a, b),\n  };\n  if (a?.reasoning !== undefined || b?.reasoning !== undefined) {\n    output.reasoning = (a?.reasoning ?? 0) + (b?.reasoning ?? 0);\n  }\n  return output;\n}\n\n/**\n * Usage metadata for a message, such as token counts.\n */\nexport type UsageMetadata = {\n  /**\n   * Count of input (or prompt) tokens. Sum of all input token types.\n   */\n  input_tokens: number;\n  /**\n   * Count of output (or completion) tokens. Sum of all output token types.\n   */\n  output_tokens: number;\n  /**\n   * Total token count. Sum of input_tokens + output_tokens.\n   */\n  total_tokens: number;\n\n  /**\n   * Breakdown of input token counts.\n   *\n   * Does *not* need to sum to full input token count. Does *not* need to have all keys.\n   */\n  input_token_details?: InputTokenDetails;\n\n  /**\n   * Breakdown of output token counts.\n   *\n   * Does *not* need to sum to full output token count. Does *not* need to have all keys.\n   */\n  output_token_details?: OutputTokenDetails;\n};\n\nexport function mergeUsageMetadata(\n  a?: UsageMetadata,\n  b?: UsageMetadata\n): UsageMetadata {\n  return {\n    input_tokens: (a?.input_tokens ?? 0) + (b?.input_tokens ?? 0),\n    output_tokens: (a?.output_tokens ?? 0) + (b?.output_tokens ?? 0),\n    total_tokens: (a?.total_tokens ?? 0) + (b?.total_tokens ?? 0),\n    input_token_details: mergeInputTokenDetails(\n      a?.input_token_details,\n      b?.input_token_details\n    ),\n    output_token_details: mergeOutputTokenDetails(\n      a?.output_token_details,\n      b?.output_token_details\n    ),\n  };\n}\n"],"names":["a?: ResponseMetadata","b?: ResponseMetadata","output: ResponseMetadata","a?: ModalitiesTokenDetails","b?: ModalitiesTokenDetails","output: ModalitiesTokenDetails","a?: InputTokenDetails","b?: InputTokenDetails","output: InputTokenDetails","a?: OutputTokenDetails","b?: OutputTokenDetails","output: OutputTokenDetails","a?: UsageMetadata","b?: UsageMetadata"],"mappings":";;;;;;;;;AAUA,SAAgB,sBACdA,CAAAA,EACAC,CAAAA,EACkB;IAClB,MAAMC,aAA2B,gLAAA,EAAY,KAAK,CAAE,GAAE,KAAK,CAAE,EAAC;IAC9D,OAAO;AACR;AA+BD,SAAS,4BACPC,CAAAA,EACAC,CAAAA,EACwB;IACxB,MAAMC,SAAiC,CAAE;IACzC,IAAI,GAAG,UAAU,KAAA,KAAa,GAAG,UAAU,KAAA,GACzC,OAAO,KAAA,GAAA,CAAS,GAAG,SAAS,CAAA,IAAA,CAAM,GAAG,SAAS,CAAA;IAEhD,IAAI,GAAG,UAAU,KAAA,KAAa,GAAG,UAAU,KAAA,GACzC,OAAO,KAAA,GAAA,CAAS,GAAG,SAAS,CAAA,IAAA,CAAM,GAAG,SAAS,CAAA;IAEhD,IAAI,GAAG,UAAU,KAAA,KAAa,GAAG,UAAU,KAAA,GACzC,OAAO,KAAA,GAAA,CAAS,GAAG,SAAS,CAAA,IAAA,CAAM,GAAG,SAAS,CAAA;IAEhD,IAAI,GAAG,aAAa,KAAA,KAAa,GAAG,aAAa,KAAA,GAC/C,OAAO,QAAA,GAAA,CAAY,GAAG,YAAY,CAAA,IAAA,CAAM,GAAG,YAAY,CAAA;IAEzD,IAAI,GAAG,SAAS,KAAA,KAAa,GAAG,SAAS,KAAA,GACvC,OAAO,IAAA,GAAA,CAAQ,GAAG,QAAQ,CAAA,IAAA,CAAM,GAAG,QAAQ,CAAA;IAE7C,OAAO;AACR;AAwBD,SAAS,uBACPC,CAAAA,EACAC,CAAAA,EACmB;IACnB,MAAMC,SAA4B;QAChC,GAAG,4BAA4B,GAAG,EAAE;IACrC;IACD,IAAI,GAAG,eAAe,KAAA,KAAa,GAAG,eAAe,KAAA,GACnD,OAAO,UAAA,GAAA,CAAc,GAAG,cAAc,CAAA,IAAA,CAAM,GAAG,cAAc,CAAA;IAE/D,IAAI,GAAG,mBAAmB,KAAA,KAAa,GAAG,mBAAmB,KAAA,GAC3D,OAAO,cAAA,GAAA,CAAkB,GAAG,kBAAkB,CAAA,IAAA,CAAM,GAAG,kBAAkB,CAAA;IAE3E,OAAO;AACR;AAiBD,SAAS,wBACPC,CAAAA,EACAC,CAAAA,EACoB;IACpB,MAAMC,SAA6B;QACjC,GAAG,4BAA4B,GAAG,EAAE;IACrC;IACD,IAAI,GAAG,cAAc,KAAA,KAAa,GAAG,cAAc,KAAA,GACjD,OAAO,SAAA,GAAA,CAAa,GAAG,aAAa,CAAA,IAAA,CAAM,GAAG,aAAa,CAAA;IAE5D,OAAO;AACR;AAkCD,SAAgB,mBACdC,CAAAA,EACAC,CAAAA,EACe;IACf,OAAO;QACL,cAAA,CAAe,GAAG,gBAAgB,CAAA,IAAA,CAAM,GAAG,gBAAgB,CAAA;QAC3D,eAAA,CAAgB,GAAG,iBAAiB,CAAA,IAAA,CAAM,GAAG,iBAAiB,CAAA;QAC9D,cAAA,CAAe,GAAG,gBAAgB,CAAA,IAAA,CAAM,GAAG,gBAAgB,CAAA;QAC3D,qBAAqB,uBACnB,GAAG,qBACH,GAAG,oBACJ;QACD,sBAAsB,wBACpB,GAAG,sBACH,GAAG,qBACJ;IACF;AACF"}},
    {"offset": {"line": 4860, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/tool.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/tool.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n  _mergeObj,\n  _mergeStatus,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface ToolMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"tool\"> {\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n  tool_call_id: string;\n  status?: \"success\" | \"error\";\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Marker parameter for objects that tools can return directly.\n *\n * If a custom BaseTool is invoked with a ToolCall and the output of custom code is\n * not an instance of DirectToolOutput, the output will automatically be coerced to\n * a string and wrapped in a ToolMessage.\n */\nexport interface DirectToolOutput {\n  readonly lc_direct_tool_output: true;\n}\n\nexport function isDirectToolOutput(x: unknown): x is DirectToolOutput {\n  return (\n    x != null &&\n    typeof x === \"object\" &&\n    \"lc_direct_tool_output\" in x &&\n    x.lc_direct_tool_output === true\n  );\n}\n\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"tool\">\n  implements DirectToolOutput\n{\n  static lc_name() {\n    return \"ToolMessage\";\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return { tool_call_id: \"tool_call_id\" };\n  }\n\n  lc_direct_tool_output = true as const;\n\n  readonly type = \"tool\" as const;\n\n  /**\n   * Status of the tool invocation.\n   * @version 0.2.19\n   */\n  status?: \"success\" | \"error\";\n\n  tool_call_id: string;\n\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"tool\"> | ToolMessageFields,\n    tool_call_id: string,\n    name?: string\n  );\n\n  constructor(fields: ToolMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"tool\">\n      | ToolMessageFields<TStructure>,\n    tool_call_id?: string,\n    name?: string\n  ) {\n    const toolMessageFields: ToolMessageFields<TStructure> =\n      typeof fields === \"string\" || Array.isArray(fields)\n        ? { content: fields, name, tool_call_id: tool_call_id! }\n        : fields;\n    super(toolMessageFields);\n    this.tool_call_id = toolMessageFields.tool_call_id;\n    this.artifact = toolMessageFields.artifact;\n    this.status = toolMessageFields.status;\n    this.metadata = toolMessageFields.metadata;\n  }\n\n  static isInstance(message: unknown): message is ToolMessage {\n    return super.isInstance(message) && message.type === \"tool\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_call_id: this.tool_call_id,\n      artifact: this.artifact,\n    };\n  }\n}\n\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"tool\"> {\n  readonly type = \"tool\" as const;\n\n  tool_call_id: string;\n\n  /**\n   * Status of the tool invocation.\n   * @version 0.2.19\n   */\n  status?: \"success\" | \"error\";\n\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n\n  constructor(fields: ToolMessageFields<TStructure>) {\n    super(fields);\n    this.tool_call_id = fields.tool_call_id;\n    this.artifact = fields.artifact;\n    this.status = fields.status;\n  }\n\n  static lc_name() {\n    return \"ToolMessageChunk\";\n  }\n\n  concat(chunk: ToolMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      artifact: _mergeObj(this.artifact, chunk.artifact),\n      tool_call_id: this.tool_call_id,\n      id: this.id ?? chunk.id,\n      status: _mergeStatus(this.status, chunk.status),\n    });\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_call_id: this.tool_call_id,\n      artifact: this.artifact,\n    };\n  }\n}\n\nexport interface ToolCall<\n  TName extends string = string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  TArgs extends Record<string, any> = Record<string, any>\n> {\n  readonly type?: \"tool_call\";\n  /**\n   * If provided, an identifier associated with the tool call\n   */\n  id?: string;\n  /**\n   * The name of the tool being called\n   */\n  name: TName;\n  /**\n   * The arguments to the tool call\n   */\n  args: TArgs;\n}\n\n/**\n * A chunk of a tool call (e.g., as part of a stream).\n * When merging ToolCallChunks (e.g., via AIMessageChunk.__add__),\n * all string attributes are concatenated. Chunks are only merged if their\n * values of `index` are equal and not None.\n *\n * @example\n * ```ts\n * const leftChunks = [\n *   {\n *     name: \"foo\",\n *     args: '{\"a\":',\n *     index: 0\n *   }\n * ];\n *\n * const leftAIMessageChunk = new AIMessageChunk({\n *   content: \"\",\n *   tool_call_chunks: leftChunks\n * });\n *\n * const rightChunks = [\n *   {\n *     name: undefined,\n *     args: '1}',\n *     index: 0\n *   }\n * ];\n *\n * const rightAIMessageChunk = new AIMessageChunk({\n *   content: \"\",\n *   tool_call_chunks: rightChunks\n * });\n *\n * const result = leftAIMessageChunk.concat(rightAIMessageChunk);\n * // result.tool_call_chunks is equal to:\n * // [\n * //   {\n * //     name: \"foo\",\n * //     args: '{\"a\":1}'\n * //     index: 0\n * //   }\n * // ]\n * ```\n */\nexport interface ToolCallChunk<TName extends string = string> {\n  readonly type?: \"tool_call_chunk\";\n  /**\n   * If provided, a substring of an identifier for the tool call\n   */\n  id?: string;\n  /**\n   * If provided, a substring of the name of the tool to be called\n   */\n  name?: TName;\n  /**\n   * If provided, a JSON substring of the arguments to the tool call\n   */\n  args?: string;\n  /**\n   * If provided, the index of the tool call in a sequence\n   */\n  index?: number;\n}\n\nexport interface InvalidToolCall<TName extends string = string> {\n  readonly type?: \"invalid_tool_call\";\n  /**\n   * If provided, an identifier associated with the tool call\n   */\n  id?: string;\n  /**\n      /**\n     * The name of the tool being called\n     */\n  name?: TName;\n  /**\n   * The arguments to the tool call\n   */\n  args?: string;\n  /**\n   * An error message associated with the tool call\n   */\n  error?: string;\n  /**\n   * Index of block in aggregate response\n   */\n  index?: string | number;\n}\n\nexport function defaultToolCallParser(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCalls: Record<string, any>[]\n): [ToolCall[], InvalidToolCall[]] {\n  const toolCalls: ToolCall[] = [];\n  const invalidToolCalls: InvalidToolCall[] = [];\n  for (const toolCall of rawToolCalls) {\n    if (!toolCall.function) {\n      continue;\n    } else {\n      const functionName = toolCall.function.name;\n      try {\n        const functionArgs = JSON.parse(toolCall.function.arguments);\n        toolCalls.push({\n          name: functionName || \"\",\n          args: functionArgs || {},\n          id: toolCall.id,\n        });\n      } catch {\n        invalidToolCalls.push({\n          name: functionName,\n          args: toolCall.function.arguments,\n          id: toolCall.id,\n          error: \"Malformed args.\",\n        });\n      }\n    }\n  }\n  return [toolCalls, invalidToolCalls];\n}\n\n/**\n * @deprecated Use {@link ToolMessage.isInstance} instead\n */\nexport function isToolMessage(x: unknown): x is ToolMessage {\n  return (\n    typeof x === \"object\" &&\n    x !== null &&\n    \"getType\" in x &&\n    typeof x.getType === \"function\" &&\n    x.getType() === \"tool\"\n  );\n}\n\n/**\n * @deprecated Use {@link ToolMessageChunk.isInstance} instead\n */\nexport function isToolMessageChunk(x: BaseMessageChunk): x is ToolMessageChunk {\n  return x._getType() === \"tool\";\n}\n"],"names":["x: unknown","fields:\n      | $InferMessageContent<TStructure, \"tool\">\n      | ToolMessageFields<TStructure>","tool_call_id?: string","name?: string","toolMessageFields: ToolMessageFields<TStructure>","message: unknown","fields: ToolMessageFields<TStructure>","chunk: ToolMessageChunk<TStructure>","rawToolCalls: Record<string, any>[]","toolCalls: ToolCall[]","invalidToolCalls: InvalidToolCall[]","x: BaseMessageChunk"],"mappings":"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"}},
    {"offset": {"line": 5031, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/bedrock_converse.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/bedrock_converse.ts"],"sourcesContent":["import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport { KNOWN_BLOCK_TYPES } from \"../content/tools.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport {\n  _isArray,\n  _isBytesArray,\n  _isContentBlock,\n  _isNumber,\n  _isObject,\n  _isString,\n  iife,\n} from \"./utils.js\";\n\n// see `/libs/providers/langchain-aws/src/utils/compat.ts:convertFileFormatToMimeType`\nfunction convertFileFormatToMimeType(format: string): string {\n  switch (format) {\n    // DocumentBlock\n    case \"csv\":\n      return \"text/csv\";\n    case \"doc\":\n      return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n    case \"docx\":\n      return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n    case \"html\":\n      return \"text/html\";\n    case \"md\":\n      return \"text/markdown\";\n    case \"pdf\":\n      return \"application/pdf\";\n    case \"txt\":\n      return \"text/plain\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    // ImageBlock\n    case \"gif\":\n      return \"image/gif\";\n    case \"jpeg\":\n      return \"image/jpeg\";\n    case \"jpg\":\n      return \"image/jpeg\";\n    case \"png\":\n      return \"image/png\";\n    case \"webp\":\n      return \"image/webp\";\n    // VideoBlock\n    case \"flv\":\n      return \"video/flv\";\n    case \"mkv\":\n      return \"video/mkv\";\n    case \"mov\":\n      return \"video/mov\";\n    case \"mp4\":\n      return \"video/mp4\";\n    case \"mpeg\":\n      return \"video/mpeg\";\n    case \"mpg\":\n      return \"video/mpg\";\n    case \"three_gp\":\n      return \"video/three_gp\";\n    case \"webm\":\n      return \"video/webm\";\n    case \"wmv\":\n      return \"video/wmv\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\n\nfunction convertConverseDocumentBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (_isObject(block.document) && _isObject(block.document.source)) {\n    const format =\n      _isObject(block.document) && _isString(block.document.format)\n        ? block.document.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.document.source)) {\n      if (\n        _isObject(block.document.source.s3Location) &&\n        _isString(block.document.source.s3Location.uri)\n      ) {\n        return {\n          type: \"file\",\n          mimeType,\n          fileId: block.document.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.document.source.bytes)) {\n        return {\n          type: \"file\",\n          mimeType,\n          data: block.document.source.bytes,\n        };\n      }\n      if (_isString(block.document.source.text)) {\n        return {\n          type: \"file\",\n          mimeType,\n          data: Buffer.from(block.document.source.text).toString(\"base64\"),\n        };\n      }\n      if (_isArray(block.document.source.content)) {\n        const data = block.document.source.content.reduce(\n          (acc: string, item) => {\n            if (_isObject(item) && _isString(item.text)) {\n              return acc + item.text;\n            }\n            return acc;\n          },\n          \"\"\n        );\n        return {\n          type: \"file\",\n          mimeType,\n          data,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nfunction convertConverseImageBlock(block: ContentBlock): ContentBlock.Standard {\n  if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n    const format =\n      _isObject(block.image) && _isString(block.image.format)\n        ? block.image.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.image.source)) {\n      if (\n        _isObject(block.image.source.s3Location) &&\n        _isString(block.image.source.s3Location.uri)\n      ) {\n        return {\n          type: \"image\",\n          mimeType,\n          fileId: block.image.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.image.source.bytes)) {\n        return {\n          type: \"image\",\n          mimeType,\n          data: block.image.source.bytes,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nfunction convertConverseVideoBlock(block: ContentBlock): ContentBlock.Standard {\n  if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n    const format =\n      _isObject(block.video) && _isString(block.video.format)\n        ? block.video.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.video.source)) {\n      if (\n        _isObject(block.video.source.s3Location) &&\n        _isString(block.video.source.s3Location.uri)\n      ) {\n        return {\n          type: \"video\",\n          mimeType,\n          fileId: block.video.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.video.source.bytes)) {\n        return {\n          type: \"video\",\n          mimeType,\n          data: block.video.source.bytes,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nexport function convertToV1FromChatBedrockConverseInput(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    const blocks = content.map((block) => {\n      if (_isContentBlock(block, \"non_standard\") && \"value\" in block) {\n        return block.value as ContentBlock;\n      }\n      return block;\n    });\n    for (const block of blocks) {\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (\n        _isContentBlock(block, \"document\") &&\n        _isObject(block.document)\n      ) {\n        yield convertConverseDocumentBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n        yield convertConverseImageBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n        yield convertConverseVideoBlock(block);\n        continue;\n      }\n      if (KNOWN_BLOCK_TYPES.includes(block.type)) {\n        yield block as ContentBlock.Standard;\n      } else {\n        yield { type: \"non_standard\", value: block };\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nfunction convertToV1FromChatBedrockConverseMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `/libs/providers/langchain-aws/src/utils/message_outputs.ts:convertConverseMessageToLangChainMessage`\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"cache_point\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (\n        _isContentBlock(block, \"citations_content\") &&\n        _isObject(block.citationsContent)\n      ) {\n        const text = _isArray(block.citationsContent.content)\n          ? block.citationsContent.content.reduce((acc: string, item) => {\n              if (_isObject(item) && _isString(item.text)) {\n                return acc + item.text;\n              }\n              return acc;\n            }, \"\")\n          : \"\";\n        const annotations = _isArray(block.citationsContent.citations)\n          ? block.citationsContent.citations.reduce(\n              (acc: Array<ContentBlock.Citation>, item) => {\n                if (_isObject(item)) {\n                  const citedText = _isArray(item.sourceContent)\n                    ? item.sourceContent.reduce((acc: string, item) => {\n                        if (_isObject(item) && _isString(item.text)) {\n                          return acc + item.text;\n                        }\n                        return acc;\n                      }, \"\")\n                    : \"\";\n                  const properties = iife(() => {\n                    if (_isObject(item.location)) {\n                      const location =\n                        item.location.documentChar ||\n                        item.location.documentPage ||\n                        item.location.documentChunk;\n                      if (_isObject(location)) {\n                        return {\n                          source: _isNumber(location.documentIndex)\n                            ? location.documentIndex.toString()\n                            : undefined,\n                          startIndex: _isNumber(location.start)\n                            ? location.start\n                            : undefined,\n                          endIndex: _isNumber(location.end)\n                            ? location.end\n                            : undefined,\n                        };\n                      }\n                    }\n                    return {};\n                  });\n                  acc.push({ type: \"citation\", citedText, ...properties });\n                }\n                return acc;\n              },\n              []\n            )\n          : [];\n        yield { type: \"text\", text, annotations };\n        continue;\n      } else if (\n        _isContentBlock(block, \"document\") &&\n        _isObject(block.document)\n      ) {\n        yield convertConverseDocumentBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"guard_content\")) {\n        yield {\n          type: \"non_standard\",\n          value: block,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n        yield convertConverseImageBlock(block);\n        continue;\n      } else if (\n        _isContentBlock(block, \"reasoning_content\") &&\n        _isString(block.reasoningText)\n      ) {\n        yield {\n          type: \"reasoning\",\n          reasoning: block.reasoningText,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (_isContentBlock(block, \"tool_result\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (_isContentBlock(block, \"tool_call\")) {\n        // no-op - filtered to tools\n        continue;\n      } else if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n        yield convertConverseVideoBlock(block);\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatBedrockConverseTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatBedrockConverseMessage,\n  translateContentChunk: convertToV1FromChatBedrockConverseMessage,\n};\n"],"names":["format: string","block: ContentBlock","acc: string","message: AIMessage","acc: Array<ContentBlock.Citation>","item","acc","ChatBedrockConverseTranslator: StandardContentBlockTranslator"],"mappings":"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"}},
    {"offset": {"line": 5276, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/google_genai.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/google_genai.ts"],"sourcesContent":["import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { _isContentBlock, _isObject, _isString } from \"./utils.js\";\n\nfunction convertToV1FromChatGoogleMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `libs/providers/langchain-google-genai/src/utils/common.ts:mapGenerateContentResultToChatResult\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (\n        _isContentBlock(block, \"inlineData\") &&\n        _isObject(block.inlineData) &&\n        _isString(block.inlineData.mimeType) &&\n        _isString(block.inlineData.data)\n      ) {\n        yield {\n          type: \"file\",\n          mimeType: block.inlineData.mimeType,\n          data: block.inlineData.data,\n        };\n        continue;\n      } else if (\n        _isContentBlock(block, \"functionCall\") &&\n        _isObject(block.functionCall) &&\n        _isString(block.functionCall.name) &&\n        _isObject(block.functionCall.args)\n      ) {\n        yield {\n          type: \"tool_call\",\n          id: message.id,\n          name: block.functionCall.name,\n          args: block.functionCall.args,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"functionResponse\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (\n        _isContentBlock(block, \"fileData\") &&\n        _isObject(block.fileData) &&\n        _isString(block.fileData.mimeType) &&\n        _isString(block.fileData.fileUri)\n      ) {\n        yield {\n          type: \"file\",\n          mimeType: block.fileData.mimeType,\n          fileId: block.fileData.fileUri,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"executableCode\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (_isContentBlock(block, \"codeExecutionResult\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatGoogleGenAITranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatGoogleMessage,\n  translateContentChunk: convertToV1FromChatGoogleMessage,\n};\n"],"names":["message: AIMessage","ChatGoogleGenAITranslator: StandardContentBlockTranslator"],"mappings":";;;;;;;AAKA,SAAS,iCACPA,OAAAA,EAC8B;IAE9B,UAAU,iBAAkD;QAC1D,MAAM,UACJ,OAAO,QAAQ,OAAA,KAAY,WACvB;YAAC;gBAAE,MAAM;gBAAQ,MAAM,QAAQ,OAAA;YAAS,CAAC;SAAA,GACzC,QAAQ,OAAA;QACd,KAAK,MAAM,SAAS,QAAS;YAC3B,QAAI,0MAAA,EAAgB,OAAO,OAAO,QAAI,oMAAA,EAAU,MAAM,IAAA,CAAK,EAAE;gBAC3D,MAAM;oBAAE,MAAM;oBAAQ,MAAM,MAAM,IAAA;gBAAM;gBACxC;YACD,OAAA,QACC,0MAAA,EAAgB,OAAO,aAAa,QACpC,oMAAA,EAAU,MAAM,UAAA,CAAW,QAC3B,oMAAA,EAAU,MAAM,UAAA,CAAW,QAAA,CAAS,QACpC,oMAAA,EAAU,MAAM,UAAA,CAAW,IAAA,CAAK,EAChC;gBACA,MAAM;oBACJ,MAAM;oBACN,UAAU,MAAM,UAAA,CAAW,QAAA;oBAC3B,MAAM,MAAM,UAAA,CAAW,IAAA;gBACxB;gBACD;YACD,OAAA,QACC,0MAAA,EAAgB,OAAO,eAAe,QACtC,oMAAA,EAAU,MAAM,YAAA,CAAa,QAC7B,oMAAA,EAAU,MAAM,YAAA,CAAa,IAAA,CAAK,QAClC,oMAAA,EAAU,MAAM,YAAA,CAAa,IAAA,CAAK,EAClC;gBACA,MAAM;oBACJ,MAAM;oBACN,IAAI,QAAQ,EAAA;oBACZ,MAAM,MAAM,YAAA,CAAa,IAAA;oBACzB,MAAM,MAAM,YAAA,CAAa,IAAA;gBAC1B;gBACD;YACD,OAAA,QAAU,0MAAA,EAAgB,OAAO,mBAAmB,EAAE;gBACrD,MAAM;oBAAE,MAAM;oBAAgB,OAAO;gBAAO;gBAC5C;YACD,OAAA,QACC,0MAAA,EAAgB,OAAO,WAAW,QAClC,oMAAA,EAAU,MAAM,QAAA,CAAS,QACzB,oMAAA,EAAU,MAAM,QAAA,CAAS,QAAA,CAAS,QAClC,oMAAA,EAAU,MAAM,QAAA,CAAS,OAAA,CAAQ,EACjC;gBACA,MAAM;oBACJ,MAAM;oBACN,UAAU,MAAM,QAAA,CAAS,QAAA;oBACzB,QAAQ,MAAM,QAAA,CAAS,OAAA;gBACxB;gBACD;YACD,OAAA,QAAU,0MAAA,EAAgB,OAAO,iBAAiB,EAAE;gBACnD,MAAM;oBAAE,MAAM;oBAAgB,OAAO;gBAAO;gBAC5C;YACD,OAAA,QAAU,0MAAA,EAAgB,OAAO,sBAAsB,EAAE;gBACxD,MAAM;oBAAE,MAAM;oBAAgB,OAAO;gBAAO;gBAC5C;YACD;YACD,MAAM;gBAAE,MAAM;gBAAgB,OAAO;YAAO;QAC7C;IACF;IACD,OAAO,MAAM,IAAA,CAAK,gBAAgB,CAAC;AACpC;AAED,MAAaC,4BAA4D;IACvE,kBAAkB;IAClB,uBAAuB;AACxB"}},
    {"offset": {"line": 5357, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/google_vertexai.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/google_vertexai.ts"],"sourcesContent":["import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { _isArray, _isContentBlock, _isString, iife } from \"./utils.js\";\n\nfunction convertToV1FromChatVertexMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `/libs/providers/langchain-google-common/src/utils/gemini.ts:partsToMessageContent`\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"reasoning\") && _isString(block.reasoning)) {\n        const signature = iife(() => {\n          const reasoningIndex = content.indexOf(block);\n          if (\n            _isArray(message.additional_kwargs?.signatures) &&\n            reasoningIndex >= 0\n          ) {\n            return message.additional_kwargs.signatures.at(reasoningIndex);\n          }\n          return undefined;\n        });\n        if (_isString(signature)) {\n          yield {\n            type: \"reasoning\",\n            reasoning: block.reasoning,\n            signature,\n          };\n        } else {\n          yield {\n            type: \"reasoning\",\n            reasoning: block.reasoning,\n          };\n        }\n        continue;\n      } else if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (_isContentBlock(block, \"image_url\")) {\n        if (_isString(block.image_url)) {\n          if (block.image_url.startsWith(\"data:\")) {\n            const dataUrlRegex = /^data:([^;]+);base64,(.+)$/;\n            const match = block.image_url.match(dataUrlRegex);\n            if (match) {\n              yield { type: \"image\", data: match[2], mimeType: match[1] };\n            } else {\n              yield { type: \"image\", url: block.image_url };\n            }\n          } else {\n            yield { type: \"image\", url: block.image_url };\n          }\n        }\n        continue;\n      } else if (\n        _isContentBlock(block, \"media\") &&\n        _isString(block.mimeType) &&\n        _isString(block.data)\n      ) {\n        yield { type: \"file\", mimeType: block.mimeType, data: block.data };\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatVertexTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatVertexMessage,\n  translateContentChunk: convertToV1FromChatVertexMessage,\n};\n"],"names":["message: AIMessage","ChatVertexTranslator: StandardContentBlockTranslator"],"mappings":";;;;;;;AAKA,SAAS,iCACPA,OAAAA,EAC8B;IAE9B,UAAU,iBAAkD;QAC1D,MAAM,UACJ,OAAO,QAAQ,OAAA,KAAY,WACvB;YAAC;gBAAE,MAAM;gBAAQ,MAAM,QAAQ,OAAA;YAAS,CAAC;SAAA,GACzC,QAAQ,OAAA;QACd,KAAK,MAAM,SAAS,QAAS;YAC3B,QAAI,0MAAA,EAAgB,OAAO,YAAY,QAAI,oMAAA,EAAU,MAAM,SAAA,CAAU,EAAE;gBACrE,MAAM,gBAAY,+LAAA,EAAK,MAAM;oBAC3B,MAAM,iBAAiB,QAAQ,OAAA,CAAQ,MAAM;oBAC7C,QACE,mMAAA,EAAS,QAAQ,iBAAA,EAAmB,WAAW,IAC/C,kBAAkB,EAElB,CAAA,OAAO,QAAQ,iBAAA,CAAkB,UAAA,CAAW,EAAA,CAAG,eAAe;oBAEhE,OAAO,KAAA;gBACR,EAAC;gBACF,QAAI,oMAAA,EAAU,UAAU,EACtB,MAAM;oBACJ,MAAM;oBACN,WAAW,MAAM,SAAA;oBACjB;gBACD;qBAED,MAAM;oBACJ,MAAM;oBACN,WAAW,MAAM,SAAA;gBAClB;gBAEH;YACD,OAAA,QAAU,0MAAA,EAAgB,OAAO,OAAO,QAAI,oMAAA,EAAU,MAAM,IAAA,CAAK,EAAE;gBAClE,MAAM;oBAAE,MAAM;oBAAQ,MAAM,MAAM,IAAA;gBAAM;gBACxC;YACD,OAAA,QAAU,0MAAA,EAAgB,OAAO,YAAY,EAAE;gBAC9C,QAAI,oMAAA,EAAU,MAAM,SAAA,CAAU,CAC5B,CAAA,IAAI,MAAM,SAAA,CAAU,UAAA,CAAW,QAAQ,EAAE;oBACvC,MAAM,eAAe;oBACrB,MAAM,QAAQ,MAAM,SAAA,CAAU,KAAA,CAAM,aAAa;oBACjD,IAAI,OACF,MAAM;wBAAE,MAAM;wBAAS,MAAM,KAAA,CAAM,EAAA;wBAAI,UAAU,KAAA,CAAM,EAAA;oBAAI;yBAE3D,MAAM;wBAAE,MAAM;wBAAS,KAAK,MAAM,SAAA;oBAAW;gBAEhD,OACC,MAAM;oBAAE,MAAM;oBAAS,KAAK,MAAM,SAAA;gBAAW;gBAGjD;YACD,OAAA,QACC,0MAAA,EAAgB,OAAO,QAAQ,QAC/B,oMAAA,EAAU,MAAM,QAAA,CAAS,QACzB,oMAAA,EAAU,MAAM,IAAA,CAAK,EACrB;gBACA,MAAM;oBAAE,MAAM;oBAAQ,UAAU,MAAM,QAAA;oBAAU,MAAM,MAAM,IAAA;gBAAM;gBAClE;YACD;YACD,MAAM;gBAAE,MAAM;gBAAgB,OAAO;YAAO;QAC7C;IACF;IACD,OAAO,MAAM,IAAA,CAAK,gBAAgB,CAAC;AACpC;AAED,MAAaC,uBAAuD;IAClE,kBAAkB;IAClB,uBAAuB;AACxB"}},
    {"offset": {"line": 5439, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/block_translators/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/block_translators/index.ts"],"sourcesContent":["import type { AIMessage, AIMessageChunk } from \"../ai.js\";\nimport type { ContentBlock } from \"../content/index.js\";\n\nimport { ChatAnthropicTranslator } from \"./anthropic.js\";\nimport { ChatBedrockConverseTranslator } from \"./bedrock_converse.js\";\nimport { ChatGoogleGenAITranslator } from \"./google_genai.js\";\nimport { ChatVertexTranslator } from \"./google_vertexai.js\";\nimport { ChatOpenAITranslator } from \"./openai.js\";\n\nexport interface StandardContentBlockTranslator {\n  translateContent(message: AIMessage): Array<ContentBlock.Standard>;\n  translateContentChunk(chunk: AIMessageChunk): Array<ContentBlock.Standard>;\n}\n\ntype TranslatorRegistry = Map<string, StandardContentBlockTranslator>;\n\ndeclare global {\n  var lc_block_translators_registry: TranslatorRegistry;\n}\n\nglobalThis.lc_block_translators_registry ??= new Map([\n  [\"anthropic\", ChatAnthropicTranslator],\n  [\"bedrock-converse\", ChatBedrockConverseTranslator],\n  [\"google-genai\", ChatGoogleGenAITranslator],\n  [\"google-vertexai\", ChatVertexTranslator],\n  [\"openai\", ChatOpenAITranslator],\n]);\n\nexport function registerTranslator(\n  modelProvider: string,\n  translator: StandardContentBlockTranslator\n) {\n  globalThis.lc_block_translators_registry.set(modelProvider, translator);\n}\n\nexport function getTranslator(\n  modelProvider: string\n): StandardContentBlockTranslator | undefined {\n  return globalThis.lc_block_translators_registry.get(modelProvider);\n}\n"],"names":["modelProvider: string"],"mappings":";;;;;;;;;;;;;;;AAoBA,WAAW,6BAAA,KAAkC,IAAI,IAAI;IACnD;QAAC;QAAa,sNAAwB;KAAA;IACtC;QAAC;QAAoB,mOAA8B;KAAA;IACnD;QAAC;QAAgB,2NAA0B;KAAA;IAC3C;QAAC;QAAmB,yNAAqB;KAAA;IACzC;QAAC;QAAU,gNAAqB;KAAA;CACjC;AASD,SAAgB,cACdA,aAAAA,EAC4C;IAC5C,OAAO,WAAW,6BAAA,CAA8B,GAAA,CAAI,cAAc;AACnE"}},
    {"offset": {"line": 5485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/ai.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/ai.ts"],"sourcesContent":["import { parsePartialJson } from \"../utils/json.js\";\nimport {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  _mergeLists,\n  BaseMessageFields,\n} from \"./base.js\";\nimport { getTranslator } from \"./block_translators/index.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport {\n  $InferMessageContent,\n  $InferMessageProperty,\n  MessageStructure,\n} from \"./message.js\";\nimport { mergeResponseMetadata, mergeUsageMetadata } from \"./metadata.js\";\nimport {\n  InvalidToolCall,\n  ToolCall,\n  ToolCallChunk,\n  defaultToolCallParser,\n} from \"./tool.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface AIMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"ai\"> {\n  tool_calls?: ToolCall[];\n  invalid_tool_calls?: InvalidToolCall[];\n  usage_metadata?: $InferMessageProperty<TStructure, \"ai\", \"usage_metadata\">;\n}\n\nexport class AIMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"ai\">\n  implements AIMessageFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  usage_metadata?: AIMessageFields<TStructure>[\"usage_metadata\"];\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n    };\n  }\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>\n  ) {\n    let initParams: AIMessageFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        additional_kwargs: {},\n      };\n    } else {\n      initParams = fields;\n      const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n      const toolCalls = initParams.tool_calls;\n      if (\n        !(rawToolCalls == null) &&\n        rawToolCalls.length > 0 &&\n        (toolCalls === undefined || toolCalls.length === 0)\n      ) {\n        console.warn(\n          [\n            \"New LangChain packages are available that more efficiently handle\",\n            \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n            \"message tool calls. e.g., `pnpm install @langchain/anthropic`,\",\n            \"pnpm install @langchain/openai`, etc.\",\n          ].join(\" \")\n        );\n      }\n      try {\n        if (!(rawToolCalls == null) && toolCalls === undefined) {\n          const [toolCalls, invalidToolCalls] =\n            defaultToolCallParser(rawToolCalls);\n          initParams.tool_calls = toolCalls ?? [];\n          initParams.invalid_tool_calls = invalidToolCalls ?? [];\n        } else {\n          initParams.tool_calls = initParams.tool_calls ?? [];\n          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n        }\n      } catch {\n        // Do nothing if parsing fails\n        initParams.tool_calls = [];\n        initParams.invalid_tool_calls = [];\n      }\n\n      // Convert content to content blocks if output version is v1\n      if (\n        initParams.response_metadata !== undefined &&\n        \"output_version\" in initParams.response_metadata &&\n        initParams.response_metadata.output_version === \"v1\"\n      ) {\n        initParams.contentBlocks =\n          initParams.content as Array<ContentBlock.Standard>;\n        initParams.content = undefined;\n      }\n\n      if (initParams.contentBlocks !== undefined) {\n        // Add constructor tool calls as content blocks\n        initParams.contentBlocks.push(\n          ...initParams.tool_calls.map((toolCall) => ({\n            type: \"tool_call\" as const,\n            id: toolCall.id,\n            name: toolCall.name,\n            args: toolCall.args,\n          }))\n        );\n        // Add content block tool calls that aren't in the constructor tool calls\n        const missingToolCalls = initParams.contentBlocks\n          .filter<ContentBlock.Tools.ToolCall>(\n            (block): block is ContentBlock.Tools.ToolCall =>\n              block.type === \"tool_call\"\n          )\n          .filter(\n            (block) =>\n              !initParams.tool_calls?.some(\n                (toolCall) =>\n                  toolCall.id === block.id && toolCall.name === block.name\n              )\n          );\n        if (missingToolCalls.length > 0) {\n          initParams.tool_calls = missingToolCalls.map((block) => ({\n            type: \"tool_call\" as const,\n            id: block.id!,\n            name: block.name,\n            args: block.args as Record<string, unknown>,\n          }));\n        }\n      }\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    if (typeof initParams !== \"string\") {\n      this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n      this.invalid_tool_calls =\n        initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  static lc_name() {\n    return \"AIMessage\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      const missingToolCalls = this.tool_calls.filter(\n        (block) =>\n          !blocks.some((b) => b.id === block.id && b.name === block.name)\n      );\n      blocks.push(\n        ...missingToolCalls.map((block) => ({\n          ...block,\n          type: \"tool_call\" as const,\n          id: block.id,\n          name: block.name,\n          args: block.args,\n        }))\n      );\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is AIMessage {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n\n/**\n * @deprecated Use {@link AIMessage.isInstance} instead\n */\nexport function isAIMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is AIMessage<TStructure> {\n  return x._getType() === \"ai\";\n}\n\n/**\n * @deprecated Use {@link AIMessageChunk.isInstance} instead\n */\nexport function isAIMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is AIMessageChunk<TStructure> {\n  return x._getType() === \"ai\";\n}\n\nexport type AIMessageChunkFields<\n  TStructure extends MessageStructure = MessageStructure\n> = AIMessageFields<TStructure> & {\n  tool_call_chunks?: ToolCallChunk[];\n};\n\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessageChunk<TStructure, \"ai\">\n  implements AIMessage<TStructure>, AIMessageChunkFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  tool_call_chunks?: ToolCallChunk[] = [];\n\n  usage_metadata?: AIMessageChunkFields<TStructure>[\"usage_metadata\"];\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>\n  ) {\n    let initParams: AIMessageChunkFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n      };\n    } else if (\n      fields.tool_call_chunks === undefined ||\n      fields.tool_call_chunks.length === 0\n    ) {\n      initParams = {\n        ...fields,\n        tool_calls: fields.tool_calls ?? [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    } else {\n      const toolCallChunks = fields.tool_call_chunks ?? [];\n      const groupedToolCallChunks = toolCallChunks.reduce((acc, chunk) => {\n        const matchedChunkIndex = acc.findIndex(([match]) => {\n          // If chunk has an id and index, match if both are present\n          if (\n            \"id\" in chunk &&\n            chunk.id &&\n            \"index\" in chunk &&\n            chunk.index !== undefined\n          ) {\n            return chunk.id === match.id && chunk.index === match.index;\n          }\n          // If chunk has an id, we match on id\n          if (\"id\" in chunk && chunk.id) {\n            return chunk.id === match.id;\n          }\n          // If chunk has an index, we match on index\n          if (\"index\" in chunk && chunk.index !== undefined) {\n            return chunk.index === match.index;\n          }\n          return false;\n        });\n        if (matchedChunkIndex !== -1) {\n          acc[matchedChunkIndex].push(chunk);\n        } else {\n          acc.push([chunk]);\n        }\n        return acc;\n      }, [] as ToolCallChunk[][]);\n\n      const toolCalls: ToolCall[] = [];\n      const invalidToolCalls: InvalidToolCall[] = [];\n      for (const chunks of groupedToolCallChunks) {\n        let parsedArgs: Record<string, unknown> | null = null;\n        const name = chunks[0]?.name ?? \"\";\n        const joinedArgs = chunks.map((c) => c.args || \"\").join(\"\");\n        const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n        const id = chunks[0]?.id;\n        try {\n          parsedArgs = parsePartialJson(argsStr);\n          if (\n            !id ||\n            parsedArgs === null ||\n            typeof parsedArgs !== \"object\" ||\n            Array.isArray(parsedArgs)\n          ) {\n            throw new Error(\"Malformed tool call chunk args.\");\n          }\n          toolCalls.push({\n            name,\n            args: parsedArgs,\n            id,\n            type: \"tool_call\",\n          });\n        } catch {\n          invalidToolCalls.push({\n            name,\n            args: argsStr,\n            id,\n            error: \"Malformed args.\",\n            type: \"invalid_tool_call\",\n          });\n        }\n      }\n      initParams = {\n        ...fields,\n        tool_calls: toolCalls,\n        invalid_tool_calls: invalidToolCalls,\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    this.tool_call_chunks =\n      initParams.tool_call_chunks ?? this.tool_call_chunks;\n    this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n    this.invalid_tool_calls =\n      initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n      tool_call_chunks: \"tool_call_chunks\",\n    };\n  }\n\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      if (typeof this.content !== \"string\") {\n        const contentToolCalls = this.content\n          .filter((block) => block.type === \"tool_call\")\n          .map((block) => block.id);\n        for (const toolCall of this.tool_calls) {\n          if (toolCall.id && !contentToolCalls.includes(toolCall.id)) {\n            blocks.push({\n              ...toolCall,\n              type: \"tool_call\",\n              id: toolCall.id,\n              name: toolCall.name,\n              args: toolCall.args,\n            });\n          }\n        }\n      }\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      tool_call_chunks: this.tool_call_chunks,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  concat(chunk: AIMessageChunk<TStructure>) {\n    const combinedFields: AIMessageChunkFields = {\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: mergeResponseMetadata(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      tool_call_chunks: [],\n      id: this.id ?? chunk.id,\n    };\n    if (\n      this.tool_call_chunks !== undefined ||\n      chunk.tool_call_chunks !== undefined\n    ) {\n      const rawToolCalls = _mergeLists(\n        this.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[],\n        chunk.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[]\n      );\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_call_chunks = rawToolCalls;\n      }\n    }\n    if (\n      this.usage_metadata !== undefined ||\n      chunk.usage_metadata !== undefined\n    ) {\n      combinedFields.usage_metadata = mergeUsageMetadata(\n        this.usage_metadata,\n        chunk.usage_metadata\n      );\n    }\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls(combinedFields);\n  }\n\n  static isInstance(obj: unknown): obj is AIMessageChunk {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n"],"names":["fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>","initParams: AIMessageFields<TStructure>","toolCalls","obj: unknown","x: BaseMessage","x: BaseMessageChunk","fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>","initParams: AIMessageChunkFields<TStructure>","toolCalls: ToolCall[]","invalidToolCalls: InvalidToolCall[]","parsedArgs: Record<string, unknown> | null","chunk: AIMessageChunk<TStructure>","combinedFields: AIMessageChunkFields"],"mappings":"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"}},
    {"offset": {"line": 5766, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/chat.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/chat.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface ChatMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"generic\"> {\n  role: string;\n}\n\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"generic\">\n  implements ChatMessageFields<TStructure>\n{\n  static lc_name() {\n    return \"ChatMessage\";\n  }\n\n  readonly type = \"generic\" as const;\n\n  role: string;\n\n  static _chatMessageClass(): typeof ChatMessage {\n    return ChatMessage;\n  }\n\n  constructor(\n    content: $InferMessageContent<TStructure, \"generic\">,\n    role: string\n  );\n\n  constructor(fields: ChatMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>,\n    role?: string\n  ) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = { content: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  static isInstance(obj: unknown): obj is ChatMessage {\n    return super.isInstance(obj) && obj.type === \"generic\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      role: this.role,\n    };\n  }\n}\n\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"generic\"> {\n  static lc_name() {\n    return \"ChatMessageChunk\";\n  }\n\n  readonly type = \"generic\" as const;\n\n  role: string;\n\n  constructor(\n    content: $InferMessageContent<TStructure, \"generic\">,\n    role: string\n  );\n\n  constructor(fields: ChatMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>,\n    role?: string\n  ) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = { content: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  concat(chunk: ChatMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      role: this.role,\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is ChatMessageChunk {\n    return super.isInstance(obj) && obj.type === \"generic\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      role: this.role,\n    };\n  }\n}\n\n/**\n * @deprecated Use {@link ChatMessage.isInstance} instead\n */\nexport function isChatMessage(x: BaseMessage): x is ChatMessage {\n  return x._getType() === \"generic\";\n}\n\n/**\n * @deprecated Use {@link ChatMessageChunk.isInstance} instead\n */\nexport function isChatMessageChunk(x: BaseMessageChunk): x is ChatMessageChunk {\n  return x._getType() === \"generic\";\n}\n"],"names":["fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>","role?: string","obj: unknown","chunk: ChatMessageChunk<TStructure>","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;;;;;;;;;;;;GAmBA,IAAa,cAAb,MAAa,oBACH,gLAAA,CAEV;IACE,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,UAAA;IAEhB,KAAA;IAEA,OAAO,oBAAwC;QAC7C,OAAO;IACR;IASD,YACEA,MAAAA,EAGAC,IAAAA,CACA;QACA,IAAI,OAAO,WAAW,YAAY,MAAM,OAAA,CAAQ,OAAO,EAErD,SAAS;YAAE,SAAS;YAAc;QAAO;QAE3C,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IACpB;IAED,OAAO,WAAWC,GAAAA,EAAkC;QAClD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,MAAM,IAAA,CAAK,IAAA;QACZ;IACF;AACF;;;;GAMD,IAAa,mBAAb,cAEU,qLAAA,CAAwC;IAChD,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,UAAA;IAEhB,KAAA;IASA,YACEF,MAAAA,EAGAC,IAAAA,CACA;QACA,IAAI,OAAO,WAAW,YAAY,MAAM,OAAA,CAAQ,OAAO,EAErD,SAAS;YAAE,SAAS;YAAc;QAAO;QAE3C,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IACpB;IAED,OAAOE,KAAAA,EAAqC;QAC1C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,aAAS,iLAAA,EAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,MAAM,IAAA,CAAK,IAAA;YACX,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;IAED,OAAO,WAAWD,GAAAA,EAAuC;QACvD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,MAAM,IAAA,CAAK,IAAA;QACZ;IACF;AACF;;;GAKD,SAAgB,cAAcE,CAAAA,EAAkC;IAC9D,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;;;GAKD,SAAgB,mBAAmBC,CAAAA,EAA4C;IAC7E,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB"}},
    {"offset": {"line": 5861, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/function.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/function.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n} from \"./base.js\";\nimport { MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface FunctionMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"function\"> {\n  name: string;\n}\n\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessage<TStructure, \"function\">\n  implements FunctionMessageFields<TStructure>\n{\n  static lc_name() {\n    return \"FunctionMessage\";\n  }\n\n  readonly type = \"function\" as const;\n\n  name: string;\n\n  constructor(fields: FunctionMessageFields<TStructure>) {\n    super(fields);\n    this.name = fields.name;\n  }\n}\n\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"function\"> {\n  static lc_name() {\n    return \"FunctionMessageChunk\";\n  }\n\n  readonly type = \"function\" as const;\n\n  concat(chunk: FunctionMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      name: this.name ?? \"\",\n      id: this.id ?? chunk.id,\n    });\n  }\n}\n\nexport function isFunctionMessage(x: BaseMessage): x is FunctionMessage {\n  return x._getType() === \"function\";\n}\n\nexport function isFunctionMessageChunk(\n  x: BaseMessageChunk\n): x is FunctionMessageChunk {\n  return x._getType() === \"function\";\n}\n"],"names":["fields: FunctionMessageFields<TStructure>","chunk: FunctionMessageChunk<TStructure>","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;;;;;;;;;;;;GAmBA,IAAa,kBAAb,cAGU,gLAAA,CAEV;IACE,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,WAAA;IAEhB,KAAA;IAEA,YAAYA,MAAAA,CAA2C;QACrD,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IACpB;AACF;;;;GAMD,IAAa,uBAAb,cAEU,qLAAA,CAAyC;IACjD,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,WAAA;IAEhB,OAAOC,KAAAA,EAAyC;QAC9C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,aAAS,iLAAA,EAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,MAAM,IAAA,CAAK,IAAA,IAAQ;YACnB,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;AACF;AAED,SAAgB,kBAAkBC,CAAAA,EAAsC;IACtE,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;AAED,SAAgB,uBACdC,CAAAA,EAC2B;IAC3B,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB"}},
    {"offset": {"line": 5918, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/human.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/human.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  type BaseMessageFields,\n} from \"./base.js\";\nimport type { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface HumanMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"human\"> {}\n\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"human\"> {\n  static lc_name() {\n    return \"HumanMessage\";\n  }\n\n  readonly type = \"human\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  static isInstance(obj: unknown): obj is HumanMessage {\n    return super.isInstance(obj) && obj.type === \"human\";\n  }\n}\n\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"human\"> {\n  static lc_name() {\n    return \"HumanMessageChunk\";\n  }\n\n  readonly type = \"human\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  concat(chunk: HumanMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is HumanMessageChunk {\n    return super.isInstance(obj) && obj.type === \"human\";\n  }\n}\n\n/**\n * @deprecated Use {@link HumanMessage.isInstance} instead\n */\nexport function isHumanMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is HumanMessage<TStructure> {\n  return x.getType() === \"human\";\n}\n\n/**\n * @deprecated Use {@link HumanMessageChunk.isInstance} instead\n */\nexport function isHumanMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is HumanMessageChunk<TStructure> {\n  return x.getType() === \"human\";\n}\n"],"names":["fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>","obj: unknown","chunk: HumanMessageChunk<TStructure>","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;;;;;;;;;;;;GAiBA,IAAa,eAAb,cAEU,gLAAA,CAAiC;IACzC,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,QAAA;IAEhB,YACEA,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;IAED,OAAO,WAAWC,GAAAA,EAAmC;QACnD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;;GAMD,IAAa,oBAAb,cAEU,qLAAA,CAAsC;IAC9C,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,QAAA;IAEhB,YACED,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;IAED,OAAOE,KAAAA,EAAsC;QAC3C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,aAAS,iLAAA,EAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;IAED,OAAO,WAAWD,GAAAA,EAAwC;QACxD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;GAKD,SAAgB,eACdE,CAAAA,EAC+B;IAC/B,OAAO,EAAE,OAAA,EAAS,KAAK;AACxB;;;GAKD,SAAgB,oBACdC,CAAAA,EACoC;IACpC,OAAO,EAAE,OAAA,EAAS,KAAK;AACxB"}},
    {"offset": {"line": 5985, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/system.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/system.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  type BaseMessageFields,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface SystemMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"system\"> {}\n\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"system\"> {\n  static lc_name() {\n    return \"SystemMessage\";\n  }\n\n  readonly type = \"system\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  /**\n   * Concatenates a string or another system message with the current system message.\n   * @param chunk - The chunk to concatenate with the system message.\n   * @returns A new system message with the concatenated content.\n   */\n  concat(chunk: string | SystemMessage) {\n    if (typeof chunk === \"string\") {\n      return new SystemMessage({\n        ...this,\n        content: mergeContent(this.content, chunk),\n      });\n    }\n\n    if (SystemMessage.isInstance(chunk)) {\n      return new SystemMessage({\n        ...this,\n        additional_kwargs: {\n          ...this.additional_kwargs,\n          ...chunk.additional_kwargs,\n        },\n        response_metadata: {\n          ...this.response_metadata,\n          ...chunk.response_metadata,\n        },\n        content: mergeContent(this.content, chunk.content),\n      });\n    }\n\n    throw new Error(\"Unexpected chunk type for system message\");\n  }\n\n  static isInstance(obj: unknown): obj is SystemMessage {\n    return super.isInstance(obj) && obj.type === \"system\";\n  }\n}\n\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"system\"> {\n  static lc_name() {\n    return \"SystemMessageChunk\";\n  }\n\n  readonly type = \"system\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  concat(chunk: SystemMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is SystemMessageChunk {\n    return super.isInstance(obj) && obj.type === \"system\";\n  }\n}\n\n/**\n * @deprecated Use {@link SystemMessage.isInstance} instead\n */\nexport function isSystemMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is SystemMessage<TStructure> {\n  return x._getType() === \"system\";\n}\n\n/**\n * @deprecated Use {@link SystemMessageChunk.isInstance} instead\n */\nexport function isSystemMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is SystemMessageChunk<TStructure> {\n  return x._getType() === \"system\";\n}\n"],"names":["fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>","chunk: string | SystemMessage","obj: unknown","chunk: SystemMessageChunk<TStructure>","x: BaseMessage","x: BaseMessageChunk"],"mappings":";;;;;;;;;;;;;;;GAiBA,IAAa,gBAAb,MAAa,sBAEH,gLAAA,CAAkC;IAC1C,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,SAAA;IAEhB,YACEA,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;;;;;IAOD,OAAOC,KAAAA,EAA+B;QACpC,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO,IAAI,cAAc;YACvB,GAAG,IAAA;YACH,aAAS,iLAAA,EAAa,IAAA,CAAK,OAAA,EAAS,MAAM;QAC3C;QAGH,IAAI,cAAc,UAAA,CAAW,MAAM,CACjC,CAAA,OAAO,IAAI,cAAc;YACvB,GAAG,IAAA;YACH,mBAAmB;gBACjB,GAAG,IAAA,CAAK,iBAAA;gBACR,GAAG,MAAM,iBAAA;YACV;YACD,mBAAmB;gBACjB,GAAG,IAAA,CAAK,iBAAA;gBACR,GAAG,MAAM,iBAAA;YACV;YACD,aAAS,iLAAA,EAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;QACnD;QAGH,MAAM,IAAI,MAAM;IACjB;IAED,OAAO,WAAWC,GAAAA,EAAoC;QACpD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;;GAMD,IAAa,qBAAb,cAEU,qLAAA,CAAuC;IAC/C,OAAO,UAAU;QACf,OAAO;IACR;IAEQ,OAAO,SAAA;IAEhB,YACEF,MAAAA,CAGA;QACA,KAAA,CAAM,OAAO;IACd;IAED,OAAOG,KAAAA,EAAuC;QAC5C,MAAM,MAAM,IAAA,CAAK,WAAA;QACjB,OAAO,IAAI,IAAI;YACb,aAAS,iLAAA,EAAa,IAAA,CAAK,OAAA,EAAS,MAAM,OAAA,CAAQ;YAClD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,uBAAmB,gLAAA,EACjB,IAAA,CAAK,iBAAA,EACL,MAAM,iBAAA,CACP;YACD,IAAI,IAAA,CAAK,EAAA,IAAM,MAAM,EAAA;QACtB;IACF;IAED,OAAO,WAAWD,GAAAA,EAAyC;QACzD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF;;;GAKD,SAAgB,gBACdE,CAAAA,EACgC;IAChC,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB;;;GAKD,SAAgB,qBACdC,CAAAA,EACqC;IACrC,OAAO,EAAE,QAAA,EAAU,KAAK;AACzB"}},
    {"offset": {"line": 6075, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/modifier.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/modifier.ts"],"sourcesContent":["import { BaseMessage, BaseMessageFields } from \"./base.js\";\nimport { MessageStructure } from \"./message.js\";\n\nexport interface RemoveMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends Omit<BaseMessageFields<TStructure, \"remove\">, \"content\"> {\n  /**\n   * The ID of the message to remove.\n   */\n  id: string;\n}\n\n/**\n * Message responsible for deleting other messages.\n */\nexport class RemoveMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"remove\"> {\n  readonly type = \"remove\" as const;\n\n  /**\n   * The ID of the message to remove.\n   */\n  id: string;\n\n  constructor(fields: RemoveMessageFields<TStructure>) {\n    super({\n      ...fields,\n      content: [],\n    });\n    this.id = fields.id;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      id: this.id,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is RemoveMessage {\n    return super.isInstance(obj) && obj.type === \"remove\";\n  }\n}\n"],"names":["fields: RemoveMessageFields<TStructure>","obj: unknown"],"mappings":";;;;;;;;;GAeA,IAAa,gBAAb,cAEU,gLAAA,CAAkC;IACjC,OAAO,SAAA;;;IAKhB,GAAA;IAEA,YAAYA,MAAAA,CAAyC;QACnD,KAAA,CAAM;YACJ,GAAG,MAAA;YACH,SAAS,CAAE,CAAA;QACZ,EAAC;QACF,IAAA,CAAK,EAAA,GAAK,OAAO,EAAA;IAClB;IAED,IAAa,mBAA4C;QACvD,OAAO;YACL,GAAG,KAAA,CAAM,gBAAA;YACT,IAAI,IAAA,CAAK,EAAA;QACV;IACF;IAED,OAAO,WAAWC,GAAAA,EAAoC;QACpD,OAAO,KAAA,CAAM,WAAW,IAAI,IAAI,IAAI,IAAA,KAAS;IAC9C;AACF"}},
    {"offset": {"line": 6112, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/utils.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/utils.ts"],"sourcesContent":["import { addLangChainErrorFields } from \"../errors/index.js\";\nimport { SerializedConstructor } from \"../load/serializable.js\";\nimport { _isToolCall } from \"../tools/utils.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessageLike,\n  BaseMessage,\n  isBaseMessage,\n  StoredMessage,\n  StoredMessageV1,\n  BaseMessageFields,\n  _isMessageFieldWithRole,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageFields, ChatMessageChunk } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolCall, ToolMessage, ToolMessageFields } from \"./tool.js\";\n\nexport type $Expand<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = {\n  [K in keyof T]: string extends K\n    ? never\n    : number extends K\n    ? never\n    : symbol extends K\n    ? never\n    : K;\n}[keyof T];\n\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T\n  ? true\n  : number extends keyof T\n  ? true\n  : symbol extends keyof T\n  ? true\n  : false;\n\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> = $HasIndexSignature<T> extends true\n  ? [$KnownKeys<T>] extends [never]\n    ? true\n    : false\n  : false;\n\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\nexport type $MergeObjects<T, U> =\n  // If U is purely index-signature based, prefer U as a whole\n  $OnlyIndexSignatures<U> extends true\n    ? U\n    : // If T is purely index-signature based, prefer U as a whole (prevents leaking broad index signatures)\n    $OnlyIndexSignatures<T> extends true\n    ? U\n    : {\n        [K in keyof T | keyof U]: K extends keyof T\n          ? K extends keyof U\n            ? T[K] extends Record<string, unknown>\n              ? U[K] extends Record<string, unknown>\n                ? $MergeObjects<T[K], U[K]>\n                : U[K]\n              : U[K]\n            : T[K]\n          : K extends keyof U\n          ? U[K]\n          : never;\n      };\n\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\nexport type $MergeDiscriminatedUnion<\n  A extends Record<Key, PropertyKey>,\n  B extends Record<Key, PropertyKey>,\n  Key extends PropertyKey = \"type\"\n> = {\n  // Create a mapped type over all possible discriminator values from both A and B\n  [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] // Check if B has a member with this discriminator value\n    ? // If B doesn't have this discriminator value, use A's member\n      Extract<A, Record<Key, T>>\n    : // If B does have this discriminator value, merge A's and B's members (B takes precedence)\n    [Extract<A, Record<Key, T>>] extends [never]\n    ? Extract<B, Record<Key, T>>\n    : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>>;\n  // Index into the mapped type with all possible discriminator values\n  // This converts the mapped type back into a union\n}[A[Key] | B[Key]];\n\nexport type Constructor<T> = new (...args: unknown[]) => T;\n\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\nexport const iife = <T>(fn: () => T) => fn();\n\nfunction _coerceToolCall(\n  toolCall: ToolCall | Record<string, unknown>\n): ToolCall {\n  if (_isToolCall(toolCall)) {\n    return toolCall;\n  } else if (\n    typeof toolCall.id === \"string\" &&\n    toolCall.type === \"function\" &&\n    typeof toolCall.function === \"object\" &&\n    toolCall.function !== null &&\n    \"arguments\" in toolCall.function &&\n    typeof toolCall.function.arguments === \"string\" &&\n    \"name\" in toolCall.function &&\n    typeof toolCall.function.name === \"string\"\n  ) {\n    // Handle OpenAI tool call format\n    return {\n      id: toolCall.id,\n      args: JSON.parse(toolCall.function.arguments),\n      name: toolCall.function.name,\n      type: \"tool_call\",\n    };\n  } else {\n    // TODO: Throw an error?\n    return toolCall as unknown as ToolCall;\n  }\n}\n\nfunction isSerializedConstructor(x: unknown): x is SerializedConstructor {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    (x as SerializedConstructor).lc === 1 &&\n    Array.isArray((x as SerializedConstructor).id) &&\n    (x as SerializedConstructor).kwargs != null &&\n    typeof (x as SerializedConstructor).kwargs === \"object\"\n  );\n}\n\nfunction _constructMessageFromParams(\n  params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor\n) {\n  let type: string;\n  let rest: BaseMessageFields & Record<string, unknown>;\n  // Support serialized messages\n  if (isSerializedConstructor(params)) {\n    const className = params.id.at(-1);\n    if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n      type = \"user\";\n    } else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n      type = \"assistant\";\n    } else if (\n      className === \"SystemMessage\" ||\n      className === \"SystemMessageChunk\"\n    ) {\n      type = \"system\";\n    } else if (\n      className === \"FunctionMessage\" ||\n      className === \"FunctionMessageChunk\"\n    ) {\n      type = \"function\";\n    } else if (\n      className === \"ToolMessage\" ||\n      className === \"ToolMessageChunk\"\n    ) {\n      type = \"tool\";\n    } else {\n      type = \"unknown\";\n    }\n    rest = params.kwargs as BaseMessageFields;\n  } else {\n    const { type: extractedType, ...otherParams } = params;\n    type = extractedType;\n    rest = otherParams;\n  }\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage(rest);\n  } else if (type === \"ai\" || type === \"assistant\") {\n    const { tool_calls: rawToolCalls, ...other } = rest;\n    if (!Array.isArray(rawToolCalls)) {\n      return new AIMessage(rest);\n    }\n    const tool_calls = rawToolCalls.map(_coerceToolCall);\n    return new AIMessage({ ...other, tool_calls });\n  } else if (type === \"system\") {\n    return new SystemMessage(rest);\n  } else if (type === \"developer\") {\n    return new SystemMessage({\n      ...rest,\n      additional_kwargs: {\n        ...rest.additional_kwargs,\n        __openai_role__: \"developer\",\n      },\n    });\n  } else if (type === \"tool\" && \"tool_call_id\" in rest) {\n    return new ToolMessage({\n      ...rest,\n      content: rest.content,\n      tool_call_id: rest.tool_call_id as string,\n      name: rest.name,\n    });\n  } else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n    return new RemoveMessage({ ...rest, id: rest.id });\n  } else {\n    const error = addLangChainErrorFields(\n      new Error(\n        `Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(\n          params,\n          null,\n          2\n        )}`\n      ),\n      \"MESSAGE_COERCION_FAILURE\"\n    );\n    throw error;\n  }\n}\n\nexport function coerceMessageLikeToMessage(\n  messageLike: BaseMessageLike\n): BaseMessage {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  if (Array.isArray(messageLike)) {\n    const [type, content] = messageLike;\n    return _constructMessageFromParams({ type, content });\n  } else if (_isMessageFieldWithRole(messageLike)) {\n    const { role: type, ...rest } = messageLike;\n    return _constructMessageFromParams({ ...rest, type });\n  } else {\n    return _constructMessageFromParams(messageLike);\n  }\n}\n\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(\n  messages: BaseMessage[],\n  humanPrefix = \"Human\",\n  aiPrefix = \"AI\"\n): string {\n  const string_messages: string[] = [];\n  for (const m of messages) {\n    let role: string;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = (m as ChatMessage).role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    const readableContent =\n      typeof m.content === \"string\"\n        ? m.content\n        : JSON.stringify(m.content, null, 2);\n    string_messages.push(`${role}: ${nameStr}${readableContent}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(\n  message: StoredMessage | StoredMessageV1\n): StoredMessage {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if ((message as StoredMessage).data !== undefined) {\n    return message as StoredMessage;\n  } else {\n    const v1Message = message as StoredMessageV1;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined,\n      },\n    };\n  }\n}\n\nexport function mapStoredMessageToChatMessage(message: StoredMessage) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data as FunctionMessageFields);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data as ToolMessageFields);\n    case \"generic\": {\n      if (storedMessage.data.role === undefined) {\n        throw new Error(\"Role must be defined for chat messages\");\n      }\n      return new ChatMessage(storedMessage.data as ChatMessageFields);\n    }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(\n  messages: StoredMessage[]\n): BaseMessage[] {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(\n  messages: BaseMessage[]\n): StoredMessage[] {\n  return messages.map((message) => message.toDict());\n}\n\nexport function convertToChunk(message: BaseMessage) {\n  const type = message._getType();\n  if (type === \"human\") {\n    return new HumanMessageChunk({ ...message });\n  } else if (type === \"ai\") {\n    let aiChunkFields: AIMessageChunkFields = {\n      ...message,\n    };\n    if (\"tool_calls\" in aiChunkFields) {\n      aiChunkFields = {\n        ...aiChunkFields,\n        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n          ...tc,\n          type: \"tool_call_chunk\",\n          index: undefined,\n          args: JSON.stringify(tc.args),\n        })),\n      };\n    }\n    return new AIMessageChunk({ ...aiChunkFields });\n  } else if (type === \"system\") {\n    return new SystemMessageChunk({ ...message });\n  } else if (type === \"function\") {\n    return new FunctionMessageChunk({ ...message });\n  } else if (ChatMessage.isInstance(message)) {\n    return new ChatMessageChunk({ ...message });\n  } else {\n    throw new Error(\"Unknown message type.\");\n  }\n}\n"],"names":["fn: () => T","toolCall: ToolCall | Record<string, unknown>","x: unknown","params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor","type: string","rest: BaseMessageFields & Record<string, unknown>","messageLike: BaseMessageLike","messages: BaseMessage[]","string_messages: string[]","role: string","message: StoredMessage | StoredMessageV1","message: StoredMessage","messages: StoredMessage[]","message: BaseMessage","aiChunkFields: AIMessageChunkFields"],"mappings":"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"}},
    {"offset": {"line": 6352, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/transformers.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/transformers.ts"],"sourcesContent":["import { BaseDocumentTransformer } from \"../documents/transformers.js\";\nimport { BaseLanguageModel } from \"../language_models/base.js\";\nimport { Runnable, RunnableLambda } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessage,\n  BaseMessageChunk,\n  BaseMessageFields,\n  isBaseMessageChunk,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk, ChatMessageFields } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { MessageType } from \"./message.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk, ToolMessageFields } from \"./tool.js\";\nimport { convertToChunk } from \"./utils.js\";\n\nexport type MessageUnion =\n  | typeof HumanMessage\n  | typeof AIMessage\n  | typeof SystemMessage\n  | typeof ChatMessage\n  | typeof FunctionMessage\n  | typeof ToolMessage\n  | typeof RemoveMessage;\nexport type MessageChunkUnion =\n  | typeof HumanMessageChunk\n  | typeof AIMessageChunk\n  | typeof SystemMessageChunk\n  | typeof FunctionMessageChunk\n  | typeof ToolMessageChunk\n  | typeof ChatMessageChunk\n  | typeof RemoveMessage; // RemoveMessage does not have a chunk class.\nexport type MessageTypeOrClass = MessageType | MessageUnion | MessageChunkUnion;\n\nconst _isMessageType = (msg: BaseMessage, types: MessageTypeOrClass[]) => {\n  const typesAsStrings = [\n    ...new Set<string>(\n      types?.map((t) => {\n        if (typeof t === \"string\") {\n          return t;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const instantiatedMsgClass = new (t as any)({});\n        if (\n          !(\"getType\" in instantiatedMsgClass) ||\n          typeof instantiatedMsgClass.getType !== \"function\"\n        ) {\n          throw new Error(\"Invalid type provided.\");\n        }\n        return instantiatedMsgClass.getType();\n      })\n    ),\n  ];\n  const msgType = msg.getType();\n  return typesAsStrings.some((t) => t === msgType);\n};\n\nexport interface FilterMessagesFields {\n  /**\n   * @param {string[] | undefined} includeNames Message names to include.\n   */\n  includeNames?: string[];\n  /**\n   * @param {string[] | undefined} excludeNames Messages names to exclude.\n   */\n  excludeNames?: string[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} includeTypes Message types to include. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  includeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} excludeTypes Message types to exclude. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  excludeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {string[] | undefined} includeIds Message IDs to include.\n   */\n  includeIds?: string[];\n  /**\n   * @param {string[] | undefined} excludeIds Message IDs to exclude.\n   */\n  excludeIds?: string[];\n}\n\n/**\n * Filter messages based on name, type or id.\n *\n * @param {BaseMessage[] | FilterMessagesFields} messagesOrOptions - Either an array of BaseMessage objects to filter or the filtering options. If an array is provided, the `options` parameter should also be supplied. If filtering options are provided, a RunnableLambda is returned.\n * @param {FilterMessagesFields} [options] - Optional filtering options. Should only be provided if `messagesOrOptions` is an array of BaseMessage objects.\n * @returns A list of Messages that meets at least one of the include conditions and none\n *     of the exclude conditions, or a RunnableLambda which does the same. If no include conditions are specified then\n *     anything that is not explicitly excluded will be included.\n * @throws {Error} If two incompatible arguments are provided.\n *\n * @example\n * ```typescript\n * import { filterMessages, AIMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n *   new AIMessage({ content: \"steve-o\", id: \"bar\", name: \"example_assistant\" }),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"baz\" }),\n *   new AIMessage({ content: \"silicon blue\" , id: \"blah\" }),\n * ];\n *\n * filterMessages(messages, {\n *   includeNames: [\"example_user\", \"example_assistant\"],\n *   includeTypes: [\"system\"],\n *   excludeIds: [\"bar\"],\n * });\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n * ]\n * ```\n */\nexport function filterMessages(\n  options?: FilterMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function filterMessages(\n  messages: BaseMessage[],\n  options?: FilterMessagesFields\n): BaseMessage[];\nexport function filterMessages(\n  messagesOrOptions?: BaseMessage[] | FilterMessagesFields,\n  options?: FilterMessagesFields\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    return _filterMessages(messagesOrOptions, options);\n  }\n  return RunnableLambda.from((input: BaseMessage[]): BaseMessage[] => {\n    return _filterMessages(input, messagesOrOptions);\n  });\n}\n\nfunction _filterMessages(\n  messages: BaseMessage[],\n  options: FilterMessagesFields = {}\n): BaseMessage[] {\n  const {\n    includeNames,\n    excludeNames,\n    includeTypes,\n    excludeTypes,\n    includeIds,\n    excludeIds,\n  } = options;\n\n  const filtered: BaseMessage[] = [];\n\n  for (const msg of messages) {\n    if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n      continue;\n    } else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n      continue;\n    } else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n      continue;\n    }\n\n    // default to inclusion when no inclusion criteria given.\n    if (!(includeTypes || includeIds || includeNames)) {\n      filtered.push(msg);\n    } else if (\n      includeNames &&\n      msg.name &&\n      includeNames.some((iName) => iName === msg.name)\n    ) {\n      filtered.push(msg);\n    } else if (includeTypes && _isMessageType(msg, includeTypes)) {\n      filtered.push(msg);\n    } else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n      filtered.push(msg);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Merge consecutive Messages of the same type.\n *\n * **NOTE**: ToolMessages are not merged, as each has a distinct tool call id that\n * can't be merged.\n *\n * @param {BaseMessage[] | undefined} messages Sequence of Message-like objects to merge. Optional. If not provided, a RunnableLambda is returned.\n * @returns List of BaseMessages with consecutive runs of message types merged into single\n *     messages, or a RunnableLambda which returns a list of BaseMessages If two messages being merged both have string contents, the merged\n *     content is a concatenation of the two strings with a new-line separator. If at\n *     least one of the messages has a list of content blocks, the merged content is a\n *     list of content blocks.\n *\n * @example\n * ```typescript\n * import { mergeMessageRuns, AIMessage, HumanMessage, SystemMessage, ToolCall } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"foo\" }),\n *   new HumanMessage({ content: \"wait your favorite food\", id: \"bar\" }),\n *   new AIMessage({\n *     content: \"my favorite colo\",\n *     tool_calls: [{ name: \"blah_tool\", args: { x: 2 }, id: \"123\" }],\n *     id: \"baz\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"my favorite dish is lasagna\" }],\n *     tool_calls: [{ name: \"blah_tool\", args: { x: -10 }, id: \"456\" }],\n *     id: \"blur\",\n *   }),\n * ];\n *\n * mergeMessageRuns(messages);\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({\n *     content: \"what's your favorite colorwait your favorite food\",\n *     id: \"foo\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"my favorite colo\" },\n *       { type: \"text\", text: \"my favorite dish is lasagna\" },\n *     ],\n *     tool_calls: [\n *       { name: \"blah_tool\", args: { x: 2 }, id: \"123\" },\n *       { name: \"blah_tool\", args: { x: -10 }, id: \"456\" },\n *     ],\n *     id: \"baz\",\n *   }),\n * ]\n * ```\n */\nexport function mergeMessageRuns(): Runnable<BaseMessage[], BaseMessage[]>;\nexport function mergeMessageRuns(messages: BaseMessage[]): BaseMessage[];\nexport function mergeMessageRuns(\n  messages?: BaseMessage[]\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messages)) {\n    return _mergeMessageRuns(messages);\n  }\n  return RunnableLambda.from(_mergeMessageRuns);\n}\n\nfunction _mergeMessageRuns(messages: BaseMessage[]): BaseMessage[] {\n  if (!messages.length) {\n    return [];\n  }\n  const merged: BaseMessage[] = [];\n  for (const msg of messages) {\n    const curr = msg;\n    const last = merged.pop();\n    if (!last) {\n      merged.push(curr);\n    } else if (\n      curr.getType() === \"tool\" ||\n      !(curr.getType() === last.getType())\n    ) {\n      merged.push(last, curr);\n    } else {\n      const lastChunk = convertToChunk(last) as BaseMessageChunk;\n      const currChunk = convertToChunk(curr) as BaseMessageChunk;\n      const mergedChunks = lastChunk.concat(currChunk);\n      if (\n        typeof lastChunk.content === \"string\" &&\n        typeof currChunk.content === \"string\"\n      ) {\n        mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n      }\n      merged.push(_chunkToMsg(mergedChunks));\n    }\n  }\n  return merged;\n}\n\n// Since we can not import from `@langchain/textsplitters` we need\n// to reconstruct the interface here.\ninterface _TextSplitterInterface extends BaseDocumentTransformer {\n  splitText(text: string): Promise<string[]>;\n}\n\nexport interface TrimMessagesFields {\n  /**\n   * @param {number} maxTokens Max token count of trimmed messages.\n   */\n  maxTokens: number;\n  /**\n   * @param {((messages: BaseMessage[]) => number) | ((messages: BaseMessage[]) => Promise<number>) | BaseLanguageModel} tokenCounter\n   * Function or LLM for counting tokens in an array of `BaseMessage`s.\n   * If a `BaseLanguageModel` is passed in then `BaseLanguageModel.getNumTokens()` will be used.\n   */\n  tokenCounter:\n    | ((messages: BaseMessage[]) => number)\n    | ((messages: BaseMessage[]) => Promise<number>)\n    | BaseLanguageModel;\n  /**\n   * @param {\"first\" | \"last\"} [strategy=\"last\"] Strategy for trimming.\n   * - \"first\": Keep the first <= n_count tokens of the messages.\n   * - \"last\": Keep the last <= n_count tokens of the messages.\n   * @default \"last\"\n   */\n  strategy?: \"first\" | \"last\";\n  /**\n   * @param {boolean} [allowPartial=false] Whether to split a message if only part of the message can be included.\n   * If `strategy: \"last\"` then the last partial contents of a message are included.\n   * If `strategy: \"first\"` then the first partial contents of a message are included.\n   * @default false\n   */\n  allowPartial?: boolean;\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [endOn] The message type to end on.\n   * If specified then every message after the last occurrence of this type is ignored.\n   * If `strategy === \"last\"` then this is done before we attempt to get the last `maxTokens`.\n   * If `strategy === \"first\"` then this is done after we get the first `maxTokens`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [startOn] The message type to start on.\n   * Should only be specified if `strategy: \"last\"`. If specified then every message before the first occurrence\n   * of this type is ignored. This is done after we trim the initial messages to the last `maxTokens`.\n   * Does not apply to a `SystemMessage` at index 0 if `includeSystem: true`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {boolean} [includeSystem=false] Whether to keep the `SystemMessage` if there is one at index 0.\n   * Should only be specified if `strategy: \"last\"`.\n   * @default false\n   */\n  includeSystem?: boolean;\n  /**\n   * @param {((text: string) => string[]) | BaseDocumentTransformer} [textSplitter] Function or `BaseDocumentTransformer` for\n   * splitting the string contents of a message. Only used if `allowPartial: true`.\n   * If `strategy: \"last\"` then the last split tokens from a partial message will be included.\n   * If `strategy: \"first\"` then the first split tokens from a partial message will be included.\n   * Token splitter assumes that separators are kept, so that split contents can be directly concatenated\n   * to recreate the original text. Defaults to splitting on newlines.\n   */\n  textSplitter?:\n    | ((text: string) => string[])\n    | ((text: string) => Promise<string[]>)\n    | _TextSplitterInterface;\n}\n\n/**\n * Trim messages to be below a token count.\n *\n * @param {BaseMessage[]} messages Array of `BaseMessage` instances to trim.\n * @param {TrimMessagesFields} options Trimming options.\n * @returns An array of trimmed `BaseMessage`s or a `Runnable` that takes a sequence of `BaseMessage`-like objects and returns\n *     an array of trimmed `BaseMessage`s.\n * @throws {Error} If two incompatible arguments are specified or an unrecognized `strategy` is specified.\n *\n * @example\n * ```typescript\n * import { trimMessages, AIMessage, BaseMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"This is a 4 token text. The full message is 10 tokens.\"),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"This is the FIRST 4 token block.\" },\n *       { type: \"text\", text: \"This is the SECOND 4 token block.\" },\n *     ],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ];\n *\n * function dummyTokenCounter(messages: BaseMessage[]): number {\n *   // treat each message like it adds 3 default tokens at the beginning\n *   // of the message and at the end of the message. 3 + 4 + 3 = 10 tokens\n *   // per message.\n *\n *   const defaultContentLen = 4;\n *   const defaultMsgPrefixLen = 3;\n *   const defaultMsgSuffixLen = 3;\n *\n *   let count = 0;\n *   for (const msg of messages) {\n *     if (typeof msg.content === \"string\") {\n *       count += defaultMsgPrefixLen + defaultContentLen + defaultMsgSuffixLen;\n *     }\n *     if (Array.isArray(msg.content)) {\n *       count +=\n *         defaultMsgPrefixLen +\n *         msg.content.length * defaultContentLen +\n *         defaultMsgSuffixLen;\n *     }\n *   }\n *   return count;\n * }\n * ```\n *\n * First 30 tokens, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages, have to end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n *   endOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   includeSystem: true,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   allowPartial: true,\n *   includeSystem: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, allowing partial messages, end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   endOn: \"human\",\n *   includeSystem: true,\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages, start on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   includeSystem: true,\n *   allowPartial: true,\n *   startOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n */\nexport function trimMessages(\n  options: TrimMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function trimMessages(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<BaseMessage[]>;\nexport function trimMessages(\n  messagesOrOptions: BaseMessage[] | TrimMessagesFields,\n  options?: TrimMessagesFields\n): Promise<BaseMessage[]> | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    const messages = messagesOrOptions;\n    if (!options) {\n      throw new Error(\"Options parameter is required when providing messages.\");\n    }\n    return _trimMessagesHelper(messages, options);\n  } else {\n    const trimmerOptions = messagesOrOptions;\n    return RunnableLambda.from((input: BaseMessage[]) =>\n      _trimMessagesHelper(input, trimmerOptions)\n    ).withConfig({\n      runName: \"trim_messages\",\n    });\n  }\n}\n\nasync function _trimMessagesHelper(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<Array<BaseMessage>> {\n  const {\n    maxTokens,\n    tokenCounter,\n    strategy = \"last\",\n    allowPartial = false,\n    endOn,\n    startOn,\n    includeSystem = false,\n    textSplitter,\n  } = options;\n  if (startOn && strategy === \"first\") {\n    throw new Error(\n      \"`startOn` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n  if (includeSystem && strategy === \"first\") {\n    throw new Error(\n      \"`includeSystem` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n\n  let listTokenCounter: (msgs: BaseMessage[]) => Promise<number>;\n  if (\"getNumTokens\" in tokenCounter) {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> => {\n      const tokenCounts = await Promise.all(\n        msgs.map((msg) => tokenCounter.getNumTokens(msg.content))\n      );\n      return tokenCounts.reduce((sum, count) => sum + count, 0);\n    };\n  } else {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> =>\n      tokenCounter(msgs);\n  }\n\n  let textSplitterFunc: (text: string) => Promise<string[]> =\n    defaultTextSplitter;\n  if (textSplitter) {\n    if (\"splitText\" in textSplitter) {\n      textSplitterFunc = textSplitter.splitText;\n    } else {\n      textSplitterFunc = async (text: string): Promise<string[]> =>\n        textSplitter(text);\n    }\n  }\n\n  if (strategy === \"first\") {\n    return _firstMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      partialStrategy: allowPartial ? \"first\" : undefined,\n      endOn,\n    });\n  } else if (strategy === \"last\") {\n    return _lastMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      allowPartial,\n      includeSystem,\n      startOn,\n      endOn,\n    });\n  } else {\n    throw new Error(\n      `Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`\n    );\n  }\n}\n\nasync function _firstMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    partialStrategy?: \"first\" | \"last\";\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } =\n    options;\n  let messagesCopy = [...messages];\n  let idx = 0;\n  for (let i = 0; i < messagesCopy.length; i += 1) {\n    const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n    if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n      idx = messagesCopy.length - i;\n      break;\n    }\n  }\n  if (idx < messagesCopy.length && partialStrategy) {\n    let includedPartial = false;\n    if (Array.isArray(messagesCopy[idx].content)) {\n      const excluded = messagesCopy[idx];\n      if (typeof excluded.content === \"string\") {\n        throw new Error(\"Expected content to be an array.\");\n      }\n\n      const numBlock = excluded.content.length;\n      const reversedContent =\n        partialStrategy === \"last\"\n          ? [...excluded.content].reverse()\n          : excluded.content;\n      for (let i = 1; i <= numBlock; i += 1) {\n        const partialContent =\n          partialStrategy === \"first\"\n            ? reversedContent.slice(0, i)\n            : reversedContent.slice(-i);\n        const fields = Object.fromEntries(\n          Object.entries(excluded).filter(\n            ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n          )\n        ) as BaseMessageFields;\n        const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n          ...fields,\n          content: partialContent,\n        });\n        const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n        if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n          messagesCopy = slicedMessages;\n          idx += 1;\n          includedPartial = true;\n        } else {\n          break;\n        }\n      }\n      if (includedPartial && partialStrategy === \"last\") {\n        excluded.content = [...reversedContent].reverse();\n      }\n    }\n    if (!includedPartial) {\n      const excluded = messagesCopy[idx];\n      let text: string | undefined;\n      if (\n        Array.isArray(excluded.content) &&\n        excluded.content.some(\n          (block) => typeof block === \"string\" || block.type === \"text\"\n        )\n      ) {\n        const textBlock = excluded.content.find(\n          (block) => block.type === \"text\" && block.text\n        ) as { type: \"text\"; text: string } | undefined;\n        text = textBlock?.text;\n      } else if (typeof excluded.content === \"string\") {\n        text = excluded.content;\n      }\n      if (text) {\n        const splitTexts = await textSplitter(text);\n        const numSplits = splitTexts.length;\n        if (partialStrategy === \"last\") {\n          splitTexts.reverse();\n        }\n        for (let _ = 0; _ < numSplits - 1; _ += 1) {\n          splitTexts.pop();\n          excluded.content = splitTexts.join(\"\");\n          if (\n            (await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n            maxTokens\n          ) {\n            if (partialStrategy === \"last\") {\n              excluded.content = [...splitTexts].reverse().join(\"\");\n            }\n            messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n            idx += 1;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n      idx -= 1;\n    }\n  }\n\n  return messagesCopy.slice(0, idx);\n}\n\nasync function _lastMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const {\n    allowPartial = false,\n    includeSystem = false,\n    endOn,\n    startOn,\n    ...rest\n  } = options;\n\n  // Create a copy of messages to avoid mutation\n  let messagesCopy = messages.map((message) => {\n    const fields = Object.fromEntries(\n      Object.entries(message).filter(\n        ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n      )\n    ) as BaseMessageFields;\n    return _switchTypeToMessage(\n      message.getType(),\n      fields,\n      isBaseMessageChunk(message)\n    );\n  });\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (\n      messagesCopy.length > 0 &&\n      !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)\n    ) {\n      messagesCopy = messagesCopy.slice(0, -1);\n    }\n  }\n\n  const swappedSystem =\n    includeSystem && messagesCopy[0]?.getType() === \"system\";\n  let reversed_ = swappedSystem\n    ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n    : messagesCopy.reverse();\n\n  reversed_ = await _firstMaxTokens(reversed_, {\n    ...rest,\n    partialStrategy: allowPartial ? \"last\" : undefined,\n    endOn: startOn,\n  });\n\n  if (swappedSystem) {\n    return [reversed_[0], ...reversed_.slice(1).reverse()];\n  } else {\n    return reversed_.reverse();\n  }\n}\n\nconst _MSG_CHUNK_MAP: Record<\n  MessageType,\n  {\n    message: MessageUnion;\n    messageChunk: MessageChunkUnion;\n  }\n> = {\n  human: {\n    message: HumanMessage,\n    messageChunk: HumanMessageChunk,\n  },\n  ai: {\n    message: AIMessage,\n    messageChunk: AIMessageChunk,\n  },\n  system: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  developer: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  tool: {\n    message: ToolMessage,\n    messageChunk: ToolMessageChunk,\n  },\n  function: {\n    message: FunctionMessage,\n    messageChunk: FunctionMessageChunk,\n  },\n  generic: {\n    message: ChatMessage,\n    messageChunk: ChatMessageChunk,\n  },\n  remove: {\n    message: RemoveMessage,\n    messageChunk: RemoveMessage, // RemoveMessage does not have a chunk class.\n  },\n};\n\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields\n): BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk: true\n): BaseMessageChunk;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage {\n  let chunk: BaseMessageChunk | undefined;\n  let msg: BaseMessage | undefined;\n\n  switch (messageType) {\n    case \"human\":\n      if (returnChunk) {\n        chunk = new HumanMessageChunk(fields);\n      } else {\n        msg = new HumanMessage(fields);\n      }\n      break;\n    case \"ai\":\n      if (returnChunk) {\n        let aiChunkFields: AIMessageChunkFields = {\n          ...fields,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n          aiChunkFields = {\n            ...aiChunkFields,\n            tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n              ...tc,\n              type: \"tool_call_chunk\",\n              index: undefined,\n              args: JSON.stringify(tc.args),\n            })),\n          };\n        }\n        chunk = new AIMessageChunk(aiChunkFields);\n      } else {\n        msg = new AIMessage(fields);\n      }\n      break;\n    case \"system\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk(fields);\n      } else {\n        msg = new SystemMessage(fields);\n      }\n      break;\n    case \"developer\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      } else {\n        msg = new SystemMessage({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      }\n      break;\n    case \"tool\":\n      if (\"tool_call_id\" in fields) {\n        if (returnChunk) {\n          chunk = new ToolMessageChunk(fields as ToolMessageFields);\n        } else {\n          msg = new ToolMessage(fields as ToolMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\"\n        );\n      }\n      break;\n    case \"function\":\n      if (returnChunk) {\n        chunk = new FunctionMessageChunk(fields as FunctionMessageFields);\n      } else {\n        if (!fields.name) {\n          throw new Error(\"FunctionMessage must have a 'name' field\");\n        }\n        msg = new FunctionMessage(fields as FunctionMessageFields);\n      }\n      break;\n    case \"generic\":\n      if (\"role\" in fields) {\n        if (returnChunk) {\n          chunk = new ChatMessageChunk(fields as ChatMessageFields);\n        } else {\n          msg = new ChatMessage(fields as ChatMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\"\n        );\n      }\n      break;\n    default:\n      throw new Error(`Unrecognized message type ${messageType}`);\n  }\n\n  if (returnChunk && chunk) {\n    return chunk;\n  }\n  if (msg) {\n    return msg;\n  }\n  throw new Error(`Unrecognized message type ${messageType}`);\n}\n\nfunction _chunkToMsg(chunk: BaseMessageChunk): BaseMessage {\n  const chunkType = chunk.getType();\n  let msg: BaseMessage | undefined;\n  const fields = Object.fromEntries(\n    Object.entries(chunk).filter(\n      ([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")\n    )\n  ) as BaseMessageFields;\n\n  if (chunkType in _MSG_CHUNK_MAP) {\n    msg = _switchTypeToMessage(chunkType, fields);\n  }\n\n  if (!msg) {\n    throw new Error(\n      `Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(\n        _MSG_CHUNK_MAP\n      )}`\n    );\n  }\n\n  return msg;\n}\n\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport function defaultTextSplitter(text: string): Promise<string[]> {\n  const splits = text.split(\"\\n\");\n  return Promise.resolve([\n    ...splits.slice(0, -1).map((s) => `${s}\\n`),\n    splits[splits.length - 1],\n  ]);\n}\n"],"names":["msg: BaseMessage","types: MessageTypeOrClass[]","messagesOrOptions?: BaseMessage[] | FilterMessagesFields","options?: FilterMessagesFields","input: BaseMessage[]","messages: BaseMessage[]","options: FilterMessagesFields","filtered: BaseMessage[]","messages?: BaseMessage[]","merged: BaseMessage[]","messagesOrOptions: BaseMessage[] | TrimMessagesFields","options?: TrimMessagesFields","options: TrimMessagesFields","listTokenCounter: (msgs: BaseMessage[]) => Promise<number>","msgs: BaseMessage[]","textSplitterFunc: (text: string) => Promise<string[]>","text: string","options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    partialStrategy?: \"first\" | \"last\";\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }","text: string | undefined","options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }","_MSG_CHUNK_MAP: Record<\n  MessageType,\n  {\n    message: MessageUnion;\n    messageChunk: MessageChunkUnion;\n  }\n>","messageType: MessageType","fields: BaseMessageFields","returnChunk?: boolean","chunk: BaseMessageChunk | undefined","msg: BaseMessage | undefined","aiChunkFields: AIMessageChunkFields","chunk: BaseMessageChunk"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA,MAAM,iBAAiB,CAACA,KAAkBC,UAAgC;IACxE,MAAM,iBAAiB,CACrB;WAAG,IAAI,IACL,OAAO,IAAI,CAAC,MAAM;YAChB,IAAI,OAAO,MAAM,SACf,CAAA,OAAO;YAGT,MAAM,uBAAuB,IAAK,EAAU,CAAE;YAC9C,IACE,CAAA,CAAE,aAAa,oBAAA,KACf,OAAO,qBAAqB,OAAA,KAAY,WAExC,CAAA,MAAM,IAAI,MAAM;YAElB,OAAO,qBAAqB,OAAA,EAAS;QACtC,EAAC,CAEL;KAAA;IACD,MAAM,UAAU,IAAI,OAAA,EAAS;IAC7B,OAAO,eAAe,IAAA,CAAK,CAAC,IAAM,MAAM,QAAQ;AACjD;AA6ED,SAAgB,eACdC,iBAAAA,EACAC,OAAAA,EACwD;IACxD,IAAI,MAAM,OAAA,CAAQ,kBAAkB,CAClC,CAAA,OAAO,gBAAgB,mBAAmB,QAAQ;IAEpD,OAAO,oLAAA,CAAe,IAAA,CAAK,CAACC,UAAwC;QAClE,OAAO,gBAAgB,OAAO,kBAAkB;IACjD,EAAC;AACH;AAED,SAAS,gBACPC,QAAAA,EACAC,UAAgC,CAAE,CAAA,EACnB;IACf,MAAM,EACJ,YAAA,EACA,YAAA,EACA,YAAA,EACA,YAAA,EACA,UAAA,EACA,UAAA,EACD,GAAG;IAEJ,MAAMC,WAA0B,CAAE,CAAA;IAElC,KAAK,MAAM,OAAO,SAAU;QAC1B,IAAI,gBAAgB,IAAI,IAAA,IAAQ,aAAa,QAAA,CAAS,IAAI,IAAA,CAAK,CAC7D,CAAA;iBACS,gBAAgB,eAAe,KAAK,aAAa,CAC1D,CAAA;iBACS,cAAc,IAAI,EAAA,IAAM,WAAW,QAAA,CAAS,IAAI,EAAA,CAAG,CAC5D,CAAA;QAIF,IAAI,CAAA,CAAE,gBAAgB,cAAc,YAAA,GAClC,SAAS,IAAA,CAAK,IAAI;iBAElB,gBACA,IAAI,IAAA,IACJ,aAAa,IAAA,CAAK,CAAC,QAAU,UAAU,IAAI,IAAA,CAAK,EAEhD,SAAS,IAAA,CAAK,IAAI;iBACT,gBAAgB,eAAe,KAAK,aAAa,EAC1D,SAAS,IAAA,CAAK,IAAI;iBACT,cAAc,IAAI,EAAA,IAAM,WAAW,IAAA,CAAK,CAAC,KAAO,OAAO,IAAI,EAAA,CAAG,EACvE,SAAS,IAAA,CAAK,IAAI;IAErB;IAED,OAAO;AACR;AA8DD,SAAgB,iBACdC,QAAAA,EACwD;IACxD,IAAI,MAAM,OAAA,CAAQ,SAAS,CACzB,CAAA,OAAO,kBAAkB,SAAS;IAEpC,OAAO,oLAAA,CAAe,IAAA,CAAK,kBAAkB;AAC9C;AAED,SAAS,kBAAkBH,QAAAA,EAAwC;IACjE,IAAI,CAAC,SAAS,MAAA,CACZ,CAAA,OAAO,CAAE,CAAA;IAEX,MAAMI,SAAwB,CAAE,CAAA;IAChC,KAAK,MAAM,OAAO,SAAU;QAC1B,MAAM,OAAO;QACb,MAAM,OAAO,OAAO,GAAA,EAAK;QACzB,IAAI,CAAC,MACH,OAAO,IAAA,CAAK,KAAK;iBAEjB,KAAK,OAAA,EAAS,KAAK,UACnB,CAAA,CAAE,KAAK,OAAA,EAAS,KAAK,KAAK,OAAA,EAAS,GAEnC,OAAO,IAAA,CAAK,MAAM,KAAK;aAClB;YACL,MAAM,gBAAY,oLAAA,EAAe,KAAK;YACtC,MAAM,gBAAY,oLAAA,EAAe,KAAK;YACtC,MAAM,eAAe,UAAU,MAAA,CAAO,UAAU;YAChD,IACE,OAAO,UAAU,OAAA,KAAY,YAC7B,OAAO,UAAU,OAAA,KAAY,UAE7B,aAAa,OAAA,GAAU,GAAG,UAAU,OAAA,CAAQ,EAAE,EAAE,UAAU,OAAA,EAAS;YAErE,OAAO,IAAA,CAAK,YAAY,aAAa,CAAC;QACvC;IACF;IACD,OAAO;AACR;AA4UD,SAAgB,aACdC,iBAAAA,EACAC,OAAAA,EACiE;IACjE,IAAI,MAAM,OAAA,CAAQ,kBAAkB,EAAE;QACpC,MAAM,WAAW;QACjB,IAAI,CAAC,QACH,CAAA,MAAM,IAAI,MAAM;QAElB,OAAO,oBAAoB,UAAU,QAAQ;IAC9C,OAAM;QACL,MAAM,iBAAiB;QACvB,OAAO,oLAAA,CAAe,IAAA,CAAK,CAACP,QAC1B,oBAAoB,OAAO,eAAe,CAC3C,CAAC,UAAA,CAAW;YACX,SAAS;QACV,EAAC;IACH;AACF;AAED,eAAe,oBACbC,QAAAA,EACAO,OAAAA,EAC6B;IAC7B,MAAM,EACJ,SAAA,EACA,YAAA,EACA,WAAW,MAAA,EACX,eAAe,KAAA,EACf,KAAA,EACA,OAAA,EACA,gBAAgB,KAAA,EAChB,YAAA,EACD,GAAG;IACJ,IAAI,WAAW,aAAa,QAC1B,CAAA,MAAM,IAAI,MACR;IAGJ,IAAI,iBAAiB,aAAa,QAChC,CAAA,MAAM,IAAI,MACR;IAIJ,IAAIC;IACJ,IAAI,kBAAkB,cACpB,mBAAmB,OAAOC,SAAyC;QACjE,MAAM,cAAc,MAAM,QAAQ,GAAA,CAChC,KAAK,GAAA,CAAI,CAAC,MAAQ,aAAa,YAAA,CAAa,IAAI,OAAA,CAAQ,CAAC,CAC1D;QACD,OAAO,YAAY,MAAA,CAAO,CAAC,KAAK,QAAU,MAAM,OAAO,EAAE;IAC1D;SAED,mBAAmB,OAAOA,OACxB,aAAa,KAAK;IAGtB,IAAIC,mBACF;IACF,IAAI,aACF,CAAA,IAAI,eAAe,cACjB,mBAAmB,aAAa,SAAA;SAEhC,mBAAmB,OAAOC,OACxB,aAAa,KAAK;IAIxB,IAAI,aAAa,QACf,CAAA,OAAO,gBAAgB,UAAU;QAC/B;QACA,cAAc;QACd,cAAc;QACd,iBAAiB,eAAe,UAAU,KAAA;QAC1C;IACD,EAAC;aACO,aAAa,OACtB,CAAA,OAAO,eAAe,UAAU;QAC9B;QACA,cAAc;QACd,cAAc;QACd;QACA;QACA;QACA;IACD,EAAC;SAEF,MAAM,IAAI,MACR,CAAC,wBAAwB,EAAE,SAAS,oCAAoC,CAAC;AAG9E;AAED,eAAe,gBACbX,QAAAA,EACAY,OAAAA,EAOwB;IACxB,MAAM,EAAE,SAAA,EAAW,YAAA,EAAc,YAAA,EAAc,eAAA,EAAiB,KAAA,EAAO,GACrE;IACF,IAAI,eAAe,CAAC;WAAG,QAAS;KAAA;IAChC,IAAI,MAAM;IACV,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,MAAA,EAAQ,KAAK,EAAG;QAC/C,MAAM,oBAAoB,IAAI,IAAI,aAAa,KAAA,CAAM,GAAG,CAAC,EAAE,GAAG;QAC9D,IAAK,MAAM,aAAa,kBAAkB,IAAK,WAAW;YACxD,MAAM,aAAa,MAAA,GAAS;YAC5B;QACD;IACF;IACD,IAAI,MAAM,aAAa,MAAA,IAAU,iBAAiB;QAChD,IAAI,kBAAkB;QACtB,IAAI,MAAM,OAAA,CAAQ,YAAA,CAAa,IAAA,CAAK,OAAA,CAAQ,EAAE;YAC5C,MAAM,WAAW,YAAA,CAAa,IAAA;YAC9B,IAAI,OAAO,SAAS,OAAA,KAAY,SAC9B,CAAA,MAAM,IAAI,MAAM;YAGlB,MAAM,WAAW,SAAS,OAAA,CAAQ,MAAA;YAClC,MAAM,kBACJ,oBAAoB,SAChB,CAAC;mBAAG,SAAS,OAAQ;aAAA,CAAC,OAAA,EAAS,GAC/B,SAAS,OAAA;YACf,IAAK,IAAI,IAAI,GAAG,KAAK,UAAU,KAAK,EAAG;gBACrC,MAAM,iBACJ,oBAAoB,UAChB,gBAAgB,KAAA,CAAM,GAAG,EAAE,GAC3B,gBAAgB,KAAA,CAAM,CAAC,EAAE;gBAC/B,MAAM,SAAS,OAAO,WAAA,CACpB,OAAO,OAAA,CAAQ,SAAS,CAAC,MAAA,CACvB,CAAC,CAAC,EAAE,GAAK,MAAM,UAAU,CAAC,EAAE,UAAA,CAAW,MAAM,CAC9C,CACF;gBACD,MAAM,iBAAiB,qBAAqB,SAAS,OAAA,EAAS,EAAE;oBAC9D,GAAG,MAAA;oBACH,SAAS;gBACV,EAAC;gBACF,MAAM,iBAAiB,CAAC;uBAAG,aAAa,KAAA,CAAM,GAAG,IAAI;oBAAE,cAAe;iBAAA;gBACtE,IAAK,MAAM,aAAa,eAAe,IAAK,WAAW;oBACrD,eAAe;oBACf,OAAO;oBACP,kBAAkB;gBACnB,MACC,CAAA;YAEH;YACD,IAAI,mBAAmB,oBAAoB,QACzC,SAAS,OAAA,GAAU,CAAC;mBAAG,eAAgB;aAAA,CAAC,OAAA,EAAS;QAEpD;QACD,IAAI,CAAC,iBAAiB;YACpB,MAAM,WAAW,YAAA,CAAa,IAAA;YAC9B,IAAIC;YACJ,IACE,MAAM,OAAA,CAAQ,SAAS,OAAA,CAAQ,IAC/B,SAAS,OAAA,CAAQ,IAAA,CACf,CAAC,QAAU,OAAO,UAAU,YAAY,MAAM,IAAA,KAAS,OACxD,EACD;gBACA,MAAM,YAAY,SAAS,OAAA,CAAQ,IAAA,CACjC,CAAC,QAAU,MAAM,IAAA,KAAS,UAAU,MAAM,IAAA,CAC3C;gBACD,OAAO,WAAW;YACnB,OAAA,IAAU,OAAO,SAAS,OAAA,KAAY,UACrC,OAAO,SAAS,OAAA;YAElB,IAAI,MAAM;gBACR,MAAM,aAAa,MAAM,aAAa,KAAK;gBAC3C,MAAM,YAAY,WAAW,MAAA;gBAC7B,IAAI,oBAAoB,QACtB,WAAW,OAAA,EAAS;gBAEtB,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,GAAG,KAAK,EAAG;oBACzC,WAAW,GAAA,EAAK;oBAChB,SAAS,OAAA,GAAU,WAAW,IAAA,CAAK,GAAG;oBACtC,IACG,MAAM,aAAa,CAAC;2BAAG,aAAa,KAAA,CAAM,GAAG,IAAI;wBAAE,QAAS;qBAAA,CAAC,IAC9D,WACA;wBACA,IAAI,oBAAoB,QACtB,SAAS,OAAA,GAAU,CAAC;+BAAG,UAAW;yBAAA,CAAC,OAAA,EAAS,CAAC,IAAA,CAAK,GAAG;wBAEvD,eAAe,CAAC;+BAAG,aAAa,KAAA,CAAM,GAAG,IAAI;4BAAE,QAAS;yBAAA;wBACxD,OAAO;wBACP;oBACD;gBACF;YACF;QACF;IACF;IAED,IAAI,OAAO;QACT,MAAM,WAAW,MAAM,OAAA,CAAQ,MAAM,GAAG,QAAQ;YAAC,KAAM;SAAA;QACvD,MAAO,MAAM,KAAK,CAAC,eAAe,YAAA,CAAa,MAAM,EAAA,EAAI,SAAS,CAChE,OAAO;IAEV;IAED,OAAO,aAAa,KAAA,CAAM,GAAG,IAAI;AAClC;AAED,eAAe,eACbb,QAAAA,EACAc,OAAAA,EAewB;IACxB,MAAM,EACJ,eAAe,KAAA,EACf,gBAAgB,KAAA,EAChB,KAAA,EACA,OAAA,EACA,GAAG,MACJ,GAAG;IAGJ,IAAI,eAAe,SAAS,GAAA,CAAI,CAAC,YAAY;QAC3C,MAAM,SAAS,OAAO,WAAA,CACpB,OAAO,OAAA,CAAQ,QAAQ,CAAC,MAAA,CACtB,CAAC,CAAC,EAAE,GAAK,MAAM,UAAU,CAAC,EAAE,UAAA,CAAW,MAAM,CAC9C,CACF;QACD,OAAO,qBACL,QAAQ,OAAA,EAAS,EACjB,YACA,uLAAA,EAAmB,QAAQ,CAC5B;IACF,EAAC;IAEF,IAAI,OAAO;QACT,MAAM,WAAW,MAAM,OAAA,CAAQ,MAAM,GAAG,QAAQ;YAAC,KAAM;SAAA;QACvD,MACE,aAAa,MAAA,GAAS,KACtB,CAAC,eAAe,YAAA,CAAa,aAAa,MAAA,GAAS,EAAA,EAAI,SAAS,CAEhE,eAAe,aAAa,KAAA,CAAM,GAAG,CAAA,EAAG;IAE3C;IAED,MAAM,gBACJ,iBAAiB,YAAA,CAAa,EAAA,EAAI,SAAS,KAAK;IAClD,IAAI,YAAY,gBACZ,aAAa,KAAA,CAAM,GAAG,EAAE,CAAC,MAAA,CAAO,aAAa,KAAA,CAAM,EAAE,CAAC,OAAA,EAAS,CAAC,GAChE,aAAa,OAAA,EAAS;IAE1B,YAAY,MAAM,gBAAgB,WAAW;QAC3C,GAAG,IAAA;QACH,iBAAiB,eAAe,SAAS,KAAA;QACzC,OAAO;IACR,EAAC;IAEF,IAAI,cACF,CAAA,OAAO;QAAC,SAAA,CAAU,EAAA,EAAI;WAAG,UAAU,KAAA,CAAM,EAAE,CAAC,OAAA,EAAS,AAAC;KAAA;SAEtD,OAAO,UAAU,OAAA,EAAS;AAE7B;AAED,MAAMC,iBAMF;IACF,OAAO;QACL,SAAS,kLAAA;QACT,cAAc,uLAAA;IACf;IACD,IAAI;QACF,SAAS,4KAAA;QACT,cAAc,iLAAA;IACf;IACD,QAAQ;QACN,SAAS,oLAAA;QACT,cAAc,yLAAA;IACf;IACD,WAAW;QACT,SAAS,oLAAA;QACT,cAAc,yLAAA;IACf;IACD,MAAM;QACJ,SAAS,gLAAA;QACT,cAAc,qLAAA;IACf;IACD,UAAU;QACR,SAAS,wLAAA;QACT,cAAc,6LAAA;IACf;IACD,SAAS;QACP,SAAS,gLAAA;QACT,cAAc,qLAAA;IACf;IACD,QAAQ;QACN,SAAS,sLAAA;QACT,cAAc,sLAAA;IACf;AACF;AAgBD,SAAS,qBACPC,WAAAA,EACAC,MAAAA,EACAC,WAAAA,EACgC;IAChC,IAAIC;IACJ,IAAIC;IAEJ,OAAQ,aAAR;QACE,KAAK;YACH,IAAI,aACF,QAAQ,IAAI,uLAAA,CAAkB;iBAE9B,MAAM,IAAI,kLAAA,CAAa;YAEzB;QACF,KAAK;YACH,IAAI,aAAa;gBACf,IAAIC,gBAAsC;oBACxC,GAAG,MAAA;gBACJ;gBACD,IAAI,gBAAgB,eAClB,gBAAgB;oBACd,GAAG,aAAA;oBACH,kBAAkB,cAAc,UAAA,EAAY,IAAI,CAAC,KAAA,CAAQ;4BACvD,GAAG,EAAA;4BACH,MAAM;4BACN,OAAO,KAAA;4BACP,MAAM,KAAK,SAAA,CAAU,GAAG,IAAA,CAAK;wBAC9B,CAAA,EAAE;gBACJ;gBAEH,QAAQ,IAAI,iLAAA,CAAe;YAC5B,OACC,MAAM,IAAI,4KAAA,CAAU;YAEtB;QACF,KAAK;YACH,IAAI,aACF,QAAQ,IAAI,yLAAA,CAAmB;iBAE/B,MAAM,IAAI,oLAAA,CAAc;YAE1B;QACF,KAAK;YACH,IAAI,aACF,QAAQ,IAAI,yLAAA,CAAmB;gBAC7B,GAAG,MAAA;gBACH,mBAAmB;oBACjB,GAAG,OAAO,iBAAA;oBACV,iBAAiB;gBAClB;YACF;iBAED,MAAM,IAAI,oLAAA,CAAc;gBACtB,GAAG,MAAA;gBACH,mBAAmB;oBACjB,GAAG,OAAO,iBAAA;oBACV,iBAAiB;gBAClB;YACF;YAEH;QACF,KAAK;YACH,IAAI,kBAAkB,OACpB,CAAA,IAAI,aACF,QAAQ,IAAI,qLAAA,CAAiB;iBAE7B,MAAM,IAAI,gLAAA,CAAY;iBAGxB,MAAM,IAAI,MACR;YAGJ;QACF,KAAK;YACH,IAAI,aACF,QAAQ,IAAI,6LAAA,CAAqB;iBAC5B;gBACL,IAAI,CAAC,OAAO,IAAA,CACV,CAAA,MAAM,IAAI,MAAM;gBAElB,MAAM,IAAI,wLAAA,CAAgB;YAC3B;YACD;QACF,KAAK;YACH,IAAI,UAAU,OACZ,CAAA,IAAI,aACF,QAAQ,IAAI,qLAAA,CAAiB;iBAE7B,MAAM,IAAI,gLAAA,CAAY;iBAGxB,MAAM,IAAI,MACR;YAGJ;QACF,QACE;YAAA,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,aAAa;IAC7D;IAED,IAAI,eAAe,MACjB,CAAA,OAAO;IAET,IAAI,IACF,CAAA,OAAO;IAET,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,aAAa;AAC3D;AAED,SAAS,YAAYC,KAAAA,EAAsC;IACzD,MAAM,YAAY,MAAM,OAAA,EAAS;IACjC,IAAIF;IACJ,MAAM,SAAS,OAAO,WAAA,CACpB,OAAO,OAAA,CAAQ,MAAM,CAAC,MAAA,CACpB,CAAC,CAAC,EAAE,GAAK,CAAC;YAAC;YAAQ,kBAAmB;SAAA,CAAC,QAAA,CAAS,EAAE,IAAI,CAAC,EAAE,UAAA,CAAW,MAAM,CAC3E,CACF;IAED,IAAI,aAAa,gBACf,MAAM,qBAAqB,WAAW,OAAO;IAG/C,IAAI,CAAC,IACH,CAAA,MAAM,IAAI,MACR,CAAC,iCAAiC,EAAE,UAAU,wBAAwB,EAAE,OAAO,IAAA,CAC7E,eACD,EAAE;IAIP,OAAO;AACR;;;;;;GAQD,SAAgB,oBAAoBT,IAAAA,EAAiC;IACnE,MAAM,SAAS,KAAK,KAAA,CAAM,KAAK;IAC/B,OAAO,QAAQ,OAAA,CAAQ,CACrB;WAAG,OAAO,KAAA,CAAM,GAAG,CAAA,EAAG,CAAC,GAAA,CAAI,CAAC,IAAM,GAAG,EAAE,EAAE,CAAC,CAAC;QAC3C,MAAA,CAAO,OAAO,MAAA,GAAS,EACxB;KAAA,CAAC;AACH"}},
    {"offset": {"line": 6720, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/tools.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/tools.ts"],"sourcesContent":["import { BaseContentBlock } from \"./base.js\";\n\nexport type Tools = never;\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"tool_call\",\n  \"tool_call_chunk\",\n  \"invalid_tool_call\",\n  \"server_tool_call\",\n  \"server_tool_call_chunk\",\n  \"server_tool_call_result\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Tools {\n  /**\n   * Represents a request to call a tool.\n   *\n   * @example\n   * ```ts\n   * const toolCall: ToolCall = {\n   *     type: \"tool_call\",\n   *     name: \"foo\",\n   *     args: { a: 1 },\n   *     callId: \"123\"\n   * };\n   * ```\n   * This represents a request to call the tool named \"foo\" with arguments {\"a\": 1}\n   * and an identifier of \"123\".\n   */\n  export interface ToolCall<TName extends string = string, TArgs = unknown>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args: TArgs;\n  }\n\n  /** Content block to represent partial data of a tool call */\n  export interface ToolCallChunk<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"tool_call_chunk\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n    /**\n     * The index of the tool call chunk\n     */\n    index?: number;\n  }\n\n  /** Content block to represent an invalid tool call */\n  export interface InvalidToolCall<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"invalid_tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n    /**\n     * An error message associated with the tool call\n     */\n    error?: string;\n    /**\n     * Index of block in aggregate response\n     */\n    index?: string | number;\n  }\n\n  export interface ServerToolCall<\n    TName extends string = string,\n    TArgs = unknown\n  > extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args: TArgs;\n  }\n\n  export interface ServerToolCallChunk<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call_chunk\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n  }\n\n  export interface ServerToolCallResult<TOutput = Record<string, unknown>>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call_result\";\n    /**\n     * The unique identifier of the tool call that this result corresponds to\n     */\n    toolCallId: string;\n    /**\n     * The status of the server tool call\n     */\n    status: \"success\" | \"error\";\n    /**\n     * The output of the server tool call\n     */\n    output: TOutput;\n  }\n\n  export type Standard =\n    | ToolCall\n    | ToolCallChunk\n    | InvalidToolCall\n    | ServerToolCall\n    | ServerToolCallChunk\n    | ServerToolCallResult;\n}\n"],"names":[],"mappings":";;;;;AAIA,MAAa,oBAAoB;IAC/B;IACA;IACA;IACA;IACA;IACA;CACD"}},
    {"offset": {"line": 6739, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/multimodal.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/multimodal.ts"],"sourcesContent":["import { BaseContentBlock } from \"./base.js\";\n\nexport type Multimodal = never;\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"image\",\n  \"video\",\n  \"audio\",\n  \"text-plain\",\n  \"file\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Multimodal {\n  type BaseDataRecord = {\n    /**\n     * MIME type of the file.\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml#image\n     */\n    mimeType?: string | undefined;\n  };\n  type DataRecordFileId = BaseDataRecord & {\n    /**\n     * ID of the data file, e.g. from a provider's file api\n     */\n    fileId: string;\n    url?: never;\n    data?: never;\n  };\n  type DataRecordUrl = BaseDataRecord & {\n    fileId?: never;\n    /**\n     * URL of the data file\n     */\n    url: string;\n    data?: never;\n  };\n  type DataRecordBase64 = BaseDataRecord & {\n    fileId?: never;\n    url?: never;\n    /**\n     * MIME type of the file. Required for base64 encoding.\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml#image\n     */\n    mimeType: string;\n    /**\n     * Base64 encoded string or binary data of the data\n     */\n    data: string | Uint8Array;\n  };\n  type DataRecord = DataRecordFileId | DataRecordUrl | DataRecordBase64;\n\n  /** Content block for multimodal data */\n  export type Data<TMetadata = Record<string, unknown>> = BaseContentBlock &\n    DataRecord & {\n      /**\n       * MIME type of the file. Required for base64 encoding.\n       */\n      mimeType?: string;\n      /**\n       * Metadata of the file\n       */\n      metadata?: TMetadata;\n      /**\n       * Content block identifier for multimodal content, e.g. image, video, audio, file or plain text. This can be either:\n       *  - generated by the provider (e.g., an OpenAI block ID)\n       *  - generated by LangChain upon creation\n       */\n      id?: string;\n    };\n\n  /** Content block for image data */\n  export type Image = Data & {\n    /** Type of the content block */\n    readonly type: \"image\";\n  };\n  /** Content block for video data */\n  export type Video = Data & {\n    /** Type of the content block */\n    readonly type: \"video\";\n  };\n  /** Content block for audio data */\n  export type Audio = Data & {\n    /** Type of the content block */\n    readonly type: \"audio\";\n  };\n  /** Content block for plain text data */\n  export type PlainText = Data & {\n    /** Type of the content block */\n    readonly type: \"text-plain\";\n    /**\n     * Plaintext content. This is optional if the data is base64 encoded.\n     */\n    text?: string;\n    /**\n     * Title of the file, e.g. the title of a document\n     */\n    title?: string;\n    /**\n     * Context for the text, e.g. a description or a summary of the text's content\n     */\n    context?: string;\n  };\n\n  /** Content block for file data */\n  export type File = Data & {\n    /**\n     * Non-descript multimodal content block\n     *\n     * This block is intended for files that aren't covered by existing content block types.\n     */\n    readonly type: \"file\";\n  };\n\n  export type Standard = Image | Video | Audio | PlainText | File;\n}\n"],"names":[],"mappings":";;;;;AAIA,MAAa,oBAAoB;IAC/B;IACA;IACA;IACA;IACA;CACD"}},
    {"offset": {"line": 6757, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/content/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/content/index.ts"],"sourcesContent":["import type { BaseContentBlock } from \"./base.js\";\nimport {\n  KNOWN_BLOCK_TYPES as KNOWN_TOOL_BLOCK_TYPES,\n  type Tools,\n} from \"./tools.js\";\nimport {\n  KNOWN_BLOCK_TYPES as KNOWN_MULTIMODAL_BLOCK_TYPES,\n  type Multimodal,\n} from \"./multimodal.js\";\nimport { type Data } from \"./data.js\";\n\nexport interface ContentBlock extends BaseContentBlock {}\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"text\",\n  \"reasoning\",\n  ...KNOWN_TOOL_BLOCK_TYPES,\n  ...KNOWN_MULTIMODAL_BLOCK_TYPES,\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace ContentBlock {\n  /**\n   * Annotation for citing data from a document.\n   */\n  export interface Citation {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"citation\";\n    /**\n     * Source type for the citation.\n     */\n    source?: string;\n    /**\n     * URL of the document source\n     */\n    url?: string;\n    /**\n     * Source document title.\n     *\n     * For example, the page title for a web page or the title of a paper.\n     */\n    title?: string;\n    /**\n     * Start index of the **response text** for which the annotation applies.\n     *\n     * @see {Text}\n     */\n    startIndex?: number;\n    /**\n     * End index of the **response text** for which the annotation applies.\n     *\n     * @see {Text}\n     */\n    endIndex?: number;\n    /**\n     * Excerpt of source text being cited.\n     */\n    citedText?: string;\n  }\n\n  /**\n   * Text output from a LLM.\n   *\n   * This typically represents the main text content of a message, such as the response\n   * from a language model or the text of a user message.\n   */\n  export interface Text extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"text\";\n    /**\n     * Block text.\n     */\n    text: string;\n    /**\n     * Index of block in aggregate response. Used during streaming.\n     */\n    index?: number;\n    /**\n     * Citations and other annotations.\n     */\n    annotations?: Array<Citation | BaseContentBlock>;\n  }\n\n  /**\n   * Reasoning output from a LLM.\n   */\n  export interface Reasoning extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"reasoning\";\n    /**\n     * Reasoning text.\n     *\n     * Either the thought summary or the raw reasoning text itself.\n     * This is often parsed from `<think>` tags in the model's response.\n     */\n    reasoning: string;\n    /**\n     * Index of block in aggregate response. Used during streaming.\n     */\n    index?: number;\n  }\n\n  /**\n   * Provider-specific content block.\n   *\n   * This is used to represent content blocks that are not part of the standard LangChain content model.\n   * If a provider's non-standard output includes reasoning and tool calls, it should be\n   * the adapter's job to parse that payload and emit the corresponding standard reasoning and tool call blocks.\n   */\n  export interface NonStandard<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    TValue extends Record<string, any> = Record<string, any>\n  > extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    type: \"non_standard\";\n    /**\n     * Provider-specific data\n     */\n    value: TValue;\n  }\n\n  export { Tools };\n  export { Multimodal };\n  export { Data };\n\n  export type Standard =\n    | Text\n    | Reasoning\n    | NonStandard\n    | Tools.Standard\n    | Multimodal.Standard;\n}\n"],"names":["KNOWN_BLOCK_TYPES","KNOWN_TOOL_BLOCK_TYPES","KNOWN_MULTIMODAL_BLOCK_TYPES"],"mappings":";;;;;;;;;AAaA,MAAaA,sBAAoB;IAC/B;IACA;OACGC,kMAAAA;OACAC,uMAAAA;CACJ"}},
    {"offset": {"line": 6778, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/messages/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/messages/index.ts"],"sourcesContent":["export * from \"./ai.js\";\nexport * from \"./base.js\";\nexport * from \"./chat.js\";\nexport * from \"./function.js\";\nexport * from \"./human.js\";\nexport * from \"./system.js\";\nexport * from \"./utils.js\";\nexport * from \"./transformers.js\";\nexport * from \"./metadata.js\";\nexport * from \"./message.js\";\nexport * from \"./modifier.js\";\nexport * from \"./tool.js\";\n\n// This is an old export for backwards compatibility with existing multimodal content blocks\n// TODO: remove this in v2\nexport * from \"./content/data.js\";\nexport * from \"./content/index.js\";\n"],"names":[],"mappings":""}}]
}