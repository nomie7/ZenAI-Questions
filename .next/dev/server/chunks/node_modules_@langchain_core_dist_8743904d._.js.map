{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/dist/_virtual/rolldown_runtime.cjs"],"sourcesContent":["//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\n\nexports.__export = __export;\nexports.__toESM = __toESM;"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B,IAAI,WAAW,OAAO,MAAM;AAC5B,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,mBAAmB,OAAO,wBAAwB;AACtD,IAAI,oBAAoB,OAAO,mBAAmB;AAClD,IAAI,eAAe,OAAO,cAAc;AACxC,IAAI,eAAe,OAAO,SAAS,CAAC,cAAc;AAClD,IAAI,WAAW,CAAC,QAAQ;IACvB,IAAK,IAAI,QAAQ,IAAK,UAAU,QAAQ,MAAM;QAC7C,KAAK,GAAG,CAAC,KAAK;QACd,YAAY;IACb;AACD;AACA,IAAI,cAAc,CAAC,IAAI,MAAM,QAAQ;IACpC,IAAI,QAAQ,OAAO,SAAS,YAAY,OAAO,SAAS,YAAY,IAAK,IAAI,OAAO,kBAAkB,OAAO,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,IAAI,GAAG,IAAK;QACrJ,MAAM,IAAI,CAAC,EAAE;QACb,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,QAAQ,QAAQ,QAAQ,UAAU,IAAI,KAAK;YACrE,KAAK,CAAC,CAAC,IAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM;YACjC,YAAY,CAAC,CAAC,OAAO,iBAAiB,MAAM,IAAI,KAAK,KAAK,UAAU;QACrE;IACD;IACA,OAAO;AACR;AACA,IAAI,UAAU,CAAC,KAAK,YAAY,SAAW,CAAC,SAAS,OAAO,OAAO,SAAS,aAAa,QAAQ,CAAC,GAAG,YAAY,cAAc,CAAC,OAAO,CAAC,IAAI,UAAU,GAAG,UAAU,QAAQ,WAAW;QACrL,OAAO;QACP,YAAY;IACb,KAAK,QAAQ,IAAI;AAEjB,YAAY;AAEZ,QAAQ,QAAQ,GAAG;AACnB,QAAQ,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/dist/_virtual/rolldown_runtime.js"],"sourcesContent":["//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n};\n\n//#endregion\nexport { __export };"],"names":[],"mappings":"AAAA,0BAA0B;;;;;AAC1B,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,WAAW,CAAC,QAAQ;IACvB,IAAK,IAAI,QAAQ,IAAK,UAAU,QAAQ,MAAM;QAC7C,KAAK,GAAG,CAAC,KAAK;QACd,YAAY;IACb;AACD","ignoreList":[0]}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/load/map_keys.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/load/map_keys.ts"],"sourcesContent":["import snakeCase from \"decamelize\";\nimport camelCase from \"camelcase\";\n\nexport interface SerializedFields {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\nexport interface SerializedKeyAlias {\n  [key: string]: string;\n}\n\nexport function keyToJson(key: string, map?: SerializedKeyAlias): string {\n  return map?.[key] || snakeCase(key);\n}\n\nexport function keyFromJson(key: string, map?: SerializedKeyAlias): string {\n  return map?.[key] || camelCase(key);\n}\n\nexport function mapKeys(\n  fields: SerializedFields,\n  mapper: typeof keyToJson,\n  map?: SerializedKeyAlias\n): SerializedFields {\n  const mapped: SerializedFields = {};\n\n  for (const key in fields) {\n    if (Object.hasOwn(fields, key)) {\n      mapped[mapper(key, map)] = fields[key];\n    }\n  }\n\n  return mapped;\n}\n"],"names":["key: string","map?: SerializedKeyAlias","fields: SerializedFields","mapper: typeof keyToJson","mapped: SerializedFields"],"mappings":";;;;AAYA,SAAgB,UAAUA,GAAAA,EAAaC,GAAAA,EAAkC;IACvE,OAAO,KAAA,CAAM,IAAA,IAAA,CAAA,GAAA,WAAA,OAAA,EAAkB,IAAI;AACpC;AAED,SAAgB,YAAYD,GAAAA,EAAaC,GAAAA,EAAkC;IACzE,OAAO,KAAA,CAAM,IAAA,IAAA,CAAA,GAAA,UAAA,OAAA,EAAkB,IAAI;AACpC;AAED,SAAgB,QACdC,MAAAA,EACAC,MAAAA,EACAF,GAAAA,EACkB;IAClB,MAAMG,SAA2B,CAAE;IAEnC,IAAK,MAAM,OAAO,OAChB,IAAI,OAAO,MAAA,CAAO,QAAQ,IAAI,EAC5B,MAAA,CAAO,OAAO,KAAK,IAAI,CAAA,GAAI,MAAA,CAAO,IAAA;IAItC,OAAO;AACR"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/load/serializable.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/load/serializable.ts"],"sourcesContent":["import { type SerializedFields, keyToJson, mapKeys } from \"./map_keys.js\";\n\nexport interface BaseSerialized<T extends string> {\n  lc: number;\n  type: T;\n  id: string[];\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  graph?: Record<string, any>;\n}\n\nexport interface SerializedConstructor extends BaseSerialized<\"constructor\"> {\n  kwargs: SerializedFields;\n}\n\nexport interface SerializedSecret extends BaseSerialized<\"secret\"> {}\n\nexport interface SerializedNotImplemented\n  extends BaseSerialized<\"not_implemented\"> {}\n\nexport type Serialized =\n  | SerializedConstructor\n  | SerializedSecret\n  | SerializedNotImplemented;\n\nfunction shallowCopy<T extends object>(obj: T): T {\n  return Array.isArray(obj) ? ([...obj] as T) : ({ ...obj } as T);\n}\n\nfunction replaceSecrets(\n  root: SerializedFields,\n  secretsMap: { [key: string]: string }\n): SerializedFields {\n  const result = shallowCopy(root);\n  for (const [path, secretId] of Object.entries(secretsMap)) {\n    const [last, ...partsReverse] = path.split(\".\").reverse();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let current: any = result;\n    for (const part of partsReverse.reverse()) {\n      if (current[part] === undefined) {\n        break;\n      }\n      current[part] = shallowCopy(current[part]);\n      current = current[part];\n    }\n    if (current[last] !== undefined) {\n      current[last] = {\n        lc: 1,\n        type: \"secret\",\n        id: [secretId],\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nexport function get_lc_unique_name(\n  serializableClass: typeof Serializable\n): string {\n  // \"super\" here would refer to the parent class of Serializable,\n  // when we want the parent class of the module actually calling this method.\n  const parentClass = Object.getPrototypeOf(serializableClass);\n  const lcNameIsSubclassed =\n    typeof serializableClass.lc_name === \"function\" &&\n    (typeof parentClass.lc_name !== \"function\" ||\n      serializableClass.lc_name() !== parentClass.lc_name());\n  if (lcNameIsSubclassed) {\n    return serializableClass.lc_name();\n  } else {\n    return serializableClass.name;\n  }\n}\n\nexport interface SerializableInterface {\n  get lc_id(): string[];\n}\n\nexport abstract class Serializable implements SerializableInterface {\n  lc_serializable = false;\n\n  lc_kwargs: SerializedFields;\n\n  /**\n   * A path to the module that contains the class, eg. [\"langchain\", \"llms\"]\n   * Usually should be the same as the entrypoint the class is exported from.\n   */\n  abstract lc_namespace: string[];\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof Serializable),\n    ];\n  }\n\n  /**\n   * A map of secrets, which will be omitted from serialization.\n   * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n   * Values are the secret ids, which will be used when deserializing.\n   */\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of additional attributes to merge with constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the attribute values, which will be serialized.\n   * These attributes need to be accepted by the constructor as arguments.\n   */\n  get lc_attributes(): SerializedFields | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of aliases for constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the alias that will replace the key in serialization.\n   * This is used to eg. make argument names match Python.\n   */\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A manual list of keys that should be serialized.\n   * If not overridden, all fields passed into the constructor will be serialized.\n   */\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  constructor(kwargs?: SerializedFields, ..._args: never[]) {\n    if (this.lc_serializable_keys !== undefined) {\n      this.lc_kwargs = Object.fromEntries(\n        Object.entries(kwargs || {}).filter(([key]) =>\n          this.lc_serializable_keys?.includes(key)\n        )\n      );\n    } else {\n      this.lc_kwargs = kwargs ?? {};\n    }\n  }\n\n  toJSON(): Serialized {\n    if (!this.lc_serializable) {\n      return this.toJSONNotImplemented();\n    }\n    if (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      this.lc_kwargs instanceof Serializable ||\n      typeof this.lc_kwargs !== \"object\" ||\n      Array.isArray(this.lc_kwargs)\n    ) {\n      // We do not support serialization of classes with arg not a POJO\n      // I'm aware the check above isn't as strict as it could be\n      return this.toJSONNotImplemented();\n    }\n\n    const aliases: { [key: string]: string } = {};\n    const secrets: { [key: string]: string } = {};\n    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n      acc[key] = key in this ? this[key as keyof this] : this.lc_kwargs[key];\n      return acc;\n    }, {} as SerializedFields);\n    // get secrets, attributes and aliases from all superclasses\n    for (\n      let current = Object.getPrototypeOf(this);\n      current;\n      current = Object.getPrototypeOf(current)\n    ) {\n      Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n      Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n      Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n    }\n\n    // include all secrets used, even if not in kwargs,\n    // will be replaced with sentinel value in replaceSecrets\n    Object.keys(secrets).forEach((keyPath) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let read: any = this;\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let write: any = kwargs;\n\n      const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n      for (const key of partsReverse.reverse()) {\n        if (!(key in read) || read[key] === undefined) return;\n        if (!(key in write) || write[key] === undefined) {\n          if (typeof read[key] === \"object\" && read[key] != null) {\n            write[key] = {};\n          } else if (Array.isArray(read[key])) {\n            write[key] = [];\n          }\n        }\n\n        read = read[key];\n        write = write[key];\n      }\n\n      if (last in read && read[last] !== undefined) {\n        write[last] = write[last] || read[last];\n      }\n    });\n\n    return {\n      lc: 1,\n      type: \"constructor\",\n      id: this.lc_id,\n      kwargs: mapKeys(\n        Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs,\n        keyToJson,\n        aliases\n      ),\n    };\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return {\n      lc: 1,\n      type: \"not_implemented\",\n      id: this.lc_id,\n    };\n  }\n}\n"],"names":["obj: T","root: SerializedFields","secretsMap: { [key: string]: string }","current: any","serializableClass: typeof Serializable","kwargs?: SerializedFields","aliases: { [key: string]: string }","secrets: { [key: string]: string }","read: any","write: any","mapKeys","keyToJson"],"mappings":";;;;;;;;AAyBA,SAAS,YAA8BA,GAAAA,EAAW;IAChD,OAAO,MAAM,OAAA,CAAQ,IAAI,GAAI,CAAC;WAAG,GAAI;KAAA,GAAU;QAAE,GAAG,GAAA;IAAK;AAC1D;AAED,SAAS,eACPC,IAAAA,EACAC,UAAAA,EACkB;IAClB,MAAM,SAAS,YAAY,KAAK;IAChC,KAAK,MAAM,CAAC,MAAM,SAAS,IAAI,OAAO,OAAA,CAAQ,WAAW,CAAE;QACzD,MAAM,CAAC,MAAM,GAAG,aAAa,GAAG,KAAK,KAAA,CAAM,IAAI,CAAC,OAAA,EAAS;QAEzD,IAAIC,UAAe;QACnB,KAAK,MAAM,QAAQ,aAAa,OAAA,EAAS,CAAE;YACzC,IAAI,OAAA,CAAQ,KAAA,KAAU,KAAA,EACpB,CAAA;YAEF,OAAA,CAAQ,KAAA,GAAQ,YAAY,OAAA,CAAQ,KAAA,CAAM;YAC1C,UAAU,OAAA,CAAQ,KAAA;QACnB;QACD,IAAI,OAAA,CAAQ,KAAA,KAAU,KAAA,GACpB,OAAA,CAAQ,KAAA,GAAQ;YACd,IAAI;YACJ,MAAM;YACN,IAAI;gBAAC,QAAS;aAAA;QACf;IAEJ;IACD,OAAO;AACR;;;;GAMD,SAAgB,mBACdC,iBAAAA,EACQ;IAGR,MAAM,cAAc,OAAO,cAAA,CAAe,kBAAkB;IAC5D,MAAM,qBACJ,OAAO,kBAAkB,OAAA,KAAY,cAAA,CACpC,OAAO,YAAY,OAAA,KAAY,cAC9B,kBAAkB,OAAA,EAAS,KAAK,YAAY,OAAA,EAAS;IACzD,IAAI,mBACF,CAAA,OAAO,kBAAkB,OAAA,EAAS;SAElC,OAAO,kBAAkB,IAAA;AAE5B;AAMD,IAAsB,eAAtB,MAAsB,aAA8C;IAClE,kBAAkB,MAAA;IAElB,UAAA;;;;;;IAcA,OAAO,UAAkB;QACvB,OAAO,IAAA,CAAK,IAAA;IACb;;;IAKD,IAAI,QAAkB;QACpB,OAAO,CACL;eAAG,IAAA,CAAK,YAAA;YACR,mBAAmB,IAAA,CAAK,WAAA,CAAmC,AAC5D;SAAA;IACF;;;;;IAOD,IAAI,aAAoD;QACtD,OAAO,KAAA;IACR;;;;;;IAQD,IAAI,gBAA8C;QAChD,OAAO,KAAA;IACR;;;;;;IAQD,IAAI,aAAoD;QACtD,OAAO,KAAA;IACR;;;;IAMD,IAAI,uBAA6C;QAC/C,OAAO,KAAA;IACR;IAED,YAAYC,MAAAA,EAA2B,GAAG,KAAA,CAAgB;QACxD,IAAI,IAAA,CAAK,oBAAA,KAAyB,KAAA,GAChC,IAAA,CAAK,SAAA,GAAY,OAAO,WAAA,CACtB,OAAO,OAAA,CAAQ,UAAU,CAAE,EAAC,CAAC,MAAA,CAAO,CAAC,CAAC,IAAI,GACxC,IAAA,CAAK,oBAAA,EAAsB,SAAS,IAAI,CACzC,CACF;aAED,IAAA,CAAK,SAAA,GAAY,UAAU,CAAE;IAEhC;IAED,SAAqB;QACnB,IAAI,CAAC,IAAA,CAAK,eAAA,CACR,CAAA,OAAO,IAAA,CAAK,oBAAA,EAAsB;QAEpC,IAEE,IAAA,CAAK,SAAA,YAAqB,gBAC1B,OAAO,IAAA,CAAK,SAAA,KAAc,YAC1B,MAAM,OAAA,CAAQ,IAAA,CAAK,SAAA,CAAU,CAI7B,CAAA,OAAO,IAAA,CAAK,oBAAA,EAAsB;QAGpC,MAAMC,UAAqC,CAAE;QAC7C,MAAMC,UAAqC,CAAE;QAC7C,MAAM,SAAS,OAAO,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,CAAC,MAAA,CAAO,CAAC,KAAK,QAAQ;YAC9D,GAAA,CAAI,IAAA,GAAO,OAAO,IAAA,GAAO,IAAA,CAAK,IAAA,GAAqB,IAAA,CAAK,SAAA,CAAU,IAAA;YAClE,OAAO;QACR,GAAE,CAAE,EAAqB;QAE1B,IACE,IAAI,UAAU,OAAO,cAAA,CAAe,IAAA,CAAK,EACzC,SACA,UAAU,OAAO,cAAA,CAAe,QAAQ,CACxC;YACA,OAAO,MAAA,CAAO,SAAS,QAAQ,GAAA,CAAI,SAAS,cAAc,IAAA,CAAK,CAAC;YAChE,OAAO,MAAA,CAAO,SAAS,QAAQ,GAAA,CAAI,SAAS,cAAc,IAAA,CAAK,CAAC;YAChE,OAAO,MAAA,CAAO,QAAQ,QAAQ,GAAA,CAAI,SAAS,iBAAiB,IAAA,CAAK,CAAC;QACnE;QAID,OAAO,IAAA,CAAK,QAAQ,CAAC,OAAA,CAAQ,CAAC,YAAY;YAExC,IAAIC,OAAY,IAAA;YAGhB,IAAIC,QAAa;YAEjB,MAAM,CAAC,MAAM,GAAG,aAAa,GAAG,QAAQ,KAAA,CAAM,IAAI,CAAC,OAAA,EAAS;YAC5D,KAAK,MAAM,OAAO,aAAa,OAAA,EAAS,CAAE;gBACxC,IAAI,CAAA,CAAE,OAAO,IAAA,KAAS,IAAA,CAAK,IAAA,KAAS,KAAA,EAAW,CAAA;gBAC/C,IAAI,CAAA,CAAE,OAAO,KAAA,KAAU,KAAA,CAAM,IAAA,KAAS,KAAA,GACpC;wBAAI,OAAO,IAAA,CAAK,IAAA,KAAS,YAAY,IAAA,CAAK,IAAA,IAAQ,MAChD,KAAA,CAAM,IAAA,GAAO,CAAE;6BACN,MAAM,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,EACjC,KAAA,CAAM,IAAA,GAAO,CAAE,CAAA;gBAChB;gBAGH,OAAO,IAAA,CAAK,IAAA;gBACZ,QAAQ,KAAA,CAAM,IAAA;YACf;YAED,IAAI,QAAQ,QAAQ,IAAA,CAAK,KAAA,KAAU,KAAA,GACjC,KAAA,CAAM,KAAA,GAAQ,KAAA,CAAM,KAAA,IAAS,IAAA,CAAK,KAAA;QAErC,EAAC;QAEF,OAAO;YACL,IAAI;YACJ,MAAM;YACN,IAAI,IAAA,CAAK,KAAA;YACT,QAAQC,iBAAAA,OAAAA,CACN,OAAO,IAAA,CAAK,QAAQ,CAAC,MAAA,GAAS,eAAe,QAAQ,QAAQ,GAAG,QAChEC,iBAAAA,SAAAA,EACA,QACD;QACF;IACF;IAED,uBAAiD;QAC/C,OAAO;YACL,IAAI;YACJ,MAAM;YACN,IAAI,IAAA,CAAK,KAAA;QACV;IACF;AACF"}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/load/map_keys.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/load/map_keys.ts"],"sourcesContent":["import snakeCase from \"decamelize\";\nimport camelCase from \"camelcase\";\n\nexport interface SerializedFields {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\nexport interface SerializedKeyAlias {\n  [key: string]: string;\n}\n\nexport function keyToJson(key: string, map?: SerializedKeyAlias): string {\n  return map?.[key] || snakeCase(key);\n}\n\nexport function keyFromJson(key: string, map?: SerializedKeyAlias): string {\n  return map?.[key] || camelCase(key);\n}\n\nexport function mapKeys(\n  fields: SerializedFields,\n  mapper: typeof keyToJson,\n  map?: SerializedKeyAlias\n): SerializedFields {\n  const mapped: SerializedFields = {};\n\n  for (const key in fields) {\n    if (Object.hasOwn(fields, key)) {\n      mapped[mapper(key, map)] = fields[key];\n    }\n  }\n\n  return mapped;\n}\n"],"names":["key: string","map?: SerializedKeyAlias","fields: SerializedFields","mapper: typeof keyToJson","mapped: SerializedFields"],"mappings":";;;;;;;;;;;;;AAYA,SAAgB,UAAUA,GAAAA,EAAaC,GAAAA,EAAkC;IACvE,OAAO,KAAA,CAAM,IAAA,QAAQ,gJAAA,EAAU,IAAI;AACpC;AAED,SAAgB,YAAYD,GAAAA,EAAaC,GAAAA,EAAkC;IACzE,OAAO,KAAA,CAAM,IAAA,QAAQ,+IAAA,EAAU,IAAI;AACpC;AAED,SAAgB,QACdC,MAAAA,EACAC,MAAAA,EACAF,GAAAA,EACkB;IAClB,MAAMG,SAA2B,CAAE;IAEnC,IAAK,MAAM,OAAO,OAChB,IAAI,OAAO,MAAA,CAAO,QAAQ,IAAI,EAC5B,MAAA,CAAO,OAAO,KAAK,IAAI,CAAA,GAAI,MAAA,CAAO,IAAA;IAItC,OAAO;AACR"}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/load/serializable.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/load/serializable.ts"],"sourcesContent":["import { type SerializedFields, keyToJson, mapKeys } from \"./map_keys.js\";\n\nexport interface BaseSerialized<T extends string> {\n  lc: number;\n  type: T;\n  id: string[];\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  graph?: Record<string, any>;\n}\n\nexport interface SerializedConstructor extends BaseSerialized<\"constructor\"> {\n  kwargs: SerializedFields;\n}\n\nexport interface SerializedSecret extends BaseSerialized<\"secret\"> {}\n\nexport interface SerializedNotImplemented\n  extends BaseSerialized<\"not_implemented\"> {}\n\nexport type Serialized =\n  | SerializedConstructor\n  | SerializedSecret\n  | SerializedNotImplemented;\n\nfunction shallowCopy<T extends object>(obj: T): T {\n  return Array.isArray(obj) ? ([...obj] as T) : ({ ...obj } as T);\n}\n\nfunction replaceSecrets(\n  root: SerializedFields,\n  secretsMap: { [key: string]: string }\n): SerializedFields {\n  const result = shallowCopy(root);\n  for (const [path, secretId] of Object.entries(secretsMap)) {\n    const [last, ...partsReverse] = path.split(\".\").reverse();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let current: any = result;\n    for (const part of partsReverse.reverse()) {\n      if (current[part] === undefined) {\n        break;\n      }\n      current[part] = shallowCopy(current[part]);\n      current = current[part];\n    }\n    if (current[last] !== undefined) {\n      current[last] = {\n        lc: 1,\n        type: \"secret\",\n        id: [secretId],\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nexport function get_lc_unique_name(\n  serializableClass: typeof Serializable\n): string {\n  // \"super\" here would refer to the parent class of Serializable,\n  // when we want the parent class of the module actually calling this method.\n  const parentClass = Object.getPrototypeOf(serializableClass);\n  const lcNameIsSubclassed =\n    typeof serializableClass.lc_name === \"function\" &&\n    (typeof parentClass.lc_name !== \"function\" ||\n      serializableClass.lc_name() !== parentClass.lc_name());\n  if (lcNameIsSubclassed) {\n    return serializableClass.lc_name();\n  } else {\n    return serializableClass.name;\n  }\n}\n\nexport interface SerializableInterface {\n  get lc_id(): string[];\n}\n\nexport abstract class Serializable implements SerializableInterface {\n  lc_serializable = false;\n\n  lc_kwargs: SerializedFields;\n\n  /**\n   * A path to the module that contains the class, eg. [\"langchain\", \"llms\"]\n   * Usually should be the same as the entrypoint the class is exported from.\n   */\n  abstract lc_namespace: string[];\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof Serializable),\n    ];\n  }\n\n  /**\n   * A map of secrets, which will be omitted from serialization.\n   * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n   * Values are the secret ids, which will be used when deserializing.\n   */\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of additional attributes to merge with constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the attribute values, which will be serialized.\n   * These attributes need to be accepted by the constructor as arguments.\n   */\n  get lc_attributes(): SerializedFields | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of aliases for constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the alias that will replace the key in serialization.\n   * This is used to eg. make argument names match Python.\n   */\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A manual list of keys that should be serialized.\n   * If not overridden, all fields passed into the constructor will be serialized.\n   */\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  constructor(kwargs?: SerializedFields, ..._args: never[]) {\n    if (this.lc_serializable_keys !== undefined) {\n      this.lc_kwargs = Object.fromEntries(\n        Object.entries(kwargs || {}).filter(([key]) =>\n          this.lc_serializable_keys?.includes(key)\n        )\n      );\n    } else {\n      this.lc_kwargs = kwargs ?? {};\n    }\n  }\n\n  toJSON(): Serialized {\n    if (!this.lc_serializable) {\n      return this.toJSONNotImplemented();\n    }\n    if (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      this.lc_kwargs instanceof Serializable ||\n      typeof this.lc_kwargs !== \"object\" ||\n      Array.isArray(this.lc_kwargs)\n    ) {\n      // We do not support serialization of classes with arg not a POJO\n      // I'm aware the check above isn't as strict as it could be\n      return this.toJSONNotImplemented();\n    }\n\n    const aliases: { [key: string]: string } = {};\n    const secrets: { [key: string]: string } = {};\n    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n      acc[key] = key in this ? this[key as keyof this] : this.lc_kwargs[key];\n      return acc;\n    }, {} as SerializedFields);\n    // get secrets, attributes and aliases from all superclasses\n    for (\n      let current = Object.getPrototypeOf(this);\n      current;\n      current = Object.getPrototypeOf(current)\n    ) {\n      Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n      Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n      Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n    }\n\n    // include all secrets used, even if not in kwargs,\n    // will be replaced with sentinel value in replaceSecrets\n    Object.keys(secrets).forEach((keyPath) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let read: any = this;\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let write: any = kwargs;\n\n      const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n      for (const key of partsReverse.reverse()) {\n        if (!(key in read) || read[key] === undefined) return;\n        if (!(key in write) || write[key] === undefined) {\n          if (typeof read[key] === \"object\" && read[key] != null) {\n            write[key] = {};\n          } else if (Array.isArray(read[key])) {\n            write[key] = [];\n          }\n        }\n\n        read = read[key];\n        write = write[key];\n      }\n\n      if (last in read && read[last] !== undefined) {\n        write[last] = write[last] || read[last];\n      }\n    });\n\n    return {\n      lc: 1,\n      type: \"constructor\",\n      id: this.lc_id,\n      kwargs: mapKeys(\n        Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs,\n        keyToJson,\n        aliases\n      ),\n    };\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return {\n      lc: 1,\n      type: \"not_implemented\",\n      id: this.lc_id,\n    };\n  }\n}\n"],"names":["obj: T","root: SerializedFields","secretsMap: { [key: string]: string }","current: any","serializableClass: typeof Serializable","kwargs?: SerializedFields","aliases: { [key: string]: string }","secrets: { [key: string]: string }","read: any","write: any"],"mappings":"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"}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/errors/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/errors/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type LangChainErrorCodes =\n  | \"INVALID_PROMPT_INPUT\"\n  | \"INVALID_TOOL_RESULTS\"\n  | \"MESSAGE_COERCION_FAILURE\"\n  | \"MODEL_AUTHENTICATION\"\n  | \"MODEL_NOT_FOUND\"\n  | \"MODEL_RATE_LIMIT\"\n  | \"OUTPUT_PARSING_FAILURE\";\n\nexport function addLangChainErrorFields(\n  error: any,\n  lc_error_code: LangChainErrorCodes\n) {\n  (error as any).lc_error_code = lc_error_code;\n  error.message = `${error.message}\\n\\nTroubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/\\n`;\n  return error;\n}\n"],"names":["error: any","lc_error_code: LangChainErrorCodes"],"mappings":";AAWA,SAAgB,wBACdA,KAAAA,EACAC,aAAAA,EACA;IACC,MAAc,aAAA,GAAgB;IAC/B,MAAM,OAAA,GAAU,GAAG,MAAM,OAAA,CAAQ,oFAAoF,EAAE,cAAc,GAAG,CAAC;IACzI,OAAO;AACR"}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/errors/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/errors/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type LangChainErrorCodes =\n  | \"INVALID_PROMPT_INPUT\"\n  | \"INVALID_TOOL_RESULTS\"\n  | \"MESSAGE_COERCION_FAILURE\"\n  | \"MODEL_AUTHENTICATION\"\n  | \"MODEL_NOT_FOUND\"\n  | \"MODEL_RATE_LIMIT\"\n  | \"OUTPUT_PARSING_FAILURE\";\n\nexport function addLangChainErrorFields(\n  error: any,\n  lc_error_code: LangChainErrorCodes\n) {\n  (error as any).lc_error_code = lc_error_code;\n  error.message = `${error.message}\\n\\nTroubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/\\n`;\n  return error;\n}\n"],"names":["error: any","lc_error_code: LangChainErrorCodes"],"mappings":";;;;;AAWA,SAAgB,wBACdA,KAAAA,EACAC,aAAAA,EACA;IACC,MAAc,aAAA,GAAgB;IAC/B,MAAM,OAAA,GAAU,GAAG,MAAM,OAAA,CAAQ,oFAAoF,EAAE,cAAc,GAAG,CAAC;IACzI,OAAO;AACR"}},
    {"offset": {"line": 440, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tools/utils.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tools/utils.ts"],"sourcesContent":["import { ToolCall } from \"../messages/tool.js\";\n\nexport function _isToolCall(toolCall?: unknown): toolCall is ToolCall {\n  return !!(\n    toolCall &&\n    typeof toolCall === \"object\" &&\n    \"type\" in toolCall &&\n    toolCall.type === \"tool_call\"\n  );\n}\n\nexport function _configHasToolCallId(\n  config?: unknown\n): config is { toolCall: { id?: string } } {\n  return !!(\n    config &&\n    typeof config === \"object\" &&\n    \"toolCall\" in config &&\n    config.toolCall != null &&\n    typeof config.toolCall === \"object\" &&\n    \"id\" in config.toolCall &&\n    typeof config.toolCall.id === \"string\"\n  );\n}\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nexport class ToolInputParsingException extends Error {\n  output?: string;\n\n  constructor(message: string, output?: string) {\n    super(message);\n    this.output = output;\n  }\n}\n"],"names":["toolCall?: unknown","config?: unknown","message: string","output?: string"],"mappings":";AAEA,SAAgB,YAAYA,QAAAA,EAA0C;IACpE,OAAO,CAAC,CAAA,CACN,YACA,OAAO,aAAa,YACpB,UAAU,YACV,SAAS,IAAA,KAAS,WAAA;AAErB;AAED,SAAgB,qBACdC,MAAAA,EACyC;IACzC,OAAO,CAAC,CAAA,CACN,UACA,OAAO,WAAW,YAClB,cAAc,UACd,OAAO,QAAA,IAAY,QACnB,OAAO,OAAO,QAAA,KAAa,YAC3B,QAAQ,OAAO,QAAA,IACf,OAAO,OAAO,QAAA,CAAS,EAAA,KAAO,QAAA;AAEjC;;;;;GAMD,IAAa,4BAAb,cAA+C,MAAM;IACnD,OAAA;IAEA,YAAYC,OAAAA,EAAiBC,MAAAA,CAAiB;QAC5C,KAAA,CAAM,QAAQ;QACd,IAAA,CAAK,MAAA,GAAS;IACf;AACF"}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tools/types.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tools/types.ts"],"sourcesContent":["import type { z as z3 } from \"zod/v3\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport type {\n  BaseLangChainParams,\n  ToolDefinition,\n} from \"../language_models/base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport {\n  Runnable,\n  RunnableToolLike,\n  type RunnableInterface,\n} from \"../runnables/base.js\";\nimport {\n  type DirectToolOutput,\n  type ToolCall,\n  type ToolMessage,\n} from \"../messages/tool.js\";\nimport type { MessageContent } from \"../messages/base.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodType,\n  isInteropZodSchema,\n  type InteropZodObject,\n} from \"../utils/types/zod.js\";\n\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport type { BaseStore } from \"../stores.js\";\n\nexport type ResponseFormat = \"content\" | \"content_and_artifact\" | string;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ContentAndArtifact = [MessageContent, any];\n\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\nexport type ToolReturnType<TInput, TConfig, TOutput> =\n  TOutput extends DirectToolOutput\n    ? TOutput\n    : TConfig extends { toolCall: { id: string } }\n    ? ToolMessage\n    : TConfig extends { toolCall: { id: undefined } }\n    ? TOutput\n    : TConfig extends { toolCall: { id?: string } }\n    ? TOutput | ToolMessage\n    : TInput extends ToolCall\n    ? ToolMessage\n    : TOutput;\n\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\nexport type ToolInputSchemaBase = z3.ZodTypeAny | JSONSchema;\n\n/**\n * Parameters for the Tool classes.\n */\nexport interface ToolParams extends BaseLangChainParams {\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n  /**\n   * Whether to show full details in the thrown parsing errors.\n   *\n   * @default false\n   */\n  verboseParsingErrors?: boolean;\n  /**\n   * Metadata for the tool.\n   */\n  metadata?: Record<string, unknown>;\n}\n\nexport type ToolRunnableConfig<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableFieldType extends Record<string, any> = Record<string, any>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextSchema = any\n> = RunnableConfig<ConfigurableFieldType> & {\n  toolCall?: ToolCall;\n  context?: ContextSchema;\n};\n\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\nexport interface StructuredToolParams\n  extends Pick<StructuredToolInterface, \"name\" | \"schema\"> {\n  /**\n   * An optional description of the tool to pass to the model.\n   */\n  description?: string;\n}\n\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaOutputType<T> = T extends InteropZodType\n  ? InferInteropZodOutput<T>\n  : T extends JSONSchema\n  ? unknown\n  : never;\n\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaInputType<T> = T extends InteropZodType\n  ? InferInteropZodInput<T>\n  : T extends JSONSchema\n  ? unknown\n  : never;\n\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport type StructuredToolCallInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>\n> =\n  | (ToolInputSchemaOutputType<SchemaT> extends string ? string : never)\n  | SchemaInputT\n  | ToolCall;\n\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\nexport type StringInputToolSchema = z3.ZodType<\n  string | undefined,\n  z3.ZodTypeDef,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  any\n>;\n\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\nexport type ToolCallInput<SchemaT = StringInputToolSchema> =\n  StructuredToolCallInput<SchemaT, ToolInputSchemaInputType<SchemaT>>;\n\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface StructuredToolInterface<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends RunnableInterface<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  > {\n  lc_namespace: string[];\n\n  /**\n   * A Zod schema representing the parameters of the tool.\n   */\n  schema: SchemaT;\n\n  /**\n   * Invokes the tool with the provided argument and configuration.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration for the tool call.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  invoke<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * The name of the tool.\n   */\n  name: string;\n\n  /**\n   * A description of the tool.\n   */\n  description: string;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect: boolean;\n}\n\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface ToolInterface<\n  SchemaT = StringInputToolSchema,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    // TODO: shouldn't this be narrowed based on SchemaT?\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\nexport interface BaseDynamicToolInput extends ToolParams {\n  name: string;\n  description: string;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\nexport interface DynamicToolInput<ToolOutputT = ToolOutputType>\n  extends BaseDynamicToolInput {\n  func: (\n    input: string,\n    runManager?: CallbackManagerForToolRun,\n    config?: ToolRunnableConfig\n  ) => Promise<ToolOutputT>;\n}\n\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface DynamicStructuredToolInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends BaseDynamicToolInput {\n  /**\n   * Tool handler function - the function that will be called when the tool is invoked.\n   *\n   * @param input - The input to the tool.\n   * @param runManager - The run manager for the tool.\n   * @param config - The configuration for the tool.\n   * @returns The result of the tool.\n   */\n  func: (\n    input: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    config?: RunnableConfig\n  ) => Promise<ToolOutputT>;\n  schema: SchemaT;\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nexport function isStructuredTool(\n  tool?: StructuredToolInterface | ToolDefinition | JSONSchema\n): tool is StructuredToolInterface {\n  return (\n    tool !== undefined &&\n    Array.isArray((tool as StructuredToolInterface).lc_namespace)\n  );\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nexport function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike {\n  return (\n    tool !== undefined &&\n    Runnable.isRunnable(tool) &&\n    \"lc_name\" in tool.constructor &&\n    typeof tool.constructor.lc_name === \"function\" &&\n    tool.constructor.lc_name() === \"RunnableToolLike\"\n  );\n}\n\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nexport function isStructuredToolParams(\n  tool?: unknown\n): tool is StructuredToolParams {\n  return (\n    !!tool &&\n    typeof tool === \"object\" &&\n    \"name\" in tool &&\n    \"schema\" in tool &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (isInteropZodSchema(tool.schema as Record<string, any>) ||\n      (tool.schema != null &&\n        typeof tool.schema === \"object\" &&\n        \"type\" in tool.schema &&\n        typeof tool.schema.type === \"string\" &&\n        [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(\n          tool.schema.type\n        )))\n  );\n}\n\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nexport function isLangChainTool(tool?: unknown): tool is StructuredToolParams {\n  return (\n    isStructuredToolParams(tool) ||\n    isRunnableToolLike(tool) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isStructuredTool(tool as any)\n  );\n}\n\n/**\n * Runtime context automatically injected into tools.\n *\n * When a tool function has a parameter named `tool_runtime` with type hint\n * `ToolRuntime`, the tool execution system will automatically inject an instance\n * containing:\n *\n * - `state`: The current graph state\n * - `toolCallId`: The ID of the current tool call\n * - `config`: `RunnableConfig` for the current execution\n * - `context`: Runtime context\n * - `store`: `BaseStore` instance for persistent storage\n * - `writer`: Stream writer for streaming output\n *\n * No `Annotated` wrapper is needed - just use `runtime: ToolRuntime`\n * as a parameter.\n *\n * @example\n * ```typescript\n * import { tool, ToolRuntime } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const stateSchema = z.object({\n *   messages: z.array(z.any()),\n *   userId: z.string().optional(),\n * });\n *\n * const greet = tool(\n *   async ({ name }, runtime) => {\n *     // Access state\n *     const messages = runtime.state.messages;\n *\n *     // Access tool_call_id\n *     console.log(`Tool call ID: ${runtime.toolCallId}`);\n *\n *     // Access config\n *     console.log(`Run ID: ${runtime.config.runId}`);\n *\n *     // Access runtime context\n *     const userId = runtime.context?.userId;\n *\n *     // Access store\n *     await runtime.store?.mset([[\"key\", \"value\"]]);\n *\n *     // Stream output\n *     runtime.writer?.(\"Processing...\");\n *\n *     return `Hello! User ID: ${runtime.state.userId || \"unknown\"} ${name}`;\n *   },\n *   {\n *     name: \"greet\",\n *     description: \"Use this to greet the user once you found their info.\",\n *     schema: z.object({ name: z.string() }),\n *     stateSchema,\n *   }\n * );\n * ```\n *\n * @template StateT - The type of the state schema (inferred from stateSchema)\n * @template ContextT - The type of the context schema (inferred from contextSchema)\n */\nexport type ToolRuntime<\n  TState = unknown,\n  TContext = unknown\n> = RunnableConfig & {\n  /**\n   * The current graph state.\n   */\n  state: TState extends InteropZodObject\n    ? InferInteropZodOutput<TState>\n    : TState extends Record<string, unknown>\n    ? TState\n    : unknown;\n  /**\n   * The ID of the current tool call.\n   */\n  toolCallId: string;\n  /**\n   * The current tool call.\n   */\n  toolCall?: ToolCall;\n  /**\n   * RunnableConfig for the current execution.\n   */\n  config: ToolRunnableConfig;\n  /**\n   * Runtime context (from langgraph `Runtime`).\n   */\n  context: TContext extends InteropZodObject\n    ? InferInteropZodOutput<TContext>\n    : TContext extends Record<string, unknown>\n    ? TContext\n    : unknown;\n  /**\n   * BaseStore instance for persistent storage (from langgraph `Runtime`).\n   */\n  store: BaseStore<string, unknown> | null;\n  /**\n   * Stream writer for streaming output (from langgraph `Runtime`).\n   */\n  writer: ((chunk: unknown) => void) | null;\n};\n"],"names":["tool?: StructuredToolInterface | ToolDefinition | JSONSchema","tool?: unknown","Runnable","isInteropZodSchema"],"mappings":";;;;;;;;GA2WA,SAAgB,iBACdA,IAAAA,EACiC;IACjC,OACE,SAAS,KAAA,KACT,MAAM,OAAA,CAAS,KAAiC,YAAA,CAAa;AAEhE;;;;;;GAQD,SAAgB,mBAAmBC,IAAAA,EAA0C;IAC3E,OACE,SAAS,KAAA,KACTC,aAAAA,QAAAA,CAAS,UAAA,CAAW,KAAK,IACzB,aAAa,KAAK,WAAA,IAClB,OAAO,KAAK,WAAA,CAAY,OAAA,KAAY,cACpC,KAAK,WAAA,CAAY,OAAA,EAAS,KAAK;AAElC;;;;;;GAQD,SAAgB,uBACdD,IAAAA,EAC8B;IAC9B,OACE,CAAC,CAAC,QACF,OAAO,SAAS,YAChB,UAAU,QACV,YAAY,QAAA,CAEXE,YAAAA,kBAAAA,CAAmB,KAAK,MAAA,CAA8B,IACpD,KAAK,MAAA,IAAU,QACd,OAAO,KAAK,MAAA,KAAW,YACvB,UAAU,KAAK,MAAA,IACf,OAAO,KAAK,MAAA,CAAO,IAAA,KAAS,YAC5B;QAAC;QAAQ;QAAW;QAAU;QAAS;QAAU;KAAS,CAAC,QAAA,CACzD,KAAK,MAAA,CAAO,IAAA,CACb;AAER;;;;;;;;GAUD,SAAgB,gBAAgBF,IAAAA,EAA8C;IAC5E,OACE,uBAAuB,KAAK,IAC5B,mBAAmB,KAAK,IAExB,iBAAiB,KAAY;AAEhC"}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tools/utils.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tools/utils.ts"],"sourcesContent":["import { ToolCall } from \"../messages/tool.js\";\n\nexport function _isToolCall(toolCall?: unknown): toolCall is ToolCall {\n  return !!(\n    toolCall &&\n    typeof toolCall === \"object\" &&\n    \"type\" in toolCall &&\n    toolCall.type === \"tool_call\"\n  );\n}\n\nexport function _configHasToolCallId(\n  config?: unknown\n): config is { toolCall: { id?: string } } {\n  return !!(\n    config &&\n    typeof config === \"object\" &&\n    \"toolCall\" in config &&\n    config.toolCall != null &&\n    typeof config.toolCall === \"object\" &&\n    \"id\" in config.toolCall &&\n    typeof config.toolCall.id === \"string\"\n  );\n}\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nexport class ToolInputParsingException extends Error {\n  output?: string;\n\n  constructor(message: string, output?: string) {\n    super(message);\n    this.output = output;\n  }\n}\n"],"names":["toolCall?: unknown","config?: unknown","message: string","output?: string"],"mappings":";;;;;;;;;AAEA,SAAgB,YAAYA,QAAAA,EAA0C;IACpE,OAAO,CAAC,CAAA,CACN,YACA,OAAO,aAAa,YACpB,UAAU,YACV,SAAS,IAAA,KAAS,WAAA;AAErB;AAED,SAAgB,qBACdC,MAAAA,EACyC;IACzC,OAAO,CAAC,CAAA,CACN,UACA,OAAO,WAAW,YAClB,cAAc,UACd,OAAO,QAAA,IAAY,QACnB,OAAO,OAAO,QAAA,KAAa,YAC3B,QAAQ,OAAO,QAAA,IACf,OAAO,OAAO,QAAA,CAAS,EAAA,KAAO,QAAA;AAEjC;;;;;GAMD,IAAa,4BAAb,cAA+C,MAAM;IACnD,OAAA;IAEA,YAAYC,OAAAA,EAAiBC,MAAAA,CAAiB;QAC5C,KAAA,CAAM,QAAQ;QACd,IAAA,CAAK,MAAA,GAAS;IACf;AACF"}},
    {"offset": {"line": 550, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tools/types.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tools/types.ts"],"sourcesContent":["import type { z as z3 } from \"zod/v3\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport type {\n  BaseLangChainParams,\n  ToolDefinition,\n} from \"../language_models/base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport {\n  Runnable,\n  RunnableToolLike,\n  type RunnableInterface,\n} from \"../runnables/base.js\";\nimport {\n  type DirectToolOutput,\n  type ToolCall,\n  type ToolMessage,\n} from \"../messages/tool.js\";\nimport type { MessageContent } from \"../messages/base.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodType,\n  isInteropZodSchema,\n  type InteropZodObject,\n} from \"../utils/types/zod.js\";\n\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport type { BaseStore } from \"../stores.js\";\n\nexport type ResponseFormat = \"content\" | \"content_and_artifact\" | string;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ContentAndArtifact = [MessageContent, any];\n\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\nexport type ToolReturnType<TInput, TConfig, TOutput> =\n  TOutput extends DirectToolOutput\n    ? TOutput\n    : TConfig extends { toolCall: { id: string } }\n    ? ToolMessage\n    : TConfig extends { toolCall: { id: undefined } }\n    ? TOutput\n    : TConfig extends { toolCall: { id?: string } }\n    ? TOutput | ToolMessage\n    : TInput extends ToolCall\n    ? ToolMessage\n    : TOutput;\n\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\nexport type ToolInputSchemaBase = z3.ZodTypeAny | JSONSchema;\n\n/**\n * Parameters for the Tool classes.\n */\nexport interface ToolParams extends BaseLangChainParams {\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n  /**\n   * Whether to show full details in the thrown parsing errors.\n   *\n   * @default false\n   */\n  verboseParsingErrors?: boolean;\n  /**\n   * Metadata for the tool.\n   */\n  metadata?: Record<string, unknown>;\n}\n\nexport type ToolRunnableConfig<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableFieldType extends Record<string, any> = Record<string, any>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextSchema = any\n> = RunnableConfig<ConfigurableFieldType> & {\n  toolCall?: ToolCall;\n  context?: ContextSchema;\n};\n\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\nexport interface StructuredToolParams\n  extends Pick<StructuredToolInterface, \"name\" | \"schema\"> {\n  /**\n   * An optional description of the tool to pass to the model.\n   */\n  description?: string;\n}\n\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaOutputType<T> = T extends InteropZodType\n  ? InferInteropZodOutput<T>\n  : T extends JSONSchema\n  ? unknown\n  : never;\n\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaInputType<T> = T extends InteropZodType\n  ? InferInteropZodInput<T>\n  : T extends JSONSchema\n  ? unknown\n  : never;\n\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport type StructuredToolCallInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>\n> =\n  | (ToolInputSchemaOutputType<SchemaT> extends string ? string : never)\n  | SchemaInputT\n  | ToolCall;\n\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\nexport type StringInputToolSchema = z3.ZodType<\n  string | undefined,\n  z3.ZodTypeDef,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  any\n>;\n\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\nexport type ToolCallInput<SchemaT = StringInputToolSchema> =\n  StructuredToolCallInput<SchemaT, ToolInputSchemaInputType<SchemaT>>;\n\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface StructuredToolInterface<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends RunnableInterface<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  > {\n  lc_namespace: string[];\n\n  /**\n   * A Zod schema representing the parameters of the tool.\n   */\n  schema: SchemaT;\n\n  /**\n   * Invokes the tool with the provided argument and configuration.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration for the tool call.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  invoke<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * The name of the tool.\n   */\n  name: string;\n\n  /**\n   * A description of the tool.\n   */\n  description: string;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect: boolean;\n}\n\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface ToolInterface<\n  SchemaT = StringInputToolSchema,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    // TODO: shouldn't this be narrowed based on SchemaT?\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\nexport interface BaseDynamicToolInput extends ToolParams {\n  name: string;\n  description: string;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\nexport interface DynamicToolInput<ToolOutputT = ToolOutputType>\n  extends BaseDynamicToolInput {\n  func: (\n    input: string,\n    runManager?: CallbackManagerForToolRun,\n    config?: ToolRunnableConfig\n  ) => Promise<ToolOutputT>;\n}\n\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface DynamicStructuredToolInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends BaseDynamicToolInput {\n  /**\n   * Tool handler function - the function that will be called when the tool is invoked.\n   *\n   * @param input - The input to the tool.\n   * @param runManager - The run manager for the tool.\n   * @param config - The configuration for the tool.\n   * @returns The result of the tool.\n   */\n  func: (\n    input: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    config?: RunnableConfig\n  ) => Promise<ToolOutputT>;\n  schema: SchemaT;\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nexport function isStructuredTool(\n  tool?: StructuredToolInterface | ToolDefinition | JSONSchema\n): tool is StructuredToolInterface {\n  return (\n    tool !== undefined &&\n    Array.isArray((tool as StructuredToolInterface).lc_namespace)\n  );\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nexport function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike {\n  return (\n    tool !== undefined &&\n    Runnable.isRunnable(tool) &&\n    \"lc_name\" in tool.constructor &&\n    typeof tool.constructor.lc_name === \"function\" &&\n    tool.constructor.lc_name() === \"RunnableToolLike\"\n  );\n}\n\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nexport function isStructuredToolParams(\n  tool?: unknown\n): tool is StructuredToolParams {\n  return (\n    !!tool &&\n    typeof tool === \"object\" &&\n    \"name\" in tool &&\n    \"schema\" in tool &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (isInteropZodSchema(tool.schema as Record<string, any>) ||\n      (tool.schema != null &&\n        typeof tool.schema === \"object\" &&\n        \"type\" in tool.schema &&\n        typeof tool.schema.type === \"string\" &&\n        [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(\n          tool.schema.type\n        )))\n  );\n}\n\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nexport function isLangChainTool(tool?: unknown): tool is StructuredToolParams {\n  return (\n    isStructuredToolParams(tool) ||\n    isRunnableToolLike(tool) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isStructuredTool(tool as any)\n  );\n}\n\n/**\n * Runtime context automatically injected into tools.\n *\n * When a tool function has a parameter named `tool_runtime` with type hint\n * `ToolRuntime`, the tool execution system will automatically inject an instance\n * containing:\n *\n * - `state`: The current graph state\n * - `toolCallId`: The ID of the current tool call\n * - `config`: `RunnableConfig` for the current execution\n * - `context`: Runtime context\n * - `store`: `BaseStore` instance for persistent storage\n * - `writer`: Stream writer for streaming output\n *\n * No `Annotated` wrapper is needed - just use `runtime: ToolRuntime`\n * as a parameter.\n *\n * @example\n * ```typescript\n * import { tool, ToolRuntime } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const stateSchema = z.object({\n *   messages: z.array(z.any()),\n *   userId: z.string().optional(),\n * });\n *\n * const greet = tool(\n *   async ({ name }, runtime) => {\n *     // Access state\n *     const messages = runtime.state.messages;\n *\n *     // Access tool_call_id\n *     console.log(`Tool call ID: ${runtime.toolCallId}`);\n *\n *     // Access config\n *     console.log(`Run ID: ${runtime.config.runId}`);\n *\n *     // Access runtime context\n *     const userId = runtime.context?.userId;\n *\n *     // Access store\n *     await runtime.store?.mset([[\"key\", \"value\"]]);\n *\n *     // Stream output\n *     runtime.writer?.(\"Processing...\");\n *\n *     return `Hello! User ID: ${runtime.state.userId || \"unknown\"} ${name}`;\n *   },\n *   {\n *     name: \"greet\",\n *     description: \"Use this to greet the user once you found their info.\",\n *     schema: z.object({ name: z.string() }),\n *     stateSchema,\n *   }\n * );\n * ```\n *\n * @template StateT - The type of the state schema (inferred from stateSchema)\n * @template ContextT - The type of the context schema (inferred from contextSchema)\n */\nexport type ToolRuntime<\n  TState = unknown,\n  TContext = unknown\n> = RunnableConfig & {\n  /**\n   * The current graph state.\n   */\n  state: TState extends InteropZodObject\n    ? InferInteropZodOutput<TState>\n    : TState extends Record<string, unknown>\n    ? TState\n    : unknown;\n  /**\n   * The ID of the current tool call.\n   */\n  toolCallId: string;\n  /**\n   * The current tool call.\n   */\n  toolCall?: ToolCall;\n  /**\n   * RunnableConfig for the current execution.\n   */\n  config: ToolRunnableConfig;\n  /**\n   * Runtime context (from langgraph `Runtime`).\n   */\n  context: TContext extends InteropZodObject\n    ? InferInteropZodOutput<TContext>\n    : TContext extends Record<string, unknown>\n    ? TContext\n    : unknown;\n  /**\n   * BaseStore instance for persistent storage (from langgraph `Runtime`).\n   */\n  store: BaseStore<string, unknown> | null;\n  /**\n   * Stream writer for streaming output (from langgraph `Runtime`).\n   */\n  writer: ((chunk: unknown) => void) | null;\n};\n"],"names":["tool?: StructuredToolInterface | ToolDefinition | JSONSchema","tool?: unknown"],"mappings":";;;;;;;;;;;;;;;;;;;;GA2WA,SAAgB,iBACdA,IAAAA,EACiC;IACjC,OACE,SAAS,KAAA,KACT,MAAM,OAAA,CAAS,KAAiC,YAAA,CAAa;AAEhE;;;;;;GAQD,SAAgB,mBAAmBC,IAAAA,EAA0C;IAC3E,OACE,SAAS,KAAA,KACT,8KAAA,CAAS,UAAA,CAAW,KAAK,IACzB,aAAa,KAAK,WAAA,IAClB,OAAO,KAAK,WAAA,CAAY,OAAA,KAAY,cACpC,KAAK,WAAA,CAAY,OAAA,EAAS,KAAK;AAElC;;;;;;GAQD,SAAgB,uBACdA,IAAAA,EAC8B;IAC9B,OACE,CAAC,CAAC,QACF,OAAO,SAAS,YAChB,UAAU,QACV,YAAY,QAAA,KAEX,4LAAA,EAAmB,KAAK,MAAA,CAA8B,IACpD,KAAK,MAAA,IAAU,QACd,OAAO,KAAK,MAAA,KAAW,YACvB,UAAU,KAAK,MAAA,IACf,OAAO,KAAK,MAAA,CAAO,IAAA,KAAS,YAC5B;QAAC;QAAQ;QAAW;QAAU;QAAS;QAAU;KAAS,CAAC,QAAA,CACzD,KAAK,MAAA,CAAO,IAAA,CACb;AAER;;;;;;;;GAUD,SAAgB,gBAAgBA,IAAAA,EAA8C;IAC5E,OACE,uBAAuB,KAAK,IAC5B,mBAAmB,KAAK,IAExB,iBAAiB,KAAY;AAEhC"}},
    {"offset": {"line": 612, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tools/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tools/index.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { z as z4, ZodError } from \"zod/v4\";\nimport {\n  validate,\n  type Schema as ValidationSchema,\n} from \"@cfworker/json-schema\";\nimport {\n  CallbackManager,\n  CallbackManagerForToolRun,\n  parseCallbackConfigArg,\n} from \"../callbacks/manager.js\";\nimport { BaseLangChain } from \"../language_models/base.js\";\nimport {\n  mergeConfigs,\n  ensureConfig,\n  patchConfig,\n  pickRunnableConfigKeys,\n  type RunnableConfig,\n} from \"../runnables/config.js\";\nimport type { RunnableFunc } from \"../runnables/base.js\";\nimport { isDirectToolOutput, ToolCall, ToolMessage } from \"../messages/tool.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport type { RunnableToolLike } from \"../runnables/base.js\";\nimport {\n  _configHasToolCallId,\n  _isToolCall,\n  ToolInputParsingException,\n} from \"./utils.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodObject,\n  type InteropZodType,\n  interopParseAsync,\n  isSimpleStringZodSchema,\n  isInteropZodError,\n  isInteropZodSchema,\n  type ZodStringV3,\n  type ZodStringV4,\n  type ZodObjectV3,\n  type ZodObjectV4,\n} from \"../utils/types/zod.js\";\nimport { getAbortSignalError } from \"../utils/signal.js\";\nimport type {\n  StructuredToolCallInput,\n  ToolInputSchemaBase,\n  ToolReturnType,\n  ResponseFormat,\n  ToolInputSchemaInputType,\n  ToolInputSchemaOutputType,\n  ToolParams,\n  ToolRunnableConfig,\n  StructuredToolInterface,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  StringInputToolSchema,\n  ToolInterface,\n  ToolOutputType,\n  ToolRuntime,\n} from \"./types.js\";\nimport { type JSONSchema, validatesOnlyStrings } from \"../utils/json_schema.js\";\n\nexport type {\n  BaseDynamicToolInput,\n  ContentAndArtifact,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  ResponseFormat,\n  StructuredToolCallInput,\n  StructuredToolInterface,\n  StructuredToolParams,\n  ToolInterface,\n  ToolParams,\n  ToolReturnType,\n  ToolRunnableConfig,\n  ToolInputSchemaBase as ToolSchemaBase,\n} from \"./types.js\";\n\nexport {\n  isLangChainTool,\n  isRunnableToolLike,\n  isStructuredTool,\n  isStructuredToolParams,\n  type ToolRuntime,\n} from \"./types.js\";\n\nexport { ToolInputParsingException };\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport abstract class StructuredTool<\n    SchemaT = ToolInputSchemaBase,\n    SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n    SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n    ToolOutputT = ToolOutputType\n  >\n  extends BaseLangChain<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  >\n  implements StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT>\n{\n  abstract name: string;\n\n  abstract description: string;\n\n  abstract schema: SchemaT;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect = false;\n\n  verboseParsingErrors = false;\n\n  get lc_namespace() {\n    return [\"langchain\", \"tools\"];\n  }\n\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat = \"content\";\n\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n\n  constructor(fields?: ToolParams) {\n    super(fields ?? {});\n\n    this.verboseParsingErrors =\n      fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n    this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;\n    this.metadata = fields?.metadata ?? this.metadata;\n  }\n\n  protected abstract _call(\n    arg: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT>;\n\n  /**\n   * Invokes the tool with the provided input and configuration.\n   * @param input The input for the tool.\n   * @param config Optional configuration for the tool.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  async invoke<\n    TInput extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    input: TInput,\n    config?: TConfig\n  ): Promise<ToolReturnType<TInput, TConfig, ToolOutputT>> {\n    let toolInput: Exclude<\n      StructuredToolCallInput<SchemaT, SchemaInputT>,\n      ToolCall\n    >;\n\n    let enrichedConfig: ToolRunnableConfig = ensureConfig(\n      mergeConfigs(this.defaultConfig, config)\n    );\n    if (_isToolCall(input)) {\n      toolInput = input.args as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n      enrichedConfig = {\n        ...enrichedConfig,\n        toolCall: input,\n      };\n    } else {\n      toolInput = input as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n    }\n\n    return this.call(toolInput, enrichedConfig) as Promise<\n      ToolReturnType<TInput, TConfig, ToolOutputT>\n    >;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>> {\n    // Determine the actual input that needs parsing/validation.\n    // If arg is a ToolCall, use its args; otherwise, use arg directly.\n    const inputForValidation = _isToolCall(arg) ? arg.args : arg;\n\n    let parsed: SchemaOutputT; // This will hold the successfully parsed input of the expected output type.\n    if (isInteropZodSchema(this.schema)) {\n      try {\n        // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n        parsed = await interopParseAsync(\n          this.schema as InteropZodType,\n          inputForValidation as Exclude<TArg, ToolCall>\n        );\n      } catch (e) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${(e as Error).message}`;\n        }\n        if (isInteropZodError(e)) {\n          message = `${message}\\n\\n${z4.prettifyError(e as ZodError)}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n    } else {\n      const result = validate(\n        inputForValidation,\n        this.schema as ValidationSchema\n      );\n      if (!result.valid) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${result.errors\n            .map((e) => `${e.keywordLocation}: ${e.error}`)\n            .join(\"\\n\")}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n      // Assign the validated input to parsed\n      // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n      parsed = inputForValidation as SchemaOutputT;\n    }\n\n    const config = parseCallbackConfigArg(configArg);\n    const callbackManager_ = CallbackManager.configure(\n      config.callbacks,\n      this.callbacks,\n      config.tags || tags,\n      this.tags,\n      config.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleToolStart(\n      this.toJSON(),\n      // Log the original raw input arg\n      typeof arg === \"string\" ? arg : JSON.stringify(arg),\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config.runName\n    );\n    delete config.runId;\n    let result;\n    try {\n      // Pass the correctly typed parsed input to _call\n      result = await this._call(parsed, runManager, config);\n    } catch (e) {\n      await runManager?.handleToolError(e);\n      throw e;\n    }\n    let content;\n    let artifact;\n    if (this.responseFormat === \"content_and_artifact\") {\n      if (Array.isArray(result) && result.length === 2) {\n        [content, artifact] = result;\n      } else {\n        throw new Error(\n          `Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(\n            result\n          )}`\n        );\n      }\n    } else {\n      content = result;\n    }\n\n    let toolCallId: string | undefined;\n    // Extract toolCallId ONLY if the original arg was a ToolCall\n    if (_isToolCall(arg)) {\n      toolCallId = arg.id;\n    }\n    // Or if it was provided in the config's toolCall property\n    if (!toolCallId && _configHasToolCallId(config)) {\n      toolCallId = config.toolCall.id;\n    }\n\n    const formattedOutput = _formatToolOutput<ToolOutputT>({\n      content,\n      artifact,\n      toolCallId,\n      name: this.name,\n      metadata: this.metadata,\n    });\n    await runManager?.handleToolEnd(formattedOutput);\n    return formattedOutput as ToolReturnType<TArg, TConfig, ToolOutputT>;\n  }\n}\n\n/**\n * Base class for Tools that accept input as a string.\n */\nexport abstract class Tool<ToolOutputT = ToolOutputType>\n  extends StructuredTool<\n    StringInputToolSchema,\n    ToolInputSchemaOutputType<StringInputToolSchema>,\n    ToolInputSchemaInputType<StringInputToolSchema>,\n    ToolOutputT\n  >\n  implements\n    ToolInterface<\n      StringInputToolSchema,\n      ToolInputSchemaInputType<StringInputToolSchema>,\n      ToolOutputT\n    >\n{\n  schema = z\n    .object({ input: z.string().optional() })\n    .transform((obj) => obj.input);\n\n  constructor(fields?: ToolParams) {\n    super(fields);\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  // Match the base class signature including the generics and conditional return type\n  call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    // Prepare the input for the base class call method.\n    // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n    const structuredArg =\n      typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n\n    // Ensure TConfig is passed to super.call\n    return super.call(structuredArg, callbacks);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool<\n  ToolOutputT = ToolOutputType\n> extends Tool<ToolOutputT> {\n  static lc_name() {\n    return \"DynamicTool\";\n  }\n\n  name: string;\n\n  description: string;\n\n  func: DynamicToolInput<ToolOutputT>[\"func\"];\n\n  constructor(fields: DynamicToolInput<ToolOutputT>) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  async call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    // Call the Tool class's call method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig);\n  }\n\n  /** @ignore */\n  async _call(\n    input: string, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(input, runManager, parentConfig);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nexport class DynamicStructuredTool<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends StructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT> {\n  static lc_name() {\n    return \"DynamicStructuredTool\";\n  }\n\n  name: string;\n\n  description: string;\n\n  func: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>[\"func\"];\n\n  schema: SchemaT;\n\n  constructor(\n    fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>\n  ) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    this.schema = fields.schema;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  // Match the base class signature\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n\n    // Call the base class method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig, tags);\n  }\n\n  protected _call(\n    arg: Parameters<\n      DynamicStructuredToolInput<SchemaT, SchemaOutputT>[\"func\"]\n    >[0],\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: RunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(arg, runManager, parentConfig);\n  }\n}\n\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nexport abstract class BaseToolkit {\n  abstract tools: StructuredToolInterface[];\n\n  getTools(): StructuredToolInterface[] {\n    return this.tools;\n  }\n}\n\n/**\n * Parameters for the tool function.\n * Schema can be provided as Zod or JSON schema.\n * Both schema types will be validated.\n * @template {ToolInputSchemaBase} RunInput The input schema for the tool.\n */\ninterface ToolWrapperParams<RunInput = ToolInputSchemaBase | undefined>\n  extends ToolParams {\n  /**\n   * The name of the tool. If using with an LLM, this\n   * will be passed as the tool name.\n   */\n  name: string;\n  /**\n   * The description of the tool.\n   * @default `${fields.name} tool`\n   */\n  description?: string;\n  /**\n   * The input schema for the tool. If using an LLM, this\n   * will be passed as the tool schema to generate arguments\n   * for.\n   */\n  schema?: RunInput;\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Creates a new StructuredTool instance with the provided function, name, description, and schema.\n *\n * Schema can be provided as Zod or JSON schema, and both will be validated.\n *\n * @function\n * @template {ToolInputSchemaBase} SchemaT The input schema for the tool.\n * @template {ToolReturnType} ToolOutputT The output type of the tool.\n *\n * @param {RunnableFunc<z.output<SchemaT>, ToolOutputT>} func - The function to invoke when the tool is called.\n * @param {ToolWrapperParams<SchemaT>} fields - An object containing the following properties:\n * @param {string} fields.name The name of the tool.\n * @param {string | undefined} fields.description The description of the tool. Defaults to either the description on the Zod schema, or `${fields.name} tool`.\n * @param {z.AnyZodObject | z.ZodString | undefined} fields.schema The Zod schema defining the input for the tool. If undefined, it will default to a Zod string schema.\n *\n * @returns {DynamicStructuredTool<SchemaT>} A new StructuredTool instance.\n */\nexport function tool<SchemaT extends ZodStringV3, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<SchemaT extends ZodStringV4, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<\n    Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n):\n  | DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>\n  | DynamicTool<ToolOutputT>;\n\n// Overloads with ToolRuntime as CallOptions\nexport function tool<\n  SchemaT extends ZodStringV3,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodStringV4,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n):\n  | DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>\n  | DynamicTool<ToolOutputT> {\n  const isSimpleStringSchema = isSimpleStringZodSchema(fields.schema);\n  const isStringJSONSchema = validatesOnlyStrings(fields.schema);\n\n  // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n  if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n    return new DynamicTool<ToolOutputT>({\n      ...fields,\n      description:\n        fields.description ??\n        (fields.schema as { description?: string } | undefined)?.description ??\n        `${fields.name} tool`,\n      func: async (input, runManager, config) => {\n        return new Promise<ToolOutputT>((resolve, reject) => {\n          const childConfig = patchConfig(config, {\n            callbacks: runManager?.getChild(),\n          });\n          // eslint-disable-next-line no-void\n          void AsyncLocalStorageProviderSingleton.runWithConfig(\n            pickRunnableConfigKeys(childConfig),\n            async () => {\n              try {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                resolve(func(input as any, childConfig as any));\n              } catch (e) {\n                reject(e);\n              }\n            }\n          );\n        });\n      },\n    });\n  }\n\n  const schema = fields.schema as InteropZodObject | JSONSchema;\n\n  const description =\n    fields.description ??\n    (fields.schema as { description?: string }).description ??\n    `${fields.name} tool`;\n\n  return new DynamicStructuredTool<\n    typeof schema,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT\n  >({\n    ...fields,\n    description,\n    schema,\n    func: async (input, runManager, config) => {\n      return new Promise<ToolOutputT>((resolve, reject) => {\n        let listener: (() => void) | undefined;\n        const cleanup = () => {\n          if (config?.signal && listener) {\n            config.signal.removeEventListener(\"abort\", listener);\n          }\n        };\n\n        if (config?.signal) {\n          listener = () => {\n            cleanup();\n            reject(getAbortSignalError(config.signal));\n          };\n          config.signal.addEventListener(\"abort\", listener);\n        }\n\n        const childConfig = patchConfig(config, {\n          callbacks: runManager?.getChild(),\n        });\n        // eslint-disable-next-line no-void\n        void AsyncLocalStorageProviderSingleton.runWithConfig(\n          pickRunnableConfigKeys(childConfig),\n          async () => {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              const result = await func(input as any, childConfig as any);\n\n              /**\n               * If the signal is aborted, we don't want to resolve the promise\n               * as the promise is already rejected.\n               */\n              if (config?.signal?.aborted) {\n                cleanup();\n                return;\n              }\n\n              cleanup();\n              resolve(result);\n            } catch (e) {\n              cleanup();\n              reject(e);\n            }\n          }\n        );\n      });\n    },\n  }) as DynamicStructuredTool<\n    SchemaT,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT\n  >;\n}\n\nfunction _formatToolOutput<TOutput extends ToolOutputType>(params: {\n  content: TOutput;\n  name: string;\n  artifact?: unknown;\n  toolCallId?: string;\n  metadata?: Record<string, unknown>;\n}): ToolMessage | TOutput {\n  const { content, artifact, toolCallId, metadata } = params;\n  if (toolCallId && !isDirectToolOutput(content)) {\n    if (\n      typeof content === \"string\" ||\n      (Array.isArray(content) &&\n        content.every((item) => typeof item === \"object\"))\n    ) {\n      return new ToolMessage({\n        status: \"success\",\n        content,\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    } else {\n      return new ToolMessage({\n        status: \"success\",\n        content: _stringify(content),\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    }\n  } else {\n    return content;\n  }\n}\n\nfunction _stringify(content: unknown): string {\n  try {\n    return JSON.stringify(content, null, 2) ?? \"\";\n  } catch (_noOp) {\n    return `${content}`;\n  }\n}\n\nexport type ServerTool = Record<string, unknown>;\nexport type ClientTool =\n  | StructuredToolInterface\n  | DynamicTool\n  | RunnableToolLike;\n"],"names":["fields?: ToolParams","input: TInput","config?: TConfig","toolInput: Exclude<\n      StructuredToolCallInput<SchemaT, SchemaInputT>,\n      ToolCall\n    >","enrichedConfig: ToolRunnableConfig","arg: TArg","configArg?: TConfig","tags?: string[]","parsed: SchemaOutputT","z4","result","toolCallId: string | undefined","callbacks?: TConfig","fields: DynamicToolInput<ToolOutputT>","input: string","runManager?: CallbackManagerForToolRun","parentConfig?: ToolRunnableConfig","fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>","arg: Parameters<\n      DynamicStructuredToolInput<SchemaT, SchemaOutputT>[\"func\"]\n    >[0]","parentConfig?: RunnableConfig","func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>","fields: ToolWrapperParams<SchemaT>","listener: (() => void) | undefined","params: {\n  content: TOutput;\n  name: string;\n  artifact?: unknown;\n  toolCallId?: string;\n  metadata?: Record<string, unknown>;\n}","content: unknown"],"mappings":"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"}},
    {"offset": {"line": 981, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/callbacks/base.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/callbacks/base.ts"],"sourcesContent":["import * as uuid from \"uuid\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type {\n  ChatGenerationChunk,\n  GenerationChunk,\n  LLMResult,\n} from \"../outputs.js\";\nimport {\n  Serializable,\n  Serialized,\n  SerializedNotImplemented,\n  get_lc_unique_name,\n} from \"../load/serializable.js\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Error = any;\n\n/**\n * Interface for the input parameters of the BaseCallbackHandler class. It\n * allows to specify which types of events should be ignored by the\n * callback handler.\n */\nexport interface BaseCallbackHandlerInput {\n  ignoreLLM?: boolean;\n  ignoreChain?: boolean;\n  ignoreAgent?: boolean;\n  ignoreRetriever?: boolean;\n  ignoreCustomEvent?: boolean;\n  _awaitHandler?: boolean;\n  raiseError?: boolean;\n}\n\n/**\n * Interface for the indices of a new token produced by an LLM or Chat\n * Model in streaming mode.\n */\nexport interface NewTokenIndices {\n  prompt: number;\n  completion: number;\n}\n\n// TODO: Add all additional callback fields here\nexport type HandleLLMNewTokenCallbackFields = {\n  chunk?: GenerationChunk | ChatGenerationChunk;\n};\n\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nabstract class BaseCallbackHandlerMethodsClass {\n  /**\n   * Called at the start of an LLM or Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleLLMStart?(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called when an LLM/ChatModel in `streaming` mode produces a new token\n   */\n  handleLLMNewToken?(\n    token: string,\n    /**\n     * idx.prompt is the index of the prompt that produced the token\n     *   (if there are multiple prompts)\n     * idx.completion is the index of the completion that produced the token\n     *   (if multiple completions per prompt are requested)\n     */\n    idx: NewTokenIndices,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if an LLM/ChatModel run encounters an error\n   */\n  handleLLMError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of an LLM/ChatModel run, with the output and the run ID.\n   */\n  handleLLMEnd?(\n    output: LLMResult,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleChatModelStart?(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chain run, with the chain name and inputs\n   * and the run ID.\n   */\n  handleChainStart?(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runType?: string,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Chain run encounters an error\n   */\n  handleChainError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Chain run, with the outputs and the run ID.\n   */\n  handleChainEnd?(\n    outputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Tool run, with the tool name and input\n   * and the run ID.\n   */\n  handleToolStart?(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Tool run encounters an error\n   */\n  handleToolError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Tool run, with the tool output and the run ID.\n   */\n  handleToolEnd?(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    output: any,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleText?(\n    text: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent is about to execute an action,\n   * with the action and the run ID.\n   */\n  handleAgentAction?(\n    action: AgentAction,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent finishes execution, before it exits.\n   * with the final output and the run ID.\n   */\n  handleAgentEnd?(\n    action: AgentFinish,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  handleRetrieverStart?(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    name?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverEnd?(\n    documents: DocumentInterface[],\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n}\n\n/**\n * Base interface for callbacks. All methods are optional. If a method is not\n * implemented, it will be ignored. If a method is implemented, it will be\n * called at the appropriate time. All methods are called with the run ID of\n * the LLM/ChatModel/Chain that is running, which is generated by the\n * CallbackManager.\n *\n * @interface\n */\nexport type CallbackHandlerMethods = BaseCallbackHandlerMethodsClass;\n\n/**\n * Interface for handlers that can indicate a preference for streaming responses.\n * When implemented, this allows the handler to signal whether it prefers to receive\n * streaming responses from language models rather than complete responses.\n */\nexport interface CallbackHandlerPrefersStreaming {\n  readonly lc_prefer_streaming: boolean;\n}\n\nexport function callbackHandlerPrefersStreaming(x: BaseCallbackHandler) {\n  return \"lc_prefer_streaming\" in x && x.lc_prefer_streaming;\n}\n\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nexport abstract class BaseCallbackHandler\n  extends BaseCallbackHandlerMethodsClass\n  implements BaseCallbackHandlerInput, Serializable\n{\n  lc_serializable = false;\n\n  get lc_namespace(): [\"langchain_core\", \"callbacks\", string] {\n    return [\"langchain_core\", \"callbacks\", this.name];\n  }\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_attributes(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof BaseCallbackHandler),\n    ];\n  }\n\n  lc_kwargs: SerializedFields;\n\n  abstract name: string;\n\n  ignoreLLM = false;\n\n  ignoreChain = false;\n\n  ignoreAgent = false;\n\n  ignoreRetriever = false;\n\n  ignoreCustomEvent = false;\n\n  raiseError = false;\n\n  awaitHandlers =\n    getEnvironmentVariable(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\";\n\n  constructor(input?: BaseCallbackHandlerInput) {\n    super();\n    this.lc_kwargs = input || {};\n    if (input) {\n      this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n      this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n      this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n      this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n      this.ignoreCustomEvent =\n        input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n      this.raiseError = input.raiseError ?? this.raiseError;\n      this.awaitHandlers =\n        this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n    }\n  }\n\n  copy(): BaseCallbackHandler {\n    return new (this.constructor as new (\n      input?: BaseCallbackHandlerInput\n    ) => BaseCallbackHandler)(this);\n  }\n\n  toJSON(): Serialized {\n    return Serializable.prototype.toJSON.call(this);\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return Serializable.prototype.toJSONNotImplemented.call(this);\n  }\n\n  static fromMethods(methods: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuid.v4();\n\n      constructor() {\n        super();\n        Object.assign(this, methods);\n      }\n    }\n    return new Handler();\n  }\n}\n\nexport const isBaseCallbackHandler = (x: unknown) => {\n  const callbackHandler = x as BaseCallbackHandler;\n  return (\n    callbackHandler !== undefined &&\n    typeof callbackHandler.copy === \"function\" &&\n    typeof callbackHandler.name === \"string\" &&\n    typeof callbackHandler.awaitHandlers === \"boolean\"\n  );\n};\n"],"names":["x: BaseCallbackHandler","get_lc_unique_name","getEnvironmentVariable","input?: BaseCallbackHandlerInput","Serializable","methods: CallbackHandlerMethods","x: unknown"],"mappings":";;;;;;;;;;;;;;;GAwDA,IAAe,kCAAf,MAA+C;AA4N9C;AAsBD,SAAgB,gCAAgCA,CAAAA,EAAwB;IACtE,OAAO,yBAAyB,KAAK,EAAE,mBAAA;AACxC;;;;;;GAQD,IAAsB,sBAAtB,cACU,gCAEV;IACE,kBAAkB,MAAA;IAElB,IAAI,eAAwD;QAC1D,OAAO;YAAC;YAAkB;YAAa,IAAA,CAAK,IAAA;SAAK;IAClD;IAED,IAAI,aAAoD;QACtD,OAAO,KAAA;IACR;IAED,IAAI,gBAAuD;QACzD,OAAO,KAAA;IACR;IAED,IAAI,aAAoD;QACtD,OAAO,KAAA;IACR;IAED,IAAI,uBAA6C;QAC/C,OAAO,KAAA;IACR;;;;;;IAQD,OAAO,UAAkB;QACvB,OAAO,IAAA,CAAK,IAAA;IACb;;;IAKD,IAAI,QAAkB;QACpB,OAAO,CACL;eAAG,IAAA,CAAK,YAAA;YACRC,0BAAAA,kBAAAA,CAAmB,IAAA,CAAK,WAAA,CAA0C,AACnE;SAAA;IACF;IAED,UAAA;IAIA,YAAY,MAAA;IAEZ,cAAc,MAAA;IAEd,cAAc,MAAA;IAEd,kBAAkB,MAAA;IAElB,oBAAoB,MAAA;IAEpB,aAAa,MAAA;IAEb,gBACEC,kBAAAA,sBAAAA,CAAuB,iCAAiC,KAAK,QAAA;IAE/D,YAAYC,KAAAA,CAAkC;QAC5C,KAAA,EAAO;QACP,IAAA,CAAK,SAAA,GAAY,SAAS,CAAE;QAC5B,IAAI,OAAO;YACT,IAAA,CAAK,SAAA,GAAY,MAAM,SAAA,IAAa,IAAA,CAAK,SAAA;YACzC,IAAA,CAAK,WAAA,GAAc,MAAM,WAAA,IAAe,IAAA,CAAK,WAAA;YAC7C,IAAA,CAAK,WAAA,GAAc,MAAM,WAAA,IAAe,IAAA,CAAK,WAAA;YAC7C,IAAA,CAAK,eAAA,GAAkB,MAAM,eAAA,IAAmB,IAAA,CAAK,eAAA;YACrD,IAAA,CAAK,iBAAA,GACH,MAAM,iBAAA,IAAqB,IAAA,CAAK,iBAAA;YAClC,IAAA,CAAK,UAAA,GAAa,MAAM,UAAA,IAAc,IAAA,CAAK,UAAA;YAC3C,IAAA,CAAK,aAAA,GACH,IAAA,CAAK,UAAA,IAAA,CAAe,MAAM,aAAA,IAAiB,IAAA,CAAK,aAAA;QACnD;IACF;IAED,OAA4B;QAC1B,OAAO,IAAK,IAAA,CAAK,WAAA,CAES,IAAA;IAC3B;IAED,SAAqB;QACnB,OAAOC,0BAAAA,YAAAA,CAAa,SAAA,CAAU,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK;IAChD;IAED,uBAAiD;QAC/C,OAAOA,0BAAAA,YAAAA,CAAa,SAAA,CAAU,oBAAA,CAAqB,IAAA,CAAK,IAAA,CAAK;IAC9D;IAED,OAAO,YAAYC,OAAAA,EAAiC;QAClD,MAAM,gBAAgB,oBAAoB;YACxC,OAAO,KAAK,EAAA,EAAI,CAAA;YAEhB,aAAc;gBACZ,KAAA,EAAO;gBACP,OAAO,MAAA,CAAO,IAAA,EAAM,QAAQ;YAC7B;QACF;QACD,OAAO,IAAI;IACZ;AACF;AAED,MAAa,wBAAwB,CAACC,MAAe;IACnD,MAAM,kBAAkB;IACxB,OACE,oBAAoB,KAAA,KACpB,OAAO,gBAAgB,IAAA,KAAS,cAChC,OAAO,gBAAgB,IAAA,KAAS,YAChC,OAAO,gBAAgB,aAAA,KAAkB;AAE5C"}},
    {"offset": {"line": 1101, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/callbacks/promises.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/callbacks/promises.ts"],"sourcesContent":["import { awaitAllCallbacks, consumeCallback } from \"../singletons/callbacks.js\";\n\nexport { awaitAllCallbacks, consumeCallback };\n"],"names":[],"mappings":""}},
    {"offset": {"line": 1121, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/callbacks/manager.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/callbacks/manager.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport { LLMResult } from \"../outputs.js\";\nimport {\n  BaseCallbackHandler,\n  CallbackHandlerMethods,\n  HandleLLMNewTokenCallbackFields,\n  isBaseCallbackHandler,\n  NewTokenIndices,\n} from \"./base.js\";\nimport { ConsoleCallbackHandler } from \"../tracers/console.js\";\nimport { type BaseMessage } from \"../messages/base.js\";\nimport { getBufferString } from \"../messages/utils.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { LangChainTracer } from \"../tracers/tracer_langchain.js\";\nimport { consumeCallback } from \"./promises.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { isTracingEnabled } from \"../utils/callbacks.js\";\nimport { isBaseTracer } from \"../tracers/base.js\";\nimport {\n  getContextVariable,\n  _getConfigureHooks,\n} from \"../singletons/async_local_storage/context.js\";\n\ntype BaseCallbackManagerMethods = {\n  [K in keyof CallbackHandlerMethods]?: (\n    ...args: Parameters<Required<CallbackHandlerMethods>[K]>\n  ) => Promise<unknown>;\n};\n\nexport interface CallbackManagerOptions {\n  verbose?: boolean;\n  tracing?: boolean;\n}\n\nexport type Callbacks =\n  | CallbackManager\n  | (BaseCallbackHandler | CallbackHandlerMethods)[];\n\nexport interface BaseCallbackConfig {\n  /**\n   * Name for the tracer run for this call. Defaults to the name of the class.\n   */\n  runName?: string;\n\n  /**\n   * Tags for this call and any sub-calls (eg. a Chain calling an LLM).\n   * You can use these to filter calls.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Keys should be strings, values should be JSON-serializable.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Callbacks for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Unique identifier for the tracer run for this call. If not provided, a new UUID\n   * will be generated.\n   */\n  runId?: string;\n}\n\nexport function parseCallbackConfigArg(\n  arg: Callbacks | BaseCallbackConfig | undefined\n): BaseCallbackConfig {\n  if (!arg) {\n    return {};\n  } else if (Array.isArray(arg) || \"name\" in arg) {\n    return { callbacks: arg };\n  } else {\n    return arg;\n  }\n}\n\n/**\n * Manage callbacks from different components of LangChain.\n */\nexport abstract class BaseCallbackManager {\n  abstract addHandler(handler: BaseCallbackHandler): void;\n\n  abstract removeHandler(handler: BaseCallbackHandler): void;\n\n  abstract setHandlers(handlers: BaseCallbackHandler[]): void;\n\n  setHandler(handler: BaseCallbackHandler): void {\n    return this.setHandlers([handler]);\n  }\n}\n\n/**\n * Base class for run manager in LangChain.\n */\nexport class BaseRunManager {\n  constructor(\n    public readonly runId: string,\n    public readonly handlers: BaseCallbackHandler[],\n    protected readonly inheritableHandlers: BaseCallbackHandler[],\n    protected readonly tags: string[],\n    protected readonly inheritableTags: string[],\n    protected readonly metadata: Record<string, unknown>,\n    protected readonly inheritableMetadata: Record<string, unknown>,\n    protected readonly _parentRunId?: string\n  ) {}\n\n  get parentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleText(text: string): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleText?.(\n              text,\n              this.runId,\n              this._parentRunId,\n              this.tags\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleText: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleCustomEvent(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    _runId?: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleCustomEvent?.(\n              eventName,\n              data,\n              this.runId,\n              this.tags,\n              this.metadata\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * Manages callbacks for retriever runs.\n */\nexport class CallbackManagerForRetrieverRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleRetrieverEnd(documents: DocumentInterface[]): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverEnd?.(\n                documents,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetriever`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleRetrieverError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (error) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForLLMRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  async handleLLMNewToken(\n    token: string,\n    idx?: NewTokenIndices,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMNewToken?.(\n                token,\n                idx ?? { prompt: 0, completion: 0 },\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                fields\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForChainRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleChainError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleChainEnd(\n    output: ChainValues,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentAction(action: AgentAction): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentAction?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentEnd(action: AgentFinish): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentEnd?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForToolRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleToolError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nexport class CallbackManager\n  extends BaseCallbackManager\n  implements BaseCallbackManagerMethods\n{\n  handlers: BaseCallbackHandler[] = [];\n\n  inheritableHandlers: BaseCallbackHandler[] = [];\n\n  tags: string[] = [];\n\n  inheritableTags: string[] = [];\n\n  metadata: Record<string, unknown> = {};\n\n  inheritableMetadata: Record<string, unknown> = {};\n\n  name = \"callback_manager\";\n\n  public _parentRunId?: string;\n\n  constructor(\n    parentRunId?: string,\n    options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }\n  ) {\n    super();\n    this.handlers = options?.handlers ?? this.handlers;\n    this.inheritableHandlers =\n      options?.inheritableHandlers ?? this.inheritableHandlers;\n    this.tags = options?.tags ?? this.tags;\n    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n    this.metadata = options?.metadata ?? this.metadata;\n    this.inheritableMetadata =\n      options?.inheritableMetadata ?? this.inheritableMetadata;\n    this._parentRunId = parentRunId;\n  }\n\n  /**\n   * Gets the parent run ID, if any.\n   *\n   * @returns The parent run ID.\n   */\n  getParentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      prompts.map(async (prompt, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForLLMStart(\n                llm,\n                [prompt],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                await handler.handleLLMStart?.(\n                  llm,\n                  [prompt],\n                  runId_,\n                  this._parentRunId,\n                  extraParams,\n                  this.tags,\n                  this.metadata,\n                  runName\n                );\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      messages.map(async (messageGroup, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForChatModelStart(\n                llm,\n                [messageGroup],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                if (handler.handleChatModelStart) {\n                  await handler.handleChatModelStart?.(\n                    llm,\n                    [messageGroup],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                } else if (handler.handleLLMStart) {\n                  const messageString = getBufferString(messageGroup);\n                  await handler.handleLLMStart?.(\n                    llm,\n                    [messageString],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                }\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId = uuidv4(),\n    runType: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForChainRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreChain) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForChainStart(\n            chain,\n            inputs,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runType,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleChainStart?.(\n              chain,\n              inputs,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runType,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleChainStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForChainRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForToolRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreAgent) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForToolStart(\n            tool,\n            input,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleToolStart?.(\n              tool,\n              input,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleToolStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForToolRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForRetrieverRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreRetriever) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForRetrieverStart(\n            retriever,\n            query,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleRetrieverStart?.(\n              retriever,\n              query,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForRetrieverRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreCustomEvent) {\n            try {\n              await handler.handleCustomEvent?.(\n                eventName,\n                data,\n                runId,\n                this.tags,\n                this.metadata\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  addHandler(handler: BaseCallbackHandler, inherit = true): void {\n    this.handlers.push(handler);\n    if (inherit) {\n      this.inheritableHandlers.push(handler);\n    }\n  }\n\n  removeHandler(handler: BaseCallbackHandler): void {\n    this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n    this.inheritableHandlers = this.inheritableHandlers.filter(\n      (_handler) => _handler !== handler\n    );\n  }\n\n  setHandlers(handlers: BaseCallbackHandler[], inherit = true): void {\n    this.handlers = [];\n    this.inheritableHandlers = [];\n    for (const handler of handlers) {\n      this.addHandler(handler, inherit);\n    }\n  }\n\n  addTags(tags: string[], inherit = true): void {\n    this.removeTags(tags); // Remove duplicates\n    this.tags.push(...tags);\n    if (inherit) {\n      this.inheritableTags.push(...tags);\n    }\n  }\n\n  removeTags(tags: string[]): void {\n    this.tags = this.tags.filter((tag) => !tags.includes(tag));\n    this.inheritableTags = this.inheritableTags.filter(\n      (tag) => !tags.includes(tag)\n    );\n  }\n\n  addMetadata(metadata: Record<string, unknown>, inherit = true): void {\n    this.metadata = { ...this.metadata, ...metadata };\n    if (inherit) {\n      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n    }\n  }\n\n  removeMetadata(metadata: Record<string, unknown>): void {\n    for (const key of Object.keys(metadata)) {\n      delete this.metadata[key];\n      delete this.inheritableMetadata[key];\n    }\n  }\n\n  copy(\n    additionalHandlers: BaseCallbackHandler[] = [],\n    inherit = true\n  ): CallbackManager {\n    const manager = new CallbackManager(this._parentRunId);\n    for (const handler of this.handlers) {\n      const inheritable = this.inheritableHandlers.includes(handler);\n      manager.addHandler(handler, inheritable);\n    }\n    for (const tag of this.tags) {\n      const inheritable = this.inheritableTags.includes(tag);\n      manager.addTags([tag], inheritable);\n    }\n    for (const key of Object.keys(this.metadata)) {\n      const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n    }\n    for (const handler of additionalHandlers) {\n      if (\n        // Prevent multiple copies of console_callback_handler\n        manager.handlers\n          .filter((h) => h.name === \"console_callback_handler\")\n          .some((h) => h.name === handler.name)\n      ) {\n        continue;\n      }\n      manager.addHandler(handler, inherit);\n    }\n    return manager;\n  }\n\n  static fromHandlers(handlers: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuidv4();\n\n      constructor() {\n        super();\n        Object.assign(this, handlers);\n      }\n    }\n\n    const manager = new this();\n    manager.addHandler(new Handler());\n    return manager;\n  }\n\n  static configure(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ): CallbackManager | undefined {\n    return this._configureSync(\n      inheritableHandlers,\n      localHandlers,\n      inheritableTags,\n      localTags,\n      inheritableMetadata,\n      localMetadata,\n      options\n    );\n  }\n\n  // TODO: Deprecate async method in favor of this one.\n  static _configureSync(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ) {\n    let callbackManager: CallbackManager | undefined;\n    if (inheritableHandlers || localHandlers) {\n      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n        callbackManager = new CallbackManager();\n        callbackManager.setHandlers(\n          inheritableHandlers?.map(ensureHandler) ?? [],\n          true\n        );\n      } else {\n        callbackManager = inheritableHandlers;\n      }\n\n      callbackManager = callbackManager.copy(\n        Array.isArray(localHandlers)\n          ? localHandlers.map(ensureHandler)\n          : localHandlers?.handlers,\n        false\n      );\n    }\n\n    const verboseEnabled =\n      getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n      options?.verbose;\n\n    const tracingV2Enabled =\n      LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n      isTracingEnabled();\n\n    const tracingEnabled =\n      tracingV2Enabled ||\n      (getEnvironmentVariable(\"LANGCHAIN_TRACING\") ?? false);\n    if (verboseEnabled || tracingEnabled) {\n      if (!callbackManager) {\n        callbackManager = new CallbackManager();\n      }\n      if (\n        verboseEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === ConsoleCallbackHandler.prototype.name\n        )\n      ) {\n        const consoleHandler = new ConsoleCallbackHandler();\n        callbackManager.addHandler(consoleHandler, true);\n      }\n      if (\n        tracingEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === \"langchain_tracer\"\n        )\n      ) {\n        if (tracingV2Enabled) {\n          const tracerV2 = new LangChainTracer();\n          callbackManager.addHandler(tracerV2, true);\n        }\n      }\n      if (tracingV2Enabled) {\n        // handoff between langchain and langsmith/traceable\n        // override the parent run ID\n        const implicitRunTree = LangChainTracer.getTraceableRunTree();\n        if (implicitRunTree && callbackManager._parentRunId === undefined) {\n          callbackManager._parentRunId = implicitRunTree.id;\n          const tracerV2 = callbackManager.handlers.find(\n            (handler) => handler.name === \"langchain_tracer\"\n          ) as LangChainTracer | undefined;\n          tracerV2?.updateFromRunTree(implicitRunTree);\n        }\n      }\n    }\n\n    for (const {\n      contextVar,\n      inheritable = true,\n      handlerClass,\n      envVar,\n    } of _getConfigureHooks()) {\n      const createIfNotInContext =\n        envVar && getEnvironmentVariable(envVar) === \"true\" && handlerClass;\n      let handler: BaseCallbackHandler | undefined;\n      const contextVarValue =\n        contextVar !== undefined ? getContextVariable(contextVar) : undefined;\n      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {\n        handler = contextVarValue;\n      } else if (createIfNotInContext) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handler = new (handlerClass as any)({});\n      }\n      if (handler !== undefined) {\n        if (!callbackManager) {\n          callbackManager = new CallbackManager();\n        }\n\n        if (!callbackManager.handlers.some((h) => h.name === handler!.name)) {\n          callbackManager.addHandler(handler, inheritable);\n        }\n      }\n    }\n\n    if (inheritableTags || localTags) {\n      if (callbackManager) {\n        callbackManager.addTags(inheritableTags ?? []);\n        callbackManager.addTags(localTags ?? [], false);\n      }\n    }\n    if (inheritableMetadata || localMetadata) {\n      if (callbackManager) {\n        callbackManager.addMetadata(inheritableMetadata ?? {});\n        callbackManager.addMetadata(localMetadata ?? {}, false);\n      }\n    }\n\n    return callbackManager;\n  }\n}\n\nexport function ensureHandler(\n  handler: BaseCallbackHandler | CallbackHandlerMethods\n): BaseCallbackHandler {\n  if (\"name\" in handler) {\n    return handler;\n  }\n\n  return BaseCallbackHandler.fromMethods(handler);\n}\n"],"names":["arg: Callbacks | BaseCallbackConfig | undefined","handler: BaseCallbackHandler","runId: string","handlers: BaseCallbackHandler[]","inheritableHandlers: BaseCallbackHandler[]","tags: string[]","inheritableTags: string[]","metadata: Record<string, unknown>","inheritableMetadata: Record<string, unknown>","_parentRunId?: string","text: string","consumeCallback","eventName: string","data: any","_runId?: string","_tags?: string[]","_metadata?: Record<string, any>","tag?: string","documents: DocumentInterface[]","err: Error | unknown","token: string","idx?: NewTokenIndices","fields?: HandleLLMNewTokenCallbackFields","extraParams?: Record<string, unknown>","err","output: LLMResult","kwargs?: { inputs?: Record<string, unknown> }","output: ChainValues","action: AgentAction","action: AgentFinish","output: any","parentRunId?: string","options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }","llm: Serialized","prompts: string[]","runId: string | undefined","_parentRunId: string | undefined","extraParams: Record<string, unknown> | undefined","_tags: string[] | undefined","_metadata: Record<string, unknown> | undefined","runName: string | undefined","isBaseTracer","messages: BaseMessage[][]","getBufferString","chain: Serialized","inputs: ChainValues","runType: string | undefined","tool: Serialized","input: string","retriever: Serialized","query: string","additionalHandlers: BaseCallbackHandler[]","handlers: CallbackHandlerMethods","BaseCallbackHandler","inheritableHandlers?: Callbacks","localHandlers?: Callbacks","inheritableTags?: string[]","localTags?: string[]","inheritableMetadata?: Record<string, unknown>","localMetadata?: Record<string, unknown>","options?: CallbackManagerOptions","callbackManager: CallbackManager | undefined","getEnvironmentVariable","LangChainTracer","isTracingEnabled","ConsoleCallbackHandler","_getConfigureHooks","handler: BaseCallbackHandler | undefined","getContextVariable","isBaseCallbackHandler","handler: BaseCallbackHandler | CallbackHandlerMethods"],"mappings":"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"}},
    {"offset": {"line": 1679, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/callbacks/base.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/callbacks/base.ts"],"sourcesContent":["import * as uuid from \"uuid\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type {\n  ChatGenerationChunk,\n  GenerationChunk,\n  LLMResult,\n} from \"../outputs.js\";\nimport {\n  Serializable,\n  Serialized,\n  SerializedNotImplemented,\n  get_lc_unique_name,\n} from \"../load/serializable.js\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Error = any;\n\n/**\n * Interface for the input parameters of the BaseCallbackHandler class. It\n * allows to specify which types of events should be ignored by the\n * callback handler.\n */\nexport interface BaseCallbackHandlerInput {\n  ignoreLLM?: boolean;\n  ignoreChain?: boolean;\n  ignoreAgent?: boolean;\n  ignoreRetriever?: boolean;\n  ignoreCustomEvent?: boolean;\n  _awaitHandler?: boolean;\n  raiseError?: boolean;\n}\n\n/**\n * Interface for the indices of a new token produced by an LLM or Chat\n * Model in streaming mode.\n */\nexport interface NewTokenIndices {\n  prompt: number;\n  completion: number;\n}\n\n// TODO: Add all additional callback fields here\nexport type HandleLLMNewTokenCallbackFields = {\n  chunk?: GenerationChunk | ChatGenerationChunk;\n};\n\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nabstract class BaseCallbackHandlerMethodsClass {\n  /**\n   * Called at the start of an LLM or Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleLLMStart?(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called when an LLM/ChatModel in `streaming` mode produces a new token\n   */\n  handleLLMNewToken?(\n    token: string,\n    /**\n     * idx.prompt is the index of the prompt that produced the token\n     *   (if there are multiple prompts)\n     * idx.completion is the index of the completion that produced the token\n     *   (if multiple completions per prompt are requested)\n     */\n    idx: NewTokenIndices,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if an LLM/ChatModel run encounters an error\n   */\n  handleLLMError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of an LLM/ChatModel run, with the output and the run ID.\n   */\n  handleLLMEnd?(\n    output: LLMResult,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleChatModelStart?(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chain run, with the chain name and inputs\n   * and the run ID.\n   */\n  handleChainStart?(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runType?: string,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Chain run encounters an error\n   */\n  handleChainError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Chain run, with the outputs and the run ID.\n   */\n  handleChainEnd?(\n    outputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Tool run, with the tool name and input\n   * and the run ID.\n   */\n  handleToolStart?(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Tool run encounters an error\n   */\n  handleToolError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Tool run, with the tool output and the run ID.\n   */\n  handleToolEnd?(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    output: any,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleText?(\n    text: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent is about to execute an action,\n   * with the action and the run ID.\n   */\n  handleAgentAction?(\n    action: AgentAction,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent finishes execution, before it exits.\n   * with the final output and the run ID.\n   */\n  handleAgentEnd?(\n    action: AgentFinish,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  handleRetrieverStart?(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    name?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverEnd?(\n    documents: DocumentInterface[],\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n}\n\n/**\n * Base interface for callbacks. All methods are optional. If a method is not\n * implemented, it will be ignored. If a method is implemented, it will be\n * called at the appropriate time. All methods are called with the run ID of\n * the LLM/ChatModel/Chain that is running, which is generated by the\n * CallbackManager.\n *\n * @interface\n */\nexport type CallbackHandlerMethods = BaseCallbackHandlerMethodsClass;\n\n/**\n * Interface for handlers that can indicate a preference for streaming responses.\n * When implemented, this allows the handler to signal whether it prefers to receive\n * streaming responses from language models rather than complete responses.\n */\nexport interface CallbackHandlerPrefersStreaming {\n  readonly lc_prefer_streaming: boolean;\n}\n\nexport function callbackHandlerPrefersStreaming(x: BaseCallbackHandler) {\n  return \"lc_prefer_streaming\" in x && x.lc_prefer_streaming;\n}\n\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nexport abstract class BaseCallbackHandler\n  extends BaseCallbackHandlerMethodsClass\n  implements BaseCallbackHandlerInput, Serializable\n{\n  lc_serializable = false;\n\n  get lc_namespace(): [\"langchain_core\", \"callbacks\", string] {\n    return [\"langchain_core\", \"callbacks\", this.name];\n  }\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_attributes(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof BaseCallbackHandler),\n    ];\n  }\n\n  lc_kwargs: SerializedFields;\n\n  abstract name: string;\n\n  ignoreLLM = false;\n\n  ignoreChain = false;\n\n  ignoreAgent = false;\n\n  ignoreRetriever = false;\n\n  ignoreCustomEvent = false;\n\n  raiseError = false;\n\n  awaitHandlers =\n    getEnvironmentVariable(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\";\n\n  constructor(input?: BaseCallbackHandlerInput) {\n    super();\n    this.lc_kwargs = input || {};\n    if (input) {\n      this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n      this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n      this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n      this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n      this.ignoreCustomEvent =\n        input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n      this.raiseError = input.raiseError ?? this.raiseError;\n      this.awaitHandlers =\n        this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n    }\n  }\n\n  copy(): BaseCallbackHandler {\n    return new (this.constructor as new (\n      input?: BaseCallbackHandlerInput\n    ) => BaseCallbackHandler)(this);\n  }\n\n  toJSON(): Serialized {\n    return Serializable.prototype.toJSON.call(this);\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return Serializable.prototype.toJSONNotImplemented.call(this);\n  }\n\n  static fromMethods(methods: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuid.v4();\n\n      constructor() {\n        super();\n        Object.assign(this, methods);\n      }\n    }\n    return new Handler();\n  }\n}\n\nexport const isBaseCallbackHandler = (x: unknown) => {\n  const callbackHandler = x as BaseCallbackHandler;\n  return (\n    callbackHandler !== undefined &&\n    typeof callbackHandler.copy === \"function\" &&\n    typeof callbackHandler.name === \"string\" &&\n    typeof callbackHandler.awaitHandlers === \"boolean\"\n  );\n};\n"],"names":["x: BaseCallbackHandler","input?: BaseCallbackHandlerInput","methods: CallbackHandlerMethods","x: unknown"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwDA,IAAe,kCAAf,MAA+C;AA4N9C;AAsBD,SAAgB,gCAAgCA,CAAAA,EAAwB;IACtE,OAAO,yBAAyB,KAAK,EAAE,mBAAA;AACxC;;;;;;GAQD,IAAsB,sBAAtB,cACU,gCAEV;IACE,kBAAkB,MAAA;IAElB,IAAI,eAAwD;QAC1D,OAAO;YAAC;YAAkB;YAAa,IAAA,CAAK,IAAA;SAAK;IAClD;IAED,IAAI,aAAoD;QACtD,OAAO,KAAA;IACR;IAED,IAAI,gBAAuD;QACzD,OAAO,KAAA;IACR;IAED,IAAI,aAAoD;QACtD,OAAO,KAAA;IACR;IAED,IAAI,uBAA6C;QAC/C,OAAO,KAAA;IACR;;;;;;IAQD,OAAO,UAAkB;QACvB,OAAO,IAAA,CAAK,IAAA;IACb;;;IAKD,IAAI,QAAkB;QACpB,OAAO,CACL;eAAG,IAAA,CAAK,YAAA;gBACR,2LAAA,EAAmB,IAAA,CAAK,WAAA,CAA0C,AACnE;SAAA;IACF;IAED,UAAA;IAIA,YAAY,MAAA;IAEZ,cAAc,MAAA;IAEd,cAAc,MAAA;IAEd,kBAAkB,MAAA;IAElB,oBAAoB,MAAA;IAEpB,aAAa,MAAA;IAEb,oBACE,uLAAA,EAAuB,iCAAiC,KAAK,QAAA;IAE/D,YAAYC,KAAAA,CAAkC;QAC5C,KAAA,EAAO;QACP,IAAA,CAAK,SAAA,GAAY,SAAS,CAAE;QAC5B,IAAI,OAAO;YACT,IAAA,CAAK,SAAA,GAAY,MAAM,SAAA,IAAa,IAAA,CAAK,SAAA;YACzC,IAAA,CAAK,WAAA,GAAc,MAAM,WAAA,IAAe,IAAA,CAAK,WAAA;YAC7C,IAAA,CAAK,WAAA,GAAc,MAAM,WAAA,IAAe,IAAA,CAAK,WAAA;YAC7C,IAAA,CAAK,eAAA,GAAkB,MAAM,eAAA,IAAmB,IAAA,CAAK,eAAA;YACrD,IAAA,CAAK,iBAAA,GACH,MAAM,iBAAA,IAAqB,IAAA,CAAK,iBAAA;YAClC,IAAA,CAAK,UAAA,GAAa,MAAM,UAAA,IAAc,IAAA,CAAK,UAAA;YAC3C,IAAA,CAAK,aAAA,GACH,IAAA,CAAK,UAAA,IAAA,CAAe,MAAM,aAAA,IAAiB,IAAA,CAAK,aAAA;QACnD;IACF;IAED,OAA4B;QAC1B,OAAO,IAAK,IAAA,CAAK,WAAA,CAES,IAAA;IAC3B;IAED,SAAqB;QACnB,OAAO,qLAAA,CAAa,SAAA,CAAU,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK;IAChD;IAED,uBAAiD;QAC/C,OAAO,qLAAA,CAAa,SAAA,CAAU,oBAAA,CAAqB,IAAA,CAAK,IAAA,CAAK;IAC9D;IAED,OAAO,YAAYC,OAAAA,EAAiC;QAClD,MAAM,gBAAgB,oBAAoB;YACxC,OAAO,KAAK,4NAAA,EAAI,CAAA;YAEhB,aAAc;gBACZ,KAAA,EAAO;gBACP,OAAO,MAAA,CAAO,IAAA,EAAM,QAAQ;YAC7B;QACF;QACD,OAAO,IAAI;IACZ;AACF;AAED,MAAa,wBAAwB,CAACC,MAAe;IACnD,MAAM,kBAAkB;IACxB,OACE,oBAAoB,KAAA,KACpB,OAAO,gBAAgB,IAAA,KAAS,cAChC,OAAO,gBAAgB,IAAA,KAAS,YAChC,OAAO,gBAAgB,aAAA,KAAkB;AAE5C"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/callbacks/promises.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/callbacks/promises.ts"],"sourcesContent":["import { awaitAllCallbacks, consumeCallback } from \"../singletons/callbacks.js\";\n\nexport { awaitAllCallbacks, consumeCallback };\n"],"names":[],"mappings":""}},
    {"offset": {"line": 1826, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/callbacks/manager.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/callbacks/manager.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport { LLMResult } from \"../outputs.js\";\nimport {\n  BaseCallbackHandler,\n  CallbackHandlerMethods,\n  HandleLLMNewTokenCallbackFields,\n  isBaseCallbackHandler,\n  NewTokenIndices,\n} from \"./base.js\";\nimport { ConsoleCallbackHandler } from \"../tracers/console.js\";\nimport { type BaseMessage } from \"../messages/base.js\";\nimport { getBufferString } from \"../messages/utils.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { LangChainTracer } from \"../tracers/tracer_langchain.js\";\nimport { consumeCallback } from \"./promises.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { isTracingEnabled } from \"../utils/callbacks.js\";\nimport { isBaseTracer } from \"../tracers/base.js\";\nimport {\n  getContextVariable,\n  _getConfigureHooks,\n} from \"../singletons/async_local_storage/context.js\";\n\ntype BaseCallbackManagerMethods = {\n  [K in keyof CallbackHandlerMethods]?: (\n    ...args: Parameters<Required<CallbackHandlerMethods>[K]>\n  ) => Promise<unknown>;\n};\n\nexport interface CallbackManagerOptions {\n  verbose?: boolean;\n  tracing?: boolean;\n}\n\nexport type Callbacks =\n  | CallbackManager\n  | (BaseCallbackHandler | CallbackHandlerMethods)[];\n\nexport interface BaseCallbackConfig {\n  /**\n   * Name for the tracer run for this call. Defaults to the name of the class.\n   */\n  runName?: string;\n\n  /**\n   * Tags for this call and any sub-calls (eg. a Chain calling an LLM).\n   * You can use these to filter calls.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Keys should be strings, values should be JSON-serializable.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Callbacks for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Unique identifier for the tracer run for this call. If not provided, a new UUID\n   * will be generated.\n   */\n  runId?: string;\n}\n\nexport function parseCallbackConfigArg(\n  arg: Callbacks | BaseCallbackConfig | undefined\n): BaseCallbackConfig {\n  if (!arg) {\n    return {};\n  } else if (Array.isArray(arg) || \"name\" in arg) {\n    return { callbacks: arg };\n  } else {\n    return arg;\n  }\n}\n\n/**\n * Manage callbacks from different components of LangChain.\n */\nexport abstract class BaseCallbackManager {\n  abstract addHandler(handler: BaseCallbackHandler): void;\n\n  abstract removeHandler(handler: BaseCallbackHandler): void;\n\n  abstract setHandlers(handlers: BaseCallbackHandler[]): void;\n\n  setHandler(handler: BaseCallbackHandler): void {\n    return this.setHandlers([handler]);\n  }\n}\n\n/**\n * Base class for run manager in LangChain.\n */\nexport class BaseRunManager {\n  constructor(\n    public readonly runId: string,\n    public readonly handlers: BaseCallbackHandler[],\n    protected readonly inheritableHandlers: BaseCallbackHandler[],\n    protected readonly tags: string[],\n    protected readonly inheritableTags: string[],\n    protected readonly metadata: Record<string, unknown>,\n    protected readonly inheritableMetadata: Record<string, unknown>,\n    protected readonly _parentRunId?: string\n  ) {}\n\n  get parentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleText(text: string): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleText?.(\n              text,\n              this.runId,\n              this._parentRunId,\n              this.tags\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleText: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleCustomEvent(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    _runId?: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleCustomEvent?.(\n              eventName,\n              data,\n              this.runId,\n              this.tags,\n              this.metadata\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * Manages callbacks for retriever runs.\n */\nexport class CallbackManagerForRetrieverRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleRetrieverEnd(documents: DocumentInterface[]): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverEnd?.(\n                documents,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetriever`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleRetrieverError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (error) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForLLMRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  async handleLLMNewToken(\n    token: string,\n    idx?: NewTokenIndices,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMNewToken?.(\n                token,\n                idx ?? { prompt: 0, completion: 0 },\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                fields\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForChainRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleChainError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleChainEnd(\n    output: ChainValues,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentAction(action: AgentAction): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentAction?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentEnd(action: AgentFinish): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentEnd?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForToolRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleToolError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nexport class CallbackManager\n  extends BaseCallbackManager\n  implements BaseCallbackManagerMethods\n{\n  handlers: BaseCallbackHandler[] = [];\n\n  inheritableHandlers: BaseCallbackHandler[] = [];\n\n  tags: string[] = [];\n\n  inheritableTags: string[] = [];\n\n  metadata: Record<string, unknown> = {};\n\n  inheritableMetadata: Record<string, unknown> = {};\n\n  name = \"callback_manager\";\n\n  public _parentRunId?: string;\n\n  constructor(\n    parentRunId?: string,\n    options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }\n  ) {\n    super();\n    this.handlers = options?.handlers ?? this.handlers;\n    this.inheritableHandlers =\n      options?.inheritableHandlers ?? this.inheritableHandlers;\n    this.tags = options?.tags ?? this.tags;\n    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n    this.metadata = options?.metadata ?? this.metadata;\n    this.inheritableMetadata =\n      options?.inheritableMetadata ?? this.inheritableMetadata;\n    this._parentRunId = parentRunId;\n  }\n\n  /**\n   * Gets the parent run ID, if any.\n   *\n   * @returns The parent run ID.\n   */\n  getParentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      prompts.map(async (prompt, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForLLMStart(\n                llm,\n                [prompt],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                await handler.handleLLMStart?.(\n                  llm,\n                  [prompt],\n                  runId_,\n                  this._parentRunId,\n                  extraParams,\n                  this.tags,\n                  this.metadata,\n                  runName\n                );\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      messages.map(async (messageGroup, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForChatModelStart(\n                llm,\n                [messageGroup],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                if (handler.handleChatModelStart) {\n                  await handler.handleChatModelStart?.(\n                    llm,\n                    [messageGroup],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                } else if (handler.handleLLMStart) {\n                  const messageString = getBufferString(messageGroup);\n                  await handler.handleLLMStart?.(\n                    llm,\n                    [messageString],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                }\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId = uuidv4(),\n    runType: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForChainRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreChain) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForChainStart(\n            chain,\n            inputs,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runType,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleChainStart?.(\n              chain,\n              inputs,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runType,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleChainStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForChainRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForToolRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreAgent) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForToolStart(\n            tool,\n            input,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleToolStart?.(\n              tool,\n              input,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleToolStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForToolRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForRetrieverRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreRetriever) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForRetrieverStart(\n            retriever,\n            query,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleRetrieverStart?.(\n              retriever,\n              query,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForRetrieverRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreCustomEvent) {\n            try {\n              await handler.handleCustomEvent?.(\n                eventName,\n                data,\n                runId,\n                this.tags,\n                this.metadata\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  addHandler(handler: BaseCallbackHandler, inherit = true): void {\n    this.handlers.push(handler);\n    if (inherit) {\n      this.inheritableHandlers.push(handler);\n    }\n  }\n\n  removeHandler(handler: BaseCallbackHandler): void {\n    this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n    this.inheritableHandlers = this.inheritableHandlers.filter(\n      (_handler) => _handler !== handler\n    );\n  }\n\n  setHandlers(handlers: BaseCallbackHandler[], inherit = true): void {\n    this.handlers = [];\n    this.inheritableHandlers = [];\n    for (const handler of handlers) {\n      this.addHandler(handler, inherit);\n    }\n  }\n\n  addTags(tags: string[], inherit = true): void {\n    this.removeTags(tags); // Remove duplicates\n    this.tags.push(...tags);\n    if (inherit) {\n      this.inheritableTags.push(...tags);\n    }\n  }\n\n  removeTags(tags: string[]): void {\n    this.tags = this.tags.filter((tag) => !tags.includes(tag));\n    this.inheritableTags = this.inheritableTags.filter(\n      (tag) => !tags.includes(tag)\n    );\n  }\n\n  addMetadata(metadata: Record<string, unknown>, inherit = true): void {\n    this.metadata = { ...this.metadata, ...metadata };\n    if (inherit) {\n      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n    }\n  }\n\n  removeMetadata(metadata: Record<string, unknown>): void {\n    for (const key of Object.keys(metadata)) {\n      delete this.metadata[key];\n      delete this.inheritableMetadata[key];\n    }\n  }\n\n  copy(\n    additionalHandlers: BaseCallbackHandler[] = [],\n    inherit = true\n  ): CallbackManager {\n    const manager = new CallbackManager(this._parentRunId);\n    for (const handler of this.handlers) {\n      const inheritable = this.inheritableHandlers.includes(handler);\n      manager.addHandler(handler, inheritable);\n    }\n    for (const tag of this.tags) {\n      const inheritable = this.inheritableTags.includes(tag);\n      manager.addTags([tag], inheritable);\n    }\n    for (const key of Object.keys(this.metadata)) {\n      const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n    }\n    for (const handler of additionalHandlers) {\n      if (\n        // Prevent multiple copies of console_callback_handler\n        manager.handlers\n          .filter((h) => h.name === \"console_callback_handler\")\n          .some((h) => h.name === handler.name)\n      ) {\n        continue;\n      }\n      manager.addHandler(handler, inherit);\n    }\n    return manager;\n  }\n\n  static fromHandlers(handlers: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuidv4();\n\n      constructor() {\n        super();\n        Object.assign(this, handlers);\n      }\n    }\n\n    const manager = new this();\n    manager.addHandler(new Handler());\n    return manager;\n  }\n\n  static configure(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ): CallbackManager | undefined {\n    return this._configureSync(\n      inheritableHandlers,\n      localHandlers,\n      inheritableTags,\n      localTags,\n      inheritableMetadata,\n      localMetadata,\n      options\n    );\n  }\n\n  // TODO: Deprecate async method in favor of this one.\n  static _configureSync(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ) {\n    let callbackManager: CallbackManager | undefined;\n    if (inheritableHandlers || localHandlers) {\n      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n        callbackManager = new CallbackManager();\n        callbackManager.setHandlers(\n          inheritableHandlers?.map(ensureHandler) ?? [],\n          true\n        );\n      } else {\n        callbackManager = inheritableHandlers;\n      }\n\n      callbackManager = callbackManager.copy(\n        Array.isArray(localHandlers)\n          ? localHandlers.map(ensureHandler)\n          : localHandlers?.handlers,\n        false\n      );\n    }\n\n    const verboseEnabled =\n      getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n      options?.verbose;\n\n    const tracingV2Enabled =\n      LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n      isTracingEnabled();\n\n    const tracingEnabled =\n      tracingV2Enabled ||\n      (getEnvironmentVariable(\"LANGCHAIN_TRACING\") ?? false);\n    if (verboseEnabled || tracingEnabled) {\n      if (!callbackManager) {\n        callbackManager = new CallbackManager();\n      }\n      if (\n        verboseEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === ConsoleCallbackHandler.prototype.name\n        )\n      ) {\n        const consoleHandler = new ConsoleCallbackHandler();\n        callbackManager.addHandler(consoleHandler, true);\n      }\n      if (\n        tracingEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === \"langchain_tracer\"\n        )\n      ) {\n        if (tracingV2Enabled) {\n          const tracerV2 = new LangChainTracer();\n          callbackManager.addHandler(tracerV2, true);\n        }\n      }\n      if (tracingV2Enabled) {\n        // handoff between langchain and langsmith/traceable\n        // override the parent run ID\n        const implicitRunTree = LangChainTracer.getTraceableRunTree();\n        if (implicitRunTree && callbackManager._parentRunId === undefined) {\n          callbackManager._parentRunId = implicitRunTree.id;\n          const tracerV2 = callbackManager.handlers.find(\n            (handler) => handler.name === \"langchain_tracer\"\n          ) as LangChainTracer | undefined;\n          tracerV2?.updateFromRunTree(implicitRunTree);\n        }\n      }\n    }\n\n    for (const {\n      contextVar,\n      inheritable = true,\n      handlerClass,\n      envVar,\n    } of _getConfigureHooks()) {\n      const createIfNotInContext =\n        envVar && getEnvironmentVariable(envVar) === \"true\" && handlerClass;\n      let handler: BaseCallbackHandler | undefined;\n      const contextVarValue =\n        contextVar !== undefined ? getContextVariable(contextVar) : undefined;\n      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {\n        handler = contextVarValue;\n      } else if (createIfNotInContext) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handler = new (handlerClass as any)({});\n      }\n      if (handler !== undefined) {\n        if (!callbackManager) {\n          callbackManager = new CallbackManager();\n        }\n\n        if (!callbackManager.handlers.some((h) => h.name === handler!.name)) {\n          callbackManager.addHandler(handler, inheritable);\n        }\n      }\n    }\n\n    if (inheritableTags || localTags) {\n      if (callbackManager) {\n        callbackManager.addTags(inheritableTags ?? []);\n        callbackManager.addTags(localTags ?? [], false);\n      }\n    }\n    if (inheritableMetadata || localMetadata) {\n      if (callbackManager) {\n        callbackManager.addMetadata(inheritableMetadata ?? {});\n        callbackManager.addMetadata(localMetadata ?? {}, false);\n      }\n    }\n\n    return callbackManager;\n  }\n}\n\nexport function ensureHandler(\n  handler: BaseCallbackHandler | CallbackHandlerMethods\n): BaseCallbackHandler {\n  if (\"name\" in handler) {\n    return handler;\n  }\n\n  return BaseCallbackHandler.fromMethods(handler);\n}\n"],"names":["arg: Callbacks | BaseCallbackConfig | undefined","handler: BaseCallbackHandler","runId: string","handlers: BaseCallbackHandler[]","inheritableHandlers: BaseCallbackHandler[]","tags: string[]","inheritableTags: string[]","metadata: Record<string, unknown>","inheritableMetadata: Record<string, unknown>","_parentRunId?: string","text: string","eventName: string","data: any","_runId?: string","_tags?: string[]","_metadata?: Record<string, any>","tag?: string","documents: DocumentInterface[]","err: Error | unknown","token: string","idx?: NewTokenIndices","fields?: HandleLLMNewTokenCallbackFields","extraParams?: Record<string, unknown>","err","output: LLMResult","kwargs?: { inputs?: Record<string, unknown> }","output: ChainValues","action: AgentAction","action: AgentFinish","output: any","parentRunId?: string","options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }","llm: Serialized","prompts: string[]","runId: string | undefined","_parentRunId: string | undefined","extraParams: Record<string, unknown> | undefined","_tags: string[] | undefined","_metadata: Record<string, unknown> | undefined","runName: string | undefined","uuidv4","messages: BaseMessage[][]","chain: Serialized","inputs: ChainValues","runType: string | undefined","tool: Serialized","input: string","retriever: Serialized","query: string","additionalHandlers: BaseCallbackHandler[]","handlers: CallbackHandlerMethods","inheritableHandlers?: Callbacks","localHandlers?: Callbacks","inheritableTags?: string[]","localTags?: string[]","inheritableMetadata?: Record<string, unknown>","localMetadata?: Record<string, unknown>","options?: CallbackManagerOptions","callbackManager: CallbackManager | undefined","handler: BaseCallbackHandler | undefined","handler: BaseCallbackHandler | CallbackHandlerMethods"],"mappings":"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"}},
    {"offset": {"line": 2403, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/tracer.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/tracer.ts"],"sourcesContent":["import { Client } from \"langsmith\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\nlet client: Client;\n\nexport const getDefaultLangChainClientSingleton = () => {\n  if (client === undefined) {\n    const clientParams =\n      getEnvironmentVariable(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n        ? {\n            // LangSmith has its own backgrounding system\n            blockOnRootRunFinalization: true,\n          }\n        : {};\n    client = new Client(clientParams);\n  }\n  return client;\n};\n\nexport const setDefaultLangChainClientSingleton = (newClient: Client) => {\n  client = newClient;\n};\n"],"names":["client: Client","getEnvironmentVariable","Client"],"mappings":";;;;AAGA,IAAIA;AAEJ,MAAa,qCAAqC,MAAM;IACtD,IAAI,WAAW,KAAA,GAAW;QACxB,MAAM,eACJC,kBAAAA,sBAAAA,CAAuB,iCAAiC,KAAK,UACzD;YAEE,4BAA4B;QAC7B,IACD,CAAE;QACR,SAAS,IAAIC,UAAAA,MAAAA,CAAO;IACrB;IACD,OAAO;AACR"}},
    {"offset": {"line": 2422, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/async_local_storage/globals.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nexport interface AsyncLocalStorageInterface {\n  getStore: () => any | undefined;\n\n  run: <T>(store: any, callback: () => T) => T;\n\n  enterWith: (store: any) => void;\n}\n\nexport const TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\n\nexport const _CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\n\nexport const setGlobalAsyncLocalStorageInstance = (\n  instance: AsyncLocalStorageInterface\n) => {\n  (globalThis as any)[TRACING_ALS_KEY] = instance;\n};\n\nexport const getGlobalAsyncLocalStorageInstance = ():\n  | AsyncLocalStorageInterface\n  | undefined => {\n  return (globalThis as any)[TRACING_ALS_KEY];\n};\n"],"names":["instance: AsyncLocalStorageInterface"],"mappings":";AASA,MAAa,kBAAkB,OAAO,GAAA,CAAI,iCAAiC;AAE3E,MAAa,yBAAyB,OAAO,GAAA,CAAI,uBAAuB;AAExE,MAAa,qCAAqC,CAChDA,aACG;IACF,UAAA,CAAmB,gBAAA,GAAmB;AACxC;AAED,MAAa,qCAAqC,MAEjC;IACf,OAAQ,UAAA,CAAmB,gBAAA;AAC5B"}},
    {"offset": {"line": 2438, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/callbacks.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/callbacks.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport PQueueMod from \"p-queue\";\nimport { getGlobalAsyncLocalStorageInstance } from \"./async_local_storage/globals.js\";\nimport { getDefaultLangChainClientSingleton } from \"./tracer.js\";\n\nlet queue: typeof import(\"p-queue\")[\"default\"][\"prototype\"];\n\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n  const PQueue: any = \"default\" in PQueueMod ? PQueueMod.default : PQueueMod;\n  return new PQueue({\n    autoStart: true,\n    concurrency: 1,\n  });\n}\n\nexport function getQueue() {\n  if (typeof queue === \"undefined\") {\n    queue = createQueue();\n  }\n  return queue;\n}\n\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nexport async function consumeCallback<T>(\n  promiseFn: () => Promise<T> | T | void,\n  wait: boolean\n): Promise<void> {\n  if (wait === true) {\n    // Clear config since callbacks are not part of the root run\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n    if (asyncLocalStorageInstance !== undefined) {\n      await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n    } else {\n      await promiseFn();\n    }\n  } else {\n    queue = getQueue();\n    // eslint-disable-next-line no-void\n    void queue.add(async () => {\n      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n      if (asyncLocalStorageInstance !== undefined) {\n        await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n      } else {\n        await promiseFn();\n      }\n    });\n  }\n}\n\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nexport async function awaitAllCallbacks(): Promise<void> {\n  const defaultClient = getDefaultLangChainClientSingleton();\n  await Promise.allSettled([\n    typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve(),\n    defaultClient.awaitPendingTraceBatches(),\n  ]);\n}\n"],"names":["queue: typeof import(\"p-queue\")[\"default\"][\"prototype\"]","PQueue: any","PQueueMod","promiseFn: () => Promise<T> | T | void","wait: boolean","getGlobalAsyncLocalStorageInstance","getDefaultLangChainClientSingleton"],"mappings":";;;;;AAMA,IAAIA;;;;;GAOJ,SAAS,cAAc;IACrB,MAAMC,SAAc,aAAaC,QAAAA,OAAAA,GAAYA,QAAAA,OAAAA,CAAU,OAAA,GAAUA,QAAAA,OAAAA;IACjE,OAAO,IAAI,OAAO;QAChB,WAAW;QACX,aAAa;IACd;AACF;AAED,SAAgB,WAAW;IACzB,IAAI,OAAO,UAAU,aACnB,QAAQ,aAAa;IAEvB,OAAO;AACR;;;;;GAOD,eAAsB,gBACpBC,SAAAA,EACAC,IAAAA,EACe;IACf,IAAI,SAAS,MAAM;QAGjB,MAAM,4BAA4BC,gBAAAA,kCAAAA,EAAoC;QACtE,IAAI,8BAA8B,KAAA,GAChC,MAAM,0BAA0B,GAAA,CAAI,KAAA,GAAW,UAAY,WAAW,CAAC;aAEvE,MAAM,WAAW;IAEpB,OAAM;QACL,QAAQ,UAAU;QAEb,MAAM,GAAA,CAAI,YAAY;YACzB,MAAM,4BAA4BA,gBAAAA,kCAAAA,EAAoC;YACtE,IAAI,8BAA8B,KAAA,GAChC,MAAM,0BAA0B,GAAA,CAAI,KAAA,GAAW,UAAY,WAAW,CAAC;iBAEvE,MAAM,WAAW;QAEpB,EAAC;IACH;AACF;;;;GAMD,eAAsB,oBAAmC;IACvD,MAAM,gBAAgBC,eAAAA,kCAAAA,EAAoC;IAC1D,MAAM,QAAQ,UAAA,CAAW;QACvB,OAAO,UAAU,cAAc,MAAM,MAAA,EAAQ,GAAG,QAAQ,OAAA,EAAS;QACjE,cAAc,wBAAA,EAA0B,AACzC;KAAA,CAAC;AACH"}},
    {"offset": {"line": 2493, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/async_local_storage/context.ts"],"sourcesContent":["import { isRunTree, RunTree } from \"langsmith/run_trees\";\nimport { BaseCallbackHandler } from \"../../callbacks/base.js\";\nimport {\n  _CONTEXT_VARIABLES_KEY,\n  getGlobalAsyncLocalStorageInstance,\n} from \"./globals.js\";\n\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\nexport function setContextVariable<T>(name: PropertyKey, value: T): void {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    throw new Error(\n      `Internal error: Global shared async local storage instance has not been initialized.`\n    );\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  const contextVars = { ...runTree?.[_CONTEXT_VARIABLES_KEY] };\n  contextVars[name] = value;\n  let newValue = {};\n  if (isRunTree(runTree)) {\n    newValue = new RunTree(runTree);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (newValue as any)[_CONTEXT_VARIABLES_KEY] = contextVars;\n  asyncLocalStorageInstance.enterWith(newValue);\n}\n\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getContextVariable<T = any>(name: PropertyKey): T | undefined {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    return undefined;\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];\n}\n\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\n\nexport const _getConfigureHooks = () =>\n  getContextVariable<ConfigureHook[]>(LC_CONFIGURE_HOOKS_KEY) || [];\n\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nexport const registerConfigureHook = (config: ConfigureHook) => {\n  if (config.envVar && !config.handlerClass) {\n    throw new Error(\n      \"If envVar is set, handlerClass must also be set to a non-None value.\"\n    );\n  }\n  setContextVariable(LC_CONFIGURE_HOOKS_KEY, [..._getConfigureHooks(), config]);\n};\n\nexport type ConfigureHook = {\n  contextVar?: string;\n  inheritable?: boolean;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handlerClass?: new (...args: any[]) => BaseCallbackHandler;\n  envVar?: string;\n};\n"],"names":["name: PropertyKey","value: T","getGlobalAsyncLocalStorageInstance","_CONTEXT_VARIABLES_KEY","RunTree","config: ConfigureHook"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyDA,SAAgB,mBAAsBA,IAAAA,EAAmBC,KAAAA,EAAgB;IAEvE,MAAM,4BAA4BC,gBAAAA,kCAAAA,EAAoC;IACtE,IAAI,8BAA8B,KAAA,EAChC,CAAA,MAAM,IAAI,MACR,CAAC,oFAAoF,CAAC;IAG1F,MAAM,UAAU,0BAA0B,QAAA,EAAU;IACpD,MAAM,cAAc;QAAE,GAAG,SAAA,CAAUC,gBAAAA,sBAAAA,CAAAA;IAAyB;IAC5D,WAAA,CAAY,KAAA,GAAQ;IACpB,IAAI,WAAW,CAAE;IACjB,IAAA,CAAA,GAAA,oBAAA,SAAA,EAAc,QAAQ,EACpB,WAAW,IAAIC,oBAAAA,OAAAA,CAAQ;IAGxB,QAAA,CAAiBD,gBAAAA,sBAAAA,CAAAA,GAA0B;IAC5C,0BAA0B,SAAA,CAAU,SAAS;AAC9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoDD,SAAgB,mBAA4BH,IAAAA,EAAkC;IAE5E,MAAM,4BAA4BE,gBAAAA,kCAAAA,EAAoC;IACtE,IAAI,8BAA8B,KAAA,EAChC,CAAA,OAAO,KAAA;IAET,MAAM,UAAU,0BAA0B,QAAA,EAAU;IACpD,OAAO,SAAA,CAAUC,gBAAAA,sBAAAA,CAAAA,EAAAA,CAA0B,KAAA;AAC5C;AAED,MAAM,yBAAyB,OAAO,qBAAqB;AAE3D,MAAa,qBAAqB,IAChC,mBAAoC,uBAAuB,IAAI,CAAE,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+CnE,MAAa,wBAAwB,CAACE,WAA0B;IAC9D,IAAI,OAAO,MAAA,IAAU,CAAC,OAAO,YAAA,CAC3B,CAAA,MAAM,IAAI,MACR;IAGJ,mBAAmB,wBAAwB,CAAC;WAAG,oBAAoB;QAAE,MAAO;KAAA,CAAC;AAC9E"}},
    {"offset": {"line": 2674, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/async_local_storage/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { RunTree } from \"langsmith\";\nimport {\n  AsyncLocalStorageInterface,\n  getGlobalAsyncLocalStorageInstance,\n  setGlobalAsyncLocalStorageInstance,\n  _CONTEXT_VARIABLES_KEY,\n} from \"./globals.js\";\nimport { CallbackManager } from \"../../callbacks/manager.js\";\nimport { LangChainTracer } from \"../../tracers/tracer_langchain.js\";\n\nexport class MockAsyncLocalStorage implements AsyncLocalStorageInterface {\n  getStore(): any {\n    return undefined;\n  }\n\n  run<T>(_store: any, callback: () => T): T {\n    return callback();\n  }\n\n  enterWith(_store: any) {\n    return undefined;\n  }\n}\n\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\n\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\n\nclass AsyncLocalStorageProvider {\n  getInstance(): AsyncLocalStorageInterface {\n    return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage;\n  }\n\n  getRunnableConfig() {\n    const storage = this.getInstance();\n    // this has the runnable config\n    // which means that we should also have an instance of a LangChainTracer\n    // with the run map prepopulated\n    return storage.getStore()?.extra?.[LC_CHILD_KEY];\n  }\n\n  runWithConfig<T>(\n    config: any,\n    callback: () => T,\n    avoidCreatingRootRunTree?: boolean\n  ): T {\n    const callbackManager = CallbackManager._configureSync(\n      config?.callbacks,\n      undefined,\n      config?.tags,\n      undefined,\n      config?.metadata\n    );\n    const storage = this.getInstance();\n    const previousValue = storage.getStore();\n    const parentRunId = callbackManager?.getParentRunId();\n\n    const langChainTracer = callbackManager?.handlers?.find(\n      (handler) => handler?.name === \"langchain_tracer\"\n    ) as LangChainTracer | undefined;\n\n    let runTree;\n    if (langChainTracer && parentRunId) {\n      runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);\n    } else if (!avoidCreatingRootRunTree) {\n      runTree = new RunTree({\n        name: \"<runnable_lambda>\",\n        tracingEnabled: false,\n      });\n    }\n\n    if (runTree) {\n      runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n    }\n\n    if (\n      previousValue !== undefined &&\n      previousValue[_CONTEXT_VARIABLES_KEY] !== undefined\n    ) {\n      if (runTree === undefined) {\n        runTree = {};\n      }\n      (runTree as any)[_CONTEXT_VARIABLES_KEY] =\n        previousValue[_CONTEXT_VARIABLES_KEY];\n    }\n\n    return storage.run(runTree, callback);\n  }\n\n  initializeGlobalInstance(instance: AsyncLocalStorageInterface) {\n    if (getGlobalAsyncLocalStorageInstance() === undefined) {\n      setGlobalAsyncLocalStorageInstance(instance);\n    }\n  }\n}\n\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\nexport { AsyncLocalStorageProviderSingleton, type AsyncLocalStorageInterface };\n"],"names":["_store: any","callback: () => T","getGlobalAsyncLocalStorageInstance","config: any","avoidCreatingRootRunTree?: boolean","CallbackManager","RunTree","_CONTEXT_VARIABLES_KEY","instance: AsyncLocalStorageInterface","setGlobalAsyncLocalStorageInstance"],"mappings":";;;;;AAWA,IAAa,wBAAb,MAAyE;IACvE,WAAgB;QACd,OAAO,KAAA;IACR;IAED,IAAOA,MAAAA,EAAaC,QAAAA,EAAsB;QACxC,OAAO,UAAU;IAClB;IAED,UAAUD,MAAAA,EAAa;QACrB,OAAO,KAAA;IACR;AACF;AAED,MAAM,wBAAwB,IAAI;AAElC,MAAM,eAAe,OAAO,GAAA,CAAI,kBAAkB;AAElD,IAAM,4BAAN,MAAgC;IAC9B,cAA0C;QACxC,OAAOE,gBAAAA,kCAAAA,EAAoC,IAAI;IAChD;IAED,oBAAoB;QAClB,MAAM,UAAU,IAAA,CAAK,WAAA,EAAa;QAIlC,OAAO,QAAQ,QAAA,EAAU,EAAE,OAAA,CAAQ,aAAA;IACpC;IAED,cACEC,MAAAA,EACAF,QAAAA,EACAG,wBAAAA,EACG;QACH,MAAM,kBAAkBC,0BAAAA,eAAAA,CAAgB,cAAA,CACtC,QAAQ,WACR,KAAA,GACA,QAAQ,MACR,KAAA,GACA,QAAQ,SACT;QACD,MAAM,UAAU,IAAA,CAAK,WAAA,EAAa;QAClC,MAAM,gBAAgB,QAAQ,QAAA,EAAU;QACxC,MAAM,cAAc,iBAAiB,gBAAgB;QAErD,MAAM,kBAAkB,iBAAiB,UAAU,KACjD,CAAC,UAAY,SAAS,SAAS,mBAChC;QAED,IAAI;QACJ,IAAI,mBAAmB,aACrB,UAAU,gBAAgB,2BAAA,CAA4B,YAAY;iBACzD,CAAC,0BACV,UAAU,IAAIC,UAAAA,OAAAA,CAAQ;YACpB,MAAM;YACN,gBAAgB;QACjB;QAGH,IAAI,SACF,QAAQ,KAAA,GAAQ;YAAE,GAAG,QAAQ,KAAA;aAAQ,aAAA,EAAe;QAAQ;QAG9D,IACE,kBAAkB,KAAA,KAClB,aAAA,CAAcC,gBAAAA,sBAAAA,CAAAA,KAA4B,KAAA,GAC1C;YACA,IAAI,YAAY,KAAA,GACd,UAAU,CAAE;YAEb,OAAA,CAAgBA,gBAAAA,sBAAAA,CAAAA,GACf,aAAA,CAAcA,gBAAAA,sBAAAA,CAAAA;QACjB;QAED,OAAO,QAAQ,GAAA,CAAI,SAAS,SAAS;IACtC;IAED,yBAAyBC,QAAAA,EAAsC;QAC7D,IAAIN,gBAAAA,kCAAAA,EAAoC,KAAK,KAAA,GAC3CO,gBAAAA,kCAAAA,CAAmC,SAAS;IAE/C;AACF;AAED,MAAM,qCAAqC,IAAI"}},
    {"offset": {"line": 2733, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/index.ts"],"sourcesContent":["import {\n  type AsyncLocalStorageInterface,\n  AsyncLocalStorageProviderSingleton,\n  MockAsyncLocalStorage,\n} from \"./async_local_storage/index.js\";\nimport { _CONTEXT_VARIABLES_KEY } from \"./async_local_storage/globals.js\";\n\nexport {\n  type AsyncLocalStorageInterface,\n  AsyncLocalStorageProviderSingleton,\n  MockAsyncLocalStorage,\n};\nexport { _CONTEXT_VARIABLES_KEY };\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2757, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/async_local_storage/globals.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nexport interface AsyncLocalStorageInterface {\n  getStore: () => any | undefined;\n\n  run: <T>(store: any, callback: () => T) => T;\n\n  enterWith: (store: any) => void;\n}\n\nexport const TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\n\nexport const _CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\n\nexport const setGlobalAsyncLocalStorageInstance = (\n  instance: AsyncLocalStorageInterface\n) => {\n  (globalThis as any)[TRACING_ALS_KEY] = instance;\n};\n\nexport const getGlobalAsyncLocalStorageInstance = ():\n  | AsyncLocalStorageInterface\n  | undefined => {\n  return (globalThis as any)[TRACING_ALS_KEY];\n};\n"],"names":["instance: AsyncLocalStorageInterface"],"mappings":";;;;;;;;;AASA,MAAa,kBAAkB,OAAO,GAAA,CAAI,iCAAiC;AAE3E,MAAa,yBAAyB,OAAO,GAAA,CAAI,uBAAuB;AAExE,MAAa,qCAAqC,CAChDA,aACG;IACF,UAAA,CAAmB,gBAAA,GAAmB;AACxC;AAED,MAAa,qCAAqC,MAEjC;IACf,OAAQ,UAAA,CAAmB,gBAAA;AAC5B"}},
    {"offset": {"line": 2780, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/tracer.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/tracer.ts"],"sourcesContent":["import { Client } from \"langsmith\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\nlet client: Client;\n\nexport const getDefaultLangChainClientSingleton = () => {\n  if (client === undefined) {\n    const clientParams =\n      getEnvironmentVariable(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n        ? {\n            // LangSmith has its own backgrounding system\n            blockOnRootRunFinalization: true,\n          }\n        : {};\n    client = new Client(clientParams);\n  }\n  return client;\n};\n\nexport const setDefaultLangChainClientSingleton = (newClient: Client) => {\n  client = newClient;\n};\n"],"names":["client: Client"],"mappings":";;;;;;;;;;AAGA,IAAIA;AAEJ,MAAa,qCAAqC,MAAM;IACtD,IAAI,WAAW,KAAA,GAAW;QACxB,MAAM,mBACJ,uLAAA,EAAuB,iCAAiC,KAAK,UACzD;YAEE,4BAA4B;QAC7B,IACD,CAAE;QACR,SAAS,IAAI,sJAAA,CAAO;IACrB;IACD,OAAO;AACR"}},
    {"offset": {"line": 2806, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/callbacks.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/callbacks.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport PQueueMod from \"p-queue\";\nimport { getGlobalAsyncLocalStorageInstance } from \"./async_local_storage/globals.js\";\nimport { getDefaultLangChainClientSingleton } from \"./tracer.js\";\n\nlet queue: typeof import(\"p-queue\")[\"default\"][\"prototype\"];\n\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n  const PQueue: any = \"default\" in PQueueMod ? PQueueMod.default : PQueueMod;\n  return new PQueue({\n    autoStart: true,\n    concurrency: 1,\n  });\n}\n\nexport function getQueue() {\n  if (typeof queue === \"undefined\") {\n    queue = createQueue();\n  }\n  return queue;\n}\n\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nexport async function consumeCallback<T>(\n  promiseFn: () => Promise<T> | T | void,\n  wait: boolean\n): Promise<void> {\n  if (wait === true) {\n    // Clear config since callbacks are not part of the root run\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n    if (asyncLocalStorageInstance !== undefined) {\n      await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n    } else {\n      await promiseFn();\n    }\n  } else {\n    queue = getQueue();\n    // eslint-disable-next-line no-void\n    void queue.add(async () => {\n      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n      if (asyncLocalStorageInstance !== undefined) {\n        await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n      } else {\n        await promiseFn();\n      }\n    });\n  }\n}\n\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nexport async function awaitAllCallbacks(): Promise<void> {\n  const defaultClient = getDefaultLangChainClientSingleton();\n  await Promise.allSettled([\n    typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve(),\n    defaultClient.awaitPendingTraceBatches(),\n  ]);\n}\n"],"names":["queue: typeof import(\"p-queue\")[\"default\"][\"prototype\"]","PQueue: any","promiseFn: () => Promise<T> | T | void","wait: boolean"],"mappings":";;;;;;;;;;;;;AAMA,IAAIA;;;;;GAOJ,SAAS,cAAc;IACrB,MAAMC,SAAc,aAAa,wJAAA,GAAY,wJAAA,CAAU,OAAA,GAAU,wJAAA;IACjE,OAAO,IAAI,OAAO;QAChB,WAAW;QACX,aAAa;IACd;AACF;AAED,SAAgB,WAAW;IACzB,IAAI,OAAO,UAAU,aACnB,QAAQ,aAAa;IAEvB,OAAO;AACR;;;;;GAOD,eAAsB,gBACpBC,SAAAA,EACAC,IAAAA,EACe;IACf,IAAI,SAAS,MAAM;QAGjB,MAAM,gCAA4B,mOAAA,EAAoC;QACtE,IAAI,8BAA8B,KAAA,GAChC,MAAM,0BAA0B,GAAA,CAAI,KAAA,GAAW,UAAY,WAAW,CAAC;aAEvE,MAAM,WAAW;IAEpB,OAAM;QACL,QAAQ,UAAU;QAEb,MAAM,GAAA,CAAI,YAAY;YACzB,MAAM,4BAA4B,oCAAoC;YACtE,IAAI,8BAA8B,KAAA,GAChC,MAAM,0BAA0B,GAAA,CAAI,KAAA,GAAW,UAAY,WAAW,CAAC;iBAEvE,MAAM,WAAW;QAEpB,EAAC;IACH;AACF;;;;GAMD,eAAsB,oBAAmC;IACvD,MAAM,oBAAgB,2MAAA,EAAoC;IAC1D,MAAM,QAAQ,UAAA,CAAW;QACvB,OAAO,UAAU,cAAc,MAAM,MAAA,EAAQ,GAAG,QAAQ,OAAA,EAAS;QACjE,cAAc,wBAAA,EAA0B,AACzC;KAAA,CAAC;AACH"}},
    {"offset": {"line": 2869, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/async_local_storage/context.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/async_local_storage/context.ts"],"sourcesContent":["import { isRunTree, RunTree } from \"langsmith/run_trees\";\nimport { BaseCallbackHandler } from \"../../callbacks/base.js\";\nimport {\n  _CONTEXT_VARIABLES_KEY,\n  getGlobalAsyncLocalStorageInstance,\n} from \"./globals.js\";\n\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\nexport function setContextVariable<T>(name: PropertyKey, value: T): void {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    throw new Error(\n      `Internal error: Global shared async local storage instance has not been initialized.`\n    );\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  const contextVars = { ...runTree?.[_CONTEXT_VARIABLES_KEY] };\n  contextVars[name] = value;\n  let newValue = {};\n  if (isRunTree(runTree)) {\n    newValue = new RunTree(runTree);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (newValue as any)[_CONTEXT_VARIABLES_KEY] = contextVars;\n  asyncLocalStorageInstance.enterWith(newValue);\n}\n\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getContextVariable<T = any>(name: PropertyKey): T | undefined {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    return undefined;\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];\n}\n\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\n\nexport const _getConfigureHooks = () =>\n  getContextVariable<ConfigureHook[]>(LC_CONFIGURE_HOOKS_KEY) || [];\n\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nexport const registerConfigureHook = (config: ConfigureHook) => {\n  if (config.envVar && !config.handlerClass) {\n    throw new Error(\n      \"If envVar is set, handlerClass must also be set to a non-None value.\"\n    );\n  }\n  setContextVariable(LC_CONFIGURE_HOOKS_KEY, [..._getConfigureHooks(), config]);\n};\n\nexport type ConfigureHook = {\n  contextVar?: string;\n  inheritable?: boolean;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handlerClass?: new (...args: any[]) => BaseCallbackHandler;\n  envVar?: string;\n};\n"],"names":["name: PropertyKey","value: T","config: ConfigureHook"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyDA,SAAgB,mBAAsBA,IAAAA,EAAmBC,KAAAA,EAAgB;IAEvE,MAAM,gCAA4B,mOAAA,EAAoC;IACtE,IAAI,8BAA8B,KAAA,EAChC,CAAA,MAAM,IAAI,MACR,CAAC,oFAAoF,CAAC;IAG1F,MAAM,UAAU,0BAA0B,QAAA,EAAU;IACpD,MAAM,cAAc;QAAE,GAAG,SAAA,CAAU,uNAAA,CAAA;IAAyB;IAC5D,WAAA,CAAY,KAAA,GAAQ;IACpB,IAAI,WAAW,CAAE;IACjB,QAAI,6JAAA,EAAU,QAAQ,EACpB,WAAW,IAAI,2JAAA,CAAQ;IAGxB,QAAA,CAAiB,uNAAA,CAAA,GAA0B;IAC5C,0BAA0B,SAAA,CAAU,SAAS;AAC9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoDD,SAAgB,mBAA4BD,IAAAA,EAAkC;IAE5E,MAAM,gCAA4B,mOAAA,EAAoC;IACtE,IAAI,8BAA8B,KAAA,EAChC,CAAA,OAAO,KAAA;IAET,MAAM,UAAU,0BAA0B,QAAA,EAAU;IACpD,OAAO,SAAA,CAAU,uNAAA,CAAA,EAAA,CAA0B,KAAA;AAC5C;AAED,MAAM,yBAAyB,OAAO,qBAAqB;AAE3D,MAAa,qBAAqB,IAChC,mBAAoC,uBAAuB,IAAI,CAAE,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+CnE,MAAa,wBAAwB,CAACE,WAA0B;IAC9D,IAAI,OAAO,MAAA,IAAU,CAAC,OAAO,YAAA,CAC3B,CAAA,MAAM,IAAI,MACR;IAGJ,mBAAmB,wBAAwB,CAAC;WAAG,oBAAoB;QAAE,MAAO;KAAA,CAAC;AAC9E"}},
    {"offset": {"line": 3060, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/async_local_storage/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/async_local_storage/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { RunTree } from \"langsmith\";\nimport {\n  AsyncLocalStorageInterface,\n  getGlobalAsyncLocalStorageInstance,\n  setGlobalAsyncLocalStorageInstance,\n  _CONTEXT_VARIABLES_KEY,\n} from \"./globals.js\";\nimport { CallbackManager } from \"../../callbacks/manager.js\";\nimport { LangChainTracer } from \"../../tracers/tracer_langchain.js\";\n\nexport class MockAsyncLocalStorage implements AsyncLocalStorageInterface {\n  getStore(): any {\n    return undefined;\n  }\n\n  run<T>(_store: any, callback: () => T): T {\n    return callback();\n  }\n\n  enterWith(_store: any) {\n    return undefined;\n  }\n}\n\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\n\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\n\nclass AsyncLocalStorageProvider {\n  getInstance(): AsyncLocalStorageInterface {\n    return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage;\n  }\n\n  getRunnableConfig() {\n    const storage = this.getInstance();\n    // this has the runnable config\n    // which means that we should also have an instance of a LangChainTracer\n    // with the run map prepopulated\n    return storage.getStore()?.extra?.[LC_CHILD_KEY];\n  }\n\n  runWithConfig<T>(\n    config: any,\n    callback: () => T,\n    avoidCreatingRootRunTree?: boolean\n  ): T {\n    const callbackManager = CallbackManager._configureSync(\n      config?.callbacks,\n      undefined,\n      config?.tags,\n      undefined,\n      config?.metadata\n    );\n    const storage = this.getInstance();\n    const previousValue = storage.getStore();\n    const parentRunId = callbackManager?.getParentRunId();\n\n    const langChainTracer = callbackManager?.handlers?.find(\n      (handler) => handler?.name === \"langchain_tracer\"\n    ) as LangChainTracer | undefined;\n\n    let runTree;\n    if (langChainTracer && parentRunId) {\n      runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);\n    } else if (!avoidCreatingRootRunTree) {\n      runTree = new RunTree({\n        name: \"<runnable_lambda>\",\n        tracingEnabled: false,\n      });\n    }\n\n    if (runTree) {\n      runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n    }\n\n    if (\n      previousValue !== undefined &&\n      previousValue[_CONTEXT_VARIABLES_KEY] !== undefined\n    ) {\n      if (runTree === undefined) {\n        runTree = {};\n      }\n      (runTree as any)[_CONTEXT_VARIABLES_KEY] =\n        previousValue[_CONTEXT_VARIABLES_KEY];\n    }\n\n    return storage.run(runTree, callback);\n  }\n\n  initializeGlobalInstance(instance: AsyncLocalStorageInterface) {\n    if (getGlobalAsyncLocalStorageInstance() === undefined) {\n      setGlobalAsyncLocalStorageInstance(instance);\n    }\n  }\n}\n\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\nexport { AsyncLocalStorageProviderSingleton, type AsyncLocalStorageInterface };\n"],"names":["_store: any","callback: () => T","config: any","avoidCreatingRootRunTree?: boolean","instance: AsyncLocalStorageInterface"],"mappings":";;;;;;;;;;;;;;AAWA,IAAa,wBAAb,MAAyE;IACvE,WAAgB;QACd,OAAO,KAAA;IACR;IAED,IAAOA,MAAAA,EAAaC,QAAAA,EAAsB;QACxC,OAAO,UAAU;IAClB;IAED,UAAUD,MAAAA,EAAa;QACrB,OAAO,KAAA;IACR;AACF;AAED,MAAM,wBAAwB,IAAI;AAElC,MAAM,eAAe,OAAO,GAAA,CAAI,kBAAkB;AAElD,IAAM,4BAAN,MAAgC;IAC9B,cAA0C;QACxC,WAAO,mOAAA,EAAoC,KAAI;IAChD;IAED,oBAAoB;QAClB,MAAM,UAAU,IAAA,CAAK,WAAA,EAAa;QAIlC,OAAO,QAAQ,QAAA,EAAU,EAAE,OAAA,CAAQ,aAAA;IACpC;IAED,cACEE,MAAAA,EACAD,QAAAA,EACAE,wBAAAA,EACG;QACH,MAAM,kBAAkB,wLAAA,CAAgB,cAAA,CACtC,QAAQ,WACR,KAAA,GACA,QAAQ,MACR,KAAA,GACA,QAAQ,SACT;QACD,MAAM,UAAU,IAAA,CAAK,WAAA,EAAa;QAClC,MAAM,gBAAgB,QAAQ,QAAA,EAAU;QACxC,MAAM,cAAc,iBAAiB,gBAAgB;QAErD,MAAM,kBAAkB,iBAAiB,UAAU,KACjD,CAAC,UAAY,SAAS,SAAS,mBAChC;QAED,IAAI;QACJ,IAAI,mBAAmB,aACrB,UAAU,gBAAgB,2BAAA,CAA4B,YAAY;iBACzD,CAAC,0BACV,UAAU,IAAI,uJAAA,CAAQ;YACpB,MAAM;YACN,gBAAgB;QACjB;QAGH,IAAI,SACF,QAAQ,KAAA,GAAQ;YAAE,GAAG,QAAQ,KAAA;aAAQ,aAAA,EAAe;QAAQ;QAG9D,IACE,kBAAkB,KAAA,KAClB,aAAA,CAAc,uNAAA,CAAA,KAA4B,KAAA,GAC1C;YACA,IAAI,YAAY,KAAA,GACd,UAAU,CAAE;YAEb,OAAA,CAAgB,uNAAA,CAAA,GACf,aAAA,CAAc,uNAAA,CAAA;QACjB;QAED,OAAO,QAAQ,GAAA,CAAI,SAAS,SAAS;IACtC;IAED,yBAAyBC,QAAAA,EAAsC;QAC7D,QAAI,mOAAA,EAAoC,MAAK,KAAA,OAC3C,mOAAA,EAAmC,SAAS;IAE/C;AACF;AAED,MAAM,qCAAqC,IAAI"}},
    {"offset": {"line": 3128, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/singletons/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/singletons/index.ts"],"sourcesContent":["import {\n  type AsyncLocalStorageInterface,\n  AsyncLocalStorageProviderSingleton,\n  MockAsyncLocalStorage,\n} from \"./async_local_storage/index.js\";\nimport { _CONTEXT_VARIABLES_KEY } from \"./async_local_storage/globals.js\";\n\nexport {\n  type AsyncLocalStorageInterface,\n  AsyncLocalStorageProviderSingleton,\n  MockAsyncLocalStorage,\n};\nexport { _CONTEXT_VARIABLES_KEY };\n"],"names":[],"mappings":""}},
    {"offset": {"line": 3150, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/outputs.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/outputs.ts"],"sourcesContent":["import { type BaseMessage, type BaseMessageChunk } from \"./messages/base.js\";\n\nexport const RUN_KEY = \"__run\";\n\n/**\n * Output of a single generation.\n */\nexport interface Generation {\n  /**\n   * Generated text output\n   */\n  text: string;\n  /**\n   * Raw generation info response from the provider.\n   * May include things like reason for finishing (e.g. in {@link OpenAI})\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  generationInfo?: Record<string, any>;\n}\n\nexport type GenerationChunkFields = {\n  text: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  generationInfo?: Record<string, any>;\n};\n\n/**\n * Chunk of a single generation. Used for streaming.\n */\nexport class GenerationChunk implements Generation {\n  public text: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public generationInfo?: Record<string, any>;\n\n  constructor(fields: GenerationChunkFields) {\n    this.text = fields.text;\n    this.generationInfo = fields.generationInfo;\n  }\n\n  concat(chunk: GenerationChunk): GenerationChunk {\n    return new GenerationChunk({\n      text: this.text + chunk.text,\n      generationInfo: {\n        ...this.generationInfo,\n        ...chunk.generationInfo,\n      },\n    });\n  }\n}\n\n/**\n * Contains all relevant information returned by an LLM.\n */\nexport type LLMResult = {\n  /**\n   * List of the things generated. Each input could have multiple {@link Generation | generations}, hence this is a list of lists.\n   */\n  generations: Generation[][];\n  /**\n   * Dictionary of arbitrary LLM-provider specific output.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  llmOutput?: Record<string, any>;\n  /**\n   * Dictionary of run metadata\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [RUN_KEY]?: Record<string, any>;\n};\n\nexport interface ChatGeneration extends Generation {\n  message: BaseMessage;\n}\n\nexport type ChatGenerationChunkFields = GenerationChunkFields & {\n  message: BaseMessageChunk;\n};\n\nexport class ChatGenerationChunk\n  extends GenerationChunk\n  implements ChatGeneration\n{\n  public message: BaseMessageChunk;\n\n  constructor(fields: ChatGenerationChunkFields) {\n    super(fields);\n    this.message = fields.message;\n  }\n\n  concat(chunk: ChatGenerationChunk) {\n    return new ChatGenerationChunk({\n      text: this.text + chunk.text,\n      generationInfo: {\n        ...this.generationInfo,\n        ...chunk.generationInfo,\n      },\n      message: this.message.concat(chunk.message),\n    });\n  }\n}\n\nexport interface ChatResult {\n  generations: ChatGeneration[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  llmOutput?: Record<string, any>;\n}\n"],"names":["fields: GenerationChunkFields","chunk: GenerationChunk","fields: ChatGenerationChunkFields","chunk: ChatGenerationChunk"],"mappings":";;;;;;;;AAEA,MAAa,UAAU;;;GA2BvB,IAAa,kBAAb,MAAa,gBAAsC;IAC1C,KAAA;IAGA,eAAA;IAEP,YAAYA,MAAAA,CAA+B;QACzC,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;QACnB,IAAA,CAAK,cAAA,GAAiB,OAAO,cAAA;IAC9B;IAED,OAAOC,KAAAA,EAAyC;QAC9C,OAAO,IAAI,gBAAgB;YACzB,MAAM,IAAA,CAAK,IAAA,GAAO,MAAM,IAAA;YACxB,gBAAgB;gBACd,GAAG,IAAA,CAAK,cAAA;gBACR,GAAG,MAAM,cAAA;YACV;QACF;IACF;AACF;AA8BD,IAAa,sBAAb,MAAa,4BACH,gBAEV;IACS,QAAA;IAEP,YAAYC,MAAAA,CAAmC;QAC7C,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,OAAA,GAAU,OAAO,OAAA;IACvB;IAED,OAAOC,KAAAA,EAA4B;QACjC,OAAO,IAAI,oBAAoB;YAC7B,MAAM,IAAA,CAAK,IAAA,GAAO,MAAM,IAAA;YACxB,gBAAgB;gBACd,GAAG,IAAA,CAAK,cAAA;gBACR,GAAG,MAAM,cAAA;YACV;YACD,SAAS,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,MAAM,OAAA,CAAQ;QAC5C;IACF;AACF"}},
    {"offset": {"line": 3208, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/prompt_values.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/prompt_values.ts"],"sourcesContent":["import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage } from \"./messages/base.js\";\nimport { HumanMessage } from \"./messages/human.js\";\nimport { getBufferString } from \"./messages/utils.js\";\n\nexport interface BasePromptValueInterface extends Serializable {\n  toString(): string;\n\n  toChatMessages(): BaseMessage[];\n}\n\nexport interface StringPromptValueInterface extends BasePromptValueInterface {\n  value: string;\n}\n\nexport interface ChatPromptValueInterface extends BasePromptValueInterface {\n  messages: BaseMessage[];\n}\n\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nexport abstract class BasePromptValue\n  extends Serializable\n  implements BasePromptValueInterface\n{\n  abstract toString(): string;\n\n  abstract toChatMessages(): BaseMessage[];\n}\n\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nexport class StringPromptValue\n  extends BasePromptValue\n  implements StringPromptValueInterface\n{\n  static lc_name(): string {\n    return \"StringPromptValue\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  value: string;\n\n  constructor(value: string) {\n    super({ value });\n    this.value = value;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  toChatMessages() {\n    return [new HumanMessage(this.value)];\n  }\n}\n\n/**\n * Interface for the fields of a ChatPromptValue.\n */\nexport interface ChatPromptValueFields {\n  messages: BaseMessage[];\n}\n\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nexport class ChatPromptValue\n  extends BasePromptValue\n  implements ChatPromptValueInterface\n{\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ChatPromptValue\";\n  }\n\n  messages: BaseMessage[];\n\n  constructor(messages: BaseMessage[]);\n\n  constructor(fields: ChatPromptValueFields);\n\n  constructor(fields: BaseMessage[] | ChatPromptValueFields) {\n    if (Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { messages: fields };\n    }\n\n    super(fields);\n    this.messages = fields.messages;\n  }\n\n  toString() {\n    return getBufferString(this.messages);\n  }\n\n  toChatMessages() {\n    return this.messages;\n  }\n}\n\nexport type ImageContent = {\n  /** Specifies the detail level of the image. */\n  detail?: \"auto\" | \"low\" | \"high\";\n\n  /** Either a URL of the image or the base64 encoded image data. */\n  url: string;\n};\n\nexport interface ImagePromptValueFields {\n  imageUrl: ImageContent;\n}\n\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nexport class ImagePromptValue extends BasePromptValue {\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ImagePromptValue\";\n  }\n\n  imageUrl: ImageContent;\n\n  /** @ignore */\n  value: string;\n\n  constructor(fields: ImagePromptValueFields);\n\n  constructor(fields: ImageContent);\n\n  constructor(fields: ImageContent | ImagePromptValueFields) {\n    if (!(\"imageUrl\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { imageUrl: fields };\n    }\n\n    super(fields);\n    this.imageUrl = fields.imageUrl;\n  }\n\n  toString() {\n    return this.imageUrl.url;\n  }\n\n  toChatMessages() {\n    return [\n      new HumanMessage({\n        content: [\n          {\n            type: \"image_url\",\n            image_url: {\n              detail: this.imageUrl.detail,\n              url: this.imageUrl.url,\n            },\n          },\n        ],\n      }),\n    ];\n  }\n}\n"],"names":["Serializable","value: string","HumanMessage","fields: BaseMessage[] | ChatPromptValueFields","getBufferString","fields: ImageContent | ImagePromptValueFields"],"mappings":";;;;;;;;;;;;;;GAsBA,IAAsB,kBAAtB,cACUA,0BAAAA,YAAAA,CAEV;AAIC;;;;GAMD,IAAa,oBAAb,cACU,gBAEV;IACE,OAAO,UAAkB;QACvB,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,eAAgB;KAAA,CAAA;IAElD,kBAAkB,KAAA;IAElB,MAAA;IAEA,YAAYC,KAAAA,CAAe;QACzB,KAAA,CAAM;YAAE;QAAO,EAAC;QAChB,IAAA,CAAK,KAAA,GAAQ;IACd;IAED,WAAW;QACT,OAAO,IAAA,CAAK,KAAA;IACb;IAED,iBAAiB;QACf,OAAO;YAAC,IAAIC,cAAAA,YAAAA,CAAa,IAAA,CAAK,KAAA,CAAO;SAAA;IACtC;AACF;;;;GAaD,IAAa,kBAAb,cACU,gBAEV;IACE,eAAe;QAAC;QAAkB,eAAgB;KAAA,CAAA;IAElD,kBAAkB,KAAA;IAElB,OAAO,UAAU;QACf,OAAO;IACR;IAED,SAAA;IAMA,YAAYC,MAAAA,CAA+C;QACzD,IAAI,MAAM,OAAA,CAAQ,OAAO,EAEvB,SAAS;YAAE,UAAU;QAAQ;QAG/B,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,QAAA,GAAW,OAAO,QAAA;IACxB;IAED,WAAW;QACT,OAAOC,cAAAA,eAAAA,CAAgB,IAAA,CAAK,QAAA,CAAS;IACtC;IAED,iBAAiB;QACf,OAAO,IAAA,CAAK,QAAA;IACb;AACF;;;;GAkBD,IAAa,mBAAb,cAAsC,gBAAgB;IACpD,eAAe;QAAC;QAAkB,eAAgB;KAAA,CAAA;IAElD,kBAAkB,KAAA;IAElB,OAAO,UAAU;QACf,OAAO;IACR;IAED,SAAA;mBAGA,MAAA;IAMA,YAAYC,MAAAA,CAA+C;QACzD,IAAI,CAAA,CAAE,cAAc,MAAA,GAElB,SAAS;YAAE,UAAU;QAAQ;QAG/B,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,QAAA,GAAW,OAAO,QAAA;IACxB;IAED,WAAW;QACT,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA;IACtB;IAED,iBAAiB;QACf,OAAO;YACL,IAAIH,cAAAA,YAAAA,CAAa;gBACf,SAAS;oBACP;wBACE,MAAM;wBACN,WAAW;4BACT,QAAQ,IAAA,CAAK,QAAA,CAAS,MAAA;4BACtB,KAAK,IAAA,CAAK,QAAA,CAAS,GAAA;wBACpB;oBACF,CACF;iBAAA;YACF,EACF;SAAA;IACF;AACF"}},
    {"offset": {"line": 3333, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/caches/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/caches/index.ts"],"sourcesContent":["import { sha256, type HashKeyEncoder } from \"../utils/hash.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { mapStoredMessageToChatMessage } from \"../messages/utils.js\";\nimport { type StoredGeneration } from \"../messages/base.js\";\n\nexport const defaultHashKeyEncoder: HashKeyEncoder = (...strings) =>\n  sha256(strings.join(\"_\"));\n\nexport function deserializeStoredGeneration(\n  storedGeneration: StoredGeneration\n) {\n  if (storedGeneration.message !== undefined) {\n    return {\n      text: storedGeneration.text,\n      message: mapStoredMessageToChatMessage(storedGeneration.message),\n    };\n  } else {\n    return { text: storedGeneration.text };\n  }\n}\n\nexport function serializeGeneration(generation: Generation) {\n  const serializedValue: StoredGeneration = {\n    text: generation.text,\n  };\n  if ((generation as ChatGeneration).message !== undefined) {\n    serializedValue.message = (generation as ChatGeneration).message.toDict();\n  }\n  return serializedValue;\n}\n\n/**\n * Base class for all caches. All caches should extend this class.\n */\nexport abstract class BaseCache<T = Generation[]> {\n  protected keyEncoder: HashKeyEncoder = defaultHashKeyEncoder;\n\n  /**\n   * Sets a custom key encoder function for the cache.\n   * This function should take a prompt and an LLM key and return a string\n   * that will be used as the cache key.\n   * @param keyEncoderFn The custom key encoder function.\n   */\n  makeDefaultKeyEncoder(keyEncoderFn: HashKeyEncoder): void {\n    this.keyEncoder = keyEncoderFn;\n  }\n\n  abstract lookup(prompt: string, llmKey: string): Promise<T | null>;\n\n  abstract update(prompt: string, llmKey: string, value: T): Promise<void>;\n}\n\nconst GLOBAL_MAP = new Map();\n\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nexport class InMemoryCache<T = Generation[]> extends BaseCache<T> {\n  private cache: Map<string, T>;\n\n  constructor(map?: Map<string, T>) {\n    super();\n    this.cache = map ?? new Map();\n  }\n\n  /**\n   * Retrieves data from the cache using a prompt and an LLM key. If the\n   * data is not found, it returns null.\n   * @param prompt The prompt used to find the data.\n   * @param llmKey The LLM key used to find the data.\n   * @returns The data corresponding to the prompt and LLM key, or null if not found.\n   */\n  lookup(prompt: string, llmKey: string): Promise<T | null> {\n    return Promise.resolve(\n      this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null\n    );\n  }\n\n  /**\n   * Updates the cache with new data using a prompt and an LLM key.\n   * @param prompt The prompt used to store the data.\n   * @param llmKey The LLM key used to store the data.\n   * @param value The data to be stored.\n   */\n  async update(prompt: string, llmKey: string, value: T): Promise<void> {\n    this.cache.set(this.keyEncoder(prompt, llmKey), value);\n  }\n\n  /**\n   * Returns a global instance of InMemoryCache using a predefined global\n   * map as the initial cache.\n   * @returns A global instance of InMemoryCache.\n   */\n  static global(): InMemoryCache {\n    return new InMemoryCache(GLOBAL_MAP);\n  }\n}\n"],"names":["defaultHashKeyEncoder: HashKeyEncoder","sha256","storedGeneration: StoredGeneration","mapStoredMessageToChatMessage","generation: Generation","serializedValue: StoredGeneration","keyEncoderFn: HashKeyEncoder","map?: Map<string, T>","prompt: string","llmKey: string","value: T"],"mappings":";;;;;;;;;;;;;AAKA,MAAaA,wBAAwC,CAAC,GAAG,UACvDC,aAAAA,MAAAA,CAAO,QAAQ,IAAA,CAAK,IAAI,CAAC;AAE3B,SAAgB,4BACdC,gBAAAA,EACA;IACA,IAAI,iBAAiB,OAAA,KAAY,KAAA,EAC/B,CAAA,OAAO;QACL,MAAM,iBAAiB,IAAA;QACvB,SAASC,cAAAA,6BAAAA,CAA8B,iBAAiB,OAAA,CAAQ;IACjE;SAED,OAAO;QAAE,MAAM,iBAAiB,IAAA;IAAM;AAEzC;AAED,SAAgB,oBAAoBC,UAAAA,EAAwB;IAC1D,MAAMC,kBAAoC;QACxC,MAAM,WAAW,IAAA;IAClB;IACD,IAAK,WAA8B,OAAA,KAAY,KAAA,GAC7C,gBAAgB,OAAA,GAAW,WAA8B,OAAA,CAAQ,MAAA,EAAQ;IAE3E,OAAO;AACR;;;GAKD,IAAsB,YAAtB,MAAkD;IACtC,aAA6B,sBAAA;;;;;;IAQvC,sBAAsBC,YAAAA,EAAoC;QACxD,IAAA,CAAK,UAAA,GAAa;IACnB;AAKF;AAED,MAAM,aAAA,aAAA,GAAa,IAAI;;;GAKvB,IAAa,gBAAb,MAAa,sBAAwC,UAAa;IACxD,MAAA;IAER,YAAYC,GAAAA,CAAsB;QAChC,KAAA,EAAO;QACP,IAAA,CAAK,KAAA,GAAQ,OAAA,aAAA,GAAO,IAAI;IACzB;;;;;;;IASD,OAAOC,MAAAA,EAAgBC,MAAAA,EAAmC;QACxD,OAAO,QAAQ,OAAA,CACb,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAA,CAAK,UAAA,CAAW,QAAQ,OAAO,CAAC,IAAI,KACpD;IACF;;;;;;IAQD,MAAM,OAAOD,MAAAA,EAAgBC,MAAAA,EAAgBC,KAAAA,EAAyB;QACpE,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAA,CAAK,UAAA,CAAW,QAAQ,OAAO,EAAE,MAAM;IACvD;;;;;IAOD,OAAO,SAAwB;QAC7B,OAAO,IAAI,cAAc;IAC1B;AACF"}},
    {"offset": {"line": 3426, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/caches/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/caches/index.ts"],"sourcesContent":["import { sha256, type HashKeyEncoder } from \"../utils/hash.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { mapStoredMessageToChatMessage } from \"../messages/utils.js\";\nimport { type StoredGeneration } from \"../messages/base.js\";\n\nexport const defaultHashKeyEncoder: HashKeyEncoder = (...strings) =>\n  sha256(strings.join(\"_\"));\n\nexport function deserializeStoredGeneration(\n  storedGeneration: StoredGeneration\n) {\n  if (storedGeneration.message !== undefined) {\n    return {\n      text: storedGeneration.text,\n      message: mapStoredMessageToChatMessage(storedGeneration.message),\n    };\n  } else {\n    return { text: storedGeneration.text };\n  }\n}\n\nexport function serializeGeneration(generation: Generation) {\n  const serializedValue: StoredGeneration = {\n    text: generation.text,\n  };\n  if ((generation as ChatGeneration).message !== undefined) {\n    serializedValue.message = (generation as ChatGeneration).message.toDict();\n  }\n  return serializedValue;\n}\n\n/**\n * Base class for all caches. All caches should extend this class.\n */\nexport abstract class BaseCache<T = Generation[]> {\n  protected keyEncoder: HashKeyEncoder = defaultHashKeyEncoder;\n\n  /**\n   * Sets a custom key encoder function for the cache.\n   * This function should take a prompt and an LLM key and return a string\n   * that will be used as the cache key.\n   * @param keyEncoderFn The custom key encoder function.\n   */\n  makeDefaultKeyEncoder(keyEncoderFn: HashKeyEncoder): void {\n    this.keyEncoder = keyEncoderFn;\n  }\n\n  abstract lookup(prompt: string, llmKey: string): Promise<T | null>;\n\n  abstract update(prompt: string, llmKey: string, value: T): Promise<void>;\n}\n\nconst GLOBAL_MAP = new Map();\n\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nexport class InMemoryCache<T = Generation[]> extends BaseCache<T> {\n  private cache: Map<string, T>;\n\n  constructor(map?: Map<string, T>) {\n    super();\n    this.cache = map ?? new Map();\n  }\n\n  /**\n   * Retrieves data from the cache using a prompt and an LLM key. If the\n   * data is not found, it returns null.\n   * @param prompt The prompt used to find the data.\n   * @param llmKey The LLM key used to find the data.\n   * @returns The data corresponding to the prompt and LLM key, or null if not found.\n   */\n  lookup(prompt: string, llmKey: string): Promise<T | null> {\n    return Promise.resolve(\n      this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null\n    );\n  }\n\n  /**\n   * Updates the cache with new data using a prompt and an LLM key.\n   * @param prompt The prompt used to store the data.\n   * @param llmKey The LLM key used to store the data.\n   * @param value The data to be stored.\n   */\n  async update(prompt: string, llmKey: string, value: T): Promise<void> {\n    this.cache.set(this.keyEncoder(prompt, llmKey), value);\n  }\n\n  /**\n   * Returns a global instance of InMemoryCache using a predefined global\n   * map as the initial cache.\n   * @returns A global instance of InMemoryCache.\n   */\n  static global(): InMemoryCache {\n    return new InMemoryCache(GLOBAL_MAP);\n  }\n}\n"],"names":["defaultHashKeyEncoder: HashKeyEncoder","storedGeneration: StoredGeneration","generation: Generation","serializedValue: StoredGeneration","keyEncoderFn: HashKeyEncoder","map?: Map<string, T>","prompt: string","llmKey: string","value: T"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAaA,wBAAwC,CAAC,GAAG,cACvD,wLAAA,EAAO,QAAQ,IAAA,CAAK,IAAI,CAAC;AAE3B,SAAgB,4BACdC,gBAAAA,EACA;IACA,IAAI,iBAAiB,OAAA,KAAY,KAAA,EAC/B,CAAA,OAAO;QACL,MAAM,iBAAiB,IAAA;QACvB,aAAS,mMAAA,EAA8B,iBAAiB,OAAA,CAAQ;IACjE;SAED,OAAO;QAAE,MAAM,iBAAiB,IAAA;IAAM;AAEzC;AAED,SAAgB,oBAAoBC,UAAAA,EAAwB;IAC1D,MAAMC,kBAAoC;QACxC,MAAM,WAAW,IAAA;IAClB;IACD,IAAK,WAA8B,OAAA,KAAY,KAAA,GAC7C,gBAAgB,OAAA,GAAW,WAA8B,OAAA,CAAQ,MAAA,EAAQ;IAE3E,OAAO;AACR;;;GAKD,IAAsB,YAAtB,MAAkD;IACtC,aAA6B,sBAAA;;;;;;IAQvC,sBAAsBC,YAAAA,EAAoC;QACxD,IAAA,CAAK,UAAA,GAAa;IACnB;AAKF;AAED,MAAM,aAAA,aAAA,GAAa,IAAI;;;GAKvB,IAAa,gBAAb,MAAa,sBAAwC,UAAa;IACxD,MAAA;IAER,YAAYC,GAAAA,CAAsB;QAChC,KAAA,EAAO;QACP,IAAA,CAAK,KAAA,GAAQ,OAAA,aAAA,GAAO,IAAI;IACzB;;;;;;;IASD,OAAOC,MAAAA,EAAgBC,MAAAA,EAAmC;QACxD,OAAO,QAAQ,OAAA,CACb,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAA,CAAK,UAAA,CAAW,QAAQ,OAAO,CAAC,IAAI,KACpD;IACF;;;;;;IAQD,MAAM,OAAOD,MAAAA,EAAgBC,MAAAA,EAAgBC,KAAAA,EAAyB;QACpE,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAA,CAAK,UAAA,CAAW,QAAQ,OAAO,EAAE,MAAM;IACvD;;;;;IAOD,OAAO,SAAwB;QAC7B,OAAO,IAAI,cAAc;IAC1B;AACF"}},
    {"offset": {"line": 3526, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/base.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/base.ts"],"sourcesContent":["import type { Tiktoken, TiktokenModel } from \"js-tiktoken/lite\";\nimport type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\n\nimport { type BaseCache, InMemoryCache } from \"../caches/index.js\";\nimport {\n  type BasePromptValueInterface,\n  StringPromptValue,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport {\n  type BaseMessage,\n  type BaseMessageLike,\n  type MessageContent,\n} from \"../messages/base.js\";\nimport { coerceMessageLikeToMessage } from \"../messages/utils.js\";\nimport { type LLMResult } from \"../outputs.js\";\nimport { CallbackManager, Callbacks } from \"../callbacks/manager.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"../utils/async_caller.js\";\nimport { encodingForModel } from \"../utils/tiktoken.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n} from \"../utils/types/zod.js\";\nimport { ModelProfile } from \"./profile.js\";\n\n// https://www.npmjs.com/package/js-tiktoken\n\nexport const getModelNameForTiktoken = (modelName: string): TiktokenModel => {\n  if (modelName.startsWith(\"gpt-5\")) {\n    return \"gpt-5\" as TiktokenModel;\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n    return \"gpt-3.5-turbo-16k\";\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n    return \"gpt-3.5-turbo\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-32k\")) {\n    return \"gpt-4-32k\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-\")) {\n    return \"gpt-4\";\n  }\n\n  if (modelName.startsWith(\"gpt-4o\")) {\n    return \"gpt-4o\";\n  }\n\n  return modelName as TiktokenModel;\n};\n\nexport const getEmbeddingContextSize = (modelName?: string): number => {\n  switch (modelName) {\n    case \"text-embedding-ada-002\":\n      return 8191;\n    default:\n      return 2046;\n  }\n};\n\n/**\n * Get the context window size (max input tokens) for a given model.\n *\n * Context window sizes are sourced from official model documentation:\n * - OpenAI: https://platform.openai.com/docs/models\n * - Anthropic: https://docs.anthropic.com/claude/docs/models-overview\n * - Google: https://ai.google.dev/gemini/docs/models/gemini\n *\n * @param modelName - The name of the model\n * @returns The context window size in tokens\n */\nexport const getModelContextSize = (modelName: string): number => {\n  const normalizedName = getModelNameForTiktoken(modelName) as string;\n\n  switch (normalizedName) {\n    // GPT-5 series\n    case \"gpt-5\":\n    case \"gpt-5-turbo\":\n    case \"gpt-5-turbo-preview\":\n      return 400000;\n\n    // GPT-4o series\n    case \"gpt-4o\":\n    case \"gpt-4o-mini\":\n    case \"gpt-4o-2024-05-13\":\n    case \"gpt-4o-2024-08-06\":\n      return 128000;\n\n    // GPT-4 Turbo series\n    case \"gpt-4-turbo\":\n    case \"gpt-4-turbo-preview\":\n    case \"gpt-4-turbo-2024-04-09\":\n    case \"gpt-4-0125-preview\":\n    case \"gpt-4-1106-preview\":\n      return 128000;\n\n    // GPT-4 series\n    case \"gpt-4-32k\":\n    case \"gpt-4-32k-0314\":\n    case \"gpt-4-32k-0613\":\n      return 32768;\n    case \"gpt-4\":\n    case \"gpt-4-0314\":\n    case \"gpt-4-0613\":\n      return 8192;\n\n    // GPT-3.5 Turbo series\n    case \"gpt-3.5-turbo-16k\":\n    case \"gpt-3.5-turbo-16k-0613\":\n      return 16384;\n    case \"gpt-3.5-turbo\":\n    case \"gpt-3.5-turbo-0301\":\n    case \"gpt-3.5-turbo-0613\":\n    case \"gpt-3.5-turbo-1106\":\n    case \"gpt-3.5-turbo-0125\":\n      return 4096;\n\n    // Legacy GPT-3 models\n    case \"text-davinci-003\":\n    case \"text-davinci-002\":\n      return 4097;\n    case \"text-davinci-001\":\n      return 2049;\n    case \"text-curie-001\":\n    case \"text-babbage-001\":\n    case \"text-ada-001\":\n      return 2048;\n\n    // Code models\n    case \"code-davinci-002\":\n    case \"code-davinci-001\":\n      return 8000;\n    case \"code-cushman-001\":\n      return 2048;\n\n    // Claude models (Anthropic)\n    case \"claude-3-5-sonnet-20241022\":\n    case \"claude-3-5-sonnet-20240620\":\n    case \"claude-3-opus-20240229\":\n    case \"claude-3-sonnet-20240229\":\n    case \"claude-3-haiku-20240307\":\n    case \"claude-2.1\":\n      return 200000;\n    case \"claude-2.0\":\n    case \"claude-instant-1.2\":\n      return 100000;\n\n    // Gemini models (Google)\n    case \"gemini-1.5-pro\":\n    case \"gemini-1.5-pro-latest\":\n    case \"gemini-1.5-flash\":\n    case \"gemini-1.5-flash-latest\":\n      return 1000000; // 1M tokens\n    case \"gemini-pro\":\n    case \"gemini-pro-vision\":\n      return 32768;\n\n    default:\n      return 4097;\n  }\n};\n\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nexport function isOpenAITool(tool: unknown): tool is ToolDefinition {\n  if (typeof tool !== \"object\" || !tool) return false;\n  if (\n    \"type\" in tool &&\n    tool.type === \"function\" &&\n    \"function\" in tool &&\n    typeof tool.function === \"object\" &&\n    tool.function &&\n    \"name\" in tool.function &&\n    \"parameters\" in tool.function\n  ) {\n    return true;\n  }\n  return false;\n}\n\ninterface CalculateMaxTokenProps {\n  prompt: string;\n  modelName: TiktokenModel;\n}\n\nexport const calculateMaxTokens = async ({\n  prompt,\n  modelName,\n}: CalculateMaxTokenProps) => {\n  let numTokens;\n\n  try {\n    numTokens = (\n      await encodingForModel(getModelNameForTiktoken(modelName))\n    ).encode(prompt).length;\n  } catch {\n    console.warn(\n      \"Failed to calculate number of tokens, falling back to approximate count\"\n    );\n\n    // fallback to approximate calculation if tiktoken is not available\n    // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n    numTokens = Math.ceil(prompt.length / 4);\n  }\n\n  const maxTokens = getModelContextSize(modelName);\n  return maxTokens - numTokens;\n};\n\nconst getVerbosity = () => false;\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLangChainParams {\n  verbose?: boolean;\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Base class for language models, chains, tools.\n */\nexport abstract class BaseLangChain<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput, CallOptions>\n  implements BaseLangChainParams\n{\n  /**\n   * Whether to print out response text.\n   */\n  verbose: boolean;\n\n  callbacks?: Callbacks;\n\n  tags?: string[];\n\n  metadata?: Record<string, unknown>;\n\n  get lc_attributes(): { [key: string]: undefined } | undefined {\n    return {\n      callbacks: undefined,\n      verbose: undefined,\n    };\n  }\n\n  constructor(params: BaseLangChainParams) {\n    super(params);\n    this.verbose = params.verbose ?? getVerbosity();\n    this.callbacks = params.callbacks;\n    this.tags = params.tags ?? [];\n    this.metadata = params.metadata ?? {};\n  }\n}\n\n/**\n * Base interface for language model parameters.\n * A subclass of {@link BaseLanguageModel} should have a constructor that\n * takes in a parameter that extends this interface.\n */\nexport interface BaseLanguageModelParams\n  extends AsyncCallerParams,\n    BaseLangChainParams {\n  /**\n   * @deprecated Use `callbacks` instead\n   */\n  callbackManager?: CallbackManager;\n\n  cache?: BaseCache | boolean;\n}\n\nexport interface BaseLanguageModelTracingCallOptions {\n  /**\n   * Describes the format of structured outputs.\n   * This should be provided if an output is considered to be structured\n   */\n  ls_structured_output_format?: {\n    /**\n     * An object containing the method used for structured output (e.g., \"jsonMode\").\n     */\n    kwargs: { method: string };\n    /**\n     * The JSON schema describing the expected output structure.\n     */\n    schema?: JSONSchema;\n  };\n}\n\nexport interface BaseLanguageModelCallOptions\n  extends RunnableConfig,\n    BaseLanguageModelTracingCallOptions {\n  /**\n   * Stop tokens to use for this call.\n   * If not provided, the default stop tokens for the model will be used.\n   */\n  stop?: string[];\n}\n\nexport interface FunctionDefinition {\n  /**\n   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n   * underscores and dashes, with a maximum length of 64.\n   */\n  name: string;\n\n  /**\n   * The parameters the functions accepts, described as a JSON Schema object. See the\n   * [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for\n   * examples, and the\n   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n   * documentation about the format.\n   *\n   * To describe a function that accepts no parameters, provide the value\n   * `{\"type\": \"object\", \"properties\": {}}`.\n   */\n  parameters: Record<string, unknown> | JSONSchema;\n\n  /**\n   * A description of what the function does, used by the model to choose when and\n   * how to call the function.\n   */\n  description?: string;\n}\n\nexport interface ToolDefinition {\n  type: \"function\";\n  function: FunctionDefinition;\n}\n\nexport type FunctionCallOption = {\n  name: string;\n};\n\nexport interface BaseFunctionCallOptions extends BaseLanguageModelCallOptions {\n  function_call?: FunctionCallOption;\n  functions?: FunctionDefinition[];\n}\n\nexport type BaseLanguageModelInput =\n  | BasePromptValueInterface\n  | string\n  | BaseMessageLike[];\n\nexport type StructuredOutputType = InferInteropZodOutput<InteropZodObject>;\n\nexport type StructuredOutputMethodOptions<IncludeRaw extends boolean = false> =\n  {\n    name?: string;\n    method?: \"functionCalling\" | \"jsonMode\" | \"jsonSchema\" | string;\n    includeRaw?: IncludeRaw;\n    /** Whether to use strict mode. Currently only supported by OpenAI models. */\n    strict?: boolean;\n  };\n\n/** @deprecated Use StructuredOutputMethodOptions instead */\nexport type StructuredOutputMethodParams<\n  RunOutput,\n  IncludeRaw extends boolean = false\n> = {\n  /** @deprecated Pass schema in as the first argument */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: InteropZodType<RunOutput> | Record<string, any>;\n  name?: string;\n  method?: \"functionCalling\" | \"jsonMode\";\n  includeRaw?: IncludeRaw;\n};\n\nexport interface BaseLanguageModelInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions\n> extends RunnableInterface<BaseLanguageModelInput, RunOutput, CallOptions> {\n  get callKeys(): string[];\n\n  generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  _modelType(): string;\n\n  _llmType(): string;\n\n  getNumTokens(content: MessageContent): Promise<number>;\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any>;\n\n  serialize(): SerializedLLM;\n}\n\nexport type LanguageModelOutput = BaseMessage | string;\n\nexport type LanguageModelLike = Runnable<\n  BaseLanguageModelInput,\n  LanguageModelOutput\n>;\n\n/**\n * Base class for language models.\n */\nexport abstract class BaseLanguageModel<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions\n  >\n  extends BaseLangChain<BaseLanguageModelInput, RunOutput, CallOptions>\n  implements\n    BaseLanguageModelParams,\n    BaseLanguageModelInterface<RunOutput, CallOptions>\n{\n  /**\n   * Keys that the language model accepts as call options.\n   */\n  get callKeys(): string[] {\n    return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n  }\n\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  cache?: BaseCache;\n\n  constructor({\n    callbacks,\n    callbackManager,\n    ...params\n  }: BaseLanguageModelParams) {\n    const { cache, ...rest } = params;\n    super({\n      callbacks: callbacks ?? callbackManager,\n      ...rest,\n    });\n    if (typeof cache === \"object\") {\n      this.cache = cache;\n    } else if (cache) {\n      this.cache = InMemoryCache.global();\n    } else {\n      this.cache = undefined;\n    }\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  abstract generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  abstract _modelType(): string;\n\n  abstract _llmType(): string;\n\n  private _encoding?: Tiktoken;\n\n  /**\n   * Get the number of tokens in the content.\n   * @param content The content to get the number of tokens for.\n   * @returns The number of tokens in the content.\n   */\n  async getNumTokens(content: MessageContent) {\n    // Extract text content from MessageContent\n    let textContent: string;\n    if (typeof content === \"string\") {\n      textContent = content;\n    } else {\n      /**\n       * Content is an array of ContentBlock\n       *\n       * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n       * We need to find a better way to do this.\n       * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n       */\n      textContent = content\n        .map((item) => {\n          if (typeof item === \"string\") return item;\n          if (item.type === \"text\" && \"text\" in item) return item.text;\n          return \"\";\n        })\n        .join(\"\");\n    }\n\n    // fallback to approximate calculation if tiktoken is not available\n    let numTokens = Math.ceil(textContent.length / 4);\n\n    if (!this._encoding) {\n      try {\n        this._encoding = await encodingForModel(\n          \"modelName\" in this\n            ? getModelNameForTiktoken(this.modelName as string)\n            : \"gpt2\"\n        );\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    if (this._encoding) {\n      try {\n        numTokens = this._encoding.encode(textContent).length;\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    return numTokens;\n  }\n\n  protected static _convertInputToPromptValue(\n    input: BaseLanguageModelInput\n  ): BasePromptValueInterface {\n    if (typeof input === \"string\") {\n      return new StringPromptValue(input);\n    } else if (Array.isArray(input)) {\n      return new ChatPromptValue(input.map(coerceMessageLikeToMessage));\n    } else {\n      return input;\n    }\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Create a unique cache key for a specific call to a specific language model.\n   * @param callOptions Call options for the model\n   * @returns A unique cache key.\n   */\n  _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }: CallOptions & { config?: RunnableConfig }\n  ): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const params: Record<string, any> = {\n      ...this._identifyingParams(),\n      ...callOptions,\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n    const filteredEntries = Object.entries(params).filter(\n      ([_, value]) => value !== undefined\n    );\n    const serializedEntries = filteredEntries\n      .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n      .sort()\n      .join(\",\");\n    return serializedEntries;\n  }\n\n  /**\n   * @deprecated\n   * Return a json-like object representing this LLM.\n   */\n  serialize(): SerializedLLM {\n    return {\n      ...this._identifyingParams(),\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n  }\n\n  /**\n   * @deprecated\n   * Load an LLM from a json-like object describing it.\n   */\n  static async deserialize(_data: SerializedLLM): Promise<BaseLanguageModel> {\n    throw new Error(\"Use .toJSON() instead\");\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   */\n  get profile(): ModelProfile {\n    return {};\n  }\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  /**\n   * Model wrapper that returns outputs formatted to match the given schema.\n   *\n   * @template {BaseLanguageModelInput} RunInput The input type for the Runnable, expected to be the same input for the LLM.\n   * @template {Record<string, any>} RunOutput The output type for the Runnable, expected to be a Zod schema object for structured output validation.\n   *\n   * @param {InteropZodType<RunOutput>} schema The schema for the structured output. Either as a Zod schema or a valid JSON schema object.\n   *   If a Zod schema is passed, the returned attributes will be validated, whereas with JSON schema they will not be.\n   * @param {string} name The name of the function to call.\n   * @param {\"functionCalling\" | \"jsonMode\"} [method=functionCalling] The method to use for getting the structured output. Defaults to \"functionCalling\".\n   * @param {boolean | undefined} [includeRaw=false] Whether to include the raw output in the result. Defaults to false.\n   * @returns {Runnable<RunInput, RunOutput> | Runnable<RunInput, { raw: BaseMessage; parsed: RunOutput }>} A new runnable that calls the LLM with structured output.\n   */\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      >;\n}\n\n/**\n * Shared interface for token usage\n * return type from LLM calls.\n */\nexport interface TokenUsage {\n  completionTokens?: number;\n  promptTokens?: number;\n  totalTokens?: number;\n}\n"],"names":["modelName: string","modelName?: string","tool: unknown","encodingForModel","Runnable","params: BaseLangChainParams","InMemoryCache","AsyncCaller","content: MessageContent","textContent: string","input: BaseLanguageModelInput","StringPromptValue","ChatPromptValue","coerceMessageLikeToMessage","params: Record<string, any>","_data: SerializedLLM"],"mappings":";;;;;;;;;;;;;;;;;;AAgCA,MAAa,0BAA0B,CAACA,cAAqC;IAC3E,IAAI,UAAU,UAAA,CAAW,QAAQ,CAC/B,CAAA,OAAO;IAGT,IAAI,UAAU,UAAA,CAAW,oBAAoB,CAC3C,CAAA,OAAO;IAGT,IAAI,UAAU,UAAA,CAAW,iBAAiB,CACxC,CAAA,OAAO;IAGT,IAAI,UAAU,UAAA,CAAW,YAAY,CACnC,CAAA,OAAO;IAGT,IAAI,UAAU,UAAA,CAAW,SAAS,CAChC,CAAA,OAAO;IAGT,IAAI,UAAU,UAAA,CAAW,SAAS,CAChC,CAAA,OAAO;IAGT,OAAO;AACR;AAED,MAAa,0BAA0B,CAACC,cAA+B;IACrE,OAAQ,WAAR;QACE,KAAK,yBACH;YAAA,OAAO;QACT,QACE;YAAA,OAAO;IACV;AACF;;;;;;;;;;;GAaD,MAAa,sBAAsB,CAACD,cAA8B;IAChE,MAAM,iBAAiB,wBAAwB,UAAU;IAEzD,OAAQ,gBAAR;QAEE,KAAK;QACL,KAAK;QACL,KAAK,sBACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,oBACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,qBACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK;QACL,KAAK,iBACH;YAAA,OAAO;QACT,KAAK;QACL,KAAK;QACL,KAAK,aACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK,yBACH;YAAA,OAAO;QACT,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,qBACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK,mBACH;YAAA,OAAO;QACT,KAAK,mBACH;YAAA,OAAO;QACT,KAAK;QACL,KAAK;QACL,KAAK,eACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK,mBACH;YAAA,OAAO;QACT,KAAK,mBACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,aACH;YAAA,OAAO;QACT,KAAK;QACL,KAAK,qBACH;YAAA,OAAO;QAGT,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK,0BACH;YAAA,OAAO;QACT,KAAK;QACL,KAAK,oBACH;YAAA,OAAO;QAET,QACE;YAAA,OAAO;IACV;AACF;;;;;GAOD,SAAgB,aAAaE,IAAAA,EAAuC;IAClE,IAAI,OAAO,SAAS,YAAY,CAAC,KAAM,CAAA,OAAO;IAC9C,IACE,UAAU,QACV,KAAK,IAAA,KAAS,cACd,cAAc,QACd,OAAO,KAAK,QAAA,KAAa,YACzB,KAAK,QAAA,IACL,UAAU,KAAK,QAAA,IACf,gBAAgB,KAAK,QAAA,CAErB,CAAA,OAAO;IAET,OAAO;AACR;AAOD,MAAa,qBAAqB,OAAO,EACvC,MAAA,EACA,SAAA,EACuB,KAAK;IAC5B,IAAI;IAEJ,IAAI;QACF,YAAA,CACE,MAAMC,uBAAAA,gBAAAA,CAAiB,wBAAwB,UAAU,CAAC,EAC1D,MAAA,CAAO,OAAO,CAAC,MAAA;IAClB,EAAA,OAAO;QACN,QAAQ,IAAA,CACN,0EACD;QAID,YAAY,KAAK,IAAA,CAAK,OAAO,MAAA,GAAS,EAAE;IACzC;IAED,MAAM,YAAY,oBAAoB,UAAU;IAChD,OAAO,YAAY;AACpB;AAED,MAAM,eAAe,IAAM;;;GAkB3B,IAAsB,gBAAtB,cAKUC,aAAAA,QAAAA,CAEV;;;IAIE,QAAA;IAEA,UAAA;IAEA,KAAA;IAEA,SAAA;IAEA,IAAI,gBAA0D;QAC5D,OAAO;YACL,WAAW,KAAA;YACX,SAAS,KAAA;QACV;IACF;IAED,YAAYC,MAAAA,CAA6B;QACvC,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,OAAA,GAAU,OAAO,OAAA,IAAW,cAAc;QAC/C,IAAA,CAAK,SAAA,GAAY,OAAO,SAAA;QACxB,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA,IAAQ,CAAE,CAAA;QAC7B,IAAA,CAAK,QAAA,GAAW,OAAO,QAAA,IAAY,CAAE;IACtC;AACF;;;GAwJD,IAAsB,oBAAtB,cAKU,cAIV;;;IAIE,IAAI,WAAqB;QACvB,OAAO;YAAC;YAAQ;YAAW;YAAU;YAAQ;YAAY;SAAY;IACtE;;;;IAMD,OAAA;IAEA,MAAA;IAEA,YAAY,EACV,SAAA,EACA,eAAA,EACA,GAAG,QACqB,CAAE;QAC1B,MAAM,EAAE,KAAA,EAAO,GAAG,MAAM,GAAG;QAC3B,KAAA,CAAM;YACJ,WAAW,aAAa;YACxB,GAAG,IAAA;QACJ,EAAC;QACF,IAAI,OAAO,UAAU,UACnB,IAAA,CAAK,KAAA,GAAQ;iBACJ,OACT,IAAA,CAAK,KAAA,GAAQC,qBAAAA,aAAAA,CAAc,MAAA,EAAQ;aAEnC,IAAA,CAAK,KAAA,GAAQ,KAAA;QAEf,IAAA,CAAK,MAAA,GAAS,IAAIC,2BAAAA,WAAAA,CAAY,UAAU,CAAE;IAC3C;IAYO,UAAA;;;;;IAOR,MAAM,aAAaC,OAAAA,EAAyB;QAE1C,IAAIC;QACJ,IAAI,OAAO,YAAY,UACrB,cAAc;;;;;;;KASd,cAAc,QACX,GAAA,CAAI,CAAC,SAAS;YACb,IAAI,OAAO,SAAS,SAAU,CAAA,OAAO;YACrC,IAAI,KAAK,IAAA,KAAS,UAAU,UAAU,KAAM,CAAA,OAAO,KAAK,IAAA;YACxD,OAAO;QACR,EAAC,CACD,IAAA,CAAK,GAAG;QAIb,IAAI,YAAY,KAAK,IAAA,CAAK,YAAY,MAAA,GAAS,EAAE;QAEjD,IAAI,CAAC,IAAA,CAAK,SAAA,CACR,CAAA,IAAI;YACF,IAAA,CAAK,SAAA,GAAY,MAAMN,uBAAAA,gBAAAA,CACrB,eAAe,IAAA,GACX,wBAAwB,IAAA,CAAK,SAAA,CAAoB,GACjD,OACL;QACF,EAAA,OAAQ,OAAO;YACd,QAAQ,IAAA,CACN,2EACA,MACD;QACF;QAGH,IAAI,IAAA,CAAK,SAAA,CACP,CAAA,IAAI;YACF,YAAY,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,YAAY,CAAC,MAAA;QAChD,EAAA,OAAQ,OAAO;YACd,QAAQ,IAAA,CACN,2EACA,MACD;QACF;QAGH,OAAO;IACR;IAED,OAAiB,2BACfO,KAAAA,EAC0B;QAC1B,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO,IAAIC,sBAAAA,iBAAAA,CAAkB;iBACpB,MAAM,OAAA,CAAQ,MAAM,CAC7B,CAAA,OAAO,IAAIC,sBAAAA,eAAAA,CAAgB,MAAM,GAAA,CAAIC,cAAAA,0BAAAA,CAA2B;aAEhE,OAAO;IAEV;;;IAMD,qBAA0C;QACxC,OAAO,CAAE;IACV;;;;;IAOD,wCAEE,EAAE,MAAA,EAAQ,GAAG,aAAwD,EAC7D;QAER,MAAMC,SAA8B;YAClC,GAAG,IAAA,CAAK,kBAAA,EAAoB;YAC5B,GAAG,WAAA;YACH,OAAO,IAAA,CAAK,QAAA,EAAU;YACtB,QAAQ,IAAA,CAAK,UAAA,EAAY;QAC1B;QACD,MAAM,kBAAkB,OAAO,OAAA,CAAQ,OAAO,CAAC,MAAA,CAC7C,CAAC,CAAC,GAAG,MAAM,GAAK,UAAU,KAAA,EAC3B;QACD,MAAM,oBAAoB,gBACvB,GAAA,CAAI,CAAC,CAAC,KAAK,MAAM,GAAK,GAAG,IAAI,CAAC,EAAE,KAAK,SAAA,CAAU,MAAM,EAAE,CAAC,CACxD,IAAA,EAAM,CACN,IAAA,CAAK,IAAI;QACZ,OAAO;IACR;;;;IAMD,YAA2B;QACzB,OAAO;YACL,GAAG,IAAA,CAAK,kBAAA,EAAoB;YAC5B,OAAO,IAAA,CAAK,QAAA,EAAU;YACtB,QAAQ,IAAA,CAAK,UAAA,EAAY;QAC1B;IACF;;;;IAMD,aAAa,YAAYC,KAAAA,EAAkD;QACzE,MAAM,IAAI,MAAM;IACjB;;;;;IAOD,IAAI,UAAwB;QAC1B,OAAO,CAAE;IACV;AA6EF"}},
    {"offset": {"line": 3815, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/utils.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/utils.ts"],"sourcesContent":["import { BaseMessage } from \"../messages/base.js\";\n\ntype Constructor<T> = new (...args: unknown[]) => T;\n\nexport const iife = <T>(fn: () => T): T => fn();\n\nfunction castStandardMessageContent<T extends BaseMessage>(message: T) {\n  const Cls = message.constructor as Constructor<T>;\n  return new Cls({\n    ...message,\n    content: message.contentBlocks,\n    response_metadata: {\n      ...message.response_metadata,\n      output_version: \"v1\",\n    },\n  });\n}\n\nexport { castStandardMessageContent };\n"],"names":["fn: () => T","message: T"],"mappings":";AAIA,MAAa,OAAO,CAAIA,KAAmB,IAAI;AAE/C,SAAS,2BAAkDC,OAAAA,EAAY;IACrE,MAAM,MAAM,QAAQ,WAAA;IACpB,OAAO,IAAI,IAAI;QACb,GAAG,OAAA;QACH,SAAS,QAAQ,aAAA;QACjB,mBAAmB;YACjB,GAAG,QAAQ,iBAAA;YACX,gBAAgB;QACjB;IACF;AACF"}},
    {"offset": {"line": 3834, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/chat_models.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/chat_models.ts"],"sourcesContent":["import type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\nimport {\n  AIMessage,\n  type BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  AIMessageChunk,\n  isAIMessageChunk,\n  isBaseMessage,\n  isAIMessage,\n  MessageOutputVersion,\n} from \"../messages/index.js\";\nimport {\n  convertToOpenAIImageBlock,\n  isURLContentBlock,\n  isBase64ContentBlock,\n} from \"../messages/content/data.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  LLMResult,\n  RUN_KEY,\n  type ChatGeneration,\n  ChatGenerationChunk,\n  type ChatResult,\n  type Generation,\n} from \"../outputs.js\";\nimport {\n  BaseLanguageModel,\n  type StructuredOutputMethodOptions,\n  type ToolDefinition,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport {\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport {\n  StructuredToolInterface,\n  StructuredToolParams,\n} from \"../tools/index.js\";\nimport {\n  Runnable,\n  RunnableLambda,\n  RunnableSequence,\n  RunnableToolLike,\n} from \"../runnables/base.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { RunnablePassthrough } from \"../runnables/passthrough.js\";\nimport {\n  getSchemaDescription,\n  InteropZodType,\n  isInteropZodSchema,\n} from \"../utils/types/zod.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { castStandardMessageContent, iife } from \"./utils.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolChoice = string | Record<string, any> | \"auto\" | \"any\";\n\n/**\n * Represents a serialized chat model.\n */\nexport type SerializedChatModel = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n// todo?\n/**\n * Represents a serialized large language model.\n */\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n/**\n * Represents the parameters for a base chat model.\n */\nexport type BaseChatModelParams = BaseLanguageModelParams & {\n  /**\n   * Whether to disable streaming.\n   *\n   * If streaming is bypassed, then `stream()` will defer to\n   * `invoke()`.\n   *\n   * - If true, will always bypass streaming case.\n   * - If false (default), will always use streaming case if available.\n   */\n  disableStreaming?: boolean;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\n/**\n * Represents the call options for a base chat model.\n */\nexport type BaseChatModelCallOptions = BaseLanguageModelCallOptions & {\n  /**\n   * Specifies how the chat model should use tools.\n   * @default undefined\n   *\n   * Possible values:\n   * - \"auto\": The model may choose to use any of the provided tools, or none.\n   * - \"any\": The model must use one of the provided tools.\n   * - \"none\": The model must not use any tools.\n   * - A string (not \"auto\", \"any\", or \"none\"): The name of a specific tool the model must use.\n   * - An object: A custom schema specifying tool choice parameters. Specific to the provider.\n   *\n   * Note: Not all providers support tool_choice. An error will be thrown\n   * if used with an unsupported model.\n   */\n  tool_choice?: ToolChoice;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\nfunction _formatForTracing(messages: BaseMessage[]): BaseMessage[] {\n  const messagesToTrace: BaseMessage[] = [];\n  for (const message of messages) {\n    let messageToTrace = message;\n    if (Array.isArray(message.content)) {\n      for (let idx = 0; idx < message.content.length; idx++) {\n        const block = message.content[idx];\n        if (isURLContentBlock(block) || isBase64ContentBlock(block)) {\n          if (messageToTrace === message) {\n            // Also shallow-copy content\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            messageToTrace = new (message.constructor as any)({\n              ...messageToTrace,\n              content: [\n                ...message.content.slice(0, idx),\n                convertToOpenAIImageBlock(block),\n                ...message.content.slice(idx + 1),\n              ],\n            });\n          }\n        }\n      }\n    }\n    messagesToTrace.push(messageToTrace);\n  }\n  return messagesToTrace;\n}\n\nexport type LangSmithParams = {\n  ls_provider?: string;\n  ls_model_name?: string;\n  ls_model_type: \"chat\";\n  ls_temperature?: number;\n  ls_max_tokens?: number;\n  ls_stop?: Array<string>;\n};\n\nexport type BindToolsInput =\n  | StructuredToolInterface\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | Record<string, any>\n  | ToolDefinition\n  | RunnableToolLike\n  | StructuredToolParams;\n\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nexport abstract class BaseChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions,\n  // TODO: Fix the parameter order on the next minor version.\n  OutputMessageType extends BaseMessageChunk = AIMessageChunk\n> extends BaseLanguageModel<OutputMessageType, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"chat_models\", this._llmType()];\n\n  disableStreaming = false;\n\n  outputVersion?: MessageOutputVersion;\n\n  get callKeys(): string[] {\n    return [...super.callKeys, \"outputVersion\"];\n  }\n\n  constructor(fields: BaseChatModelParams) {\n    super(fields);\n    this.outputVersion = iife(() => {\n      const outputVersion =\n        fields.outputVersion ?? getEnvironmentVariable(\"LC_OUTPUT_VERSION\");\n      if (outputVersion && [\"v0\", \"v1\"].includes(outputVersion)) {\n        return outputVersion as \"v0\" | \"v1\";\n      }\n      return \"v0\";\n    });\n  }\n\n  _combineLLMOutput?(\n    ...llmOutputs: LLMResult[\"llmOutput\"][]\n  ): LLMResult[\"llmOutput\"];\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  /**\n   * Bind tool-like objects to this chat model.\n   *\n   * @param tools A list of tool definitions to bind to this chat model.\n   * Can be a structured tool, an OpenAI formatted tool, or an object\n   * matching the provider's specific tool schema.\n   * @param kwargs Any additional parameters to bind.\n   */\n  bindTools?(\n    tools: BindToolsInput[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, OutputMessageType, CallOptions>;\n\n  /**\n   * Invokes the chat model with a single input.\n   * @param input The input for the language model.\n   * @param options The call options.\n   * @returns A Promise that resolves to a BaseMessageChunk.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<OutputMessageType> {\n    const promptValue = BaseChatModel._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    const chatGeneration = result.generations[0][0] as ChatGeneration;\n    // TODO: Remove cast after figuring out inheritance\n    return chatGeneration.message as OutputMessageType;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<OutputMessageType> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks ===\n        BaseChatModel.prototype._streamResponseChunks ||\n      this.disableStreaming\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseChatModel._convertInputToPromptValue(input);\n      const messages = prompt.toChatMessages();\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n\n      const inheritableMetadata = {\n        ...runnableConfig.metadata,\n        ...this.getLsParams(callOptions),\n      };\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const outputVersion = callOptions.outputVersion ?? this.outputVersion;\n      const runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        [_formatForTracing(messages)],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generationChunk: ChatGenerationChunk | undefined;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let llmOutput: Record<string, any> | undefined;\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          messages,\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          chunk.message.response_metadata = {\n            ...chunk.generationInfo,\n            ...chunk.message.response_metadata,\n          };\n          if (outputVersion === \"v1\") {\n            yield castStandardMessageContent(\n              chunk.message\n            ) as OutputMessageType;\n          } else {\n            yield chunk.message as OutputMessageType;\n          }\n          if (!generationChunk) {\n            generationChunk = chunk;\n          } else {\n            generationChunk = generationChunk.concat(chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            // TODO: Remove cast after figuring out inheritance\n            generations: [[generationChunk as ChatGeneration]],\n            llmOutput,\n          })\n        )\n      );\n    }\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const providerName = this.getName().startsWith(\"Chat\")\n      ? this.getName().replace(\"Chat\", \"\")\n      : this.getName();\n\n    return {\n      ls_model_type: \"chat\",\n      ls_stop: options.stop,\n      ls_provider: providerName,\n    };\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    messages: BaseMessageLike[][],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: RunnableConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === baseMessages.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const inheritableMetadata = {\n        ...handledOptions.metadata,\n        ...this.getLsParams(parsedOptions),\n      };\n      // create callback manager and start run\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: 1,\n      };\n      runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        baseMessages.map(_formatForTracing),\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions.runName\n      );\n    }\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: ChatGeneration[][] = [];\n    const llmOutputs: LLMResult[\"llmOutput\"][] = [];\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    if (\n      hasStreamingHandler &&\n      !this.disableStreaming &&\n      baseMessages.length === 1 &&\n      this._streamResponseChunks !==\n        BaseChatModel.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          baseMessages[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let llmOutput: Record<string, any> | undefined;\n        for await (const chunk of stream) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        generations.push([aggregated]);\n        await runManagers?.[0].handleLLMEnd({\n          generations,\n          llmOutput,\n        });\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      // generate results\n      const results = await Promise.allSettled(\n        baseMessages.map(async (messageList, i) => {\n          const generateResults = await this._generate(\n            messageList,\n            { ...parsedOptions, promptIndex: i },\n            runManagers?.[i]\n          );\n          if (outputVersion === \"v1\") {\n            for (const generation of generateResults.generations) {\n              generation.message = castStandardMessageContent(\n                generation.message\n              );\n            }\n          }\n          return generateResults;\n        })\n      );\n      // handle results\n      await Promise.all(\n        results.map(async (pResult, i) => {\n          if (pResult.status === \"fulfilled\") {\n            const result = pResult.value;\n            for (const generation of result.generations) {\n              if (generation.message.id == null) {\n                const runId = runManagers?.at(0)?.runId;\n                if (runId != null) generation.message._updateId(`run-${runId}`);\n              }\n              generation.message.response_metadata = {\n                ...generation.generationInfo,\n                ...generation.message.response_metadata,\n              };\n            }\n            if (result.generations.length === 1) {\n              result.generations[0].message.response_metadata = {\n                ...result.llmOutput,\n                ...result.generations[0].message.response_metadata,\n              };\n            }\n            generations[i] = result.generations;\n            llmOutputs[i] = result.llmOutput;\n            return runManagers?.[i]?.handleLLMEnd({\n              generations: [result.generations],\n              llmOutput: result.llmOutput,\n            });\n          } else {\n            // status === \"rejected\"\n            await runManagers?.[i]?.handleLLMError(pResult.reason);\n            return Promise.reject(pResult.reason);\n          }\n        })\n      );\n    }\n    // create combined output\n    const output: LLMResult = {\n      generations,\n      llmOutput: llmOutputs.length\n        ? this._combineLLMOutput?.(...llmOutputs)\n        : undefined,\n    };\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    messages,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n  }: {\n    messages: BaseMessageLike[][];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const inheritableMetadata = {\n      ...handledOptions.metadata,\n      ...this.getLsParams(parsedOptions),\n    };\n    // create callback manager and start run\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      inheritableMetadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: 1,\n    };\n    const runManagers = await callbackManager_?.handleChatModelStart(\n      this.toJSON(),\n      baseMessages.map(_formatForTracing),\n      handledOptions.runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      baseMessages.map(async (baseMessage, index) => {\n        // Join all content into one string for the prompt index\n        const prompt =\n          BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n        const result = await cache.lookup(prompt, llmStringKey);\n\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            if (\n              \"message\" in result &&\n              isBaseMessage(result.message) &&\n              isAIMessage(result.message)\n            ) {\n              result.message.usage_metadata = {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n              };\n              if (outputVersion === \"v1\") {\n                result.message = castStandardMessageContent(result.message);\n              }\n            }\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Generates chat based on the input messages.\n   * @param messages An array of arrays of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generate(\n    messages: BaseMessageLike[][],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    // parse call options\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(baseMessages, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        messages: baseMessages,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => baseMessages[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          // Join all content into one string for the prompt index\n          const prompt = BaseChatModel._convertInputToPromptValue(\n            baseMessages[promptIndex]\n          ).toString();\n          return cache.update(prompt, llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _modelType(): string {\n    return \"base_chat_model\" as const;\n  }\n\n  abstract _llmType(): string;\n\n  /**\n   * Generates a prompt based on the input prompt values.\n   * @param promptValues An array of BasePromptValue instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const promptMessages: BaseMessage[][] = promptValues.map((promptValue) =>\n      promptValue.toChatMessages()\n    );\n    return this.generate(promptMessages, options, callbacks);\n  }\n\n  abstract _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      > {\n    if (typeof this.bindTools !== \"function\") {\n      throw new Error(\n        `Chat model must implement \".bindTools()\" to use withStructuredOutput.`\n      );\n    }\n    if (config?.strict) {\n      throw new Error(\n        `\"strict\" mode is not supported for this model by default.`\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: Record<string, any> | InteropZodType<RunOutput> =\n      outputSchema;\n    const name = config?.name;\n    const description =\n      getSchemaDescription(schema) ?? \"A function available to call.\";\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n    if (method === \"jsonMode\") {\n      throw new Error(\n        `Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`\n      );\n    }\n\n    let functionName = name ?? \"extract\";\n    let tools: ToolDefinition[];\n    if (isInteropZodSchema(schema)) {\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: toJsonSchema(schema),\n          },\n        },\n      ];\n    } else {\n      if (\"name\" in schema) {\n        functionName = schema.name;\n      }\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: schema,\n          },\n        },\n      ];\n    }\n\n    const llm = this.bindTools(tools);\n    const outputParser = RunnableLambda.from<OutputMessageType, RunOutput>(\n      (input: BaseMessageChunk): RunOutput => {\n        if (!AIMessageChunk.isInstance(input)) {\n          throw new Error(\"Input is not an AIMessageChunk.\");\n        }\n        if (!input.tool_calls || input.tool_calls.length === 0) {\n          throw new Error(\"No tool calls found in the response.\");\n        }\n        const toolCall = input.tool_calls.find(\n          (tc) => tc.name === functionName\n        );\n        if (!toolCall) {\n          throw new Error(`No tool call found with name ${functionName}.`);\n        }\n        return toolCall.args as RunOutput;\n      }\n    );\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser).withConfig({\n        runName: \"StructuredOutput\",\n      }) as Runnable<BaseLanguageModelInput, RunOutput>;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]).withConfig({\n      runName: \"StructuredOutputRunnable\",\n    });\n  }\n}\n\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nexport abstract class SimpleChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions\n> extends BaseChatModel<CallOptions> {\n  abstract _call(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const text = await this._call(messages, options, runManager);\n    const message = new AIMessage(text);\n    if (typeof message.content !== \"string\") {\n      throw new Error(\n        \"Cannot generate with a simple chat model when output is not a string.\"\n      );\n    }\n    return {\n      generations: [\n        {\n          text: message.content,\n          message,\n        },\n      ],\n    };\n  }\n}\n"],"names":["messages: BaseMessage[]","messagesToTrace: BaseMessage[]","isURLContentBlock","isBase64ContentBlock","convertToOpenAIImageBlock","BaseLanguageModel","fields: BaseChatModelParams","iife","getEnvironmentVariable","options?: Partial<CallOptions>","input: BaseLanguageModelInput","options?: CallOptions","_messages: BaseMessage[]","_options: this[\"ParsedCallOptions\"]","_runManager?: CallbackManagerForLLMRun","CallbackManager","generationChunk: ChatGenerationChunk | undefined","llmOutput: Record<string, any> | undefined","castStandardMessageContent","isAIMessageChunk","options: this[\"ParsedCallOptions\"]","messages: BaseMessageLike[][]","parsedOptions: this[\"ParsedCallOptions\"]","handledOptions: RunnableConfig","startedRunManagers?: CallbackManagerForLLMRun[]","coerceMessageLikeToMessage","runManagers: CallbackManagerForLLMRun[] | undefined","generations: ChatGeneration[][]","llmOutputs: LLMResult[\"llmOutput\"][]","callbackHandlerPrefersStreaming","concat","output: LLMResult","RUN_KEY","missingPromptIndices: number[]","generations: Generation[][]","result","isBaseMessage","isAIMessage","options?: string[] | CallOptions","callbacks?: Callbacks","parsedOptions: CallOptions | undefined","_options?: this[\"ParsedCallOptions\"]","promptValues: BasePromptValueInterface[]","promptMessages: BaseMessage[][]","outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>","config?: StructuredOutputMethodOptions<boolean>","schema: Record<string, any> | InteropZodType<RunOutput>","getSchemaDescription","tools: ToolDefinition[]","isInteropZodSchema","toJsonSchema","RunnableLambda","input: BaseMessageChunk","AIMessageChunk","RunnablePassthrough","input: any","config","RunnableSequence","runManager?: CallbackManagerForLLMRun","AIMessage"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AA4JA,SAAS,kBAAkBA,QAAAA,EAAwC;IACjE,MAAMC,kBAAiC,CAAE,CAAA;IACzC,KAAK,MAAM,WAAW,SAAU;QAC9B,IAAI,iBAAiB;QACrB,IAAI,MAAM,OAAA,CAAQ,QAAQ,OAAA,CAAQ,CAChC,CAAA,IAAK,IAAI,MAAM,GAAG,MAAM,QAAQ,OAAA,CAAQ,MAAA,EAAQ,MAAO;YACrD,MAAM,QAAQ,QAAQ,OAAA,CAAQ,IAAA;YAC9B,IAAIC,aAAAA,iBAAAA,CAAkB,MAAM,IAAIC,aAAAA,oBAAAA,CAAqB,MAAM,EACzD;oBAAI,mBAAmB,SAGrB,iBAAiB,IAAK,QAAQ,WAAA,CAAoB;oBAChD,GAAG,cAAA;oBACH,SAAS;2BACJ,QAAQ,OAAA,CAAQ,KAAA,CAAM,GAAG,IAAI;wBAChCC,aAAAA,yBAAAA,CAA0B,MAAM;2BAC7B,QAAQ,OAAA,CAAQ,KAAA,CAAM,MAAM,EAAE;qBAClC;gBACF;YACF;QAEJ;QAEH,gBAAgB,IAAA,CAAK,eAAe;IACrC;IACD,OAAO;AACR;;;;GAuBD,IAAsB,gBAAtB,MAAsB,sBAIZC,6BAAAA,iBAAAA,CAAkD;IAQ1D,eAAe;QAAC;QAAa;QAAe,IAAA,CAAK,QAAA,EAAU;KAAC,CAAA;IAE5D,mBAAmB,MAAA;IAEnB,cAAA;IAEA,IAAI,WAAqB;QACvB,OAAO,CAAC;eAAG,KAAA,CAAM;YAAU,eAAgB;SAAA;IAC5C;IAED,YAAYC,MAAAA,CAA6B;QACvC,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,aAAA,GAAgBC,gBAAAA,IAAAA,CAAK,MAAM;YAC9B,MAAM,gBACJ,OAAO,aAAA,IAAiBC,kBAAAA,sBAAAA,CAAuB,oBAAoB;YACrE,IAAI,iBAAiB;gBAAC;gBAAM,IAAK;aAAA,CAAC,QAAA,CAAS,cAAc,CACvD,CAAA,OAAO;YAET,OAAO;QACR,EAAC;IACH;IAMS,6CACRC,OAAAA,EAC6C;QAE7C,MAAM,CAAC,gBAAgB,YAAY,GACjC,KAAA,CAAM,uCAAuC,QAAQ;QACtD,YAA0C,MAAA,GAAS,eAAe,MAAA;QACnE,OAAO;YAAC;YAAgB,WAAyC;SAAA;IAClE;;;;;;IAqBD,MAAM,OACJC,KAAAA,EACAC,OAAAA,EAC4B;QAC5B,MAAM,cAAc,cAAc,0BAAA,CAA2B,MAAM;QACnE,MAAM,SAAS,MAAM,IAAA,CAAK,cAAA,CACxB;YAAC,WAAY;SAAA,EACb,SACA,SAAS,UACV;QACD,MAAM,iBAAiB,OAAO,WAAA,CAAY,EAAA,CAAG,EAAA;QAE7C,OAAO,eAAe,OAAA;IACvB;IAGD,OAAO,sBACLC,SAAAA,EACAC,QAAAA,EACAC,WAAAA,EACqC;QACrC,MAAM,IAAI,MAAM;IACjB;IAED,OAAO,gBACLJ,KAAAA,EACAC,OAAAA,EACmC;QAEnC,IACE,IAAA,CAAK,qBAAA,KACH,cAAc,SAAA,CAAU,qBAAA,IAC1B,IAAA,CAAK,gBAAA,EAEL,MAAM,IAAA,CAAK,MAAA,CAAO,OAAO,QAAQ;aAC5B;YACL,MAAM,SAAS,cAAc,0BAAA,CAA2B,MAAM;YAC9D,MAAM,WAAW,OAAO,cAAA,EAAgB;YACxC,MAAM,CAAC,gBAAgB,YAAY,GACjC,IAAA,CAAK,4CAAA,CAA6C,QAAQ;YAE5D,MAAM,sBAAsB;gBAC1B,GAAG,eAAe,QAAA;gBAClB,GAAG,IAAA,CAAK,WAAA,CAAY,YAAY;YACjC;YACD,MAAM,mBAAmB,MAAMI,0BAAAA,eAAAA,CAAgB,SAAA,CAC7C,eAAe,SAAA,EACf,IAAA,CAAK,SAAA,EACL,eAAe,IAAA,EACf,IAAA,CAAK,IAAA,EACL,qBACA,IAAA,CAAK,QAAA,EACL;gBAAE,SAAS,IAAA,CAAK,OAAA;YAAS,EAC1B;YACD,MAAM,QAAQ;gBACZ,SAAS;gBACT,mBAAmB,IAAA,EAAM,iBAAiB,YAAY;gBACtD,YAAY;YACb;YACD,MAAM,gBAAgB,YAAY,aAAA,IAAiB,IAAA,CAAK,aAAA;YACxD,MAAM,cAAc,MAAM,kBAAkB,qBAC1C,IAAA,CAAK,MAAA,EAAQ,EACb;gBAAC,kBAAkB,SAAS,AAAC;aAAA,EAC7B,eAAe,KAAA,EACf,KAAA,GACA,OACA,KAAA,GACA,KAAA,GACA,eAAe,OAAA,CAChB;YACD,IAAIC;YAEJ,IAAIC;YACJ,IAAI;gBACF,WAAW,MAAM,SAAS,IAAA,CAAK,qBAAA,CAC7B,UACA,aACA,aAAA,CAAc,EAAA,CACf,CAAE;oBACD,IAAI,MAAM,OAAA,CAAQ,EAAA,IAAM,MAAM;wBAC5B,MAAM,QAAQ,aAAa,GAAG,EAAE,EAAE;wBAClC,IAAI,SAAS,MAAM,MAAM,OAAA,CAAQ,SAAA,CAAU,CAAC,IAAI,EAAE,OAAO,CAAC;oBAC3D;oBACD,MAAM,OAAA,CAAQ,iBAAA,GAAoB;wBAChC,GAAG,MAAM,cAAA;wBACT,GAAG,MAAM,OAAA,CAAQ,iBAAA;oBAClB;oBACD,IAAI,kBAAkB,MACpB,MAAMC,gBAAAA,0BAAAA,CACJ,MAAM,OAAA,CACP;yBAED,MAAM,MAAM,OAAA;oBAEd,IAAI,CAAC,iBACH,kBAAkB;yBAElB,kBAAkB,gBAAgB,MAAA,CAAO,MAAM;oBAEjD,IACEC,WAAAA,gBAAAA,CAAiB,MAAM,OAAA,CAAQ,IAC/B,MAAM,OAAA,CAAQ,cAAA,KAAmB,KAAA,GAEjC,YAAY;wBACV,YAAY;4BACV,cAAc,MAAM,OAAA,CAAQ,cAAA,CAAe,YAAA;4BAC3C,kBAAkB,MAAM,OAAA,CAAQ,cAAA,CAAe,aAAA;4BAC/C,aAAa,MAAM,OAAA,CAAQ,cAAA,CAAe,YAAA;wBAC3C;oBACF;gBAEJ;YACF,EAAA,OAAQ,KAAK;gBACZ,MAAM,QAAQ,GAAA,CAAA,CACX,eAAe,CAAE,CAAA,EAAE,GAAA,CAAI,CAAC,aACvB,YAAY,eAAe,IAAI,CAChC,CACF;gBACD,MAAM;YACP;YACD,MAAM,QAAQ,GAAA,CAAA,CACX,eAAe,CAAE,CAAA,EAAE,GAAA,CAAI,CAAC,aACvB,YAAY,aAAa;oBAEvB,aAAa;wBAAC;4BAAC,eAAkC;yBAAC;qBAAA;oBAClD;gBACD,EAAC,CACH,CACF;QACF;IACF;IAED,YAAYC,OAAAA,EAAqD;QAC/D,MAAM,eAAe,IAAA,CAAK,OAAA,EAAS,CAAC,UAAA,CAAW,OAAO,GAClD,IAAA,CAAK,OAAA,EAAS,CAAC,OAAA,CAAQ,QAAQ,GAAG,GAClC,IAAA,CAAK,OAAA,EAAS;QAElB,OAAO;YACL,eAAe;YACf,SAAS,QAAQ,IAAA;YACjB,aAAa;QACd;IACF;mBAGD,MAAM,kBACJC,QAAAA,EACAC,aAAAA,EACAC,cAAAA,EACAC,kBAAAA,EACoB;QACpB,MAAM,eAAe,SAAS,GAAA,CAAI,CAAC,cACjC,YAAY,GAAA,CAAIC,cAAAA,0BAAAA,CAA2B,CAC5C;QAED,IAAIC;QACJ,IACE,uBAAuB,KAAA,KACvB,mBAAmB,MAAA,KAAW,aAAa,MAAA,EAE3C,cAAc;aACT;YACL,MAAM,sBAAsB;gBAC1B,GAAG,eAAe,QAAA;gBAClB,GAAG,IAAA,CAAK,WAAA,CAAY,cAAc;YACnC;YAED,MAAM,mBAAmB,MAAMX,0BAAAA,eAAAA,CAAgB,SAAA,CAC7C,eAAe,SAAA,EACf,IAAA,CAAK,SAAA,EACL,eAAe,IAAA,EACf,IAAA,CAAK,IAAA,EACL,qBACA,IAAA,CAAK,QAAA,EACL;gBAAE,SAAS,IAAA,CAAK,OAAA;YAAS,EAC1B;YACD,MAAM,QAAQ;gBACZ,SAAS;gBACT,mBAAmB,IAAA,EAAM,iBAAiB,cAAc;gBACxD,YAAY;YACb;YACD,cAAc,MAAM,kBAAkB,qBACpC,IAAA,CAAK,MAAA,EAAQ,EACb,aAAa,GAAA,CAAI,kBAAkB,EACnC,eAAe,KAAA,EACf,KAAA,GACA,OACA,KAAA,GACA,KAAA,GACA,eAAe,OAAA,CAChB;QACF;QACD,MAAM,gBAAgB,cAAc,aAAA,IAAiB,IAAA,CAAK,aAAA;QAC1D,MAAMY,cAAkC,CAAE,CAAA;QAC1C,MAAMC,aAAuC,CAAE,CAAA;QAI/C,MAAM,sBAAsB,CAAC,CAAC,aAAA,CAAc,EAAA,CAAG,SAAS,KACtDC,uBAAAA,+BAAAA,CACD;QACD,IACE,uBACA,CAAC,IAAA,CAAK,gBAAA,IACN,aAAa,MAAA,KAAW,KACxB,IAAA,CAAK,qBAAA,KACH,cAAc,SAAA,CAAU,qBAAA,CAE1B,CAAA,IAAI;YACF,MAAM,SAAS,MAAM,IAAA,CAAK,qBAAA,CACxB,YAAA,CAAa,EAAA,EACb,eACA,aAAA,CAAc,EAAA,CACf;YACD,IAAI;YAEJ,IAAIZ;YACJ,WAAW,MAAM,SAAS,OAAQ;gBAChC,IAAI,MAAM,OAAA,CAAQ,EAAA,IAAM,MAAM;oBAC5B,MAAM,QAAQ,aAAa,GAAG,EAAE,EAAE;oBAClC,IAAI,SAAS,MAAM,MAAM,OAAA,CAAQ,SAAA,CAAU,CAAC,IAAI,EAAE,OAAO,CAAC;gBAC3D;gBACD,IAAI,eAAe,KAAA,GACjB,aAAa;qBAEb,aAAaa,qBAAAA,MAAAA,CAAO,YAAY,MAAM;gBAExC,IACEX,WAAAA,gBAAAA,CAAiB,MAAM,OAAA,CAAQ,IAC/B,MAAM,OAAA,CAAQ,cAAA,KAAmB,KAAA,GAEjC,YAAY;oBACV,YAAY;wBACV,cAAc,MAAM,OAAA,CAAQ,cAAA,CAAe,YAAA;wBAC3C,kBAAkB,MAAM,OAAA,CAAQ,cAAA,CAAe,aAAA;wBAC/C,aAAa,MAAM,OAAA,CAAQ,cAAA,CAAe,YAAA;oBAC3C;gBACF;YAEJ;YACD,IAAI,eAAe,KAAA,EACjB,CAAA,MAAM,IAAI,MAAM;YAElB,YAAY,IAAA,CAAK;gBAAC,UAAW;aAAA,CAAC;YAC9B,MAAM,aAAA,CAAc,EAAA,CAAG,aAAa;gBAClC;gBACA;YACD,EAAC;QACH,EAAA,OAAQ,GAAG;YACV,MAAM,aAAA,CAAc,EAAA,CAAG,eAAe,EAAE;YACxC,MAAM;QACP;aACI;YAEL,MAAM,UAAU,MAAM,QAAQ,UAAA,CAC5B,aAAa,GAAA,CAAI,OAAO,aAAa,MAAM;gBACzC,MAAM,kBAAkB,MAAM,IAAA,CAAK,SAAA,CACjC,aACA;oBAAE,GAAG,aAAA;oBAAe,aAAa;gBAAG,GACpC,aAAA,CAAc,EAAA,CACf;gBACD,IAAI,kBAAkB,KACpB,CAAA,KAAK,MAAM,cAAc,gBAAgB,WAAA,CACvC,WAAW,OAAA,GAAUD,gBAAAA,0BAAAA,CACnB,WAAW,OAAA,CACZ;gBAGL,OAAO;YACR,EAAC,CACH;YAED,MAAM,QAAQ,GAAA,CACZ,QAAQ,GAAA,CAAI,OAAO,SAAS,MAAM;gBAChC,IAAI,QAAQ,MAAA,KAAW,aAAa;oBAClC,MAAM,SAAS,QAAQ,KAAA;oBACvB,KAAK,MAAM,cAAc,OAAO,WAAA,CAAa;wBAC3C,IAAI,WAAW,OAAA,CAAQ,EAAA,IAAM,MAAM;4BACjC,MAAM,QAAQ,aAAa,GAAG,EAAE,EAAE;4BAClC,IAAI,SAAS,MAAM,WAAW,OAAA,CAAQ,SAAA,CAAU,CAAC,IAAI,EAAE,OAAO,CAAC;wBAChE;wBACD,WAAW,OAAA,CAAQ,iBAAA,GAAoB;4BACrC,GAAG,WAAW,cAAA;4BACd,GAAG,WAAW,OAAA,CAAQ,iBAAA;wBACvB;oBACF;oBACD,IAAI,OAAO,WAAA,CAAY,MAAA,KAAW,GAChC,OAAO,WAAA,CAAY,EAAA,CAAG,OAAA,CAAQ,iBAAA,GAAoB;wBAChD,GAAG,OAAO,SAAA;wBACV,GAAG,OAAO,WAAA,CAAY,EAAA,CAAG,OAAA,CAAQ,iBAAA;oBAClC;oBAEH,WAAA,CAAY,EAAA,GAAK,OAAO,WAAA;oBACxB,UAAA,CAAW,EAAA,GAAK,OAAO,SAAA;oBACvB,OAAO,aAAA,CAAc,EAAA,EAAI,aAAa;wBACpC,aAAa;4BAAC,OAAO,WAAY;yBAAA;wBACjC,WAAW,OAAO,SAAA;oBACnB,EAAC;gBACH,OAAM;oBAEL,MAAM,aAAA,CAAc,EAAA,EAAI,eAAe,QAAQ,MAAA,CAAO;oBACtD,OAAO,QAAQ,MAAA,CAAO,QAAQ,MAAA,CAAO;gBACtC;YACF,EAAC,CACH;QACF;QAED,MAAMa,SAAoB;YACxB;YACA,WAAW,WAAW,MAAA,GAClB,IAAA,CAAK,iBAAA,GAAoB,GAAG,WAAW,GACvC,KAAA;QACL;QACD,OAAO,cAAA,CAAe,QAAQC,gBAAAA,OAAAA,EAAS;YACrC,OAAO,cACH;gBAAE,QAAQ,aAAa,IAAI,CAAC,UAAY,QAAQ,KAAA,CAAM;YAAE,IACxD,KAAA;YACJ,cAAc;QACf,EAAC;QACF,OAAO;IACR;IAED,MAAM,gBAAgB,EACpB,QAAA,EACA,KAAA,EACA,YAAA,EACA,aAAA,EACA,cAAA,EAQD,EAKC;QACA,MAAM,eAAe,SAAS,GAAA,CAAI,CAAC,cACjC,YAAY,GAAA,CAAIP,cAAAA,0BAAAA,CAA2B,CAC5C;QAED,MAAM,sBAAsB;YAC1B,GAAG,eAAe,QAAA;YAClB,GAAG,IAAA,CAAK,WAAA,CAAY,cAAc;QACnC;QAED,MAAM,mBAAmB,MAAMV,0BAAAA,eAAAA,CAAgB,SAAA,CAC7C,eAAe,SAAA,EACf,IAAA,CAAK,SAAA,EACL,eAAe,IAAA,EACf,IAAA,CAAK,IAAA,EACL,qBACA,IAAA,CAAK,QAAA,EACL;YAAE,SAAS,IAAA,CAAK,OAAA;QAAS,EAC1B;QACD,MAAM,QAAQ;YACZ,SAAS;YACT,mBAAmB,IAAA,EAAM,iBAAiB,cAAc;YACxD,YAAY;QACb;QACD,MAAM,cAAc,MAAM,kBAAkB,qBAC1C,IAAA,CAAK,MAAA,EAAQ,EACb,aAAa,GAAA,CAAI,kBAAkB,EACnC,eAAe,KAAA,EACf,KAAA,GACA,OACA,KAAA,GACA,KAAA,GACA,eAAe,OAAA,CAChB;QAGD,MAAMkB,uBAAiC,CAAE,CAAA;QACzC,MAAM,UAAU,MAAM,QAAQ,UAAA,CAC5B,aAAa,GAAA,CAAI,OAAO,aAAa,UAAU;YAE7C,MAAM,SACJ,cAAc,0BAAA,CAA2B,YAAY,CAAC,QAAA,EAAU;YAClE,MAAM,SAAS,MAAM,MAAM,MAAA,CAAO,QAAQ,aAAa;YAEvD,IAAI,UAAU,MACZ,qBAAqB,IAAA,CAAK,MAAM;YAGlC,OAAO;QACR,EAAC,CACH;QAID,MAAM,gBAAgB,QACnB,GAAA,CAAI,CAAC,QAAQ,QAAA,CAAW;gBAAE;gBAAQ,YAAY,aAAA,CAAc,MAAA;YAAQ,CAAA,EAAE,CACtE,MAAA,CACC,CAAC,EAAE,MAAA,EAAQ,GACR,OAAO,MAAA,KAAW,eAAe,OAAO,KAAA,IAAS,QAClD,OAAO,MAAA,KAAW,WACrB;QAGH,MAAM,gBAAgB,cAAc,aAAA,IAAiB,IAAA,CAAK,aAAA;QAC1D,MAAMC,cAA8B,CAAE,CAAA;QACtC,MAAM,QAAQ,GAAA,CACZ,cAAc,GAAA,CAAI,OAAO,EAAE,QAAQ,aAAA,EAAe,UAAA,EAAY,EAAE,MAAM;YACpE,IAAI,cAAc,MAAA,KAAW,aAAa;gBACxC,MAAM,SAAS,cAAc,KAAA;gBAC7B,WAAA,CAAY,EAAA,GAAK,OAAO,GAAA,CAAI,CAACC,aAAW;oBACtC,IACE,aAAaA,YACbC,aAAAA,aAAAA,CAAcD,SAAO,OAAA,CAAQ,IAC7BE,WAAAA,WAAAA,CAAYF,SAAO,OAAA,CAAQ,EAC3B;wBACAA,SAAO,OAAA,CAAQ,cAAA,GAAiB;4BAC9B,cAAc;4BACd,eAAe;4BACf,cAAc;wBACf;wBACD,IAAI,kBAAkB,MACpBA,SAAO,OAAA,GAAUjB,gBAAAA,0BAAAA,CAA2BiB,SAAO,OAAA,CAAQ;oBAE9D;oBACDA,SAAO,cAAA,GAAiB;wBACtB,GAAGA,SAAO,cAAA;wBACV,YAAY,CAAE;oBACf;oBACD,OAAOA;gBACR,EAAC;gBACF,IAAI,OAAO,MAAA,EACT,MAAM,YAAY,kBAAkB,MAAA,CAAO,EAAA,CAAG,IAAA,CAAK;gBAErD,OAAO,YAAY,aACjB;oBACE,aAAa;wBAAC,MAAO;qBAAA;gBACtB,GACD,KAAA,GACA,KAAA,GACA,KAAA,GACA;oBACE,QAAQ;gBACT,EACF;YACF,OAAM;gBAEL,MAAM,YAAY,eAChB,cAAc,MAAA,EACd,KAAA,GACA,KAAA,GACA,KAAA,GACA;oBACE,QAAQ;gBACT,EACF;gBACD,OAAO,QAAQ,MAAA,CAAO,cAAc,MAAA,CAAO;YAC5C;QACF,EAAC,CACH;QAED,MAAM,SAAS;YACb;YACA;YACA,oBAAoB;QACrB;QAKD,OAAO,cAAA,CAAe,QAAQH,gBAAAA,OAAAA,EAAS;YACrC,OAAO,cACH;gBAAE,QAAQ,aAAa,IAAI,CAAC,UAAY,QAAQ,KAAA,CAAM;YAAE,IACxD,KAAA;YACJ,cAAc;QACf,EAAC;QAEF,OAAO;IACR;;;;;;;IASD,MAAM,SACJX,QAAAA,EACAiB,OAAAA,EACAC,SAAAA,EACoB;QAEpB,IAAIC;QACJ,IAAI,MAAM,OAAA,CAAQ,QAAQ,EACxB,gBAAgB;YAAE,MAAM;QAAS;aAEjC,gBAAgB;QAGlB,MAAM,eAAe,SAAS,GAAA,CAAI,CAAC,cACjC,YAAY,GAAA,CAAIf,cAAAA,0BAAAA,CAA2B,CAC5C;QAED,MAAM,CAAC,gBAAgB,YAAY,GACjC,IAAA,CAAK,4CAAA,CAA6C,cAAc;QAClE,eAAe,SAAA,GAAY,eAAe,SAAA,IAAa;QAEvD,IAAI,CAAC,IAAA,CAAK,KAAA,CACR,CAAA,OAAO,IAAA,CAAK,iBAAA,CAAkB,cAAc,aAAa,eAAe;QAG1E,MAAM,EAAE,KAAA,EAAO,GAAG,IAAA;QAClB,MAAM,eAAe,IAAA,CAAK,uCAAA,CACxB,YACD;QAED,MAAM,EAAE,WAAA,EAAa,oBAAA,EAAsB,kBAAA,EAAoB,GAC7D,MAAM,IAAA,CAAK,eAAA,CAAgB;YACzB,UAAU;YACV;YACA;YACA,eAAe;YACf,gBAAgB;QACjB,EAAC;QAEJ,IAAI,YAAY,CAAE;QAClB,IAAI,qBAAqB,MAAA,GAAS,GAAG;YACnC,MAAM,UAAU,MAAM,IAAA,CAAK,iBAAA,CACzB,qBAAqB,GAAA,CAAI,CAAC,IAAM,YAAA,CAAa,EAAA,CAAG,EAChD,aACA,gBACA,uBAAuB,KAAA,IACnB,qBAAqB,GAAA,CAAI,CAAC,IAAM,oBAAA,CAAqB,EAAA,CAAG,GACxD,KAAA,EACL;YACD,MAAM,QAAQ,GAAA,CACZ,QAAQ,WAAA,CAAY,GAAA,CAAI,OAAO,YAAY,UAAU;gBACnD,MAAM,cAAc,oBAAA,CAAqB,MAAA;gBACzC,WAAA,CAAY,YAAA,GAAe;gBAE3B,MAAM,SAAS,cAAc,0BAAA,CAC3B,YAAA,CAAa,YAAA,CACd,CAAC,QAAA,EAAU;gBACZ,OAAO,MAAM,MAAA,CAAO,QAAQ,cAAc,WAAW;YACtD,EAAC,CACH;YACD,YAAY,QAAQ,SAAA,IAAa,CAAE;QACpC;QAED,OAAO;YAAE;YAAa;QAAW;IAClC;;;IAMD,iBAAiBgB,QAAAA,EAA2C;QAC1D,OAAO,CAAE;IACV;IAED,aAAqB;QACnB,OAAO;IACR;;;;;;;IAWD,MAAM,eACJC,YAAAA,EACAJ,OAAAA,EACAC,SAAAA,EACoB;QACpB,MAAMI,iBAAkC,aAAa,GAAA,CAAI,CAAC,cACxD,YAAY,cAAA,EAAgB,CAC7B;QACD,OAAO,IAAA,CAAK,QAAA,CAAS,gBAAgB,SAAS,UAAU;IACzD;IAoDD,qBAIEC,YAAAA,EAIAC,MAAAA,EASI;QACJ,IAAI,OAAO,IAAA,CAAK,SAAA,KAAc,WAC5B,CAAA,MAAM,IAAI,MACR,CAAC,qEAAqE,CAAC;QAG3E,IAAI,QAAQ,OACV,CAAA,MAAM,IAAI,MACR,CAAC,yDAAyD,CAAC;QAI/D,MAAMC,SACJ;QACF,MAAM,OAAO,QAAQ;QACrB,MAAM,cACJC,YAAAA,oBAAAA,CAAqB,OAAO,IAAI;QAClC,MAAM,SAAS,QAAQ;QACvB,MAAM,aAAa,QAAQ;QAC3B,IAAI,WAAW,WACb,CAAA,MAAM,IAAI,MACR,CAAC,qFAAqF,CAAC;QAI3F,IAAI,eAAe,QAAQ;QAC3B,IAAIC;QACJ,IAAIC,YAAAA,kBAAAA,CAAmB,OAAO,EAC5B,QAAQ;YACN;gBACE,MAAM;gBACN,UAAU;oBACR,MAAM;oBACN;oBACA,YAAYC,0BAAAA,YAAAA,CAAa,OAAO;gBACjC;YACF,CACF;SAAA;aACI;YACL,IAAI,UAAU,QACZ,eAAe,OAAO,IAAA;YAExB,QAAQ;gBACN;oBACE,MAAM;oBACN,UAAU;wBACR,MAAM;wBACN;wBACA,YAAY;oBACb;gBACF,CACF;aAAA;QACF;QAED,MAAM,MAAM,IAAA,CAAK,SAAA,CAAU,MAAM;QACjC,MAAM,eAAeC,eAAAA,cAAAA,CAAe,IAAA,CAClC,CAACC,UAAuC;YACtC,IAAI,CAACC,WAAAA,cAAAA,CAAe,UAAA,CAAW,MAAM,CACnC,CAAA,MAAM,IAAI,MAAM;YAElB,IAAI,CAAC,MAAM,UAAA,IAAc,MAAM,UAAA,CAAW,MAAA,KAAW,EACnD,CAAA,MAAM,IAAI,MAAM;YAElB,MAAM,WAAW,MAAM,UAAA,CAAW,IAAA,CAChC,CAAC,KAAO,GAAG,IAAA,KAAS,aACrB;YACD,IAAI,CAAC,SACH,CAAA,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,aAAa,CAAC,CAAC;YAEjE,OAAO,SAAS,IAAA;QACjB,EACF;QAED,IAAI,CAAC,WACH,CAAA,OAAO,IAAI,IAAA,CAAK,aAAa,CAAC,UAAA,CAAW;YACvC,SAAS;QACV,EAAC;QAGJ,MAAM,eAAeC,oBAAAA,mBAAAA,CAAoB,MAAA,CAAO;YAE9C,QAAQ,CAACC,OAAYC,WAAW,aAAa,MAAA,CAAO,MAAM,GAAA,EAAKA,SAAO;QACvE,EAAC;QACF,MAAM,aAAaF,oBAAAA,mBAAAA,CAAoB,MAAA,CAAO;YAC5C,QAAQ,IAAM;QACf,EAAC;QACF,MAAM,qBAAqB,aAAa,aAAA,CAAc;YACpD,WAAW;gBAAC,UAAW;aAAA;QACxB,EAAC;QACF,OAAOG,eAAAA,gBAAAA,CAAiB,IAAA,CAGtB;YACA;gBACE,KAAK;YACN;YACD,kBACD;SAAA,CAAC,CAAC,UAAA,CAAW;YACZ,SAAS;QACV,EAAC;IACH;AACF;;;;GAMD,IAAsB,kBAAtB,cAEU,cAA2B;IAOnC,MAAM,UACJzD,QAAAA,EACAoB,OAAAA,EACAsC,UAAAA,EACqB;QACrB,MAAM,OAAO,MAAM,IAAA,CAAK,KAAA,CAAM,UAAU,SAAS,WAAW;QAC5D,MAAM,UAAU,IAAIC,WAAAA,SAAAA,CAAU;QAC9B,IAAI,OAAO,QAAQ,OAAA,KAAY,SAC7B,CAAA,MAAM,IAAI,MACR;QAGJ,OAAO;YACL,aAAa;gBACX;oBACE,MAAM,QAAQ,OAAA;oBACd;gBACD,CACF;aAAA;QACF;IACF;AACF"}},
    {"offset": {"line": 4333, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/llms.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/llms.ts"],"sourcesContent":["import type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  type LLMResult,\n  RUN_KEY,\n  type Generation,\n  GenerationChunk,\n} from \"../outputs.js\";\nimport {\n  type BaseCallbackConfig,\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport {\n  BaseLanguageModel,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLLMParams extends BaseLanguageModelParams {}\n\nexport interface BaseLLMCallOptions extends BaseLanguageModelCallOptions {}\n\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nexport abstract class BaseLLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions\n> extends BaseLanguageModel<string, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"llms\", this._llmType()];\n\n  /**\n   * This method takes an input and options, and returns a string. It\n   * converts the input to a prompt value and generates a result based on\n   * the prompt.\n   * @param input Input for the LLM.\n   * @param options Options for the LLM call.\n   * @returns A string result based on the prompt.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<string> {\n    const promptValue = BaseLLM._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    return result.generations[0][0].text;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _input: string,\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<GenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<string> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseLLM._convertInputToPromptValue(input);\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        runnableConfig.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        [prompt.toString()],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generation = new GenerationChunk({\n        text: \"\",\n      });\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          prompt.toString(),\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (!generation) {\n            generation = chunk;\n          } else {\n            generation = generation.concat(chunk);\n          }\n          if (typeof chunk.text === \"string\") {\n            yield chunk.text;\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            generations: [[generation]],\n          })\n        )\n      );\n    }\n  }\n\n  /**\n   * This method takes prompt values, options, and callbacks, and generates\n   * a result based on the prompts.\n   * @param promptValues Prompt values for the LLM.\n   * @param options Options for the LLM call.\n   * @param callbacks Callbacks for the LLM call.\n   * @returns An LLMResult based on the prompts.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const prompts: string[] = promptValues.map((promptValue) =>\n      promptValue.toString()\n    );\n    return this.generate(prompts, options, callbacks);\n  }\n\n  /**\n   * Run the LLM on the given prompts and input.\n   */\n  abstract _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult>;\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _flattenLLMResult(llmResult: LLMResult): LLMResult[] {\n    const llmResults: LLMResult[] = [];\n\n    for (let i = 0; i < llmResult.generations.length; i += 1) {\n      const genList = llmResult.generations[i];\n\n      if (i === 0) {\n        llmResults.push({\n          generations: [genList],\n          llmOutput: llmResult.llmOutput,\n        });\n      } else {\n        const llmOutput = llmResult.llmOutput\n          ? { ...llmResult.llmOutput, tokenUsage: {} }\n          : undefined;\n\n        llmResults.push({\n          generations: [genList],\n          llmOutput,\n        });\n      }\n    }\n\n    return llmResults;\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    prompts: string[],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: BaseCallbackConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === prompts.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        handledOptions.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: prompts.length,\n      };\n      runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        prompts,\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions?.runName\n      );\n    }\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    let output: LLMResult;\n    if (\n      hasStreamingHandler &&\n      prompts.length === 1 &&\n      this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          prompts[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        for await (const chunk of stream) {\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        output = { generations: [[aggregated]], llmOutput: {} };\n        await runManagers?.[0].handleLLMEnd(output);\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      try {\n        output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n\n      const flattenedOutputs: LLMResult[] = this._flattenLLMResult(output);\n      await Promise.all(\n        (runManagers ?? []).map((runManager, i) =>\n          runManager?.handleLLMEnd(flattenedOutputs[i])\n        )\n      );\n    }\n    const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runIds ? { runIds } : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    prompts,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n    runId,\n  }: {\n    prompts: string[];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n    runId?: string;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      handledOptions.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: prompts.length,\n    };\n    const runManagers = await callbackManager_?.handleLLMStart(\n      this.toJSON(),\n      prompts,\n      runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions?.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      prompts.map(async (prompt, index) => {\n        const result = await cache.lookup(prompt, llmStringKey);\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Run the LLM on the given prompts and input, handling caching.\n   */\n  async generate(\n    prompts: string[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    if (!Array.isArray(prompts)) {\n      throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n    }\n\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(prompts, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        prompts,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n        runId: runnableConfig.runId,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => prompts[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          return cache.update(prompts[promptIndex], llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Return the string type key uniquely identifying this class of LLM.\n   */\n  abstract _llmType(): string;\n\n  _modelType(): string {\n    return \"base_llm\" as const;\n  }\n}\n\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nexport abstract class LLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions\n> extends BaseLLM<CallOptions> {\n  /**\n   * Run the LLM on the given prompt and input.\n   */\n  abstract _call(\n    prompt: string,\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult> {\n    const generations: Generation[][] = await Promise.all(\n      prompts.map((prompt, promptIndex) =>\n        this._call(prompt, { ...options, promptIndex }, runManager).then(\n          (text) => [{ text }]\n        )\n      )\n    );\n    return { generations };\n  }\n}\n"],"names":["BaseLanguageModel","input: BaseLanguageModelInput","options?: CallOptions","_input: string","_options: this[\"ParsedCallOptions\"]","_runManager?: CallbackManagerForLLMRun","options?: Partial<CallOptions>","CallbackManager","GenerationChunk","promptValues: BasePromptValueInterface[]","options?: string[] | CallOptions","callbacks?: Callbacks","prompts: string[]","_options?: this[\"ParsedCallOptions\"]","llmResult: LLMResult","llmResults: LLMResult[]","parsedOptions: this[\"ParsedCallOptions\"]","handledOptions: BaseCallbackConfig","startedRunManagers?: CallbackManagerForLLMRun[]","runManagers: CallbackManagerForLLMRun[] | undefined","callbackHandlerPrefersStreaming","output: LLMResult","concat","flattenedOutputs: LLMResult[]","RUN_KEY","missingPromptIndices: number[]","generations: Generation[][]","result","parsedOptions: CallOptions | undefined","options: this[\"ParsedCallOptions\"]","runManager?: CallbackManagerForLLMRun"],"mappings":"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"}},
    {"offset": {"line": 4650, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/base.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/base.ts"],"sourcesContent":["import type { Tiktoken, TiktokenModel } from \"js-tiktoken/lite\";\nimport type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\n\nimport { type BaseCache, InMemoryCache } from \"../caches/index.js\";\nimport {\n  type BasePromptValueInterface,\n  StringPromptValue,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport {\n  type BaseMessage,\n  type BaseMessageLike,\n  type MessageContent,\n} from \"../messages/base.js\";\nimport { coerceMessageLikeToMessage } from \"../messages/utils.js\";\nimport { type LLMResult } from \"../outputs.js\";\nimport { CallbackManager, Callbacks } from \"../callbacks/manager.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"../utils/async_caller.js\";\nimport { encodingForModel } from \"../utils/tiktoken.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n} from \"../utils/types/zod.js\";\nimport { ModelProfile } from \"./profile.js\";\n\n// https://www.npmjs.com/package/js-tiktoken\n\nexport const getModelNameForTiktoken = (modelName: string): TiktokenModel => {\n  if (modelName.startsWith(\"gpt-5\")) {\n    return \"gpt-5\" as TiktokenModel;\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n    return \"gpt-3.5-turbo-16k\";\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n    return \"gpt-3.5-turbo\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-32k\")) {\n    return \"gpt-4-32k\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-\")) {\n    return \"gpt-4\";\n  }\n\n  if (modelName.startsWith(\"gpt-4o\")) {\n    return \"gpt-4o\";\n  }\n\n  return modelName as TiktokenModel;\n};\n\nexport const getEmbeddingContextSize = (modelName?: string): number => {\n  switch (modelName) {\n    case \"text-embedding-ada-002\":\n      return 8191;\n    default:\n      return 2046;\n  }\n};\n\n/**\n * Get the context window size (max input tokens) for a given model.\n *\n * Context window sizes are sourced from official model documentation:\n * - OpenAI: https://platform.openai.com/docs/models\n * - Anthropic: https://docs.anthropic.com/claude/docs/models-overview\n * - Google: https://ai.google.dev/gemini/docs/models/gemini\n *\n * @param modelName - The name of the model\n * @returns The context window size in tokens\n */\nexport const getModelContextSize = (modelName: string): number => {\n  const normalizedName = getModelNameForTiktoken(modelName) as string;\n\n  switch (normalizedName) {\n    // GPT-5 series\n    case \"gpt-5\":\n    case \"gpt-5-turbo\":\n    case \"gpt-5-turbo-preview\":\n      return 400000;\n\n    // GPT-4o series\n    case \"gpt-4o\":\n    case \"gpt-4o-mini\":\n    case \"gpt-4o-2024-05-13\":\n    case \"gpt-4o-2024-08-06\":\n      return 128000;\n\n    // GPT-4 Turbo series\n    case \"gpt-4-turbo\":\n    case \"gpt-4-turbo-preview\":\n    case \"gpt-4-turbo-2024-04-09\":\n    case \"gpt-4-0125-preview\":\n    case \"gpt-4-1106-preview\":\n      return 128000;\n\n    // GPT-4 series\n    case \"gpt-4-32k\":\n    case \"gpt-4-32k-0314\":\n    case \"gpt-4-32k-0613\":\n      return 32768;\n    case \"gpt-4\":\n    case \"gpt-4-0314\":\n    case \"gpt-4-0613\":\n      return 8192;\n\n    // GPT-3.5 Turbo series\n    case \"gpt-3.5-turbo-16k\":\n    case \"gpt-3.5-turbo-16k-0613\":\n      return 16384;\n    case \"gpt-3.5-turbo\":\n    case \"gpt-3.5-turbo-0301\":\n    case \"gpt-3.5-turbo-0613\":\n    case \"gpt-3.5-turbo-1106\":\n    case \"gpt-3.5-turbo-0125\":\n      return 4096;\n\n    // Legacy GPT-3 models\n    case \"text-davinci-003\":\n    case \"text-davinci-002\":\n      return 4097;\n    case \"text-davinci-001\":\n      return 2049;\n    case \"text-curie-001\":\n    case \"text-babbage-001\":\n    case \"text-ada-001\":\n      return 2048;\n\n    // Code models\n    case \"code-davinci-002\":\n    case \"code-davinci-001\":\n      return 8000;\n    case \"code-cushman-001\":\n      return 2048;\n\n    // Claude models (Anthropic)\n    case \"claude-3-5-sonnet-20241022\":\n    case \"claude-3-5-sonnet-20240620\":\n    case \"claude-3-opus-20240229\":\n    case \"claude-3-sonnet-20240229\":\n    case \"claude-3-haiku-20240307\":\n    case \"claude-2.1\":\n      return 200000;\n    case \"claude-2.0\":\n    case \"claude-instant-1.2\":\n      return 100000;\n\n    // Gemini models (Google)\n    case \"gemini-1.5-pro\":\n    case \"gemini-1.5-pro-latest\":\n    case \"gemini-1.5-flash\":\n    case \"gemini-1.5-flash-latest\":\n      return 1000000; // 1M tokens\n    case \"gemini-pro\":\n    case \"gemini-pro-vision\":\n      return 32768;\n\n    default:\n      return 4097;\n  }\n};\n\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nexport function isOpenAITool(tool: unknown): tool is ToolDefinition {\n  if (typeof tool !== \"object\" || !tool) return false;\n  if (\n    \"type\" in tool &&\n    tool.type === \"function\" &&\n    \"function\" in tool &&\n    typeof tool.function === \"object\" &&\n    tool.function &&\n    \"name\" in tool.function &&\n    \"parameters\" in tool.function\n  ) {\n    return true;\n  }\n  return false;\n}\n\ninterface CalculateMaxTokenProps {\n  prompt: string;\n  modelName: TiktokenModel;\n}\n\nexport const calculateMaxTokens = async ({\n  prompt,\n  modelName,\n}: CalculateMaxTokenProps) => {\n  let numTokens;\n\n  try {\n    numTokens = (\n      await encodingForModel(getModelNameForTiktoken(modelName))\n    ).encode(prompt).length;\n  } catch {\n    console.warn(\n      \"Failed to calculate number of tokens, falling back to approximate count\"\n    );\n\n    // fallback to approximate calculation if tiktoken is not available\n    // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n    numTokens = Math.ceil(prompt.length / 4);\n  }\n\n  const maxTokens = getModelContextSize(modelName);\n  return maxTokens - numTokens;\n};\n\nconst getVerbosity = () => false;\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLangChainParams {\n  verbose?: boolean;\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Base class for language models, chains, tools.\n */\nexport abstract class BaseLangChain<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput, CallOptions>\n  implements BaseLangChainParams\n{\n  /**\n   * Whether to print out response text.\n   */\n  verbose: boolean;\n\n  callbacks?: Callbacks;\n\n  tags?: string[];\n\n  metadata?: Record<string, unknown>;\n\n  get lc_attributes(): { [key: string]: undefined } | undefined {\n    return {\n      callbacks: undefined,\n      verbose: undefined,\n    };\n  }\n\n  constructor(params: BaseLangChainParams) {\n    super(params);\n    this.verbose = params.verbose ?? getVerbosity();\n    this.callbacks = params.callbacks;\n    this.tags = params.tags ?? [];\n    this.metadata = params.metadata ?? {};\n  }\n}\n\n/**\n * Base interface for language model parameters.\n * A subclass of {@link BaseLanguageModel} should have a constructor that\n * takes in a parameter that extends this interface.\n */\nexport interface BaseLanguageModelParams\n  extends AsyncCallerParams,\n    BaseLangChainParams {\n  /**\n   * @deprecated Use `callbacks` instead\n   */\n  callbackManager?: CallbackManager;\n\n  cache?: BaseCache | boolean;\n}\n\nexport interface BaseLanguageModelTracingCallOptions {\n  /**\n   * Describes the format of structured outputs.\n   * This should be provided if an output is considered to be structured\n   */\n  ls_structured_output_format?: {\n    /**\n     * An object containing the method used for structured output (e.g., \"jsonMode\").\n     */\n    kwargs: { method: string };\n    /**\n     * The JSON schema describing the expected output structure.\n     */\n    schema?: JSONSchema;\n  };\n}\n\nexport interface BaseLanguageModelCallOptions\n  extends RunnableConfig,\n    BaseLanguageModelTracingCallOptions {\n  /**\n   * Stop tokens to use for this call.\n   * If not provided, the default stop tokens for the model will be used.\n   */\n  stop?: string[];\n}\n\nexport interface FunctionDefinition {\n  /**\n   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n   * underscores and dashes, with a maximum length of 64.\n   */\n  name: string;\n\n  /**\n   * The parameters the functions accepts, described as a JSON Schema object. See the\n   * [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for\n   * examples, and the\n   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n   * documentation about the format.\n   *\n   * To describe a function that accepts no parameters, provide the value\n   * `{\"type\": \"object\", \"properties\": {}}`.\n   */\n  parameters: Record<string, unknown> | JSONSchema;\n\n  /**\n   * A description of what the function does, used by the model to choose when and\n   * how to call the function.\n   */\n  description?: string;\n}\n\nexport interface ToolDefinition {\n  type: \"function\";\n  function: FunctionDefinition;\n}\n\nexport type FunctionCallOption = {\n  name: string;\n};\n\nexport interface BaseFunctionCallOptions extends BaseLanguageModelCallOptions {\n  function_call?: FunctionCallOption;\n  functions?: FunctionDefinition[];\n}\n\nexport type BaseLanguageModelInput =\n  | BasePromptValueInterface\n  | string\n  | BaseMessageLike[];\n\nexport type StructuredOutputType = InferInteropZodOutput<InteropZodObject>;\n\nexport type StructuredOutputMethodOptions<IncludeRaw extends boolean = false> =\n  {\n    name?: string;\n    method?: \"functionCalling\" | \"jsonMode\" | \"jsonSchema\" | string;\n    includeRaw?: IncludeRaw;\n    /** Whether to use strict mode. Currently only supported by OpenAI models. */\n    strict?: boolean;\n  };\n\n/** @deprecated Use StructuredOutputMethodOptions instead */\nexport type StructuredOutputMethodParams<\n  RunOutput,\n  IncludeRaw extends boolean = false\n> = {\n  /** @deprecated Pass schema in as the first argument */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: InteropZodType<RunOutput> | Record<string, any>;\n  name?: string;\n  method?: \"functionCalling\" | \"jsonMode\";\n  includeRaw?: IncludeRaw;\n};\n\nexport interface BaseLanguageModelInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions\n> extends RunnableInterface<BaseLanguageModelInput, RunOutput, CallOptions> {\n  get callKeys(): string[];\n\n  generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  _modelType(): string;\n\n  _llmType(): string;\n\n  getNumTokens(content: MessageContent): Promise<number>;\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any>;\n\n  serialize(): SerializedLLM;\n}\n\nexport type LanguageModelOutput = BaseMessage | string;\n\nexport type LanguageModelLike = Runnable<\n  BaseLanguageModelInput,\n  LanguageModelOutput\n>;\n\n/**\n * Base class for language models.\n */\nexport abstract class BaseLanguageModel<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions\n  >\n  extends BaseLangChain<BaseLanguageModelInput, RunOutput, CallOptions>\n  implements\n    BaseLanguageModelParams,\n    BaseLanguageModelInterface<RunOutput, CallOptions>\n{\n  /**\n   * Keys that the language model accepts as call options.\n   */\n  get callKeys(): string[] {\n    return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n  }\n\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  cache?: BaseCache;\n\n  constructor({\n    callbacks,\n    callbackManager,\n    ...params\n  }: BaseLanguageModelParams) {\n    const { cache, ...rest } = params;\n    super({\n      callbacks: callbacks ?? callbackManager,\n      ...rest,\n    });\n    if (typeof cache === \"object\") {\n      this.cache = cache;\n    } else if (cache) {\n      this.cache = InMemoryCache.global();\n    } else {\n      this.cache = undefined;\n    }\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  abstract generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  abstract _modelType(): string;\n\n  abstract _llmType(): string;\n\n  private _encoding?: Tiktoken;\n\n  /**\n   * Get the number of tokens in the content.\n   * @param content The content to get the number of tokens for.\n   * @returns The number of tokens in the content.\n   */\n  async getNumTokens(content: MessageContent) {\n    // Extract text content from MessageContent\n    let textContent: string;\n    if (typeof content === \"string\") {\n      textContent = content;\n    } else {\n      /**\n       * Content is an array of ContentBlock\n       *\n       * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n       * We need to find a better way to do this.\n       * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n       */\n      textContent = content\n        .map((item) => {\n          if (typeof item === \"string\") return item;\n          if (item.type === \"text\" && \"text\" in item) return item.text;\n          return \"\";\n        })\n        .join(\"\");\n    }\n\n    // fallback to approximate calculation if tiktoken is not available\n    let numTokens = Math.ceil(textContent.length / 4);\n\n    if (!this._encoding) {\n      try {\n        this._encoding = await encodingForModel(\n          \"modelName\" in this\n            ? getModelNameForTiktoken(this.modelName as string)\n            : \"gpt2\"\n        );\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    if (this._encoding) {\n      try {\n        numTokens = this._encoding.encode(textContent).length;\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    return numTokens;\n  }\n\n  protected static _convertInputToPromptValue(\n    input: BaseLanguageModelInput\n  ): BasePromptValueInterface {\n    if (typeof input === \"string\") {\n      return new StringPromptValue(input);\n    } else if (Array.isArray(input)) {\n      return new ChatPromptValue(input.map(coerceMessageLikeToMessage));\n    } else {\n      return input;\n    }\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Create a unique cache key for a specific call to a specific language model.\n   * @param callOptions Call options for the model\n   * @returns A unique cache key.\n   */\n  _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }: CallOptions & { config?: RunnableConfig }\n  ): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const params: Record<string, any> = {\n      ...this._identifyingParams(),\n      ...callOptions,\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n    const filteredEntries = Object.entries(params).filter(\n      ([_, value]) => value !== undefined\n    );\n    const serializedEntries = filteredEntries\n      .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n      .sort()\n      .join(\",\");\n    return serializedEntries;\n  }\n\n  /**\n   * @deprecated\n   * Return a json-like object representing this LLM.\n   */\n  serialize(): SerializedLLM {\n    return {\n      ...this._identifyingParams(),\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n  }\n\n  /**\n   * @deprecated\n   * Load an LLM from a json-like object describing it.\n   */\n  static async deserialize(_data: SerializedLLM): Promise<BaseLanguageModel> {\n    throw new Error(\"Use .toJSON() instead\");\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   */\n  get profile(): ModelProfile {\n    return {};\n  }\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  /**\n   * Model wrapper that returns outputs formatted to match the given schema.\n   *\n   * @template {BaseLanguageModelInput} RunInput The input type for the Runnable, expected to be the same input for the LLM.\n   * @template {Record<string, any>} RunOutput The output type for the Runnable, expected to be a Zod schema object for structured output validation.\n   *\n   * @param {InteropZodType<RunOutput>} schema The schema for the structured output. Either as a Zod schema or a valid JSON schema object.\n   *   If a Zod schema is passed, the returned attributes will be validated, whereas with JSON schema they will not be.\n   * @param {string} name The name of the function to call.\n   * @param {\"functionCalling\" | \"jsonMode\"} [method=functionCalling] The method to use for getting the structured output. Defaults to \"functionCalling\".\n   * @param {boolean | undefined} [includeRaw=false] Whether to include the raw output in the result. Defaults to false.\n   * @returns {Runnable<RunInput, RunOutput> | Runnable<RunInput, { raw: BaseMessage; parsed: RunOutput }>} A new runnable that calls the LLM with structured output.\n   */\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      >;\n}\n\n/**\n * Shared interface for token usage\n * return type from LLM calls.\n */\nexport interface TokenUsage {\n  completionTokens?: number;\n  promptTokens?: number;\n  totalTokens?: number;\n}\n"],"names":["modelName: string","modelName?: string","tool: unknown","params: BaseLangChainParams","content: MessageContent","textContent: string","input: BaseLanguageModelInput","params: Record<string, any>","_data: SerializedLLM"],"mappings":"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"}},
    {"offset": {"line": 4953, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/utils.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/utils.ts"],"sourcesContent":["import { BaseMessage } from \"../messages/base.js\";\n\ntype Constructor<T> = new (...args: unknown[]) => T;\n\nexport const iife = <T>(fn: () => T): T => fn();\n\nfunction castStandardMessageContent<T extends BaseMessage>(message: T) {\n  const Cls = message.constructor as Constructor<T>;\n  return new Cls({\n    ...message,\n    content: message.contentBlocks,\n    response_metadata: {\n      ...message.response_metadata,\n      output_version: \"v1\",\n    },\n  });\n}\n\nexport { castStandardMessageContent };\n"],"names":["fn: () => T","message: T"],"mappings":";;;;;;;AAIA,MAAa,OAAO,CAAIA,KAAmB,IAAI;AAE/C,SAAS,2BAAkDC,OAAAA,EAAY;IACrE,MAAM,MAAM,QAAQ,WAAA;IACpB,OAAO,IAAI,IAAI;QACb,GAAG,OAAA;QACH,SAAS,QAAQ,aAAA;QACjB,mBAAmB;YACjB,GAAG,QAAQ,iBAAA;YACX,gBAAgB;QACjB;IACF;AACF"}},
    {"offset": {"line": 4978, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/chat_models.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/chat_models.ts"],"sourcesContent":["import type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\nimport {\n  AIMessage,\n  type BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  AIMessageChunk,\n  isAIMessageChunk,\n  isBaseMessage,\n  isAIMessage,\n  MessageOutputVersion,\n} from \"../messages/index.js\";\nimport {\n  convertToOpenAIImageBlock,\n  isURLContentBlock,\n  isBase64ContentBlock,\n} from \"../messages/content/data.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  LLMResult,\n  RUN_KEY,\n  type ChatGeneration,\n  ChatGenerationChunk,\n  type ChatResult,\n  type Generation,\n} from \"../outputs.js\";\nimport {\n  BaseLanguageModel,\n  type StructuredOutputMethodOptions,\n  type ToolDefinition,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport {\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport {\n  StructuredToolInterface,\n  StructuredToolParams,\n} from \"../tools/index.js\";\nimport {\n  Runnable,\n  RunnableLambda,\n  RunnableSequence,\n  RunnableToolLike,\n} from \"../runnables/base.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { RunnablePassthrough } from \"../runnables/passthrough.js\";\nimport {\n  getSchemaDescription,\n  InteropZodType,\n  isInteropZodSchema,\n} from \"../utils/types/zod.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { castStandardMessageContent, iife } from \"./utils.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolChoice = string | Record<string, any> | \"auto\" | \"any\";\n\n/**\n * Represents a serialized chat model.\n */\nexport type SerializedChatModel = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n// todo?\n/**\n * Represents a serialized large language model.\n */\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n/**\n * Represents the parameters for a base chat model.\n */\nexport type BaseChatModelParams = BaseLanguageModelParams & {\n  /**\n   * Whether to disable streaming.\n   *\n   * If streaming is bypassed, then `stream()` will defer to\n   * `invoke()`.\n   *\n   * - If true, will always bypass streaming case.\n   * - If false (default), will always use streaming case if available.\n   */\n  disableStreaming?: boolean;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\n/**\n * Represents the call options for a base chat model.\n */\nexport type BaseChatModelCallOptions = BaseLanguageModelCallOptions & {\n  /**\n   * Specifies how the chat model should use tools.\n   * @default undefined\n   *\n   * Possible values:\n   * - \"auto\": The model may choose to use any of the provided tools, or none.\n   * - \"any\": The model must use one of the provided tools.\n   * - \"none\": The model must not use any tools.\n   * - A string (not \"auto\", \"any\", or \"none\"): The name of a specific tool the model must use.\n   * - An object: A custom schema specifying tool choice parameters. Specific to the provider.\n   *\n   * Note: Not all providers support tool_choice. An error will be thrown\n   * if used with an unsupported model.\n   */\n  tool_choice?: ToolChoice;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\nfunction _formatForTracing(messages: BaseMessage[]): BaseMessage[] {\n  const messagesToTrace: BaseMessage[] = [];\n  for (const message of messages) {\n    let messageToTrace = message;\n    if (Array.isArray(message.content)) {\n      for (let idx = 0; idx < message.content.length; idx++) {\n        const block = message.content[idx];\n        if (isURLContentBlock(block) || isBase64ContentBlock(block)) {\n          if (messageToTrace === message) {\n            // Also shallow-copy content\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            messageToTrace = new (message.constructor as any)({\n              ...messageToTrace,\n              content: [\n                ...message.content.slice(0, idx),\n                convertToOpenAIImageBlock(block),\n                ...message.content.slice(idx + 1),\n              ],\n            });\n          }\n        }\n      }\n    }\n    messagesToTrace.push(messageToTrace);\n  }\n  return messagesToTrace;\n}\n\nexport type LangSmithParams = {\n  ls_provider?: string;\n  ls_model_name?: string;\n  ls_model_type: \"chat\";\n  ls_temperature?: number;\n  ls_max_tokens?: number;\n  ls_stop?: Array<string>;\n};\n\nexport type BindToolsInput =\n  | StructuredToolInterface\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | Record<string, any>\n  | ToolDefinition\n  | RunnableToolLike\n  | StructuredToolParams;\n\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nexport abstract class BaseChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions,\n  // TODO: Fix the parameter order on the next minor version.\n  OutputMessageType extends BaseMessageChunk = AIMessageChunk\n> extends BaseLanguageModel<OutputMessageType, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"chat_models\", this._llmType()];\n\n  disableStreaming = false;\n\n  outputVersion?: MessageOutputVersion;\n\n  get callKeys(): string[] {\n    return [...super.callKeys, \"outputVersion\"];\n  }\n\n  constructor(fields: BaseChatModelParams) {\n    super(fields);\n    this.outputVersion = iife(() => {\n      const outputVersion =\n        fields.outputVersion ?? getEnvironmentVariable(\"LC_OUTPUT_VERSION\");\n      if (outputVersion && [\"v0\", \"v1\"].includes(outputVersion)) {\n        return outputVersion as \"v0\" | \"v1\";\n      }\n      return \"v0\";\n    });\n  }\n\n  _combineLLMOutput?(\n    ...llmOutputs: LLMResult[\"llmOutput\"][]\n  ): LLMResult[\"llmOutput\"];\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  /**\n   * Bind tool-like objects to this chat model.\n   *\n   * @param tools A list of tool definitions to bind to this chat model.\n   * Can be a structured tool, an OpenAI formatted tool, or an object\n   * matching the provider's specific tool schema.\n   * @param kwargs Any additional parameters to bind.\n   */\n  bindTools?(\n    tools: BindToolsInput[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, OutputMessageType, CallOptions>;\n\n  /**\n   * Invokes the chat model with a single input.\n   * @param input The input for the language model.\n   * @param options The call options.\n   * @returns A Promise that resolves to a BaseMessageChunk.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<OutputMessageType> {\n    const promptValue = BaseChatModel._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    const chatGeneration = result.generations[0][0] as ChatGeneration;\n    // TODO: Remove cast after figuring out inheritance\n    return chatGeneration.message as OutputMessageType;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<OutputMessageType> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks ===\n        BaseChatModel.prototype._streamResponseChunks ||\n      this.disableStreaming\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseChatModel._convertInputToPromptValue(input);\n      const messages = prompt.toChatMessages();\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n\n      const inheritableMetadata = {\n        ...runnableConfig.metadata,\n        ...this.getLsParams(callOptions),\n      };\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const outputVersion = callOptions.outputVersion ?? this.outputVersion;\n      const runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        [_formatForTracing(messages)],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generationChunk: ChatGenerationChunk | undefined;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let llmOutput: Record<string, any> | undefined;\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          messages,\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          chunk.message.response_metadata = {\n            ...chunk.generationInfo,\n            ...chunk.message.response_metadata,\n          };\n          if (outputVersion === \"v1\") {\n            yield castStandardMessageContent(\n              chunk.message\n            ) as OutputMessageType;\n          } else {\n            yield chunk.message as OutputMessageType;\n          }\n          if (!generationChunk) {\n            generationChunk = chunk;\n          } else {\n            generationChunk = generationChunk.concat(chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            // TODO: Remove cast after figuring out inheritance\n            generations: [[generationChunk as ChatGeneration]],\n            llmOutput,\n          })\n        )\n      );\n    }\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const providerName = this.getName().startsWith(\"Chat\")\n      ? this.getName().replace(\"Chat\", \"\")\n      : this.getName();\n\n    return {\n      ls_model_type: \"chat\",\n      ls_stop: options.stop,\n      ls_provider: providerName,\n    };\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    messages: BaseMessageLike[][],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: RunnableConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === baseMessages.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const inheritableMetadata = {\n        ...handledOptions.metadata,\n        ...this.getLsParams(parsedOptions),\n      };\n      // create callback manager and start run\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: 1,\n      };\n      runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        baseMessages.map(_formatForTracing),\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions.runName\n      );\n    }\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: ChatGeneration[][] = [];\n    const llmOutputs: LLMResult[\"llmOutput\"][] = [];\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    if (\n      hasStreamingHandler &&\n      !this.disableStreaming &&\n      baseMessages.length === 1 &&\n      this._streamResponseChunks !==\n        BaseChatModel.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          baseMessages[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let llmOutput: Record<string, any> | undefined;\n        for await (const chunk of stream) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        generations.push([aggregated]);\n        await runManagers?.[0].handleLLMEnd({\n          generations,\n          llmOutput,\n        });\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      // generate results\n      const results = await Promise.allSettled(\n        baseMessages.map(async (messageList, i) => {\n          const generateResults = await this._generate(\n            messageList,\n            { ...parsedOptions, promptIndex: i },\n            runManagers?.[i]\n          );\n          if (outputVersion === \"v1\") {\n            for (const generation of generateResults.generations) {\n              generation.message = castStandardMessageContent(\n                generation.message\n              );\n            }\n          }\n          return generateResults;\n        })\n      );\n      // handle results\n      await Promise.all(\n        results.map(async (pResult, i) => {\n          if (pResult.status === \"fulfilled\") {\n            const result = pResult.value;\n            for (const generation of result.generations) {\n              if (generation.message.id == null) {\n                const runId = runManagers?.at(0)?.runId;\n                if (runId != null) generation.message._updateId(`run-${runId}`);\n              }\n              generation.message.response_metadata = {\n                ...generation.generationInfo,\n                ...generation.message.response_metadata,\n              };\n            }\n            if (result.generations.length === 1) {\n              result.generations[0].message.response_metadata = {\n                ...result.llmOutput,\n                ...result.generations[0].message.response_metadata,\n              };\n            }\n            generations[i] = result.generations;\n            llmOutputs[i] = result.llmOutput;\n            return runManagers?.[i]?.handleLLMEnd({\n              generations: [result.generations],\n              llmOutput: result.llmOutput,\n            });\n          } else {\n            // status === \"rejected\"\n            await runManagers?.[i]?.handleLLMError(pResult.reason);\n            return Promise.reject(pResult.reason);\n          }\n        })\n      );\n    }\n    // create combined output\n    const output: LLMResult = {\n      generations,\n      llmOutput: llmOutputs.length\n        ? this._combineLLMOutput?.(...llmOutputs)\n        : undefined,\n    };\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    messages,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n  }: {\n    messages: BaseMessageLike[][];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const inheritableMetadata = {\n      ...handledOptions.metadata,\n      ...this.getLsParams(parsedOptions),\n    };\n    // create callback manager and start run\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      inheritableMetadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: 1,\n    };\n    const runManagers = await callbackManager_?.handleChatModelStart(\n      this.toJSON(),\n      baseMessages.map(_formatForTracing),\n      handledOptions.runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      baseMessages.map(async (baseMessage, index) => {\n        // Join all content into one string for the prompt index\n        const prompt =\n          BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n        const result = await cache.lookup(prompt, llmStringKey);\n\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            if (\n              \"message\" in result &&\n              isBaseMessage(result.message) &&\n              isAIMessage(result.message)\n            ) {\n              result.message.usage_metadata = {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n              };\n              if (outputVersion === \"v1\") {\n                result.message = castStandardMessageContent(result.message);\n              }\n            }\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Generates chat based on the input messages.\n   * @param messages An array of arrays of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generate(\n    messages: BaseMessageLike[][],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    // parse call options\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(baseMessages, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        messages: baseMessages,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => baseMessages[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          // Join all content into one string for the prompt index\n          const prompt = BaseChatModel._convertInputToPromptValue(\n            baseMessages[promptIndex]\n          ).toString();\n          return cache.update(prompt, llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _modelType(): string {\n    return \"base_chat_model\" as const;\n  }\n\n  abstract _llmType(): string;\n\n  /**\n   * Generates a prompt based on the input prompt values.\n   * @param promptValues An array of BasePromptValue instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const promptMessages: BaseMessage[][] = promptValues.map((promptValue) =>\n      promptValue.toChatMessages()\n    );\n    return this.generate(promptMessages, options, callbacks);\n  }\n\n  abstract _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      > {\n    if (typeof this.bindTools !== \"function\") {\n      throw new Error(\n        `Chat model must implement \".bindTools()\" to use withStructuredOutput.`\n      );\n    }\n    if (config?.strict) {\n      throw new Error(\n        `\"strict\" mode is not supported for this model by default.`\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: Record<string, any> | InteropZodType<RunOutput> =\n      outputSchema;\n    const name = config?.name;\n    const description =\n      getSchemaDescription(schema) ?? \"A function available to call.\";\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n    if (method === \"jsonMode\") {\n      throw new Error(\n        `Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`\n      );\n    }\n\n    let functionName = name ?? \"extract\";\n    let tools: ToolDefinition[];\n    if (isInteropZodSchema(schema)) {\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: toJsonSchema(schema),\n          },\n        },\n      ];\n    } else {\n      if (\"name\" in schema) {\n        functionName = schema.name;\n      }\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: schema,\n          },\n        },\n      ];\n    }\n\n    const llm = this.bindTools(tools);\n    const outputParser = RunnableLambda.from<OutputMessageType, RunOutput>(\n      (input: BaseMessageChunk): RunOutput => {\n        if (!AIMessageChunk.isInstance(input)) {\n          throw new Error(\"Input is not an AIMessageChunk.\");\n        }\n        if (!input.tool_calls || input.tool_calls.length === 0) {\n          throw new Error(\"No tool calls found in the response.\");\n        }\n        const toolCall = input.tool_calls.find(\n          (tc) => tc.name === functionName\n        );\n        if (!toolCall) {\n          throw new Error(`No tool call found with name ${functionName}.`);\n        }\n        return toolCall.args as RunOutput;\n      }\n    );\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser).withConfig({\n        runName: \"StructuredOutput\",\n      }) as Runnable<BaseLanguageModelInput, RunOutput>;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]).withConfig({\n      runName: \"StructuredOutputRunnable\",\n    });\n  }\n}\n\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nexport abstract class SimpleChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions\n> extends BaseChatModel<CallOptions> {\n  abstract _call(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const text = await this._call(messages, options, runManager);\n    const message = new AIMessage(text);\n    if (typeof message.content !== \"string\") {\n      throw new Error(\n        \"Cannot generate with a simple chat model when output is not a string.\"\n      );\n    }\n    return {\n      generations: [\n        {\n          text: message.content,\n          message,\n        },\n      ],\n    };\n  }\n}\n"],"names":["messages: BaseMessage[]","messagesToTrace: BaseMessage[]","fields: BaseChatModelParams","options?: Partial<CallOptions>","input: BaseLanguageModelInput","options?: CallOptions","_messages: BaseMessage[]","_options: this[\"ParsedCallOptions\"]","_runManager?: CallbackManagerForLLMRun","generationChunk: ChatGenerationChunk | undefined","llmOutput: Record<string, any> | undefined","options: this[\"ParsedCallOptions\"]","messages: BaseMessageLike[][]","parsedOptions: this[\"ParsedCallOptions\"]","handledOptions: RunnableConfig","startedRunManagers?: CallbackManagerForLLMRun[]","runManagers: CallbackManagerForLLMRun[] | undefined","generations: ChatGeneration[][]","llmOutputs: LLMResult[\"llmOutput\"][]","output: LLMResult","missingPromptIndices: number[]","generations: Generation[][]","result","options?: string[] | CallOptions","callbacks?: Callbacks","parsedOptions: CallOptions | undefined","_options?: this[\"ParsedCallOptions\"]","promptValues: BasePromptValueInterface[]","promptMessages: BaseMessage[][]","outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>","config?: StructuredOutputMethodOptions<boolean>","schema: Record<string, any> | InteropZodType<RunOutput>","tools: ToolDefinition[]","input: BaseMessageChunk","input: any","config","runManager?: CallbackManagerForLLMRun"],"mappings":"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"}},
    {"offset": {"line": 5496, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/language_models/llms.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/language_models/llms.ts"],"sourcesContent":["import type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  type LLMResult,\n  RUN_KEY,\n  type Generation,\n  GenerationChunk,\n} from \"../outputs.js\";\nimport {\n  type BaseCallbackConfig,\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport {\n  BaseLanguageModel,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLLMParams extends BaseLanguageModelParams {}\n\nexport interface BaseLLMCallOptions extends BaseLanguageModelCallOptions {}\n\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nexport abstract class BaseLLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions\n> extends BaseLanguageModel<string, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"llms\", this._llmType()];\n\n  /**\n   * This method takes an input and options, and returns a string. It\n   * converts the input to a prompt value and generates a result based on\n   * the prompt.\n   * @param input Input for the LLM.\n   * @param options Options for the LLM call.\n   * @returns A string result based on the prompt.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<string> {\n    const promptValue = BaseLLM._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    return result.generations[0][0].text;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _input: string,\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<GenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<string> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseLLM._convertInputToPromptValue(input);\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        runnableConfig.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        [prompt.toString()],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generation = new GenerationChunk({\n        text: \"\",\n      });\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          prompt.toString(),\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (!generation) {\n            generation = chunk;\n          } else {\n            generation = generation.concat(chunk);\n          }\n          if (typeof chunk.text === \"string\") {\n            yield chunk.text;\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            generations: [[generation]],\n          })\n        )\n      );\n    }\n  }\n\n  /**\n   * This method takes prompt values, options, and callbacks, and generates\n   * a result based on the prompts.\n   * @param promptValues Prompt values for the LLM.\n   * @param options Options for the LLM call.\n   * @param callbacks Callbacks for the LLM call.\n   * @returns An LLMResult based on the prompts.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const prompts: string[] = promptValues.map((promptValue) =>\n      promptValue.toString()\n    );\n    return this.generate(prompts, options, callbacks);\n  }\n\n  /**\n   * Run the LLM on the given prompts and input.\n   */\n  abstract _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult>;\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _flattenLLMResult(llmResult: LLMResult): LLMResult[] {\n    const llmResults: LLMResult[] = [];\n\n    for (let i = 0; i < llmResult.generations.length; i += 1) {\n      const genList = llmResult.generations[i];\n\n      if (i === 0) {\n        llmResults.push({\n          generations: [genList],\n          llmOutput: llmResult.llmOutput,\n        });\n      } else {\n        const llmOutput = llmResult.llmOutput\n          ? { ...llmResult.llmOutput, tokenUsage: {} }\n          : undefined;\n\n        llmResults.push({\n          generations: [genList],\n          llmOutput,\n        });\n      }\n    }\n\n    return llmResults;\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    prompts: string[],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: BaseCallbackConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === prompts.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        handledOptions.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: prompts.length,\n      };\n      runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        prompts,\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions?.runName\n      );\n    }\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    let output: LLMResult;\n    if (\n      hasStreamingHandler &&\n      prompts.length === 1 &&\n      this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          prompts[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        for await (const chunk of stream) {\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        output = { generations: [[aggregated]], llmOutput: {} };\n        await runManagers?.[0].handleLLMEnd(output);\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      try {\n        output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n\n      const flattenedOutputs: LLMResult[] = this._flattenLLMResult(output);\n      await Promise.all(\n        (runManagers ?? []).map((runManager, i) =>\n          runManager?.handleLLMEnd(flattenedOutputs[i])\n        )\n      );\n    }\n    const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runIds ? { runIds } : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    prompts,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n    runId,\n  }: {\n    prompts: string[];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n    runId?: string;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      handledOptions.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: prompts.length,\n    };\n    const runManagers = await callbackManager_?.handleLLMStart(\n      this.toJSON(),\n      prompts,\n      runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions?.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      prompts.map(async (prompt, index) => {\n        const result = await cache.lookup(prompt, llmStringKey);\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Run the LLM on the given prompts and input, handling caching.\n   */\n  async generate(\n    prompts: string[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    if (!Array.isArray(prompts)) {\n      throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n    }\n\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(prompts, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        prompts,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n        runId: runnableConfig.runId,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => prompts[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          return cache.update(prompts[promptIndex], llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Return the string type key uniquely identifying this class of LLM.\n   */\n  abstract _llmType(): string;\n\n  _modelType(): string {\n    return \"base_llm\" as const;\n  }\n}\n\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nexport abstract class LLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions\n> extends BaseLLM<CallOptions> {\n  /**\n   * Run the LLM on the given prompt and input.\n   */\n  abstract _call(\n    prompt: string,\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult> {\n    const generations: Generation[][] = await Promise.all(\n      prompts.map((prompt, promptIndex) =>\n        this._call(prompt, { ...options, promptIndex }, runManager).then(\n          (text) => [{ text }]\n        )\n      )\n    );\n    return { generations };\n  }\n}\n"],"names":["input: BaseLanguageModelInput","options?: CallOptions","_input: string","_options: this[\"ParsedCallOptions\"]","_runManager?: CallbackManagerForLLMRun","options?: Partial<CallOptions>","promptValues: BasePromptValueInterface[]","options?: string[] | CallOptions","callbacks?: Callbacks","prompts: string[]","_options?: this[\"ParsedCallOptions\"]","llmResult: LLMResult","llmResults: LLMResult[]","parsedOptions: this[\"ParsedCallOptions\"]","handledOptions: BaseCallbackConfig","startedRunManagers?: CallbackManagerForLLMRun[]","runManagers: CallbackManagerForLLMRun[] | undefined","output: LLMResult","flattenedOutputs: LLMResult[]","missingPromptIndices: number[]","generations: Generation[][]","result","parsedOptions: CallOptions | undefined","options: this[\"ParsedCallOptions\"]","runManager?: CallbackManagerForLLMRun"],"mappings":"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"}},
    {"offset": {"line": 5819, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/base.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/base.ts"],"sourcesContent":["import { Runnable } from \"../runnables/index.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport type { BaseMessage, ContentBlock } from \"../messages/index.js\";\nimport type { Callbacks } from \"../callbacks/manager.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\n/**\n * Options for formatting instructions.\n */\nexport interface FormatInstructionsOptions {}\n\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport abstract class BaseLLMOutputParser<T = unknown> extends Runnable<\n  string | BaseMessage,\n  T\n> {\n  /**\n   * Parses the result of an LLM call. This method is meant to be\n   * implemented by subclasses to define how the output from the LLM should\n   * be parsed.\n   * @param generations The generations from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  abstract parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T>;\n\n  /**\n   * Parses the result of an LLM call with a given prompt. By default, it\n   * simply calls `parseResult`.\n   * @param generations The generations from an LLM call.\n   * @param _prompt The prompt used in the LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parseResultWithPrompt(\n    generations: Generation[] | ChatGeneration[],\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parseResult(generations, callbacks);\n  }\n\n  protected _baseMessageToString(message: BaseMessage): string {\n    return typeof message.content === \"string\"\n      ? message.content\n      : this._baseMessageContentToString(message.content);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return JSON.stringify(content);\n  }\n\n  /**\n   * Calls the parser with a given input and optional configuration options.\n   * If the input is a string, it creates a generation with the input as\n   * text and calls `parseResult`. If the input is a `BaseMessage`, it\n   * creates a generation with the input as a message and the content of the\n   * input as text, and then calls `parseResult`.\n   * @param input The input to the parser, which can be a string or a `BaseMessage`.\n   * @param options Optional configuration options.\n   * @returns A promise of the parsed output.\n   */\n  async invoke(\n    input: string | BaseMessage,\n    options?: RunnableConfig\n  ): Promise<T> {\n    if (typeof input === \"string\") {\n      return this._callWithConfig(\n        async (input: string, options): Promise<T> =>\n          this.parseResult([{ text: input }], options?.callbacks),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    } else {\n      return this._callWithConfig(\n        async (input: BaseMessage, options): Promise<T> =>\n          this.parseResult(\n            [\n              {\n                message: input,\n                text: this._baseMessageToString(input),\n              },\n            ],\n            options?.callbacks\n          ),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call.\n */\nexport abstract class BaseOutputParser<\n  T = unknown\n> extends BaseLLMOutputParser<T> {\n  parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(generations[0].text, callbacks);\n  }\n\n  /**\n   * Parse the output of an LLM call.\n   *\n   * @param text - LLM output to parse.\n   * @returns Parsed output.\n   */\n  abstract parse(text: string, callbacks?: Callbacks): Promise<T>;\n\n  async parseWithPrompt(\n    text: string,\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(text, callbacks);\n  }\n\n  /**\n   * Return a string describing the format of the output.\n   * @returns Format instructions.\n   * @param options - Options for formatting instructions.\n   * @example\n   * ```json\n   * {\n   *  \"foo\": \"bar\"\n   * }\n   * ```\n   */\n  abstract getFormatInstructions(options?: FormatInstructionsOptions): string;\n\n  /**\n   * Return the string type key uniquely identifying this class of parser\n   */\n  _type(): string {\n    throw new Error(\"_type not implemented\");\n  }\n}\n\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n  llmOutput?: string;\n\n  observation?: string;\n\n  sendToLLM: boolean;\n\n  constructor(\n    message: string,\n    llmOutput?: string,\n    observation?: string,\n    sendToLLM = false\n  ) {\n    super(message);\n    this.llmOutput = llmOutput;\n    this.observation = observation;\n    this.sendToLLM = sendToLLM;\n\n    if (sendToLLM) {\n      if (observation === undefined || llmOutput === undefined) {\n        throw new Error(\n          \"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\"\n        );\n      }\n    }\n\n    addLangChainErrorFields(this, \"OUTPUT_PARSING_FAILURE\");\n  }\n}\n"],"names":["Runnable","generations: Generation[] | ChatGeneration[]","_prompt: BasePromptValueInterface","callbacks?: Callbacks","message: BaseMessage","content: ContentBlock[]","input: string | BaseMessage","options?: RunnableConfig","input: string","options","input","input: BaseMessage","text: string","message: string","llmOutput?: string","observation?: string","addLangChainErrorFields"],"mappings":";;;;;;;;GAkBA,IAAsB,sBAAtB,cAA+DA,aAAAA,QAAAA,CAG7D;;;;;;;;IAsBA,sBACEC,WAAAA,EACAC,OAAAA,EACAC,SAAAA,EACY;QACZ,OAAO,IAAA,CAAK,WAAA,CAAY,aAAa,UAAU;IAChD;IAES,qBAAqBC,OAAAA,EAA8B;QAC3D,OAAO,OAAO,QAAQ,OAAA,KAAY,WAC9B,QAAQ,OAAA,GACR,IAAA,CAAK,2BAAA,CAA4B,QAAQ,OAAA,CAAQ;IACtD;IAES,4BAA4BC,OAAAA,EAAiC;QACrE,OAAO,KAAK,SAAA,CAAU,QAAQ;IAC/B;;;;;;;;;;IAYD,MAAM,OACJC,KAAAA,EACAC,OAAAA,EACY;QACZ,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO,IAAA,CAAK,eAAA,CACV,OAAOC,SAAeC,YACpB,IAAA,CAAK,WAAA,CAAY;gBAAC;oBAAE,MAAMC;gBAAO,CAAC;aAAA,EAAED,WAAS,UAAU,EACzD,OACA;YAAE,GAAG,OAAA;YAAS,SAAS;QAAU,EAClC;aAED,OAAO,IAAA,CAAK,eAAA,CACV,OAAOE,SAAoBF,YACzB,IAAA,CAAK,WAAA,CACH;gBACE;oBACE,SAASC;oBACT,MAAM,IAAA,CAAK,oBAAA,CAAqBA,QAAM;gBACvC,CACF;aAAA,EACDD,WAAS,UACV,EACH,OACA;YAAE,GAAG,OAAA;YAAS,SAAS;QAAU,EAClC;IAEJ;AACF;;;GAKD,IAAsB,mBAAtB,cAEU,oBAAuB;IAC/B,YACER,WAAAA,EACAE,SAAAA,EACY;QACZ,OAAO,IAAA,CAAK,KAAA,CAAM,WAAA,CAAY,EAAA,CAAG,IAAA,EAAM,UAAU;IAClD;IAUD,MAAM,gBACJS,IAAAA,EACAV,OAAAA,EACAC,SAAAA,EACY;QACZ,OAAO,IAAA,CAAK,KAAA,CAAM,MAAM,UAAU;IACnC;;;IAkBD,QAAgB;QACd,MAAM,IAAI,MAAM;IACjB;AACF;;;;;;;;;;;;;;;;;;GAoBD,IAAa,wBAAb,cAA2C,MAAM;IAC/C,UAAA;IAEA,YAAA;IAEA,UAAA;IAEA,YACEU,OAAAA,EACAC,SAAAA,EACAC,WAAAA,EACA,YAAY,KAAA,CACZ;QACA,KAAA,CAAM,QAAQ;QACd,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,SAAA,GAAY;QAEjB,IAAI,WACF;gBAAI,gBAAgB,KAAA,KAAa,cAAc,KAAA,EAC7C,CAAA,MAAM,IAAI,MACR;QAEH;QAGHC,cAAAA,uBAAAA,CAAwB,IAAA,EAAM,yBAAyB;IACxD;AACF"}},
    {"offset": {"line": 5927, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/transform.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/transform.ts"],"sourcesContent":["import { deepCompareStrict } from \"@cfworker/json-schema\";\nimport { BaseOutputParser } from \"./base.js\";\nimport {\n  type BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n} from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  type Generation,\n  type ChatGeneration,\n  GenerationChunk,\n  ChatGenerationChunk,\n} from \"../outputs.js\";\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport abstract class BaseTransformOutputParser<\n  T = unknown\n> extends BaseOutputParser<T> {\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{ text: chunk }]);\n      } else {\n        yield this.parseResult([\n          {\n            message: chunk,\n            text: this._baseMessageToString(chunk),\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>,\n    options: BaseCallbackConfig\n  ): AsyncGenerator<T> {\n    yield* this._transformStreamWithConfig(\n      inputGenerator,\n      this._transform.bind(this),\n      {\n        ...options,\n        runType: \"parser\",\n      }\n    );\n  }\n}\n\nexport type BaseCumulativeTransformOutputParserInput = { diff?: boolean };\n\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport abstract class BaseCumulativeTransformOutputParser<\n  T = unknown\n> extends BaseTransformOutputParser<T> {\n  protected diff = false;\n\n  constructor(fields?: BaseCumulativeTransformOutputParserInput) {\n    super(fields);\n    this.diff = fields?.diff ?? this.diff;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected abstract _diff(prev: any | undefined, next: any): any;\n\n  abstract parsePartialResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<T | undefined>;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    let prevParsed: T | undefined;\n    let accGen: GenerationChunk | undefined;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen: GenerationChunk;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content,\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content,\n        });\n      } else {\n        chunkGen = new GenerationChunk({ text: chunk });\n      }\n\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n\n      const parsed = await this.parsePartialResult([accGen]);\n      if (\n        parsed !== undefined &&\n        parsed !== null &&\n        !deepCompareStrict(parsed, prevParsed)\n      ) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"names":["BaseOutputParser","inputGenerator: AsyncGenerator<string | BaseMessage>","options: BaseCallbackConfig","fields?: BaseCumulativeTransformOutputParserInput","prevParsed: T | undefined","accGen: GenerationChunk | undefined","chunkGen: GenerationChunk","isBaseMessageChunk","ChatGenerationChunk","isBaseMessage","convertToChunk","GenerationChunk"],"mappings":";;;;;;;;;GAmBA,IAAsB,4BAAtB,cAEUA,eAAAA,gBAAAA,CAAoB;IAC5B,OAAO,WACLC,cAAAA,EACmB;QACnB,WAAW,MAAM,SAAS,eACxB,IAAI,OAAO,UAAU,UACnB,MAAM,IAAA,CAAK,WAAA,CAAY;YAAC;gBAAE,MAAM;YAAO,CAAC;SAAA,CAAC;aAEzC,MAAM,IAAA,CAAK,WAAA,CAAY;YACrB;gBACE,SAAS;gBACT,MAAM,IAAA,CAAK,oBAAA,CAAqB,MAAM;YACvC,CACF;SAAA,CAAC;IAGP;;;;;;;IASD,OAAO,UACLA,cAAAA,EACAC,OAAAA,EACmB;QACnB,OAAO,IAAA,CAAK,0BAAA,CACV,gBACA,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,IAAA,CAAK,EAC1B;YACE,GAAG,OAAA;YACH,SAAS;QACV,EACF;IACF;AACF;;;;;GASD,IAAsB,sCAAtB,cAEU,0BAA6B;IAC3B,OAAO,MAAA;IAEjB,YAAYC,MAAAA,CAAmD;QAC7D,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,QAAQ,QAAQ,IAAA,CAAK,IAAA;IAClC;IASD,OAAO,WACLF,cAAAA,EACmB;QACnB,IAAIG;QACJ,IAAIC;QACJ,WAAW,MAAM,SAAS,eAAgB;YACxC,IAAI,OAAO,UAAU,YAAY,OAAO,MAAM,OAAA,KAAY,SACxD,CAAA,MAAM,IAAI,MAAM;YAElB,IAAIC;YACJ,IAAIC,aAAAA,kBAAAA,CAAmB,MAAM,EAAE;gBAC7B,IAAI,OAAO,MAAM,OAAA,KAAY,SAC3B,CAAA,MAAM,IAAI,MAAM;gBAElB,WAAW,IAAIC,gBAAAA,mBAAAA,CAAoB;oBACjC,SAAS;oBACT,MAAM,MAAM,OAAA;gBACb;YACF,OAAA,IAAUC,aAAAA,aAAAA,CAAc,MAAM,EAAE;gBAC/B,IAAI,OAAO,MAAM,OAAA,KAAY,SAC3B,CAAA,MAAM,IAAI,MAAM;gBAElB,WAAW,IAAID,gBAAAA,mBAAAA,CAAoB;oBACjC,SAASE,cAAAA,cAAAA,CAAe,MAAM;oBAC9B,MAAM,MAAM,OAAA;gBACb;YACF,OACC,WAAW,IAAIC,gBAAAA,eAAAA,CAAgB;gBAAE,MAAM;YAAO;YAGhD,IAAI,WAAW,KAAA,GACb,SAAS;iBAET,SAAS,OAAO,MAAA,CAAO,SAAS;YAGlC,MAAM,SAAS,MAAM,IAAA,CAAK,kBAAA,CAAmB;gBAAC,MAAO;aAAA,CAAC;YACtD,IACE,WAAW,KAAA,KACX,WAAW,QACX,CAAA,CAAA,GAAA,uBAAA,iBAAA,EAAmB,QAAQ,WAAW,EACtC;gBACA,IAAI,IAAA,CAAK,IAAA,EACP,MAAM,IAAA,CAAK,KAAA,CAAM,YAAY,OAAO;qBAEpC,MAAM;gBAER,aAAa;YACd;QACF;IACF;IAED,wBAAgC;QAC9B,OAAO;IACR;AACF"}},
    {"offset": {"line": 6016, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/json.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/json.ts"],"sourcesContent":["import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\nimport { parseJsonMarkdown, parsePartialJson } from \"../utils/json.js\";\n\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  /** @internal */\n  override _concatOutputChunks<T>(first: T, second: T): T {\n    if (this.diff) {\n      return super._concatOutputChunks(first, second);\n    }\n    return second;\n  }\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  // This should actually return Partial<T>, but there's no way\n  // to specify emitted chunks as instances separate from the main output type.\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<T | undefined> {\n    return parseJsonMarkdown(generations[0].text);\n  }\n\n  async parse(text: string): Promise<T> {\n    return parseJsonMarkdown(text, JSON.parse);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n\nexport { parsePartialJson, parseJsonMarkdown };\n"],"names":["BaseCumulativeTransformOutputParser","first: T","second: T","prev: unknown | undefined","next: unknown","compare","generations: ChatGeneration[] | Generation[]","parseJsonMarkdown","text: string"],"mappings":";;;;;;;GAQA,IAAa,mBAAb,cAGUA,kBAAAA,mCAAAA,CAAuC;IAC/C,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,gBAAiB;KAAA,CAAA;IAEnD,kBAAkB,KAAA;qBAGT,oBAAuBC,KAAAA,EAAUC,MAAAA,EAAc;QACtD,IAAI,IAAA,CAAK,IAAA,CACP,CAAA,OAAO,KAAA,CAAM,oBAAoB,OAAO,OAAO;QAEjD,OAAO;IACR;IAES,MACRC,IAAAA,EACAC,IAAAA,EACyB;QACzB,IAAI,CAAC,KACH,CAAA,OAAO,KAAA;QAET,IAAI,CAAC,KACH,CAAA,OAAO;YAAC;gBAAE,IAAI;gBAAW,MAAM;gBAAI,OAAO;YAAM,CAAC;SAAA;QAEnD,OAAOC,eAAAA,OAAAA,CAAQ,MAAM,KAAK;IAC3B;IAID,MAAM,mBACJC,WAAAA,EACwB;QACxB,OAAOC,aAAAA,iBAAAA,CAAkB,WAAA,CAAY,EAAA,CAAG,IAAA,CAAK;IAC9C;IAED,MAAM,MAAMC,IAAAA,EAA0B;QACpC,OAAOD,aAAAA,iBAAAA,CAAkB,MAAM,KAAK,KAAA,CAAM;IAC3C;IAED,wBAAgC;QAC9B,OAAO;IACR;AACF"}},
    {"offset": {"line": 6062, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/openai_tools/json_output_tools_parsers.ts"],"sourcesContent":["import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport { ChatGeneration, ChatGenerationChunk } from \"../../outputs.js\";\nimport { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { InvalidToolCall, ToolCall } from \"../../messages/tool.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nimport {\n  type InteropZodType,\n  interopSafeParseAsync,\n} from \"../../utils/types/zod.js\";\n\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n};\n\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n} & BaseCumulativeTransformOutputParserInput;\n\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options: { returnId?: boolean; partial: true }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: false }\n): ToolCall;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new OutputParserException(\n        [\n          `Function \"${rawToolCall.function.name}\" arguments:`,\n          ``,\n          rawToolCall.function.arguments,\n          ``,\n          `are not valid JSON.`,\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n\n  const parsedToolCall: ToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\",\n  };\n\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n\n  return parsedToolCall;\n}\n\nexport function convertLangChainToolCallToOpenAI(toolCall: ToolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args),\n    },\n  };\n}\n\nexport function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  errorMsg?: string\n): InvalidToolCall {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\",\n  };\n}\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser<\n  T\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  protected _diff() {\n    throw new Error(\"Not supported.\");\n  }\n\n  async parse(): Promise<T> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(\n    generations: ChatGenerationChunk[] | ChatGeneration[],\n    partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map((toolCall) => {\n        const { id, ...rest } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest,\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(\n        JSON.stringify(message.additional_kwargs.tool_calls)\n      );\n      toolCalls = rawToolCalls.map((rawToolCall: Record<string, unknown>) => {\n        return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall: ParsedToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id,\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\ntype JsonOutputKeyToolsParserParamsBase = {\n  keyName: string;\n  returnSingle?: boolean;\n} & JsonOutputToolsParserParams;\n\ntype JsonOutputKeyToolsParserParamsV3<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: z3.ZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\ntype JsonOutputKeyToolsParserParamsV4<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: z4.$ZodType<T, T> } & JsonOutputKeyToolsParserParamsBase;\n\nexport type JsonOutputKeyToolsParserParamsInterop<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: InteropZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\n// Use Zod 3 for backwards compatibility\nexport type JsonOutputKeyToolsParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = JsonOutputKeyToolsParserParamsV3<T>;\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> extends JsonOutputToolsParser<T> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: JsonOutputKeyToolsParserParamsV3<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsV4<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsInterop<T>);\n\n  constructor(\n    params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>\n  ) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(\n      returnedValues.map((value) => this._validateResult(value))\n    );\n    return toolCallResults;\n  }\n}\n"],"names":["rawToolCall: Record<string, any>","options?: { returnId?: boolean; partial?: boolean }","parsePartialJson","e: any","OutputParserException","parsedToolCall: ToolCall","toolCall: ToolCall","errorMsg?: string","BaseCumulativeTransformOutputParser","fields?: JsonOutputToolsParserParams","generations: ChatGeneration[]","generations: ChatGenerationChunk[] | ChatGeneration[]","isAIMessage","rawToolCall: Record<string, unknown>","backwardsCompatibleToolCall: ParsedToolCall","params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>","result: unknown","interopSafeParseAsync","result: ParsedToolCall","returnedValues: ParsedToolCall[] | Record<string, any>[]"],"mappings":"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"}},
    {"offset": {"line": 6240, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/openai_tools/index.ts"],"sourcesContent":["export * from \"./json_output_tools_parsers.js\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 6266, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/bytes.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/bytes.ts"],"sourcesContent":["import { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nexport class BytesOutputParser extends BaseTransformOutputParser<Uint8Array> {\n  static lc_name() {\n    return \"BytesOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"bytes\"];\n\n  lc_serializable = true;\n\n  protected textEncoder: InstanceType<typeof TextEncoder> = new TextEncoder();\n\n  parse(text: string): Promise<Uint8Array> {\n    return Promise.resolve(this.textEncoder.encode(text));\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"names":["BaseTransformOutputParser","text: string"],"mappings":";;;;;GAMA,IAAa,oBAAb,cAAuCA,kBAAAA,yBAAAA,CAAsC;IAC3E,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB;QAAkB;KAAQ,CAAA;IAE5D,kBAAkB,KAAA;IAER,cAAgD,IAAI,cAAA;IAE9D,MAAMC,IAAAA,EAAmC;QACvC,OAAO,QAAQ,OAAA,CAAQ,IAAA,CAAK,WAAA,CAAY,MAAA,CAAO,KAAK,CAAC;IACtD;IAED,wBAAgC;QAC9B,OAAO;IACR;AACF"}},
    {"offset": {"line": 6294, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/list.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/list.ts"],"sourcesContent":["import { BaseMessage } from \"../messages/index.js\";\nimport { OutputParserException } from \"./base.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport abstract class ListOutputParser extends BaseTransformOutputParser<\n  string[]\n> {\n  re?: RegExp;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<string[]> {\n    let buffer = \"\";\n    for await (const input of inputGenerator) {\n      if (typeof input === \"string\") {\n        // add current chunk to buffer\n        buffer += input;\n      } else {\n        // extract message content and add to buffer\n        buffer += input.content;\n      }\n      // get parts in buffer\n      if (!this.re) {\n        const parts = await this.parse(buffer);\n        if (parts.length > 1) {\n          // if there are multiple parts, yield all but the last one\n          for (const part of parts.slice(0, -1)) {\n            yield [part];\n          }\n          // keep the last part in the buffer\n          buffer = parts[parts.length - 1];\n        }\n      } else {\n        // if there is a regex, get all matches\n        const matches = [...buffer.matchAll(this.re)];\n        if (matches.length > 1) {\n          let doneIdx = 0;\n          // if there are multiple matches, yield all but the last one\n          for (const match of matches.slice(0, -1)) {\n            yield [match[1]];\n            doneIdx += (match.index ?? 0) + match[0].length;\n          }\n          // keep the last match in the buffer\n          buffer = buffer.slice(doneIdx);\n        }\n      }\n    }\n\n    // yield the last part\n    for (const part of await this.parse(buffer)) {\n      yield [part];\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport class CommaSeparatedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"CommaSeparatedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses the given text into an array of strings, using a comma as the\n   * separator. If the parsing fails, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each comma.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      return text\n        .trim()\n        .split(\",\")\n        .map((s) => s.trim());\n    } catch {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CommaSeparatedListOutputParser.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n  }\n}\n\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport class CustomListOutputParser extends ListOutputParser {\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  private length: number | undefined;\n\n  private separator: string;\n\n  constructor({ length, separator }: { length?: number; separator?: string }) {\n    super(...arguments);\n    this.length = length;\n    this.separator = separator || \",\";\n  }\n\n  /**\n   * Parses the given text into an array of strings, using the specified\n   * separator. If the parsing fails or the number of items in the list\n   * doesn't match the expected length, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      const items = text\n        .trim()\n        .split(this.separator)\n        .map((s) => s.trim());\n      if (this.length !== undefined && items.length !== this.length) {\n        throw new OutputParserException(\n          `Incorrect number of items. Expected ${this.length}, got ${items.length}.`\n        );\n      }\n      return items;\n    } catch (e) {\n      if (Object.getPrototypeOf(e) === OutputParserException.prototype) {\n        throw e;\n      }\n      throw new OutputParserException(`Could not parse output: ${text}`);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CustomListOutputParser, including the number of items and the\n   * separator.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of ${\n      this.length === undefined ? \"\" : `${this.length} `\n    }items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${\n      this.separator\n    } baz\\`)`;\n  }\n}\n\nexport class NumberedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /\\d+\\.\\s([^\\n]+)/g;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n\nexport class MarkdownListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /^\\s*[-*]\\s([^\\n]+)$/gm;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n"],"names":["BaseTransformOutputParser","inputGenerator: AsyncGenerator<string | BaseMessage>","text: string","OutputParserException"],"mappings":";;;;;;GAQA,IAAsB,mBAAtB,cAA+CA,kBAAAA,yBAAAA,CAE7C;IACA,GAAA;IAEA,OAAO,WACLC,cAAAA,EAC0B;QAC1B,IAAI,SAAS;QACb,WAAW,MAAM,SAAS,eAAgB;YACxC,IAAI,OAAO,UAAU,UAEnB,UAAU;iBAGV,UAAU,MAAM,OAAA;YAGlB,IAAI,CAAC,IAAA,CAAK,EAAA,EAAI;gBACZ,MAAM,QAAQ,MAAM,IAAA,CAAK,KAAA,CAAM,OAAO;gBACtC,IAAI,MAAM,MAAA,GAAS,GAAG;oBAEpB,KAAK,MAAM,QAAQ,MAAM,KAAA,CAAM,GAAG,CAAA,EAAG,CACnC,MAAM;wBAAC,IAAK;qBAAA;oBAGd,SAAS,KAAA,CAAM,MAAM,MAAA,GAAS,EAAA;gBAC/B;YACF,OAAM;gBAEL,MAAM,UAAU,CAAC;uBAAG,OAAO,QAAA,CAAS,IAAA,CAAK,EAAA,CAAG,AAAC;iBAAA;gBAC7C,IAAI,QAAQ,MAAA,GAAS,GAAG;oBACtB,IAAI,UAAU;oBAEd,KAAK,MAAM,SAAS,QAAQ,KAAA,CAAM,GAAG,CAAA,EAAG,CAAE;wBACxC,MAAM;4BAAC,KAAA,CAAM,EAAG;yBAAA;wBAChB,WAAA,CAAY,MAAM,KAAA,IAAS,CAAA,IAAK,KAAA,CAAM,EAAA,CAAG,MAAA;oBAC1C;oBAED,SAAS,OAAO,KAAA,CAAM,QAAQ;gBAC/B;YACF;QACF;QAGD,KAAK,MAAM,SAAQ,MAAM,IAAA,CAAK,KAAA,CAAM,OAAA,CAAO,CACzC,MAAM;YAAC,IAAK;SAAA;IAEf;AACF;;;;GAMD,IAAa,iCAAb,cAAoD,iBAAiB;IACnE,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB;QAAkB;KAAO,CAAA;IAE3D,kBAAkB,KAAA;;;;;;IAQlB,MAAM,MAAMC,IAAAA,EAAiC;QAC3C,IAAI;YACF,OAAO,KACJ,IAAA,EAAM,CACN,KAAA,CAAM,IAAI,CACV,GAAA,CAAI,CAAC,IAAM,EAAE,IAAA,EAAM,CAAC;QACxB,EAAA,OAAO;YACN,MAAM,IAAIC,aAAAA,qBAAAA,CAAsB,CAAC,wBAAwB,EAAE,MAAM,EAAE;QACpE;IACF;;;;;IAOD,wBAAgC;QAC9B,OAAO,CAAC,+EAA+E,CAAC;IACzF;AACF;;;;GAMD,IAAa,yBAAb,cAA4C,iBAAiB;IAC3D,eAAe;QAAC;QAAkB;QAAkB;KAAO,CAAA;IAEnD,OAAA;IAEA,UAAA;IAER,YAAY,EAAE,MAAA,EAAQ,SAAA,EAAoD,CAAE;QAC1E,KAAA,CAAM,GAAG,UAAU;QACnB,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,SAAA,GAAY,aAAa;IAC/B;;;;;;;IASD,MAAM,MAAMD,IAAAA,EAAiC;QAC3C,IAAI;YACF,MAAM,QAAQ,KACX,IAAA,EAAM,CACN,KAAA,CAAM,IAAA,CAAK,SAAA,CAAU,CACrB,GAAA,CAAI,CAAC,IAAM,EAAE,IAAA,EAAM,CAAC;YACvB,IAAI,IAAA,CAAK,MAAA,KAAW,KAAA,KAAa,MAAM,MAAA,KAAW,IAAA,CAAK,MAAA,CACrD,CAAA,MAAM,IAAIC,aAAAA,qBAAAA,CACR,CAAC,oCAAoC,EAAE,IAAA,CAAK,MAAA,CAAO,MAAM,EAAE,MAAM,MAAA,CAAO,CAAC,CAAC;YAG9E,OAAO;QACR,EAAA,OAAQ,GAAG;YACV,IAAI,OAAO,cAAA,CAAe,EAAE,KAAKA,aAAAA,qBAAAA,CAAsB,SAAA,CACrD,CAAA,MAAM;YAER,MAAM,IAAIA,aAAAA,qBAAAA,CAAsB,CAAC,wBAAwB,EAAE,MAAM;QAClE;IACF;;;;;;IAQD,wBAAgC;QAC9B,OAAO,CAAC,kCAAkC,EACxC,IAAA,CAAK,MAAA,KAAW,KAAA,IAAY,KAAK,GAAG,IAAA,CAAK,MAAA,CAAO,CAAC,CAAC,CACnD,oBAAoB,EAAE,IAAA,CAAK,SAAA,CAAU,YAAY,EAAE,IAAA,CAAK,SAAA,CAAU,IAAI,EACrE,IAAA,CAAK,SAAA,CACN,OAAO,CAAC;IACV;AACF;AAED,IAAa,2BAAb,cAA8C,iBAAiB;IAC7D,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB;QAAkB;KAAO,CAAA;IAE3D,kBAAkB,KAAA;IAElB,wBAAgC;QAC9B,OAAO,CAAC,iHAAiH,CAAC;IAC3H;IAED,KAAK,mBAAA;IAEL,MAAM,MAAMD,IAAAA,EAAiC;QAC3C,OAAO,CAAC;eAAI,KAAK,QAAA,CAAS,IAAA,CAAK,EAAA,CAAG,IAAI,CAAE,CAAE;SAAA,CAAC,GAAA,CAAI,CAAC,IAAM,CAAA,CAAE,EAAA,CAAG;IAC5D;AACF;AAED,IAAa,2BAAb,cAA8C,iBAAiB;IAC7D,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB;QAAkB;KAAO,CAAA;IAE3D,kBAAkB,KAAA;IAElB,wBAAgC;QAC9B,OAAO,CAAC,iHAAiH,CAAC;IAC3H;IAED,KAAK,wBAAA;IAEL,MAAM,MAAMA,IAAAA,EAAiC;QAC3C,OAAO,CAAC;eAAI,KAAK,QAAA,CAAS,IAAA,CAAK,EAAA,CAAG,IAAI,CAAE,CAAE;SAAA,CAAC,GAAA,CAAI,CAAC,IAAM,CAAA,CAAE,EAAA,CAAG;IAC5D;AACF"}},
    {"offset": {"line": 6459, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/string.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/string.ts"],"sourcesContent":["import { BaseTransformOutputParser } from \"./transform.js\";\nimport { ContentBlock } from \"../messages/index.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nexport class StringOutputParser extends BaseTransformOutputParser<string> {\n  static lc_name() {\n    return \"StrOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"string\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parse(text: string): Promise<string> {\n    return Promise.resolve(text);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  protected _textContentToString(content: ContentBlock.Text): string {\n    return content.text;\n  }\n\n  protected _imageUrlContentToString(\n    _content: ContentBlock.Data.URLContentBlock\n  ): string {\n    throw new Error(\n      `Cannot coerce a multimodal \"image_url\" message part into a string.`\n    );\n  }\n\n  protected _messageContentToString(content: ContentBlock): string {\n    switch (content.type) {\n      case \"text\":\n      case \"text_delta\":\n        if (\"text\" in content) {\n          // Type guard for MessageContentText\n          return this._textContentToString(content as ContentBlock.Text);\n        }\n        break;\n      case \"image_url\":\n        if (\"image_url\" in content) {\n          // Type guard for MessageContentImageUrl\n          return this._imageUrlContentToString(\n            content as ContentBlock.Data.URLContentBlock\n          );\n        }\n        break;\n      default:\n        throw new Error(\n          `Cannot coerce \"${content.type}\" message part into a string.`\n        );\n    }\n    throw new Error(`Invalid content type: ${content.type}`);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return content.reduce(\n      (acc: string, item: ContentBlock) =>\n        acc + this._messageContentToString(item),\n      \"\"\n    );\n  }\n}\n"],"names":["BaseTransformOutputParser","text: string","content: ContentBlock.Text","_content: ContentBlock.Data.URLContentBlock","content: ContentBlock","content: ContentBlock[]","acc: string","item: ContentBlock"],"mappings":";;;;;;;;;;;;;;;;;;;GAqBA,IAAa,qBAAb,cAAwCA,kBAAAA,yBAAAA,CAAkC;IACxE,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB;QAAkB;KAAS,CAAA;IAE7D,kBAAkB,KAAA;;;;;;;;IAUlB,MAAMC,IAAAA,EAA+B;QACnC,OAAO,QAAQ,OAAA,CAAQ,KAAK;IAC7B;IAED,wBAAgC;QAC9B,OAAO;IACR;IAES,qBAAqBC,OAAAA,EAAoC;QACjE,OAAO,QAAQ,IAAA;IAChB;IAES,yBACRC,QAAAA,EACQ;QACR,MAAM,IAAI,MACR,CAAC,kEAAkE,CAAC;IAEvE;IAES,wBAAwBC,OAAAA,EAA+B;QAC/D,OAAQ,QAAQ,IAAA,EAAhB;YACE,KAAK;YACL,KAAK;gBACH,IAAI,UAAU,QAEZ,CAAA,OAAO,IAAA,CAAK,oBAAA,CAAqB,QAA6B;gBAEhE;YACF,KAAK;gBACH,IAAI,eAAe,QAEjB,CAAA,OAAO,IAAA,CAAK,wBAAA,CACV,QACD;gBAEH;YACF,QACE;gBAAA,MAAM,IAAI,MACR,CAAC,eAAe,EAAE,QAAQ,IAAA,CAAK,6BAA6B,CAAC;QAElE;QACD,MAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,QAAQ,IAAA,EAAM;IACxD;IAES,4BAA4BC,OAAAA,EAAiC;QACrE,OAAO,QAAQ,MAAA,CACb,CAACC,KAAaC,OACZ,MAAM,IAAA,CAAK,uBAAA,CAAwB,KAAK,EAC1C,GACD;IACF;AACF"}},
    {"offset": {"line": 6530, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/structured.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/structured.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport {\n  BaseOutputParser,\n  FormatInstructionsOptions,\n  OutputParserException,\n} from \"./base.js\";\nimport {\n  type InteropZodType,\n  type InferInteropZodOutput,\n  interopParseAsync,\n} from \"../utils/types/zod.js\";\nimport {\n  toJsonSchema,\n  type JsonSchema7Type,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"../utils/json_schema.js\";\n\nexport type JsonMarkdownStructuredOutputParserInput = {\n  interpolationDepth?: number;\n};\n\nexport interface JsonMarkdownFormatInstructionsOptions\n  extends FormatInstructionsOptions {\n  interpolationDepth?: number;\n}\n\nexport class StructuredOutputParser<\n  T extends InteropZodType\n> extends BaseOutputParser<InferInteropZodOutput<T>> {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"structured\"];\n\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n\n  constructor(public schema: T) {\n    super(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this(zodSchema);\n  }\n\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions(): string {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(toJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text: string): Promise<InferInteropZodOutput<T>> {\n    try {\n      const trimmedText = text.trim();\n\n      const json =\n        // first case: if back ticks appear at the start of the text\n        trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n        // second case: if back ticks with `json` appear anywhere in the text\n        trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n        // otherwise, return the trimmed text\n        trimmedText;\n\n      const escapedJson = json\n        .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n          const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n          return `\"${escapedInsideQuotes}\"`;\n        })\n        .replace(/\\n/g, \"\");\n\n      return await interopParseAsync(this.schema, JSON.parse(escapedJson));\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n  }\n}\n\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser<\n  T extends InteropZodType\n> extends StructuredOutputParser<T> {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n\n  getFormatInstructions(\n    options?: JsonMarkdownFormatInstructionsOptions\n  ): string {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(\n      toJsonSchema(this.schema)\n    )\n      .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n      .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n\n  private _schemaToInstruction(\n    schemaInput: JsonSchema7Type,\n    indent = 2\n  ): string {\n    const schema = schemaInput as Extract<\n      JsonSchema7Type,\n      | JsonSchema7ObjectType\n      | JsonSchema7ArrayType\n      | JsonSchema7StringType\n      | JsonSchema7NumberType\n      | JsonSchema7NullableType\n    >;\n\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type: string;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex((type) => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \") as string;\n      } else {\n        type = schema.type;\n      }\n\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        const properties = Object.entries(schema.properties)\n          .map(([key, value]) => {\n            const isOptional = schema.required?.includes(key)\n              ? \"\"\n              : \" (optional)\";\n            return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(\n              value,\n              indent + 2\n            )}${isOptional}`;\n          })\n          .join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(\n          schema.items,\n          indent + 2\n        )}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n\n    if (\"anyOf\" in schema) {\n      return schema.anyOf\n        .map((s) => this._schemaToInstruction(s, indent))\n        .join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n\n    throw new Error(\"unsupported schema type\");\n  }\n\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this<T>(schema);\n  }\n\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this<typeof zodSchema>(zodSchema);\n  }\n}\n\nexport interface AsymmetricStructuredOutputParserFields<\n  T extends InteropZodType\n> {\n  inputSchema: T;\n}\n\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport abstract class AsymmetricStructuredOutputParser<\n  T extends InteropZodType,\n  Y = unknown\n> extends BaseOutputParser<Y> {\n  private structuredInputParser: JsonMarkdownStructuredOutputParser<T>;\n\n  constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>) {\n    super(...arguments);\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(\n      inputSchema\n    );\n  }\n\n  /**\n   * Processes the parsed input into the desired output format. Must be\n   * implemented by subclasses.\n   * @param input The parsed input\n   * @returns The processed output.\n   */\n  abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n\n  async parse(text: string): Promise<Y> {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n\n    return this.outputProcessor(parsedInput);\n  }\n\n  getFormatInstructions(): string {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}\n"],"names":["BaseOutputParser","schema: T","schemas: S","z","toJsonSchema","text: string","interopParseAsync","OutputParserException","options?: JsonMarkdownFormatInstructionsOptions","schemaInput: JsonSchema7Type","type: string","type","description"],"mappings":"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"}},
    {"offset": {"line": 6695, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/xml.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/xml.ts"],"sourcesContent":["import {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\n\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\n\nexport interface XMLOutputParserFields\n  extends BaseCumulativeTransformOutputParserInput {\n  /**\n   * Optional list of tags that the output should conform to.\n   * Only used in formatting of the prompt.\n   */\n  tags?: string[];\n}\n\nexport type Content = string | undefined | Array<{ [key: string]: Content }>;\n\nexport type XMLResult = {\n  [key: string]: Content;\n};\n\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser<XMLResult> {\n  tags?: string[];\n\n  constructor(fields?: XMLOutputParserFields) {\n    super(fields);\n\n    this.tags = fields?.tags;\n  }\n\n  static lc_name() {\n    return \"XMLOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<XMLResult | undefined> {\n    return parseXMLMarkdown(generations[0].text);\n  }\n\n  async parse(text: string): Promise<XMLResult> {\n    return parseXMLMarkdown(text);\n  }\n\n  getFormatInstructions(): string {\n    const withTags = !!(this.tags && this.tags.length > 0);\n    return withTags\n      ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n      : XML_FORMAT_INSTRUCTIONS;\n  }\n}\n\nconst strip = (text: string) =>\n  text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\n\ntype ParsedResult = {\n  name: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  attributes: Record<string, any>;\n  children: Array<ParsedResult>;\n  text?: string;\n  isSelfClosing: boolean;\n};\n\nconst parseParsedResult = (input: ParsedResult): XMLResult => {\n  if (Object.keys(input).length === 0) {\n    return {};\n  }\n  const result: XMLResult = {};\n  if (input.children.length > 0) {\n    result[input.name] = input.children.map(parseParsedResult);\n    return result;\n  } else {\n    result[input.name] = input.text ?? undefined;\n    return result;\n  }\n};\n\nexport function parseXMLMarkdown(s: string): XMLResult {\n  const cleanedString = strip(s);\n  const parser = sax.parser(true);\n  let parsedResult: ParsedResult = {} as ParsedResult;\n  const elementStack: ParsedResult[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onopentag = (node: any) => {\n    const element = {\n      name: node.name,\n      attributes: node.attributes,\n      children: [],\n      text: \"\",\n      isSelfClosing: node.isSelfClosing,\n    };\n\n    if (elementStack.length > 0) {\n      const parentElement = elementStack[elementStack.length - 1];\n      parentElement.children.push(element);\n    } else {\n      parsedResult = element as ParsedResult;\n    }\n\n    if (!node.isSelfClosing) {\n      elementStack.push(element);\n    }\n  };\n\n  parser.onclosetag = () => {\n    if (elementStack.length > 0) {\n      const lastElement = elementStack.pop();\n      if (elementStack.length === 0 && lastElement) {\n        parsedResult = lastElement as ParsedResult;\n      }\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.ontext = (text: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.text += text;\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onattribute = (attr: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.attributes[attr.name] = attr.value;\n    }\n  };\n\n  // Try to find XML string within triple backticks.\n  const match = /```(xml)?(.*)```/s.exec(cleanedString);\n  const xmlString = match ? match[2] : cleanedString;\n  parser.write(xmlString).close();\n\n  // Remove the XML declaration if present\n  if (parsedResult && parsedResult.name === \"?xml\") {\n    parsedResult = parsedResult.children[0] as ParsedResult;\n  }\n\n  return parseParsedResult(parsedResult);\n}\n"],"names":["BaseCumulativeTransformOutputParser","fields?: XMLOutputParserFields","prev: unknown | undefined","next: unknown","compare","generations: ChatGeneration[] | Generation[]","text: string","input: ParsedResult","result: XMLResult","s: string","sax","parsedResult: ParsedResult","elementStack: ParsedResult[]","node: any","text: any","attr: any"],"mappings":"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"}},
    {"offset": {"line": 6812, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/index.ts"],"sourcesContent":["export * from \"./base.js\";\nexport * from \"./bytes.js\";\nexport * from \"./list.js\";\nexport * from \"./string.js\";\nexport * from \"./structured.js\";\nexport * from \"./transform.js\";\nexport * from \"./json.js\";\nexport * from \"./xml.js\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 6879, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/base.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/base.ts"],"sourcesContent":["import { Runnable } from \"../runnables/index.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport type { BaseMessage, ContentBlock } from \"../messages/index.js\";\nimport type { Callbacks } from \"../callbacks/manager.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\n/**\n * Options for formatting instructions.\n */\nexport interface FormatInstructionsOptions {}\n\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport abstract class BaseLLMOutputParser<T = unknown> extends Runnable<\n  string | BaseMessage,\n  T\n> {\n  /**\n   * Parses the result of an LLM call. This method is meant to be\n   * implemented by subclasses to define how the output from the LLM should\n   * be parsed.\n   * @param generations The generations from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  abstract parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T>;\n\n  /**\n   * Parses the result of an LLM call with a given prompt. By default, it\n   * simply calls `parseResult`.\n   * @param generations The generations from an LLM call.\n   * @param _prompt The prompt used in the LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parseResultWithPrompt(\n    generations: Generation[] | ChatGeneration[],\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parseResult(generations, callbacks);\n  }\n\n  protected _baseMessageToString(message: BaseMessage): string {\n    return typeof message.content === \"string\"\n      ? message.content\n      : this._baseMessageContentToString(message.content);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return JSON.stringify(content);\n  }\n\n  /**\n   * Calls the parser with a given input and optional configuration options.\n   * If the input is a string, it creates a generation with the input as\n   * text and calls `parseResult`. If the input is a `BaseMessage`, it\n   * creates a generation with the input as a message and the content of the\n   * input as text, and then calls `parseResult`.\n   * @param input The input to the parser, which can be a string or a `BaseMessage`.\n   * @param options Optional configuration options.\n   * @returns A promise of the parsed output.\n   */\n  async invoke(\n    input: string | BaseMessage,\n    options?: RunnableConfig\n  ): Promise<T> {\n    if (typeof input === \"string\") {\n      return this._callWithConfig(\n        async (input: string, options): Promise<T> =>\n          this.parseResult([{ text: input }], options?.callbacks),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    } else {\n      return this._callWithConfig(\n        async (input: BaseMessage, options): Promise<T> =>\n          this.parseResult(\n            [\n              {\n                message: input,\n                text: this._baseMessageToString(input),\n              },\n            ],\n            options?.callbacks\n          ),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call.\n */\nexport abstract class BaseOutputParser<\n  T = unknown\n> extends BaseLLMOutputParser<T> {\n  parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(generations[0].text, callbacks);\n  }\n\n  /**\n   * Parse the output of an LLM call.\n   *\n   * @param text - LLM output to parse.\n   * @returns Parsed output.\n   */\n  abstract parse(text: string, callbacks?: Callbacks): Promise<T>;\n\n  async parseWithPrompt(\n    text: string,\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(text, callbacks);\n  }\n\n  /**\n   * Return a string describing the format of the output.\n   * @returns Format instructions.\n   * @param options - Options for formatting instructions.\n   * @example\n   * ```json\n   * {\n   *  \"foo\": \"bar\"\n   * }\n   * ```\n   */\n  abstract getFormatInstructions(options?: FormatInstructionsOptions): string;\n\n  /**\n   * Return the string type key uniquely identifying this class of parser\n   */\n  _type(): string {\n    throw new Error(\"_type not implemented\");\n  }\n}\n\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n  llmOutput?: string;\n\n  observation?: string;\n\n  sendToLLM: boolean;\n\n  constructor(\n    message: string,\n    llmOutput?: string,\n    observation?: string,\n    sendToLLM = false\n  ) {\n    super(message);\n    this.llmOutput = llmOutput;\n    this.observation = observation;\n    this.sendToLLM = sendToLLM;\n\n    if (sendToLLM) {\n      if (observation === undefined || llmOutput === undefined) {\n        throw new Error(\n          \"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\"\n        );\n      }\n    }\n\n    addLangChainErrorFields(this, \"OUTPUT_PARSING_FAILURE\");\n  }\n}\n"],"names":["generations: Generation[] | ChatGeneration[]","_prompt: BasePromptValueInterface","callbacks?: Callbacks","message: BaseMessage","content: ContentBlock[]","input: string | BaseMessage","options?: RunnableConfig","input: string","options","input","input: BaseMessage","text: string","message: string","llmOutput?: string","observation?: string"],"mappings":";;;;;;;;;;;;;;;;;;;GAkBA,IAAsB,sBAAtB,cAA+D,8KAAA,CAG7D;;;;;;;;IAsBA,sBACEA,WAAAA,EACAC,OAAAA,EACAC,SAAAA,EACY;QACZ,OAAO,IAAA,CAAK,WAAA,CAAY,aAAa,UAAU;IAChD;IAES,qBAAqBC,OAAAA,EAA8B;QAC3D,OAAO,OAAO,QAAQ,OAAA,KAAY,WAC9B,QAAQ,OAAA,GACR,IAAA,CAAK,2BAAA,CAA4B,QAAQ,OAAA,CAAQ;IACtD;IAES,4BAA4BC,OAAAA,EAAiC;QACrE,OAAO,KAAK,SAAA,CAAU,QAAQ;IAC/B;;;;;;;;;;IAYD,MAAM,OACJC,KAAAA,EACAC,OAAAA,EACY;QACZ,IAAI,OAAO,UAAU,SACnB,CAAA,OAAO,IAAA,CAAK,eAAA,CACV,OAAOC,SAAeC,YACpB,IAAA,CAAK,WAAA,CAAY;gBAAC;oBAAE,MAAMC;gBAAO,CAAC;aAAA,EAAED,WAAS,UAAU,EACzD,OACA;YAAE,GAAG,OAAA;YAAS,SAAS;QAAU,EAClC;aAED,OAAO,IAAA,CAAK,eAAA,CACV,OAAOE,SAAoBF,YACzB,IAAA,CAAK,WAAA,CACH;gBACE;oBACE,SAASC;oBACT,MAAM,IAAA,CAAK,oBAAA,CAAqBA,QAAM;gBACvC,CACF;aAAA,EACDD,WAAS,UACV,EACH,OACA;YAAE,GAAG,OAAA;YAAS,SAAS;QAAU,EAClC;IAEJ;AACF;;;GAKD,IAAsB,mBAAtB,cAEU,oBAAuB;IAC/B,YACER,WAAAA,EACAE,SAAAA,EACY;QACZ,OAAO,IAAA,CAAK,KAAA,CAAM,WAAA,CAAY,EAAA,CAAG,IAAA,EAAM,UAAU;IAClD;IAUD,MAAM,gBACJS,IAAAA,EACAV,OAAAA,EACAC,SAAAA,EACY;QACZ,OAAO,IAAA,CAAK,KAAA,CAAM,MAAM,UAAU;IACnC;;;IAkBD,QAAgB;QACd,MAAM,IAAI,MAAM;IACjB;AACF;;;;;;;;;;;;;;;;;;GAoBD,IAAa,wBAAb,cAA2C,MAAM;IAC/C,UAAA;IAEA,YAAA;IAEA,UAAA;IAEA,YACEU,OAAAA,EACAC,SAAAA,EACAC,WAAAA,EACA,YAAY,KAAA,CACZ;QACA,KAAA,CAAM,QAAQ;QACd,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,SAAA,GAAY;QAEjB,IAAI,WACF;gBAAI,gBAAgB,KAAA,KAAa,cAAc,KAAA,EAC7C,CAAA,MAAM,IAAI,MACR;QAEH;YAGH,2LAAA,EAAwB,IAAA,EAAM,yBAAyB;IACxD;AACF"}},
    {"offset": {"line": 6997, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/transform.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/transform.ts"],"sourcesContent":["import { deepCompareStrict } from \"@cfworker/json-schema\";\nimport { BaseOutputParser } from \"./base.js\";\nimport {\n  type BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n} from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  type Generation,\n  type ChatGeneration,\n  GenerationChunk,\n  ChatGenerationChunk,\n} from \"../outputs.js\";\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport abstract class BaseTransformOutputParser<\n  T = unknown\n> extends BaseOutputParser<T> {\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{ text: chunk }]);\n      } else {\n        yield this.parseResult([\n          {\n            message: chunk,\n            text: this._baseMessageToString(chunk),\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>,\n    options: BaseCallbackConfig\n  ): AsyncGenerator<T> {\n    yield* this._transformStreamWithConfig(\n      inputGenerator,\n      this._transform.bind(this),\n      {\n        ...options,\n        runType: \"parser\",\n      }\n    );\n  }\n}\n\nexport type BaseCumulativeTransformOutputParserInput = { diff?: boolean };\n\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport abstract class BaseCumulativeTransformOutputParser<\n  T = unknown\n> extends BaseTransformOutputParser<T> {\n  protected diff = false;\n\n  constructor(fields?: BaseCumulativeTransformOutputParserInput) {\n    super(fields);\n    this.diff = fields?.diff ?? this.diff;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected abstract _diff(prev: any | undefined, next: any): any;\n\n  abstract parsePartialResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<T | undefined>;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    let prevParsed: T | undefined;\n    let accGen: GenerationChunk | undefined;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen: GenerationChunk;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content,\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content,\n        });\n      } else {\n        chunkGen = new GenerationChunk({ text: chunk });\n      }\n\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n\n      const parsed = await this.parsePartialResult([accGen]);\n      if (\n        parsed !== undefined &&\n        parsed !== null &&\n        !deepCompareStrict(parsed, prevParsed)\n      ) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"names":["inputGenerator: AsyncGenerator<string | BaseMessage>","options: BaseCallbackConfig","fields?: BaseCumulativeTransformOutputParserInput","prevParsed: T | undefined","accGen: GenerationChunk | undefined","chunkGen: GenerationChunk"],"mappings":";;;;;;;;;;;;;;;;;;;;GAmBA,IAAsB,4BAAtB,cAEU,2LAAA,CAAoB;IAC5B,OAAO,WACLA,cAAAA,EACmB;QACnB,WAAW,MAAM,SAAS,eACxB,IAAI,OAAO,UAAU,UACnB,MAAM,IAAA,CAAK,WAAA,CAAY;YAAC;gBAAE,MAAM;YAAO,CAAC;SAAA,CAAC;aAEzC,MAAM,IAAA,CAAK,WAAA,CAAY;YACrB;gBACE,SAAS;gBACT,MAAM,IAAA,CAAK,oBAAA,CAAqB,MAAM;YACvC,CACF;SAAA,CAAC;IAGP;;;;;;;IASD,OAAO,UACLA,cAAAA,EACAC,OAAAA,EACmB;QACnB,OAAO,IAAA,CAAK,0BAAA,CACV,gBACA,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,IAAA,CAAK,EAC1B;YACE,GAAG,OAAA;YACH,SAAS;QACV,EACF;IACF;AACF;;;;;GASD,IAAsB,sCAAtB,cAEU,0BAA6B;IAC3B,OAAO,MAAA;IAEjB,YAAYC,MAAAA,CAAmD;QAC7D,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO,QAAQ,QAAQ,IAAA,CAAK,IAAA;IAClC;IASD,OAAO,WACLF,cAAAA,EACmB;QACnB,IAAIG;QACJ,IAAIC;QACJ,WAAW,MAAM,SAAS,eAAgB;YACxC,IAAI,OAAO,UAAU,YAAY,OAAO,MAAM,OAAA,KAAY,SACxD,CAAA,MAAM,IAAI,MAAM;YAElB,IAAIC;YACJ,QAAI,uLAAA,EAAmB,MAAM,EAAE;gBAC7B,IAAI,OAAO,MAAM,OAAA,KAAY,SAC3B,CAAA,MAAM,IAAI,MAAM;gBAElB,WAAW,IAAI,+KAAA,CAAoB;oBACjC,SAAS;oBACT,MAAM,MAAM,OAAA;gBACb;YACF,OAAA,QAAU,kLAAA,EAAc,MAAM,EAAE;gBAC/B,IAAI,OAAO,MAAM,OAAA,KAAY,SAC3B,CAAA,MAAM,IAAI,MAAM;gBAElB,WAAW,IAAI,+KAAA,CAAoB;oBACjC,aAAS,oLAAA,EAAe,MAAM;oBAC9B,MAAM,MAAM,OAAA;gBACb;YACF,OACC,WAAW,IAAI,2KAAA,CAAgB;gBAAE,MAAM;YAAO;YAGhD,IAAI,WAAW,KAAA,GACb,SAAS;iBAET,SAAS,OAAO,MAAA,CAAO,SAAS;YAGlC,MAAM,SAAS,MAAM,IAAA,CAAK,kBAAA,CAAmB;gBAAC,MAAO;aAAA,CAAC;YACtD,IACE,WAAW,KAAA,KACX,WAAW,QACX,KAAC,+MAAA,EAAkB,QAAQ,WAAW,EACtC;gBACA,IAAI,IAAA,CAAK,IAAA,EACP,MAAM,IAAA,CAAK,KAAA,CAAM,YAAY,OAAO;qBAEpC,MAAM;gBAER,aAAa;YACd;QACF;IACF;IAED,wBAAgC;QAC9B,OAAO;IACR;AACF"}},
    {"offset": {"line": 7097, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/json.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/json.ts"],"sourcesContent":["import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\nimport { parseJsonMarkdown, parsePartialJson } from \"../utils/json.js\";\n\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  /** @internal */\n  override _concatOutputChunks<T>(first: T, second: T): T {\n    if (this.diff) {\n      return super._concatOutputChunks(first, second);\n    }\n    return second;\n  }\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  // This should actually return Partial<T>, but there's no way\n  // to specify emitted chunks as instances separate from the main output type.\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<T | undefined> {\n    return parseJsonMarkdown(generations[0].text);\n  }\n\n  async parse(text: string): Promise<T> {\n    return parseJsonMarkdown(text, JSON.parse);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n\nexport { parsePartialJson, parseJsonMarkdown };\n"],"names":["first: T","second: T","prev: unknown | undefined","next: unknown","generations: ChatGeneration[] | Generation[]","text: string"],"mappings":";;;;;;;;;;;;;;;GAQA,IAAa,mBAAb,cAGU,mNAAA,CAAuC;IAC/C,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,gBAAiB;KAAA,CAAA;IAEnD,kBAAkB,KAAA;qBAGT,oBAAuBA,KAAAA,EAAUC,MAAAA,EAAc;QACtD,IAAI,IAAA,CAAK,IAAA,CACP,CAAA,OAAO,KAAA,CAAM,oBAAoB,OAAO,OAAO;QAEjD,OAAO;IACR;IAES,MACRC,IAAAA,EACAC,IAAAA,EACyB;QACzB,IAAI,CAAC,KACH,CAAA,OAAO,KAAA;QAET,IAAI,CAAC,KACH,CAAA,OAAO;YAAC;gBAAE,IAAI;gBAAW,MAAM;gBAAI,OAAO;YAAM,CAAC;SAAA;QAEnD,WAAO,2MAAA,EAAQ,MAAM,KAAK;IAC3B;IAID,MAAM,mBACJC,WAAAA,EACwB;QACxB,WAAO,mLAAA,EAAkB,WAAA,CAAY,EAAA,CAAG,IAAA,CAAK;IAC9C;IAED,MAAM,MAAMC,IAAAA,EAA0B;QACpC,WAAO,mLAAA,EAAkB,MAAM,KAAK,KAAA,CAAM;IAC3C;IAED,wBAAgC;QAC9B,OAAO;IACR;AACF"}},
    {"offset": {"line": 7152, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/bytes.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/bytes.ts"],"sourcesContent":["import { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nexport class BytesOutputParser extends BaseTransformOutputParser<Uint8Array> {\n  static lc_name() {\n    return \"BytesOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"bytes\"];\n\n  lc_serializable = true;\n\n  protected textEncoder: InstanceType<typeof TextEncoder> = new TextEncoder();\n\n  parse(text: string): Promise<Uint8Array> {\n    return Promise.resolve(this.textEncoder.encode(text));\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"names":["text: string"],"mappings":";;;;;;;;;;GAMA,IAAa,oBAAb,cAAuC,yMAAA,CAAsC;IAC3E,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB;QAAkB;KAAQ,CAAA;IAE5D,kBAAkB,KAAA;IAER,cAAgD,IAAI,cAAA;IAE9D,MAAMA,IAAAA,EAAmC;QACvC,OAAO,QAAQ,OAAA,CAAQ,IAAA,CAAK,WAAA,CAAY,MAAA,CAAO,KAAK,CAAC;IACtD;IAED,wBAAgC;QAC9B,OAAO;IACR;AACF"}},
    {"offset": {"line": 7186, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/list.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/list.ts"],"sourcesContent":["import { BaseMessage } from \"../messages/index.js\";\nimport { OutputParserException } from \"./base.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport abstract class ListOutputParser extends BaseTransformOutputParser<\n  string[]\n> {\n  re?: RegExp;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<string[]> {\n    let buffer = \"\";\n    for await (const input of inputGenerator) {\n      if (typeof input === \"string\") {\n        // add current chunk to buffer\n        buffer += input;\n      } else {\n        // extract message content and add to buffer\n        buffer += input.content;\n      }\n      // get parts in buffer\n      if (!this.re) {\n        const parts = await this.parse(buffer);\n        if (parts.length > 1) {\n          // if there are multiple parts, yield all but the last one\n          for (const part of parts.slice(0, -1)) {\n            yield [part];\n          }\n          // keep the last part in the buffer\n          buffer = parts[parts.length - 1];\n        }\n      } else {\n        // if there is a regex, get all matches\n        const matches = [...buffer.matchAll(this.re)];\n        if (matches.length > 1) {\n          let doneIdx = 0;\n          // if there are multiple matches, yield all but the last one\n          for (const match of matches.slice(0, -1)) {\n            yield [match[1]];\n            doneIdx += (match.index ?? 0) + match[0].length;\n          }\n          // keep the last match in the buffer\n          buffer = buffer.slice(doneIdx);\n        }\n      }\n    }\n\n    // yield the last part\n    for (const part of await this.parse(buffer)) {\n      yield [part];\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport class CommaSeparatedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"CommaSeparatedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses the given text into an array of strings, using a comma as the\n   * separator. If the parsing fails, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each comma.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      return text\n        .trim()\n        .split(\",\")\n        .map((s) => s.trim());\n    } catch {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CommaSeparatedListOutputParser.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n  }\n}\n\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport class CustomListOutputParser extends ListOutputParser {\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  private length: number | undefined;\n\n  private separator: string;\n\n  constructor({ length, separator }: { length?: number; separator?: string }) {\n    super(...arguments);\n    this.length = length;\n    this.separator = separator || \",\";\n  }\n\n  /**\n   * Parses the given text into an array of strings, using the specified\n   * separator. If the parsing fails or the number of items in the list\n   * doesn't match the expected length, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      const items = text\n        .trim()\n        .split(this.separator)\n        .map((s) => s.trim());\n      if (this.length !== undefined && items.length !== this.length) {\n        throw new OutputParserException(\n          `Incorrect number of items. Expected ${this.length}, got ${items.length}.`\n        );\n      }\n      return items;\n    } catch (e) {\n      if (Object.getPrototypeOf(e) === OutputParserException.prototype) {\n        throw e;\n      }\n      throw new OutputParserException(`Could not parse output: ${text}`);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CustomListOutputParser, including the number of items and the\n   * separator.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of ${\n      this.length === undefined ? \"\" : `${this.length} `\n    }items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${\n      this.separator\n    } baz\\`)`;\n  }\n}\n\nexport class NumberedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /\\d+\\.\\s([^\\n]+)/g;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n\nexport class MarkdownListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /^\\s*[-*]\\s([^\\n]+)$/gm;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n"],"names":["inputGenerator: AsyncGenerator<string | BaseMessage>","text: string"],"mappings":"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"}},
    {"offset": {"line": 7362, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/string.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/string.ts"],"sourcesContent":["import { BaseTransformOutputParser } from \"./transform.js\";\nimport { ContentBlock } from \"../messages/index.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nexport class StringOutputParser extends BaseTransformOutputParser<string> {\n  static lc_name() {\n    return \"StrOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"string\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parse(text: string): Promise<string> {\n    return Promise.resolve(text);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  protected _textContentToString(content: ContentBlock.Text): string {\n    return content.text;\n  }\n\n  protected _imageUrlContentToString(\n    _content: ContentBlock.Data.URLContentBlock\n  ): string {\n    throw new Error(\n      `Cannot coerce a multimodal \"image_url\" message part into a string.`\n    );\n  }\n\n  protected _messageContentToString(content: ContentBlock): string {\n    switch (content.type) {\n      case \"text\":\n      case \"text_delta\":\n        if (\"text\" in content) {\n          // Type guard for MessageContentText\n          return this._textContentToString(content as ContentBlock.Text);\n        }\n        break;\n      case \"image_url\":\n        if (\"image_url\" in content) {\n          // Type guard for MessageContentImageUrl\n          return this._imageUrlContentToString(\n            content as ContentBlock.Data.URLContentBlock\n          );\n        }\n        break;\n      default:\n        throw new Error(\n          `Cannot coerce \"${content.type}\" message part into a string.`\n        );\n    }\n    throw new Error(`Invalid content type: ${content.type}`);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return content.reduce(\n      (acc: string, item: ContentBlock) =>\n        acc + this._messageContentToString(item),\n      \"\"\n    );\n  }\n}\n"],"names":["text: string","content: ContentBlock.Text","_content: ContentBlock.Data.URLContentBlock","content: ContentBlock","content: ContentBlock[]","acc: string","item: ContentBlock"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;GAqBA,IAAa,qBAAb,cAAwC,yMAAA,CAAkC;IACxE,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB;QAAkB;KAAS,CAAA;IAE7D,kBAAkB,KAAA;;;;;;;;IAUlB,MAAMA,IAAAA,EAA+B;QACnC,OAAO,QAAQ,OAAA,CAAQ,KAAK;IAC7B;IAED,wBAAgC;QAC9B,OAAO;IACR;IAES,qBAAqBC,OAAAA,EAAoC;QACjE,OAAO,QAAQ,IAAA;IAChB;IAES,yBACRC,QAAAA,EACQ;QACR,MAAM,IAAI,MACR,CAAC,kEAAkE,CAAC;IAEvE;IAES,wBAAwBC,OAAAA,EAA+B;QAC/D,OAAQ,QAAQ,IAAA,EAAhB;YACE,KAAK;YACL,KAAK;gBACH,IAAI,UAAU,QAEZ,CAAA,OAAO,IAAA,CAAK,oBAAA,CAAqB,QAA6B;gBAEhE;YACF,KAAK;gBACH,IAAI,eAAe,QAEjB,CAAA,OAAO,IAAA,CAAK,wBAAA,CACV,QACD;gBAEH;YACF,QACE;gBAAA,MAAM,IAAI,MACR,CAAC,eAAe,EAAE,QAAQ,IAAA,CAAK,6BAA6B,CAAC;QAElE;QACD,MAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,QAAQ,IAAA,EAAM;IACxD;IAES,4BAA4BC,OAAAA,EAAiC;QACrE,OAAO,QAAQ,MAAA,CACb,CAACC,KAAaC,OACZ,MAAM,IAAA,CAAK,uBAAA,CAAwB,KAAK,EAC1C,GACD;IACF;AACF"}},
    {"offset": {"line": 7439, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/structured.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/structured.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport {\n  BaseOutputParser,\n  FormatInstructionsOptions,\n  OutputParserException,\n} from \"./base.js\";\nimport {\n  type InteropZodType,\n  type InferInteropZodOutput,\n  interopParseAsync,\n} from \"../utils/types/zod.js\";\nimport {\n  toJsonSchema,\n  type JsonSchema7Type,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"../utils/json_schema.js\";\n\nexport type JsonMarkdownStructuredOutputParserInput = {\n  interpolationDepth?: number;\n};\n\nexport interface JsonMarkdownFormatInstructionsOptions\n  extends FormatInstructionsOptions {\n  interpolationDepth?: number;\n}\n\nexport class StructuredOutputParser<\n  T extends InteropZodType\n> extends BaseOutputParser<InferInteropZodOutput<T>> {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"structured\"];\n\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n\n  constructor(public schema: T) {\n    super(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this(zodSchema);\n  }\n\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions(): string {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(toJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text: string): Promise<InferInteropZodOutput<T>> {\n    try {\n      const trimmedText = text.trim();\n\n      const json =\n        // first case: if back ticks appear at the start of the text\n        trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n        // second case: if back ticks with `json` appear anywhere in the text\n        trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n        // otherwise, return the trimmed text\n        trimmedText;\n\n      const escapedJson = json\n        .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n          const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n          return `\"${escapedInsideQuotes}\"`;\n        })\n        .replace(/\\n/g, \"\");\n\n      return await interopParseAsync(this.schema, JSON.parse(escapedJson));\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n  }\n}\n\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser<\n  T extends InteropZodType\n> extends StructuredOutputParser<T> {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n\n  getFormatInstructions(\n    options?: JsonMarkdownFormatInstructionsOptions\n  ): string {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(\n      toJsonSchema(this.schema)\n    )\n      .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n      .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n\n  private _schemaToInstruction(\n    schemaInput: JsonSchema7Type,\n    indent = 2\n  ): string {\n    const schema = schemaInput as Extract<\n      JsonSchema7Type,\n      | JsonSchema7ObjectType\n      | JsonSchema7ArrayType\n      | JsonSchema7StringType\n      | JsonSchema7NumberType\n      | JsonSchema7NullableType\n    >;\n\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type: string;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex((type) => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \") as string;\n      } else {\n        type = schema.type;\n      }\n\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        const properties = Object.entries(schema.properties)\n          .map(([key, value]) => {\n            const isOptional = schema.required?.includes(key)\n              ? \"\"\n              : \" (optional)\";\n            return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(\n              value,\n              indent + 2\n            )}${isOptional}`;\n          })\n          .join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(\n          schema.items,\n          indent + 2\n        )}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n\n    if (\"anyOf\" in schema) {\n      return schema.anyOf\n        .map((s) => this._schemaToInstruction(s, indent))\n        .join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n\n    throw new Error(\"unsupported schema type\");\n  }\n\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this<T>(schema);\n  }\n\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this<typeof zodSchema>(zodSchema);\n  }\n}\n\nexport interface AsymmetricStructuredOutputParserFields<\n  T extends InteropZodType\n> {\n  inputSchema: T;\n}\n\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport abstract class AsymmetricStructuredOutputParser<\n  T extends InteropZodType,\n  Y = unknown\n> extends BaseOutputParser<Y> {\n  private structuredInputParser: JsonMarkdownStructuredOutputParser<T>;\n\n  constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>) {\n    super(...arguments);\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(\n      inputSchema\n    );\n  }\n\n  /**\n   * Processes the parsed input into the desired output format. Must be\n   * implemented by subclasses.\n   * @param input The parsed input\n   * @returns The processed output.\n   */\n  abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n\n  async parse(text: string): Promise<Y> {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n\n    return this.outputProcessor(parsedInput);\n  }\n\n  getFormatInstructions(): string {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}\n"],"names":["schema: T","schemas: S","text: string","options?: JsonMarkdownFormatInstructionsOptions","schemaInput: JsonSchema7Type","type: string","type","description"],"mappings":"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"}},
    {"offset": {"line": 7615, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/xml.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/xml.ts"],"sourcesContent":["import {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\n\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\n\nexport interface XMLOutputParserFields\n  extends BaseCumulativeTransformOutputParserInput {\n  /**\n   * Optional list of tags that the output should conform to.\n   * Only used in formatting of the prompt.\n   */\n  tags?: string[];\n}\n\nexport type Content = string | undefined | Array<{ [key: string]: Content }>;\n\nexport type XMLResult = {\n  [key: string]: Content;\n};\n\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser<XMLResult> {\n  tags?: string[];\n\n  constructor(fields?: XMLOutputParserFields) {\n    super(fields);\n\n    this.tags = fields?.tags;\n  }\n\n  static lc_name() {\n    return \"XMLOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<XMLResult | undefined> {\n    return parseXMLMarkdown(generations[0].text);\n  }\n\n  async parse(text: string): Promise<XMLResult> {\n    return parseXMLMarkdown(text);\n  }\n\n  getFormatInstructions(): string {\n    const withTags = !!(this.tags && this.tags.length > 0);\n    return withTags\n      ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n      : XML_FORMAT_INSTRUCTIONS;\n  }\n}\n\nconst strip = (text: string) =>\n  text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\n\ntype ParsedResult = {\n  name: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  attributes: Record<string, any>;\n  children: Array<ParsedResult>;\n  text?: string;\n  isSelfClosing: boolean;\n};\n\nconst parseParsedResult = (input: ParsedResult): XMLResult => {\n  if (Object.keys(input).length === 0) {\n    return {};\n  }\n  const result: XMLResult = {};\n  if (input.children.length > 0) {\n    result[input.name] = input.children.map(parseParsedResult);\n    return result;\n  } else {\n    result[input.name] = input.text ?? undefined;\n    return result;\n  }\n};\n\nexport function parseXMLMarkdown(s: string): XMLResult {\n  const cleanedString = strip(s);\n  const parser = sax.parser(true);\n  let parsedResult: ParsedResult = {} as ParsedResult;\n  const elementStack: ParsedResult[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onopentag = (node: any) => {\n    const element = {\n      name: node.name,\n      attributes: node.attributes,\n      children: [],\n      text: \"\",\n      isSelfClosing: node.isSelfClosing,\n    };\n\n    if (elementStack.length > 0) {\n      const parentElement = elementStack[elementStack.length - 1];\n      parentElement.children.push(element);\n    } else {\n      parsedResult = element as ParsedResult;\n    }\n\n    if (!node.isSelfClosing) {\n      elementStack.push(element);\n    }\n  };\n\n  parser.onclosetag = () => {\n    if (elementStack.length > 0) {\n      const lastElement = elementStack.pop();\n      if (elementStack.length === 0 && lastElement) {\n        parsedResult = lastElement as ParsedResult;\n      }\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.ontext = (text: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.text += text;\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onattribute = (attr: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.attributes[attr.name] = attr.value;\n    }\n  };\n\n  // Try to find XML string within triple backticks.\n  const match = /```(xml)?(.*)```/s.exec(cleanedString);\n  const xmlString = match ? match[2] : cleanedString;\n  parser.write(xmlString).close();\n\n  // Remove the XML declaration if present\n  if (parsedResult && parsedResult.name === \"?xml\") {\n    parsedResult = parsedResult.children[0] as ParsedResult;\n  }\n\n  return parseParsedResult(parsedResult);\n}\n"],"names":["fields?: XMLOutputParserFields","prev: unknown | undefined","next: unknown","generations: ChatGeneration[] | Generation[]","text: string","input: ParsedResult","result: XMLResult","s: string","parsedResult: ParsedResult","elementStack: ParsedResult[]","node: any","text: any","attr: any"],"mappings":"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"}},
    {"offset": {"line": 7743, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/index.ts"],"sourcesContent":["export * from \"./base.js\";\nexport * from \"./bytes.js\";\nexport * from \"./list.js\";\nexport * from \"./string.js\";\nexport * from \"./structured.js\";\nexport * from \"./transform.js\";\nexport * from \"./json.js\";\nexport * from \"./xml.js\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 7798, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/openai_tools/json_output_tools_parsers.ts"],"sourcesContent":["import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport { ChatGeneration, ChatGenerationChunk } from \"../../outputs.js\";\nimport { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { InvalidToolCall, ToolCall } from \"../../messages/tool.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nimport {\n  type InteropZodType,\n  interopSafeParseAsync,\n} from \"../../utils/types/zod.js\";\n\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n};\n\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n} & BaseCumulativeTransformOutputParserInput;\n\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options: { returnId?: boolean; partial: true }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: false }\n): ToolCall;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new OutputParserException(\n        [\n          `Function \"${rawToolCall.function.name}\" arguments:`,\n          ``,\n          rawToolCall.function.arguments,\n          ``,\n          `are not valid JSON.`,\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n\n  const parsedToolCall: ToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\",\n  };\n\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n\n  return parsedToolCall;\n}\n\nexport function convertLangChainToolCallToOpenAI(toolCall: ToolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args),\n    },\n  };\n}\n\nexport function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  errorMsg?: string\n): InvalidToolCall {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\",\n  };\n}\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser<\n  T\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  protected _diff() {\n    throw new Error(\"Not supported.\");\n  }\n\n  async parse(): Promise<T> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(\n    generations: ChatGenerationChunk[] | ChatGeneration[],\n    partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map((toolCall) => {\n        const { id, ...rest } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest,\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(\n        JSON.stringify(message.additional_kwargs.tool_calls)\n      );\n      toolCalls = rawToolCalls.map((rawToolCall: Record<string, unknown>) => {\n        return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall: ParsedToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id,\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\ntype JsonOutputKeyToolsParserParamsBase = {\n  keyName: string;\n  returnSingle?: boolean;\n} & JsonOutputToolsParserParams;\n\ntype JsonOutputKeyToolsParserParamsV3<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: z3.ZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\ntype JsonOutputKeyToolsParserParamsV4<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: z4.$ZodType<T, T> } & JsonOutputKeyToolsParserParamsBase;\n\nexport type JsonOutputKeyToolsParserParamsInterop<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: InteropZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\n// Use Zod 3 for backwards compatibility\nexport type JsonOutputKeyToolsParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = JsonOutputKeyToolsParserParamsV3<T>;\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> extends JsonOutputToolsParser<T> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: JsonOutputKeyToolsParserParamsV3<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsV4<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsInterop<T>);\n\n  constructor(\n    params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>\n  ) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(\n      returnedValues.map((value) => this._validateResult(value))\n    );\n    return toolCallResults;\n  }\n}\n"],"names":["rawToolCall: Record<string, any>","options?: { returnId?: boolean; partial?: boolean }","e: any","parsedToolCall: ToolCall","toolCall: ToolCall","errorMsg?: string","fields?: JsonOutputToolsParserParams","generations: ChatGeneration[]","generations: ChatGenerationChunk[] | ChatGeneration[]","rawToolCall: Record<string, unknown>","backwardsCompatibleToolCall: ParsedToolCall","params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>","result: unknown","result: ParsedToolCall","returnedValues: ParsedToolCall[] | Record<string, any>[]"],"mappings":"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"}},
    {"offset": {"line": 7991, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/output_parsers/openai_tools/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/output_parsers/openai_tools/index.ts"],"sourcesContent":["export * from \"./json_output_tools_parsers.js\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 8013, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/embeddings.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/embeddings.ts"],"sourcesContent":["import { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\n\n/**\n * The parameters required to initialize an instance of the Embeddings\n * class.\n */\nexport type EmbeddingsParams = AsyncCallerParams;\n\nexport interface EmbeddingsInterface<TOutput = number[]> {\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  embedQuery(document: string): Promise<TOutput>;\n}\n\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nexport abstract class Embeddings<TOutput = number[]>\n  implements EmbeddingsInterface<TOutput>\n{\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  constructor(params: EmbeddingsParams) {\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  abstract embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  abstract embedQuery(document: string): Promise<TOutput>;\n}\n"],"names":["params: EmbeddingsParams","AsyncCaller"],"mappings":";;;;;;;;;;GA+BA,IAAsB,aAAtB,MAEA;;;;IAKE,OAAA;IAEA,YAAYA,MAAAA,CAA0B;QACpC,IAAA,CAAK,MAAA,GAAS,IAAIC,2BAAAA,WAAAA,CAAY,UAAU,CAAE;IAC3C;AAkBF"}},
    {"offset": {"line": 8043, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/stores.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/stores.ts"],"sourcesContent":["import { Serializable } from \"./load/serializable.js\";\n\n/**\n * Abstract interface for a key-value store.\n */\nexport abstract class BaseStore<K, V> extends Serializable {\n  /**\n   * Abstract method to get multiple values for a set of keys.\n   * @param {K[]} keys - An array of keys.\n   * @returns {Promise<(V | undefined)[]>} - A Promise that resolves with array of values or undefined if key not found.\n   */\n  abstract mget(keys: K[]): Promise<(V | undefined)[]>;\n\n  /**\n   * Abstract method to set a value for multiple keys.\n   * @param {[K, V][]} keyValuePairs - An array of key-value pairs.\n   * @returns {Promise<void>} - A Promise that resolves when the operation is complete.\n   */\n  abstract mset(keyValuePairs: [K, V][]): Promise<void>;\n\n  /**\n   * Abstract method to delete multiple keys.\n   * @param {K[]} keys - An array of keys to delete.\n   * @returns {Promise<void>} - A Promise that resolves when the operation is complete.\n   */\n  abstract mdelete(keys: K[]): Promise<void>;\n\n  /**\n   * Abstract method to yield keys optionally based on a prefix.\n   * @param {string} prefix - Optional prefix to filter keys.\n   * @returns {AsyncGenerator<K | string>} - An asynchronous generator that yields keys on iteration.\n   */\n  abstract yieldKeys(prefix?: string): AsyncGenerator<K | string>;\n}\n\n/**\n * In-memory implementation of the BaseStore using a dictionary. Used for\n * storing key-value pairs in memory.\n * @example\n * ```typescript\n * const store = new InMemoryStore<BaseMessage>();\n * await store.mset(\n *   Array.from({ length: 5 }).map((_, index) => [\n *     `message:id:${index}`,\n *     index % 2 === 0\n *       ? new AIMessage(\"ai stuff...\")\n *       : new HumanMessage(\"human stuff...\"),\n *   ]),\n * );\n *\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * await store.mdelete(await store.yieldKeys(\"message:id:\").toArray());\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class InMemoryStore<T = any> extends BaseStore<string, T> {\n  lc_namespace = [\"langchain\", \"storage\"];\n\n  protected store: Record<string, T> = {};\n\n  /**\n   * Retrieves the values associated with the given keys from the store.\n   * @param keys Keys to retrieve values for.\n   * @returns Array of values associated with the given keys.\n   */\n  async mget(keys: string[]) {\n    return keys.map((key) => this.store[key]);\n  }\n\n  /**\n   * Sets the values for the given keys in the store.\n   * @param keyValuePairs Array of key-value pairs to set in the store.\n   * @returns Promise that resolves when all key-value pairs have been set.\n   */\n  async mset(keyValuePairs: [string, T][]): Promise<void> {\n    for (const [key, value] of keyValuePairs) {\n      this.store[key] = value;\n    }\n  }\n\n  /**\n   * Deletes the given keys and their associated values from the store.\n   * @param keys Keys to delete from the store.\n   * @returns Promise that resolves when all keys have been deleted.\n   */\n  async mdelete(keys: string[]): Promise<void> {\n    for (const key of keys) {\n      delete this.store[key];\n    }\n  }\n\n  /**\n   * Asynchronous generator that yields keys from the store. If a prefix is\n   * provided, it only yields keys that start with the prefix.\n   * @param prefix Optional prefix to filter keys.\n   * @returns AsyncGenerator that yields keys from the store.\n   */\n  async *yieldKeys(prefix?: string | undefined): AsyncGenerator<string> {\n    const keys = Object.keys(this.store);\n    for (const key of keys) {\n      if (prefix === undefined || key.startsWith(prefix)) {\n        yield key;\n      }\n    }\n  }\n}\n"],"names":["Serializable","keys: string[]","keyValuePairs: [string, T][]","prefix?: string | undefined"],"mappings":";;;;;;;;;;GAKA,IAAsB,YAAtB,cAA8CA,0BAAAA,YAAAA,CAAa;AA4B1D;;;;;;;;;;;;;;;;;;;GAsBD,IAAa,gBAAb,cAA4C,UAAqB;IAC/D,eAAe;QAAC;QAAa,SAAU;KAAA,CAAA;IAE7B,QAA2B,CAAE,EAAA;;;;;IAOvC,MAAM,KAAKC,IAAAA,EAAgB;QACzB,OAAO,KAAK,GAAA,CAAI,CAAC,MAAQ,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK;IAC1C;;;;;IAOD,MAAM,KAAKC,aAAAA,EAA6C;QACtD,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,cACzB,IAAA,CAAK,KAAA,CAAM,IAAA,GAAO;IAErB;;;;;IAOD,MAAM,QAAQD,IAAAA,EAA+B;QAC3C,KAAK,MAAM,OAAO,KAChB,OAAO,IAAA,CAAK,KAAA,CAAM,IAAA;IAErB;;;;;;IAQD,OAAO,UAAUE,MAAAA,EAAqD;QACpE,MAAM,OAAO,OAAO,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM;QACpC,KAAK,MAAM,OAAO,KAChB,IAAI,WAAW,KAAA,KAAa,IAAI,UAAA,CAAW,OAAO,EAChD,MAAM;IAGX;AACF"}},
    {"offset": {"line": 8122, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/retrievers/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/retrievers/index.ts"],"sourcesContent":["import {\n  CallbackManager,\n  CallbackManagerForRetrieverRun,\n  Callbacks,\n  parseCallbackConfigArg,\n} from \"../callbacks/manager.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig, ensureConfig } from \"../runnables/config.js\";\n\n/**\n * Input configuration options for initializing a retriever that extends\n * the `BaseRetriever` class. This interface provides base properties\n * common to all retrievers, allowing customization of callback functions,\n * tagging, metadata, and logging verbosity.\n *\n * Fields:\n * - `callbacks` (optional): An array of callback functions that handle various\n *   events during retrieval, such as logging, error handling, or progress updates.\n *\n * - `tags` (optional): An array of strings used to add contextual tags to\n *   retrieval operations, allowing for easier categorization and tracking.\n *\n * - `metadata` (optional): A record of key-value pairs to store additional\n *   contextual information for retrieval operations, which can be useful\n *   for logging or auditing purposes.\n *\n * - `verbose` (optional): A boolean flag that, if set to `true`, enables\n *   detailed logging and output during the retrieval process. Defaults to `false`.\n */\nexport interface BaseRetrieverInput {\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n  verbose?: boolean;\n}\n\n/**\n * Interface for a base retriever that defines core functionality for\n * retrieving relevant documents from a source based on a query.\n *\n * The `BaseRetrieverInterface` standardizes the `getRelevantDocuments` method,\n * enabling retrieval of documents that match the query criteria.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nexport interface BaseRetrieverInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> extends RunnableInterface<string, DocumentInterface<Metadata>[]> {}\n\n/**\n * Abstract base class for a document retrieval system, designed to\n * process string queries and return the most relevant documents from a source.\n *\n * `BaseRetriever` provides common properties and methods for derived retrievers,\n * such as callbacks, tagging, and verbose logging. Custom retrieval systems\n * should extend this class and implement `_getRelevantDocuments` to define\n * the specific retrieval logic.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nexport abstract class BaseRetriever<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Metadata extends Record<string, any> = Record<string, any>\n  >\n  extends Runnable<string, DocumentInterface<Metadata>[]>\n  implements BaseRetrieverInterface\n{\n  /**\n   * Optional callbacks to handle various events in the retrieval process.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Tags to label or categorize the retrieval operation.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata to provide additional context or information about the retrieval\n   * operation.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * If set to `true`, enables verbose logging for the retrieval process.\n   */\n  verbose?: boolean;\n\n  /**\n   * Constructs a new `BaseRetriever` instance with optional configuration fields.\n   *\n   * @param fields - Optional input configuration that can include `callbacks`,\n   *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.\n   */\n  constructor(fields?: BaseRetrieverInput) {\n    super(fields);\n    this.callbacks = fields?.callbacks;\n    this.tags = fields?.tags ?? [];\n    this.metadata = fields?.metadata ?? {};\n    this.verbose = fields?.verbose ?? false;\n  }\n\n  /**\n   * TODO: This should be an abstract method, but we'd like to avoid breaking\n   * changes to people currently using subclassed custom retrievers.\n   * Change it on next major release.\n   */\n  /**\n   * Placeholder method for retrieving relevant documents based on a query.\n   *\n   * This method is intended to be implemented by subclasses and will be\n   * converted to an abstract method in the next major release. Currently, it\n   * throws an error if not implemented, ensuring that custom retrievers define\n   * the specific retrieval logic.\n   *\n   * @param _query - The query string used to search for relevant documents.\n   * @param _callbacks - (optional) Callback manager for managing callbacks\n   *                     during retrieval.\n   * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.\n   * @throws {Error} Throws an error indicating the method is not implemented.\n   */\n  _getRelevantDocuments(\n    _query: string,\n    _callbacks?: CallbackManagerForRetrieverRun\n  ): Promise<DocumentInterface<Metadata>[]> {\n    throw new Error(\"Not implemented!\");\n  }\n\n  /**\n   * Executes a retrieval operation.\n   *\n   * @param input - The query string used to search for relevant documents.\n   * @param options - (optional) Configuration options for the retrieval run,\n   *                  which may include callbacks, tags, and metadata.\n   * @returns A promise that resolves to an array of `DocumentInterface` instances\n   *          representing the most relevant documents to the query.\n   */\n  async invoke(\n    input: string,\n    options?: RunnableConfig\n  ): Promise<DocumentInterface<Metadata>[]> {\n    const parsedConfig = ensureConfig(parseCallbackConfigArg(options));\n    const callbackManager_ = await CallbackManager.configure(\n      parsedConfig.callbacks,\n      this.callbacks,\n      parsedConfig.tags,\n      this.tags,\n      parsedConfig.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleRetrieverStart(\n      this.toJSON(),\n      input,\n      parsedConfig.runId,\n      undefined,\n      undefined,\n      undefined,\n      parsedConfig.runName\n    );\n    try {\n      const results = await this._getRelevantDocuments(input, runManager);\n      await runManager?.handleRetrieverEnd(results);\n      return results;\n    } catch (error) {\n      await runManager?.handleRetrieverError(error);\n      throw error;\n    }\n  }\n}\n"],"names":["Runnable","fields?: BaseRetrieverInput","_query: string","_callbacks?: CallbackManagerForRetrieverRun","input: string","options?: RunnableConfig","ensureConfig","parseCallbackConfigArg","CallbackManager"],"mappings":";;;;;;;;;;;;;;;;;;;;GAgEA,IAAsB,gBAAtB,cAIUA,aAAAA,QAAAA,CAEV;;;IAIE,UAAA;;;IAKA,KAAA;;;;IAMA,SAAA;;;IAKA,QAAA;;;;;;IAQA,YAAYC,MAAAA,CAA6B;QACvC,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,SAAA,GAAY,QAAQ;QACzB,IAAA,CAAK,IAAA,GAAO,QAAQ,QAAQ,CAAE,CAAA;QAC9B,IAAA,CAAK,QAAA,GAAW,QAAQ,YAAY,CAAE;QACtC,IAAA,CAAK,OAAA,GAAU,QAAQ,WAAW;IACnC;;;;;;;;;;;;;;;;;;IAqBD,sBACEC,MAAAA,EACAC,UAAAA,EACwC;QACxC,MAAM,IAAI,MAAM;IACjB;;;;;;;;;IAWD,MAAM,OACJC,KAAAA,EACAC,OAAAA,EACwC;QACxC,MAAM,eAAeC,eAAAA,YAAAA,CAAaC,0BAAAA,sBAAAA,CAAuB,QAAQ,CAAC;QAClE,MAAM,mBAAmB,MAAMC,0BAAAA,eAAAA,CAAgB,SAAA,CAC7C,aAAa,SAAA,EACb,IAAA,CAAK,SAAA,EACL,aAAa,IAAA,EACb,IAAA,CAAK,IAAA,EACL,aAAa,QAAA,EACb,IAAA,CAAK,QAAA,EACL;YAAE,SAAS,IAAA,CAAK,OAAA;QAAS,EAC1B;QACD,MAAM,aAAa,MAAM,kBAAkB,qBACzC,IAAA,CAAK,MAAA,EAAQ,EACb,OACA,aAAa,KAAA,EACb,KAAA,GACA,KAAA,GACA,KAAA,GACA,aAAa,OAAA,CACd;QACD,IAAI;YACF,MAAM,UAAU,MAAM,IAAA,CAAK,qBAAA,CAAsB,OAAO,WAAW;YACnE,MAAM,YAAY,mBAAmB,QAAQ;YAC7C,OAAO;QACR,EAAA,OAAQ,OAAO;YACd,MAAM,YAAY,qBAAqB,MAAM;YAC7C,MAAM;QACP;IACF;AACF"}},
    {"offset": {"line": 8223, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/documents/document.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/documents/document.ts"],"sourcesContent":["export interface DocumentInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> {\n  pageContent: string;\n\n  metadata?: Metadata;\n\n  /**\n   * An optional identifier for the document.\n   *\n   * Ideally this should be unique across the document collection and formatted\n   * as a UUID, but this will not be enforced.\n   */\n  id?: string;\n}\n\nexport interface DocumentInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> {\n  pageContent: string;\n\n  metadata: Metadata;\n\n  /**\n   * An optional identifier for the document.\n   *\n   * Ideally this should be unique across the document collection and formatted\n   * as a UUID, but this will not be enforced.\n   */\n  id?: string;\n}\n\n/**\n * Interface for interacting with a document.\n */\nexport class Document<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> implements DocumentInput, DocumentInterface\n{\n  pageContent: string;\n\n  metadata: Metadata;\n\n  // The ID field is optional at the moment.\n  // It will likely become required in a future major release after\n  // it has been adopted by enough vectorstore implementations.\n  /**\n   * An optional identifier for the document.\n   *\n   * Ideally this should be unique across the document collection and formatted\n   * as a UUID, but this will not be enforced.\n   */\n  id?: string;\n\n  constructor(fields: DocumentInput<Metadata>) {\n    this.pageContent =\n      fields.pageContent !== undefined ? fields.pageContent.toString() : \"\";\n    this.metadata = fields.metadata ?? ({} as Metadata);\n    this.id = fields.id;\n  }\n}\n"],"names":["fields: DocumentInput<Metadata>"],"mappings":";;;GAqCA,IAAa,WAAb,MAIA;IACE,YAAA;IAEA,SAAA;;;;;;IAWA,GAAA;IAEA,YAAYA,MAAAA,CAAiC;QAC3C,IAAA,CAAK,WAAA,GACH,OAAO,WAAA,KAAgB,KAAA,IAAY,OAAO,WAAA,CAAY,QAAA,EAAU,GAAG;QACrE,IAAA,CAAK,QAAA,GAAW,OAAO,QAAA,IAAa,CAAE;QACtC,IAAA,CAAK,EAAA,GAAK,OAAO,EAAA;IAClB;AACF"}},
    {"offset": {"line": 8246, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/documents/transformers.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/documents/transformers.ts"],"sourcesContent":["import { Runnable } from \"../runnables/base.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport type { DocumentInterface } from \"./document.js\";\n\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nexport abstract class BaseDocumentTransformer<\n  RunInput extends DocumentInterface[] = DocumentInterface[],\n  RunOutput extends DocumentInterface[] = DocumentInterface[]\n> extends Runnable<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"documents\", \"transformers\"];\n\n  /**\n   * Transform a list of documents.\n   * @param documents A sequence of documents to be transformed.\n   * @returns A list of transformed documents.\n   */\n  abstract transformDocuments(documents: RunInput): Promise<RunOutput>;\n\n  /**\n   * Method to invoke the document transformation. This method calls the\n   * transformDocuments method with the provided input.\n   * @param input The input documents to be transformed.\n   * @param _options Optional configuration object to customize the behavior of callbacks.\n   * @returns A Promise that resolves to the transformed documents.\n   */\n  invoke(input: RunInput, _options?: BaseCallbackConfig): Promise<RunOutput> {\n    return this.transformDocuments(input);\n  }\n}\n\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nexport abstract class MappingDocumentTransformer extends BaseDocumentTransformer {\n  async transformDocuments(\n    documents: DocumentInterface[]\n  ): Promise<DocumentInterface[]> {\n    const newDocuments = [];\n    for (const document of documents) {\n      const transformedDocument = await this._transformDocument(document);\n      newDocuments.push(transformedDocument);\n    }\n    return newDocuments;\n  }\n\n  abstract _transformDocument(\n    document: DocumentInterface\n  ): Promise<DocumentInterface>;\n}\n"],"names":["Runnable","input: RunInput","_options?: BaseCallbackConfig","documents: DocumentInterface[]"],"mappings":";;;;;;;;;;;GAcA,IAAsB,0BAAtB,cAGUA,aAAAA,QAAAA,CAA8B;IACtC,eAAe;QAAC;QAAkB;QAAa;KAAe,CAAA;;;;;;;IAgB9D,OAAOC,KAAAA,EAAiBC,QAAAA,EAAmD;QACzE,OAAO,IAAA,CAAK,kBAAA,CAAmB,MAAM;IACtC;AACF;;;;GAMD,IAAsB,6BAAtB,cAAyD,wBAAwB;IAC/E,MAAM,mBACJC,SAAAA,EAC8B;QAC9B,MAAM,eAAe,CAAE,CAAA;QACvB,KAAK,MAAM,YAAY,UAAW;YAChC,MAAM,sBAAsB,MAAM,IAAA,CAAK,kBAAA,CAAmB,SAAS;YACnE,aAAa,IAAA,CAAK,oBAAoB;QACvC;QACD,OAAO;IACR;AAKF"}},
    {"offset": {"line": 8292, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/documents/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/documents/index.ts"],"sourcesContent":["export * from \"./document.js\";\nexport * from \"./transformers.js\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 8316, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/outputs.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/outputs.ts"],"sourcesContent":["import { type BaseMessage, type BaseMessageChunk } from \"./messages/base.js\";\n\nexport const RUN_KEY = \"__run\";\n\n/**\n * Output of a single generation.\n */\nexport interface Generation {\n  /**\n   * Generated text output\n   */\n  text: string;\n  /**\n   * Raw generation info response from the provider.\n   * May include things like reason for finishing (e.g. in {@link OpenAI})\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  generationInfo?: Record<string, any>;\n}\n\nexport type GenerationChunkFields = {\n  text: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  generationInfo?: Record<string, any>;\n};\n\n/**\n * Chunk of a single generation. Used for streaming.\n */\nexport class GenerationChunk implements Generation {\n  public text: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public generationInfo?: Record<string, any>;\n\n  constructor(fields: GenerationChunkFields) {\n    this.text = fields.text;\n    this.generationInfo = fields.generationInfo;\n  }\n\n  concat(chunk: GenerationChunk): GenerationChunk {\n    return new GenerationChunk({\n      text: this.text + chunk.text,\n      generationInfo: {\n        ...this.generationInfo,\n        ...chunk.generationInfo,\n      },\n    });\n  }\n}\n\n/**\n * Contains all relevant information returned by an LLM.\n */\nexport type LLMResult = {\n  /**\n   * List of the things generated. Each input could have multiple {@link Generation | generations}, hence this is a list of lists.\n   */\n  generations: Generation[][];\n  /**\n   * Dictionary of arbitrary LLM-provider specific output.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  llmOutput?: Record<string, any>;\n  /**\n   * Dictionary of run metadata\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [RUN_KEY]?: Record<string, any>;\n};\n\nexport interface ChatGeneration extends Generation {\n  message: BaseMessage;\n}\n\nexport type ChatGenerationChunkFields = GenerationChunkFields & {\n  message: BaseMessageChunk;\n};\n\nexport class ChatGenerationChunk\n  extends GenerationChunk\n  implements ChatGeneration\n{\n  public message: BaseMessageChunk;\n\n  constructor(fields: ChatGenerationChunkFields) {\n    super(fields);\n    this.message = fields.message;\n  }\n\n  concat(chunk: ChatGenerationChunk) {\n    return new ChatGenerationChunk({\n      text: this.text + chunk.text,\n      generationInfo: {\n        ...this.generationInfo,\n        ...chunk.generationInfo,\n      },\n      message: this.message.concat(chunk.message),\n    });\n  }\n}\n\nexport interface ChatResult {\n  generations: ChatGeneration[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  llmOutput?: Record<string, any>;\n}\n"],"names":["fields: GenerationChunkFields","chunk: GenerationChunk","fields: ChatGenerationChunkFields","chunk: ChatGenerationChunk"],"mappings":";;;;;;;;;;;;;;;;;;;AAEA,MAAa,UAAU;;;GA2BvB,IAAa,kBAAb,MAAa,gBAAsC;IAC1C,KAAA;IAGA,eAAA;IAEP,YAAYA,MAAAA,CAA+B;QACzC,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;QACnB,IAAA,CAAK,cAAA,GAAiB,OAAO,cAAA;IAC9B;IAED,OAAOC,KAAAA,EAAyC;QAC9C,OAAO,IAAI,gBAAgB;YACzB,MAAM,IAAA,CAAK,IAAA,GAAO,MAAM,IAAA;YACxB,gBAAgB;gBACd,GAAG,IAAA,CAAK,cAAA;gBACR,GAAG,MAAM,cAAA;YACV;QACF;IACF;AACF;AA8BD,IAAa,sBAAb,MAAa,4BACH,gBAEV;IACS,QAAA;IAEP,YAAYC,MAAAA,CAAmC;QAC7C,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,OAAA,GAAU,OAAO,OAAA;IACvB;IAED,OAAOC,KAAAA,EAA4B;QACjC,OAAO,IAAI,oBAAoB;YAC7B,MAAM,IAAA,CAAK,IAAA,GAAO,MAAM,IAAA;YACxB,gBAAgB;gBACd,GAAG,IAAA,CAAK,cAAA;gBACR,GAAG,MAAM,cAAA;YACV;YACD,SAAS,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,MAAM,OAAA,CAAQ;QAC5C;IACF;AACF"}},
    {"offset": {"line": 8378, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/prompt_values.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/prompt_values.ts"],"sourcesContent":["import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage } from \"./messages/base.js\";\nimport { HumanMessage } from \"./messages/human.js\";\nimport { getBufferString } from \"./messages/utils.js\";\n\nexport interface BasePromptValueInterface extends Serializable {\n  toString(): string;\n\n  toChatMessages(): BaseMessage[];\n}\n\nexport interface StringPromptValueInterface extends BasePromptValueInterface {\n  value: string;\n}\n\nexport interface ChatPromptValueInterface extends BasePromptValueInterface {\n  messages: BaseMessage[];\n}\n\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nexport abstract class BasePromptValue\n  extends Serializable\n  implements BasePromptValueInterface\n{\n  abstract toString(): string;\n\n  abstract toChatMessages(): BaseMessage[];\n}\n\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nexport class StringPromptValue\n  extends BasePromptValue\n  implements StringPromptValueInterface\n{\n  static lc_name(): string {\n    return \"StringPromptValue\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  value: string;\n\n  constructor(value: string) {\n    super({ value });\n    this.value = value;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  toChatMessages() {\n    return [new HumanMessage(this.value)];\n  }\n}\n\n/**\n * Interface for the fields of a ChatPromptValue.\n */\nexport interface ChatPromptValueFields {\n  messages: BaseMessage[];\n}\n\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nexport class ChatPromptValue\n  extends BasePromptValue\n  implements ChatPromptValueInterface\n{\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ChatPromptValue\";\n  }\n\n  messages: BaseMessage[];\n\n  constructor(messages: BaseMessage[]);\n\n  constructor(fields: ChatPromptValueFields);\n\n  constructor(fields: BaseMessage[] | ChatPromptValueFields) {\n    if (Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { messages: fields };\n    }\n\n    super(fields);\n    this.messages = fields.messages;\n  }\n\n  toString() {\n    return getBufferString(this.messages);\n  }\n\n  toChatMessages() {\n    return this.messages;\n  }\n}\n\nexport type ImageContent = {\n  /** Specifies the detail level of the image. */\n  detail?: \"auto\" | \"low\" | \"high\";\n\n  /** Either a URL of the image or the base64 encoded image data. */\n  url: string;\n};\n\nexport interface ImagePromptValueFields {\n  imageUrl: ImageContent;\n}\n\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nexport class ImagePromptValue extends BasePromptValue {\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ImagePromptValue\";\n  }\n\n  imageUrl: ImageContent;\n\n  /** @ignore */\n  value: string;\n\n  constructor(fields: ImagePromptValueFields);\n\n  constructor(fields: ImageContent);\n\n  constructor(fields: ImageContent | ImagePromptValueFields) {\n    if (!(\"imageUrl\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { imageUrl: fields };\n    }\n\n    super(fields);\n    this.imageUrl = fields.imageUrl;\n  }\n\n  toString() {\n    return this.imageUrl.url;\n  }\n\n  toChatMessages() {\n    return [\n      new HumanMessage({\n        content: [\n          {\n            type: \"image_url\",\n            image_url: {\n              detail: this.imageUrl.detail,\n              url: this.imageUrl.url,\n            },\n          },\n        ],\n      }),\n    ];\n  }\n}\n"],"names":["value: string","fields: BaseMessage[] | ChatPromptValueFields","fields: ImageContent | ImagePromptValueFields"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsBA,IAAsB,kBAAtB,cACU,qLAAA,CAEV;AAIC;;;;GAMD,IAAa,oBAAb,cACU,gBAEV;IACE,OAAO,UAAkB;QACvB,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,eAAgB;KAAA,CAAA;IAElD,kBAAkB,KAAA;IAElB,MAAA;IAEA,YAAYA,KAAAA,CAAe;QACzB,KAAA,CAAM;YAAE;QAAO,EAAC;QAChB,IAAA,CAAK,KAAA,GAAQ;IACd;IAED,WAAW;QACT,OAAO,IAAA,CAAK,KAAA;IACb;IAED,iBAAiB;QACf,OAAO;YAAC,IAAI,kLAAA,CAAa,IAAA,CAAK,KAAA,CAAO;SAAA;IACtC;AACF;;;;GAaD,IAAa,kBAAb,cACU,gBAEV;IACE,eAAe;QAAC;QAAkB,eAAgB;KAAA,CAAA;IAElD,kBAAkB,KAAA;IAElB,OAAO,UAAU;QACf,OAAO;IACR;IAED,SAAA;IAMA,YAAYC,MAAAA,CAA+C;QACzD,IAAI,MAAM,OAAA,CAAQ,OAAO,EAEvB,SAAS;YAAE,UAAU;QAAQ;QAG/B,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,QAAA,GAAW,OAAO,QAAA;IACxB;IAED,WAAW;QACT,WAAO,qLAAA,EAAgB,IAAA,CAAK,QAAA,CAAS;IACtC;IAED,iBAAiB;QACf,OAAO,IAAA,CAAK,QAAA;IACb;AACF;;;;GAkBD,IAAa,mBAAb,cAAsC,gBAAgB;IACpD,eAAe;QAAC;QAAkB,eAAgB;KAAA,CAAA;IAElD,kBAAkB,KAAA;IAElB,OAAO,UAAU;QACf,OAAO;IACR;IAED,SAAA;mBAGA,MAAA;IAMA,YAAYC,MAAAA,CAA+C;QACzD,IAAI,CAAA,CAAE,cAAc,MAAA,GAElB,SAAS;YAAE,UAAU;QAAQ;QAG/B,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,QAAA,GAAW,OAAO,QAAA;IACxB;IAED,WAAW;QACT,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA;IACtB;IAED,iBAAiB;QACf,OAAO;YACL,IAAI,kLAAA,CAAa;gBACf,SAAS;oBACP;wBACE,MAAM;wBACN,WAAW;4BACT,QAAQ,IAAA,CAAK,QAAA,CAAS,MAAA;4BACtB,KAAK,IAAA,CAAK,QAAA,CAAS,GAAA;wBACpB;oBACF,CACF;iBAAA;YACF,EACF;SAAA;IACF;AACF"}},
    {"offset": {"line": 8511, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/embeddings.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/embeddings.ts"],"sourcesContent":["import { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\n\n/**\n * The parameters required to initialize an instance of the Embeddings\n * class.\n */\nexport type EmbeddingsParams = AsyncCallerParams;\n\nexport interface EmbeddingsInterface<TOutput = number[]> {\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  embedQuery(document: string): Promise<TOutput>;\n}\n\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nexport abstract class Embeddings<TOutput = number[]>\n  implements EmbeddingsInterface<TOutput>\n{\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  constructor(params: EmbeddingsParams) {\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  abstract embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  abstract embedQuery(document: string): Promise<TOutput>;\n}\n"],"names":["params: EmbeddingsParams"],"mappings":";;;;;;;;;;;;;;;;;;GA+BA,IAAsB,aAAtB,MAEA;;;;IAKE,OAAA;IAEA,YAAYA,MAAAA,CAA0B;QACpC,IAAA,CAAK,MAAA,GAAS,IAAI,qLAAA,CAAY,UAAU,CAAE;IAC3C;AAkBF"}}]
}