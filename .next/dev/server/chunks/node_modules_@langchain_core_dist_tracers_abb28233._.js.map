{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/base.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/base.ts"],"sourcesContent":["import { KVMap, BaseRun } from \"langsmith/schemas\";\nimport { RunTree, convertToDottedOrderFormat } from \"langsmith/run_trees\";\n\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { LLMResult } from \"../outputs.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"../callbacks/base.js\";\nimport type { Document } from \"../documents/document.js\";\nimport { getRuntimeEnvironment } from \"../utils/env.js\";\n\nexport type RunType = string;\n\n// TODO: Remove this type and just use the base LangSmith Run type.\nexport interface Run extends BaseRun {\n  // some optional fields are always present here\n  id: string;\n  start_time: number;\n  end_time?: number;\n  execution_order: number;\n  // some additional fields that don't exist in sdk runs\n  child_runs: this[];\n  child_execution_order: number;\n  events: Array<{\n    name: string;\n    time: string;\n    kwargs?: Record<string, unknown>;\n  }>;\n  trace_id?: string;\n  dotted_order?: string;\n  /** @internal */\n  _serialized_start_time?: string;\n}\n\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree?: RunTree): Run | undefined => {\n  if (!runTree) {\n    return undefined;\n  }\n  // Important that we return the raw run tree object since the reference\n  // is mutated in other places.\n  // TODO: Remove places where this is being done.\n\n  runTree.events = runTree.events ?? [];\n  runTree.child_runs = runTree.child_runs ?? [];\n  // TODO: Remove this cast and just use the LangSmith RunTree type.\n  return runTree as unknown as Run;\n};\n\nfunction convertRunToRunTree(run?: Run, parentRun?: Run): RunTree | undefined {\n  if (!run) {\n    return undefined;\n  }\n  return new RunTree({\n    ...run,\n    start_time: run._serialized_start_time ?? run.start_time,\n    parent_run: convertRunToRunTree(parentRun),\n    child_runs: run.child_runs\n      .map((r) => convertRunToRunTree(r))\n      .filter((r): r is RunTree => r !== undefined),\n    extra: {\n      ...run.extra,\n      runtime: getRuntimeEnvironment(),\n    },\n    tracingEnabled: false,\n  });\n}\n\nexport interface AgentRun extends Run {\n  actions: AgentAction[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value: any, defaultKey: string) {\n  return value && !Array.isArray(value) && typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport function isBaseTracer(x: BaseCallbackHandler): x is BaseTracer {\n  return typeof (x as BaseTracer)._addRunToRunMap === \"function\";\n}\n\nexport abstract class BaseTracer extends BaseCallbackHandler {\n  /** @deprecated Use `runTreeMap` instead. */\n  protected runMap: Map<string, Run> = new Map();\n\n  protected runTreeMap: Map<string, RunTree> = new Map();\n\n  protected usesRunTreeMap = false;\n\n  constructor(_fields?: BaseCallbackHandlerInput) {\n    super(...arguments);\n  }\n\n  copy(): this {\n    return this;\n  }\n\n  protected getRunById(runId?: string): Run | undefined {\n    if (runId === undefined) {\n      return undefined;\n    }\n    return this.usesRunTreeMap\n      ? convertRunTreeToRun(this.runTreeMap.get(runId))\n      : this.runMap.get(runId);\n  }\n\n  protected stringifyError(error: unknown) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (error instanceof Error) {\n      return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n    }\n\n    if (typeof error === \"string\") {\n      return error;\n    }\n\n    return `${error}`;\n  }\n\n  protected abstract persistRun(run: Run): Promise<void>;\n\n  protected _addChildRun(parentRun: Run, childRun: Run) {\n    parentRun.child_runs.push(childRun);\n  }\n\n  _addRunToRunMap(run: Run) {\n    const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } =\n      convertToDottedOrderFormat(\n        new Date(run.start_time).getTime(),\n        run.id,\n        run.execution_order\n      );\n    const storedRun = { ...run };\n    const parentRun = this.getRunById(storedRun.parent_run_id);\n    if (storedRun.parent_run_id !== undefined) {\n      if (parentRun) {\n        this._addChildRun(parentRun, storedRun);\n        parentRun.child_execution_order = Math.max(\n          parentRun.child_execution_order,\n          storedRun.child_execution_order\n        );\n        storedRun.trace_id = parentRun.trace_id;\n        if (parentRun.dotted_order !== undefined) {\n          storedRun.dotted_order = [\n            parentRun.dotted_order,\n            currentDottedOrder,\n          ].join(\".\");\n          storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        } else {\n          // This can happen naturally for callbacks added within a run\n          // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n        }\n      } else {\n        // This can happen naturally for callbacks added within a run\n        // console.debug(\n        //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n        // );\n      }\n    } else {\n      storedRun.trace_id = storedRun.id;\n      storedRun.dotted_order = currentDottedOrder;\n      storedRun._serialized_start_time = microsecondPrecisionDatestring;\n    }\n    if (this.usesRunTreeMap) {\n      const runTree = convertRunToRunTree(storedRun, parentRun);\n      if (runTree !== undefined) {\n        this.runTreeMap.set(storedRun.id, runTree);\n      }\n    } else {\n      this.runMap.set(storedRun.id, storedRun);\n    }\n    return storedRun;\n  }\n\n  protected async _endTrace(run: Run): Promise<void> {\n    const parentRun =\n      run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(\n        parentRun.child_execution_order,\n        run.child_execution_order\n      );\n    } else {\n      await this.persistRun(run);\n    }\n    await this.onRunUpdate?.(run);\n    if (this.usesRunTreeMap) {\n      this.runTreeMap.delete(run.id);\n    } else {\n      this.runMap.delete(run.id);\n    }\n  }\n\n  protected _getExecutionOrder(parentRunId: string | undefined): number {\n    const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n\n    return parentRun.child_execution_order + 1;\n  }\n\n  /**\n   * Create and add a run to the run map for LLM start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { prompts },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForLLMStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chat model start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { messages },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChatModelStart(\n        llm,\n        messages,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleLLMError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chain start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType ?? \"chain\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChainStart(\n        chain,\n        inputs,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        runType,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onChainStart?.(run);\n    return run;\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = _coerceToDict(outputs, \"output\");\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleChainError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for tool start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { input },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForToolStart(\n        tool,\n        input,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onToolStart?.(run);\n    return run;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { output };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleToolError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleAgentAction(action: AgentAction, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    const agentRun = run as AgentRun;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentAction?.(run as AgentRun);\n  }\n\n  async handleAgentEnd(action: AgentFinish, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentEnd?.(run);\n  }\n\n  /**\n   * Create and add a run to the run map for retriever start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { query },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForRetrieverStart(\n        retriever,\n        query,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onRetrieverStart?.(run);\n    return run;\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, unknown>>[],\n    runId: string\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { documents };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleRetrieverError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleText(text: string, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: new Date().toISOString(),\n      kwargs: { text },\n    });\n    await this.onText?.(run);\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\n        `Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`\n      );\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: new Date().toISOString(),\n      kwargs: { token, idx, chunk: fields?.chunk },\n    });\n    await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n    return run;\n  }\n\n  // custom event handlers\n\n  onRunCreate?(run: Run): void | Promise<void>;\n\n  onRunUpdate?(run: Run): void | Promise<void>;\n\n  onLLMStart?(run: Run): void | Promise<void>;\n\n  onLLMEnd?(run: Run): void | Promise<void>;\n\n  onLLMError?(run: Run): void | Promise<void>;\n\n  onChainStart?(run: Run): void | Promise<void>;\n\n  onChainEnd?(run: Run): void | Promise<void>;\n\n  onChainError?(run: Run): void | Promise<void>;\n\n  onToolStart?(run: Run): void | Promise<void>;\n\n  onToolEnd?(run: Run): void | Promise<void>;\n\n  onToolError?(run: Run): void | Promise<void>;\n\n  onAgentAction?(run: Run): void | Promise<void>;\n\n  onAgentEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverStart?(run: Run): void | Promise<void>;\n\n  onRetrieverEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverError?(run: Run): void | Promise<void>;\n\n  onText?(run: Run): void | Promise<void>;\n\n  onLLMNewToken?(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): void | Promise<void>;\n}\n"],"names":["runTree?: RunTree","run?: Run","parentRun?: Run","RunTree","getRuntimeEnvironment","value: any","defaultKey: string","x: BaseCallbackHandler","BaseCallbackHandler","_fields?: BaseCallbackHandlerInput","runId?: string","error: unknown","parentRun: Run","childRun: Run","run: Run","parentRunId: string | undefined","llm: Serialized","prompts: string[]","runId: string","parentRunId?: string","extraParams?: KVMap","tags?: string[]","metadata?: KVMap","name?: string","messages: BaseMessage[][]","output: LLMResult","_parentRunId?: string","_tags?: string[]","extraParams?: Record<string, unknown>","chain: Serialized","inputs: ChainValues","runType?: string","outputs: ChainValues","kwargs?: { inputs?: Record<string, unknown> }","tool: Serialized","input: string","output: any","action: AgentAction","action: AgentFinish","retriever: Serialized","query: string","documents: Document<Record<string, unknown>>[]","text: string","token: string","idx: NewTokenIndices","fields?: HandleLLMNewTokenCallbackFields"],"mappings":"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"}},
    {"offset": {"line": 490, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/console.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/console.ts"],"sourcesContent":["import type { CSPair } from \"ansi-styles\";\nimport styles from \"ansi-styles\";\nimport { BaseTracer, type AgentRun, type Run } from \"./base.js\";\n\nfunction wrap(style: CSPair, text: string) {\n  return `${style.open}${text}${style.close}`;\n}\n\nfunction tryJsonStringify(obj: unknown, fallback: string) {\n  try {\n    return JSON.stringify(obj, null, 2);\n  } catch {\n    return fallback;\n  }\n}\n\nfunction formatKVMapItem(value: unknown) {\n  if (typeof value === \"string\") {\n    return value.trim();\n  }\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  return tryJsonStringify(value, value.toString());\n}\n\nfunction elapsed(run: Run): string {\n  if (!run.end_time) return \"\";\n  const elapsed = run.end_time - run.start_time;\n  if (elapsed < 1000) {\n    return `${elapsed}ms`;\n  }\n  return `${(elapsed / 1000).toFixed(2)}s`;\n}\n\nconst { color } = styles;\n\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nexport class ConsoleCallbackHandler extends BaseTracer {\n  name = \"console_callback_handler\" as const;\n\n  /**\n   * Method used to persist the run. In this case, it simply returns a\n   * resolved promise as there's no persistence logic.\n   * @param _run The run to persist.\n   * @returns A resolved promise.\n   */\n  protected persistRun(_run: Run) {\n    return Promise.resolve();\n  }\n\n  // utility methods\n\n  /**\n   * Method used to get all the parent runs of a given run.\n   * @param run The run whose parents are to be retrieved.\n   * @returns An array of parent runs.\n   */\n  getParents(run: Run) {\n    const parents: Run[] = [];\n    let currentRun = run;\n    while (currentRun.parent_run_id) {\n      const parent = this.runMap.get(currentRun.parent_run_id);\n      if (parent) {\n        parents.push(parent);\n        currentRun = parent;\n      } else {\n        break;\n      }\n    }\n    return parents;\n  }\n\n  /**\n   * Method used to get a string representation of the run's lineage, which\n   * is used in logging.\n   * @param run The run whose lineage is to be retrieved.\n   * @returns A string representation of the run's lineage.\n   */\n  getBreadcrumbs(run: Run) {\n    const parents = this.getParents(run).reverse();\n    const string = [...parents, run]\n      .map((parent, i, arr) => {\n        const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n        return i === arr.length - 1 ? wrap(styles.bold, name) : name;\n      })\n      .join(\" > \");\n    return wrap(color.grey, string);\n  }\n\n  // logging methods\n\n  /**\n   * Method used to log the start of a chain run.\n   * @param run The chain run that has started.\n   * @returns void\n   */\n  onChainStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[chain/start]\"\n      )} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(\n        run.inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of a chain run.\n   * @param run The chain run that has ended.\n   * @returns void\n   */\n  onChainEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Chain run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[outputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a chain run.\n   * @param run The chain run that has errored.\n   * @returns void\n   */\n  onChainError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Chain run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the start of an LLM run.\n   * @param run The LLM run that has started.\n   * @returns void\n   */\n  onLLMStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    const inputs =\n      \"prompts\" in run.inputs\n        ? { prompts: (run.inputs.prompts as string[]).map((p) => p.trim()) }\n        : run.inputs;\n    console.log(\n      `${wrap(\n        color.green,\n        \"[llm/start]\"\n      )} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(\n        inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of an LLM run.\n   * @param run The LLM run that has ended.\n   * @returns void\n   */\n  onLLMEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting LLM run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[response]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of an LLM run.\n   * @param run The LLM run that has errored.\n   * @returns void\n   */\n  onLLMError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`\n    );\n  }\n\n  /**\n   * Method used to log the start of a tool run.\n   * @param run The tool run that has started.\n   * @returns void\n   */\n  onToolStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[tool/start]\"\n      )} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(\n        run.inputs.input\n      )}\"`\n    );\n  }\n\n  /**\n   * Method used to log the end of a tool run.\n   * @param run The tool run that has ended.\n   * @returns void\n   */\n  onToolEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n\n    console.log(\n      `${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Tool run with output: \"${formatKVMapItem(\n        run.outputs?.output\n      )}\"`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a tool run.\n   * @param run The tool run that has errored.\n   * @returns void\n   */\n  onToolError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Tool run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the start of a retriever run.\n   * @param run The retriever run that has started.\n   * @returns void\n   */\n  onRetrieverStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[retriever/start]\"\n      )} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(\n        run.inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of a retriever run.\n   * @param run The retriever run that has ended.\n   * @returns void\n   */\n  onRetrieverEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Retriever run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[outputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a retriever run.\n   * @param run The retriever run that has errored.\n   * @returns void\n   */\n  onRetrieverError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Retriever run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the action selected by the agent.\n   * @param run The run in which the agent action occurred.\n   * @returns void\n   */\n  onAgentAction(run: Run) {\n    const agentRun = run as AgentRun;\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.blue,\n        \"[agent/action]\"\n      )} [${crumbs}] Agent selected action: ${tryJsonStringify(\n        agentRun.actions[agentRun.actions.length - 1],\n        \"[action]\"\n      )}`\n    );\n  }\n}\n"],"names":["style: CSPair","text: string","obj: unknown","fallback: string","value: unknown","run: Run","elapsed","styles","BaseTracer","_run: Run","parents: Run[]"],"mappings":"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"}},
    {"offset": {"line": 696, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/tracer_langchain.ts"],"sourcesContent":["import {\n  type Client,\n  type LangSmithTracingClientInterface,\n  getDefaultProjectName,\n} from \"langsmith\";\nimport { RunTree, type RunTreeConfig } from \"langsmith/run_trees\";\nimport { getCurrentRunTree } from \"langsmith/singletons/traceable\";\n\nimport {\n  BaseRun,\n  RunCreate,\n  RunUpdate as BaseRunUpdate,\n  KVMap,\n} from \"langsmith/schemas\";\nimport { BaseTracer } from \"./base.js\";\nimport { BaseCallbackHandlerInput } from \"../callbacks/base.js\";\nimport { getDefaultLangChainClientSingleton } from \"../singletons/tracer.js\";\n\nexport interface Run extends BaseRun {\n  id: string;\n  child_runs: this[];\n  child_execution_order: number;\n  dotted_order?: string;\n  trace_id?: string;\n}\n\nexport interface RunCreate2 extends RunCreate {\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface RunUpdate extends BaseRunUpdate {\n  events: BaseRun[\"events\"];\n  inputs: KVMap;\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface LangChainTracerFields extends BaseCallbackHandlerInput {\n  exampleId?: string;\n  projectName?: string;\n  client?: LangSmithTracingClientInterface;\n  replicas?: RunTreeConfig[\"replicas\"];\n}\n\nexport class LangChainTracer\n  extends BaseTracer\n  implements LangChainTracerFields\n{\n  name = \"langchain_tracer\";\n\n  projectName?: string;\n\n  exampleId?: string;\n\n  client: LangSmithTracingClientInterface;\n\n  replicas?: RunTreeConfig[\"replicas\"];\n\n  usesRunTreeMap = true;\n\n  constructor(fields: LangChainTracerFields = {}) {\n    super(fields);\n    const { exampleId, projectName, client, replicas } = fields;\n\n    this.projectName = projectName ?? getDefaultProjectName();\n    this.replicas = replicas;\n    this.exampleId = exampleId;\n    this.client = client ?? getDefaultLangChainClientSingleton();\n\n    const traceableTree = LangChainTracer.getTraceableRunTree();\n    if (traceableTree) {\n      this.updateFromRunTree(traceableTree);\n    }\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // empty\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.postRun();\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.patchRun();\n  }\n\n  getRun(id: string): Run | undefined {\n    return this.runTreeMap.get(id);\n  }\n\n  updateFromRunTree(runTree: RunTree) {\n    this.runTreeMap.set(runTree.id, runTree);\n    let rootRun: RunTree = runTree;\n    const visited = new Set<string>();\n    while (rootRun.parent_run) {\n      if (visited.has(rootRun.id)) break;\n      visited.add(rootRun.id);\n\n      if (!rootRun.parent_run) break;\n      rootRun = rootRun.parent_run as RunTree;\n    }\n    visited.clear();\n\n    const queue = [rootRun];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      if (!current || visited.has(current.id)) continue;\n      visited.add(current.id);\n\n      this.runTreeMap.set(current.id, current);\n      if (current.child_runs) {\n        queue.push(...current.child_runs);\n      }\n    }\n\n    this.client = runTree.client ?? this.client;\n    this.replicas = runTree.replicas ?? this.replicas;\n    this.projectName = runTree.project_name ?? this.projectName;\n    this.exampleId = runTree.reference_example_id ?? this.exampleId;\n  }\n\n  getRunTreeWithTracingConfig(id: string): RunTree | undefined {\n    const runTree = this.runTreeMap.get(id);\n    if (!runTree) return undefined;\n\n    return new RunTree({\n      ...runTree,\n      client: this.client as Client,\n      project_name: this.projectName,\n      replicas: this.replicas,\n      reference_example_id: this.exampleId,\n      tracingEnabled: true,\n    });\n  }\n\n  static getTraceableRunTree(): RunTree | undefined {\n    try {\n      return (\n        // The type cast here provides forward compatibility. Old versions of LangSmith will just\n        // ignore the permitAbsentRunTree arg.\n        (\n          getCurrentRunTree as (\n            permitAbsentRunTree: boolean\n          ) => ReturnType<typeof getCurrentRunTree> | undefined\n        )(true)\n      );\n    } catch {\n      return undefined;\n    }\n  }\n}\n"],"names":["BaseTracer","fields: LangChainTracerFields","getDefaultLangChainClientSingleton","_run: Run","run: Run","id: string","runTree: RunTree","rootRun: RunTree","RunTree"],"mappings":"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"}},
    {"offset": {"line": 793, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/log_stream.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/log_stream.ts"],"sourcesContent":["import {\n  applyPatch,\n  type Operation as JSONPatchOperation,\n} from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer, type Run } from \"./base.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  CallbackHandlerPrefersStreaming,\n  HandleLLMNewTokenCallbackFields,\n} from \"../callbacks/base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ChatGenerationChunk, GenerationChunk } from \"../outputs.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport type { StreamEvent, StreamEventData } from \"./event_stream.js\";\n\nexport type { StreamEvent, StreamEventData };\n\n/**\n * Interface that represents the structure of a log entry in the\n * `LogStreamCallbackHandler`.\n */\nexport type LogEntry = {\n  /** ID of the sub-run. */\n  id: string;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n  /** List of tags for the run. */\n  tags: string[];\n  /** Key-value pairs of metadata for the run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  /** ISO-8601 timestamp of when the run started. */\n  start_time: string;\n  /** List of general output chunks streamed by this run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** List of LLM tokens streamed by this run, if applicable. */\n  streamed_output_str: string[];\n  /** Inputs to this run. Not available currently via streamLog. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputs?: any;\n  /** Final output of this run. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /** ISO-8601 timestamp of when the run ended. Only available after the run has finished. */\n  end_time?: string;\n};\n\nexport type RunState = {\n  /** ID of the sub-run. */\n  id: string;\n  /** List of output chunks streamed by Runnable.stream() */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** Final output of the run, usually the result of aggregating streamed_output. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /**\n   * List of sub-runs contained in this run, if any, in the order they were started.\n   * If filters were supplied, this list will contain only the runs that matched the filters.\n   */\n  logs: Record<string, LogEntry>;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n};\n\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n  ops: JSONPatchOperation[];\n\n  constructor(fields: { ops?: JSONPatchOperation[] }) {\n    this.ops = fields.ops ?? [];\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch({}, ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport class RunLog extends RunLogPatch {\n  state: RunState;\n\n  constructor(fields: { ops?: JSONPatchOperation[]; state: RunState }) {\n    super(fields);\n    this.state = fields.state;\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch(this.state, other.ops);\n    return new RunLog({ ops, state: states[states.length - 1].newDocument });\n  }\n\n  static fromRunLogPatch(patch: RunLogPatch) {\n    const states = applyPatch({}, patch.ops);\n    return new RunLog({\n      ops: patch.ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport type SchemaFormat = \"original\" | \"streaming_events\";\n\nexport interface LogStreamCallbackHandlerInput\n  extends BaseCallbackHandlerInput {\n  autoClose?: boolean;\n  includeNames?: string[];\n  includeTypes?: string[];\n  includeTags?: string[];\n  excludeNames?: string[];\n  excludeTypes?: string[];\n  excludeTags?: string[];\n  _schemaFormat?: SchemaFormat;\n}\n\nexport const isLogStreamHandler = (\n  handler: BaseCallbackHandler\n): handler is LogStreamCallbackHandler => handler.name === \"log_stream_tracer\";\n\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run: Run, schemaFormat: SchemaFormat) {\n  if (schemaFormat === \"original\") {\n    throw new Error(\n      \"Do not assign inputs with original schema drop the key for now. \" +\n        \"When inputs are added to streamLog they should be added with \" +\n        \"standardized schema for streaming events.\"\n    );\n  }\n\n  const { inputs } = run;\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return inputs;\n  }\n\n  if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n    return undefined;\n  }\n\n  // new style chains\n  // These nest an additional 'input' key inside the 'inputs' to make sure\n  // the input is always a dict. We need to unpack and user the inner value.\n  // We should try to fix this in Runnables and callbacks/tracers\n  // Runnables should be using a null type here not a placeholder\n  // dict.\n  return inputs.input;\n}\n\nasync function _getStandardizedOutputs(run: Run, schemaFormat: SchemaFormat) {\n  const { outputs } = run;\n  if (schemaFormat === \"original\") {\n    // Return the old schema, without standardizing anything\n    return outputs;\n  }\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return outputs;\n  }\n\n  // TODO: Remove this hacky check\n  if (\n    outputs !== undefined &&\n    Object.keys(outputs).length === 1 &&\n    outputs?.output !== undefined\n  ) {\n    return outputs.output;\n  }\n\n  return outputs;\n}\n\nfunction isChatGenerationChunk(\n  x?: ChatGenerationChunk | GenerationChunk\n): x is ChatGenerationChunk {\n  return x !== undefined && (x as ChatGenerationChunk).message !== undefined;\n}\n\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler\n  extends BaseTracer\n  implements CallbackHandlerPrefersStreaming\n{\n  protected autoClose = true;\n\n  protected includeNames?: string[];\n\n  protected includeTypes?: string[];\n\n  protected includeTags?: string[];\n\n  protected excludeNames?: string[];\n\n  protected excludeTypes?: string[];\n\n  protected excludeTags?: string[];\n\n  protected _schemaFormat: SchemaFormat = \"original\";\n\n  protected rootId?: string;\n\n  private keyMapByRunId: Record<string, string> = {};\n\n  private counterMapByRunName: Record<string, number> = {};\n\n  protected transformStream: TransformStream;\n\n  public writer: WritableStreamDefaultWriter;\n\n  public receiveStream: IterableReadableStream<RunLogPatch>;\n\n  name = \"log_stream_tracer\";\n\n  lc_prefer_streaming = true;\n\n  constructor(fields?: LogStreamCallbackHandlerInput) {\n    super({ _awaitHandler: true, ...fields });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(\n      this.transformStream.readable\n    );\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n\n  _includeRun(run: Run): boolean {\n    if (run.id === this.rootId) {\n      return false;\n    }\n    const runTags = run.tags ?? [];\n    let include =\n      this.includeNames === undefined &&\n      this.includeTags === undefined &&\n      this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.run_type);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include ||\n        runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.run_type);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n\n  async *tapOutputIterable<T>(\n    runId: string,\n    output: AsyncGenerator<T>\n  ): AsyncGenerator<T> {\n    // Tap an output async iterator to stream its values to the log.\n    for await (const chunk of output) {\n      // root run is handled in .streamLog()\n      if (runId !== this.rootId) {\n        // if we can't find the run silently ignore\n        // eg. because this run wasn't included in the log\n        const key = this.keyMapByRunId[runId];\n        if (key) {\n          await this.writer.write(\n            new RunLogPatch({\n              ops: [\n                {\n                  op: \"add\",\n                  path: `/logs/${key}/streamed_output/-`,\n                  value: chunk,\n                },\n              ],\n            })\n          );\n        }\n      }\n      yield chunk;\n    }\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    if (this.rootId === undefined) {\n      this.rootId = run.id;\n      await this.writer.write(\n        new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"\",\n              value: {\n                id: run.id,\n                name: run.name,\n                type: run.run_type,\n                streamed_output: [],\n                final_output: undefined,\n                logs: {},\n              },\n            },\n          ],\n        })\n      );\n    }\n\n    if (!this._includeRun(run)) {\n      return;\n    }\n\n    if (this.counterMapByRunName[run.name] === undefined) {\n      this.counterMapByRunName[run.name] = 0;\n    }\n    this.counterMapByRunName[run.name] += 1;\n    const count = this.counterMapByRunName[run.name];\n    this.keyMapByRunId[run.id] =\n      count === 1 ? run.name : `${run.name}:${count}`;\n\n    const logEntry: LogEntry = {\n      id: run.id,\n      name: run.name,\n      type: run.run_type,\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      start_time: new Date(run.start_time).toISOString(),\n      streamed_output: [],\n      streamed_output_str: [],\n      final_output: undefined,\n      end_time: undefined,\n    };\n\n    if (this._schemaFormat === \"streaming_events\") {\n      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n    }\n\n    await this.writer.write(\n      new RunLogPatch({\n        ops: [\n          {\n            op: \"add\",\n            path: `/logs/${this.keyMapByRunId[run.id]}`,\n            value: logEntry,\n          },\n        ],\n      })\n    );\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    try {\n      const runName = this.keyMapByRunId[run.id];\n      if (runName === undefined) {\n        return;\n      }\n      const ops: JSONPatchOperation[] = [];\n      if (this._schemaFormat === \"streaming_events\") {\n        ops.push({\n          op: \"replace\",\n          path: `/logs/${runName}/inputs`,\n          value: await _getStandardizedInputs(run, this._schemaFormat),\n        });\n      }\n      ops.push({\n        op: \"add\",\n        path: `/logs/${runName}/final_output`,\n        value: await _getStandardizedOutputs(run, this._schemaFormat),\n      });\n      if (run.end_time !== undefined) {\n        ops.push({\n          op: \"add\",\n          path: `/logs/${runName}/end_time`,\n          value: new Date(run.end_time).toISOString(),\n        });\n      }\n      const patch = new RunLogPatch({ ops });\n      await this.writer.write(patch);\n    } finally {\n      if (run.id === this.rootId) {\n        const patch = new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"/final_output\",\n              value: await _getStandardizedOutputs(run, this._schemaFormat),\n            },\n          ],\n        });\n        await this.writer.write(patch);\n        if (this.autoClose) {\n          await this.writer.close();\n        }\n      }\n    }\n  }\n\n  async onLLMNewToken(\n    run: Run,\n    token: string,\n    kwargs?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    const runName = this.keyMapByRunId[run.id];\n    if (runName === undefined) {\n      return;\n    }\n    // TODO: Remove hack\n    const isChatModel = run.inputs.messages !== undefined;\n    let streamedOutputValue;\n    if (isChatModel) {\n      if (isChatGenerationChunk(kwargs?.chunk)) {\n        streamedOutputValue = kwargs?.chunk;\n      } else {\n        streamedOutputValue = new AIMessageChunk({\n          id: `run-${run.id}`,\n          content: token,\n        });\n      }\n    } else {\n      streamedOutputValue = token;\n    }\n    const patch = new RunLogPatch({\n      ops: [\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output_str/-`,\n          value: token,\n        },\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output/-`,\n          value: streamedOutputValue,\n        },\n      ],\n    });\n    await this.writer.write(patch);\n  }\n}\n"],"names":["fields: { ops?: JSONPatchOperation[] }","other: RunLogPatch","applyPatch","fields: { ops?: JSONPatchOperation[]; state: RunState }","patch: RunLogPatch","handler: BaseCallbackHandler","run: Run","schemaFormat: SchemaFormat","x?: ChatGenerationChunk | GenerationChunk","BaseTracer","fields?: LogStreamCallbackHandlerInput","IterableReadableStream","_run: Run","runId: string","output: AsyncGenerator<T>","logEntry: LogEntry","ops: JSONPatchOperation[]","token: string","kwargs?: HandleLLMNewTokenCallbackFields","AIMessageChunk"],"mappings":"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"}},
    {"offset": {"line": 1088, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/event_stream.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/event_stream.ts"],"sourcesContent":["import { BaseTracer, type Run } from \"./base.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  CallbackHandlerPrefersStreaming,\n} from \"../callbacks/base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport { ChatGeneration, Generation, GenerationChunk } from \"../outputs.js\";\nimport { BaseMessage } from \"../messages/base.js\";\n\n/**\n * Data associated with a StreamEvent.\n */\nexport type StreamEventData = {\n  /**\n   * The input passed to the runnable that generated the event.\n   * Inputs will sometimes be available at the *START* of the runnable, and\n   * sometimes at the *END* of the runnable.\n   * If a runnable is able to stream its inputs, then its input by definition\n   * won't be known until the *END* of the runnable when it has finished streaming\n   * its inputs.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any;\n\n  /**\n   * The output of the runnable that generated the event.\n   * Outputs will only be available at the *END* of the runnable.\n   * For most runnables, this field can be inferred from the `chunk` field,\n   * though there might be some exceptions for special cased runnables (e.g., like\n   * chat models), which may return more information.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  output?: any;\n\n  /**\n   * A streaming chunk from the output that generated the event.\n   * chunks support addition in general, and adding them up should result\n   * in the output of the runnable that generated the event.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  chunk?: any;\n};\n\n/**\n * A streaming event.\n *\n * Schema of a streaming event which is produced from the streamEvents method.\n */\nexport type StreamEvent = {\n  /**\n   * Event names are of the format: on_[runnable_type]_(start|stream|end).\n   *\n   * Runnable types are one of:\n   * - llm - used by non chat models\n   * - chat_model - used by chat models\n   * - prompt --  e.g., ChatPromptTemplate\n   * - tool -- LangChain tools\n   * - chain - most Runnables are of this type\n   *\n   * Further, the events are categorized as one of:\n   * - start - when the runnable starts\n   * - stream - when the runnable is streaming\n   * - end - when the runnable ends\n   *\n   * start, stream and end are associated with slightly different `data` payload.\n   *\n   * Please see the documentation for `EventData` for more details.\n   */\n  event: string;\n  /** The name of the runnable that generated the event. */\n  name: string;\n  /**\n   * An randomly generated ID to keep track of the execution of the given runnable.\n   *\n   * Each child runnable that gets invoked as part of the execution of a parent runnable\n   * is assigned its own unique ID.\n   */\n  run_id: string;\n  /**\n   * Tags associated with the runnable that generated this event.\n   * Tags are always inherited from parent runnables.\n   */\n  tags?: string[];\n  /** Metadata associated with the runnable that generated this event. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  /**\n   * Event data.\n   *\n   * The contents of the event data depend on the event type.\n   */\n  data: StreamEventData;\n};\n\ntype RunInfo = {\n  name: string;\n  tags: string[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  runType: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputs?: Record<string, any>;\n};\n\nexport interface EventStreamCallbackHandlerInput\n  extends BaseCallbackHandlerInput {\n  autoClose?: boolean;\n  includeNames?: string[];\n  includeTypes?: string[];\n  includeTags?: string[];\n  excludeNames?: string[];\n  excludeTypes?: string[];\n  excludeTags?: string[];\n}\n\nfunction assignName({\n  name,\n  serialized,\n}: {\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serialized?: Record<string, any>;\n}): string {\n  if (name !== undefined) {\n    return name;\n  }\n  if (serialized?.name !== undefined) {\n    return serialized.name;\n  } else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n    return serialized.id[serialized.id.length - 1];\n  }\n  return \"Unnamed\";\n}\n\nexport const isStreamEventsHandler = (\n  handler: BaseCallbackHandler\n): handler is EventStreamCallbackHandler =>\n  handler.name === \"event_stream_tracer\";\n\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class EventStreamCallbackHandler\n  extends BaseTracer\n  implements CallbackHandlerPrefersStreaming\n{\n  protected autoClose = true;\n\n  protected includeNames?: string[];\n\n  protected includeTypes?: string[];\n\n  protected includeTags?: string[];\n\n  protected excludeNames?: string[];\n\n  protected excludeTypes?: string[];\n\n  protected excludeTags?: string[];\n\n  private runInfoMap: Map<string, RunInfo> = new Map();\n\n  private tappedPromises: Map<string, Promise<void>> = new Map();\n\n  protected transformStream: TransformStream;\n\n  public writer: WritableStreamDefaultWriter;\n\n  public receiveStream: IterableReadableStream<StreamEvent>;\n\n  name = \"event_stream_tracer\";\n\n  lc_prefer_streaming = true;\n\n  constructor(fields?: EventStreamCallbackHandlerInput) {\n    super({ _awaitHandler: true, ...fields });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(\n      this.transformStream.readable\n    );\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n\n  _includeRun(run: RunInfo): boolean {\n    const runTags = run.tags ?? [];\n    let include =\n      this.includeNames === undefined &&\n      this.includeTags === undefined &&\n      this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.runType);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include ||\n        runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.runType);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n\n  async *tapOutputIterable<T>(\n    runId: string,\n    outputStream: AsyncGenerator<T>\n  ): AsyncGenerator<T> {\n    const firstChunk = await outputStream.next();\n    if (firstChunk.done) {\n      return;\n    }\n    const runInfo = this.runInfoMap.get(runId);\n    // Run has finished, don't issue any stream events.\n    // An example of this is for runnables that use the default\n    // implementation of .stream(), which delegates to .invoke()\n    // and calls .onChainEnd() before passing it to the iterator.\n    if (runInfo === undefined) {\n      yield firstChunk.value;\n      return;\n    }\n    // Match format from handlers below\n    function _formatOutputChunk(eventType: string, data: unknown) {\n      if (eventType === \"llm\" && typeof data === \"string\") {\n        return new GenerationChunk({ text: data });\n      }\n      return data;\n    }\n    let tappedPromise = this.tappedPromises.get(runId);\n    // if we are the first to tap, issue stream events\n    if (tappedPromise === undefined) {\n      let tappedPromiseResolver: (() => void) | undefined;\n      tappedPromise = new Promise((resolve) => {\n        tappedPromiseResolver = resolve;\n      });\n      this.tappedPromises.set(runId, tappedPromise);\n      try {\n        const event: StreamEvent = {\n          event: `on_${runInfo.runType}_stream`,\n          run_id: runId,\n          name: runInfo.name,\n          tags: runInfo.tags,\n          metadata: runInfo.metadata,\n          data: {},\n        };\n        await this.send(\n          {\n            ...event,\n            data: {\n              chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n            },\n          },\n          runInfo\n        );\n        yield firstChunk.value;\n        for await (const chunk of outputStream) {\n          // Don't yield tool and retriever stream events\n          if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n            await this.send(\n              {\n                ...event,\n                data: {\n                  chunk: _formatOutputChunk(runInfo.runType, chunk),\n                },\n              },\n              runInfo\n            );\n          }\n          yield chunk;\n        }\n      } finally {\n        tappedPromiseResolver?.();\n        // Don't delete from the promises map to keep track of which runs have been tapped.\n      }\n    } else {\n      // otherwise just pass through\n      yield firstChunk.value;\n      for await (const chunk of outputStream) {\n        yield chunk;\n      }\n    }\n  }\n\n  async send(payload: StreamEvent, run: RunInfo) {\n    if (this._includeRun(run)) {\n      await this.writer.write(payload);\n    }\n  }\n\n  async sendEndEvent(payload: StreamEvent, run: RunInfo) {\n    const tappedPromise = this.tappedPromises.get(payload.run_id);\n    if (tappedPromise !== undefined) {\n      // eslint-disable-next-line no-void\n      void tappedPromise.then(() => {\n        // eslint-disable-next-line no-void\n        void this.send(payload, run);\n      });\n    } else {\n      await this.send(payload, run);\n    }\n  }\n\n  async onLLMStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: run.inputs,\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    const eventName = `on_${runType}_start`;\n    await this.send(\n      {\n        event: eventName,\n        data: {\n          input: run.inputs,\n        },\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onLLMNewToken(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    let chunk;\n    let eventName;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n    }\n    // Top-level streaming events are covered by tapOutputIterable\n    if (this.runInfoMap.size === 1) {\n      return;\n    }\n    if (runInfo.runType === \"chat_model\") {\n      eventName = \"on_chat_model_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new AIMessageChunk({ content: token, id: `run-${run.id}` });\n      } else {\n        chunk = kwargs.chunk.message;\n      }\n    } else if (runInfo.runType === \"llm\") {\n      eventName = \"on_llm_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new GenerationChunk({ text: token });\n      } else {\n        chunk = kwargs.chunk;\n      }\n    } else {\n      throw new Error(`Unexpected run type ${runInfo.runType}`);\n    }\n    await this.send(\n      {\n        event: eventName,\n        data: {\n          chunk,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onLLMEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    let eventName: string;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const generations: ChatGeneration[][] | Generation[][] | undefined =\n      run.outputs?.generations;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let output: BaseMessage | Record<string, any> | undefined;\n    if (runInfo.runType === \"chat_model\") {\n      for (const generation of generations ?? []) {\n        if (output !== undefined) {\n          break;\n        }\n        output = (generation[0] as ChatGeneration | undefined)?.message;\n      }\n      eventName = \"on_chat_model_end\";\n    } else if (runInfo.runType === \"llm\") {\n      output = {\n        generations: generations?.map((generation) => {\n          return generation.map((chunk) => {\n            return {\n              text: chunk.text,\n              generationInfo: chunk.generationInfo,\n            };\n          });\n        }),\n        llmOutput: run.outputs?.llmOutput ?? {},\n      };\n      eventName = \"on_llm_end\";\n    } else {\n      throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n    }\n    await this.sendEndEvent(\n      {\n        event: eventName,\n        data: {\n          output,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onChainStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = run.run_type ?? \"chain\";\n    const runInfo: RunInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: run.run_type,\n    };\n    let eventData: StreamEventData = {};\n    // Workaround Runnable core code not sending input when transform streaming.\n    if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n      eventData = {};\n      runInfo.inputs = {};\n    } else if (run.inputs.input !== undefined) {\n      eventData.input = run.inputs.input;\n      runInfo.inputs = run.inputs.input;\n    } else {\n      eventData.input = run.inputs;\n      runInfo.inputs = run.inputs;\n    }\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: `on_${runType}_start`,\n        data: eventData,\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onChainEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const eventName = `on_${run.run_type}_end`;\n    const inputs = run.inputs ?? runInfo.inputs ?? {};\n    const outputs = run.outputs?.output ?? run.outputs;\n    const data: StreamEventData = {\n      output: outputs,\n      input: inputs,\n    };\n    if (inputs.input && Object.keys(inputs).length === 1) {\n      data.input = inputs.input;\n      runInfo.inputs = inputs.input;\n    }\n    await this.sendEndEvent(\n      {\n        event: eventName,\n        data,\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onToolStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: \"tool\",\n      inputs: run.inputs ?? {},\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: \"on_tool_start\",\n        data: {\n          input: run.inputs ?? {},\n        },\n        name: runName,\n        run_id: run.id,\n        tags: run.tags ?? [],\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onToolEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n    }\n    if (runInfo.inputs === undefined) {\n      throw new Error(\n        `onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`\n      );\n    }\n    const output =\n      run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n    await this.sendEndEvent(\n      {\n        event: \"on_tool_end\",\n        data: {\n          output,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onRetrieverStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = \"retriever\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: {\n        query: run.inputs.query,\n      },\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: \"on_retriever_start\",\n        data: {\n          input: {\n            query: run.inputs.query,\n          },\n        },\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onRetrieverEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n    }\n    await this.sendEndEvent(\n      {\n        event: \"on_retriever_end\",\n        data: {\n          output: run.outputs?.documents ?? run.outputs,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleCustomEvent(eventName: string, data: any, runId: string) {\n    const runInfo = this.runInfoMap.get(runId);\n    if (runInfo === undefined) {\n      throw new Error(\n        `handleCustomEvent: Run ID ${runId} not found in run map.`\n      );\n    }\n    await this.send(\n      {\n        event: \"on_custom_event\",\n        run_id: runId,\n        name: eventName,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n        data,\n      },\n      runInfo\n    );\n  }\n\n  async finish() {\n    const pendingPromises = [...this.tappedPromises.values()];\n    // eslint-disable-next-line no-void\n    void Promise.all(pendingPromises).finally(() => {\n      // eslint-disable-next-line no-void\n      void this.writer.close();\n    });\n  }\n}\n"],"names":["handler: BaseCallbackHandler","BaseTracer","fields?: EventStreamCallbackHandlerInput","IterableReadableStream","_run: Run","run: RunInfo","runId: string","outputStream: AsyncGenerator<T>","eventType: string","data: unknown","GenerationChunk","tappedPromiseResolver: (() => void) | undefined","event: StreamEvent","payload: StreamEvent","run: Run","token: string","kwargs?: { chunk: any }","AIMessageChunk","eventName: string","generations: ChatGeneration[][] | Generation[][] | undefined","output: BaseMessage | Record<string, any> | undefined","runInfo: RunInfo","eventData: StreamEventData","data: StreamEventData","data: any"],"mappings":"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"}},
    {"offset": {"line": 1470, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/root_listener.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/root_listener.ts"],"sourcesContent":["import { RunnableConfig } from \"../runnables/config.js\";\nimport { BaseTracer, Run } from \"./base.js\";\n\nexport class RootListenersTracer extends BaseTracer {\n  name = \"RootListenersTracer\";\n\n  /** The Run's ID. Type UUID */\n  rootId?: string;\n\n  config: RunnableConfig;\n\n  argOnStart?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  argOnEnd?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  argOnError?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  constructor({\n    config,\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    config: RunnableConfig;\n    onStart?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n  }) {\n    super({ _awaitHandler: true });\n    this.config = config;\n    this.argOnStart = onStart;\n    this.argOnEnd = onEnd;\n    this.argOnError = onError;\n  }\n\n  /**\n   * This is a legacy method only called once for an entire run tree\n   * therefore not useful here\n   * @param {Run} _ Not used\n   */\n  persistRun(_: Run): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async onRunCreate(run: Run) {\n    if (this.rootId) {\n      return;\n    }\n\n    this.rootId = run.id;\n\n    if (this.argOnStart) {\n      await this.argOnStart(run, this.config);\n    }\n  }\n\n  async onRunUpdate(run: Run) {\n    if (run.id !== this.rootId) {\n      return;\n    }\n    if (!run.error) {\n      if (this.argOnEnd) {\n        await this.argOnEnd(run, this.config);\n      }\n    } else if (this.argOnError) {\n      await this.argOnError(run, this.config);\n    }\n  }\n}\n"],"names":["BaseTracer","_: Run","run: Run"],"mappings":";;AAGA,IAAa,sBAAb,cAAyCA,qBAAAA,UAAAA,CAAW;IAClD,OAAO,sBAAA;mCAGP,OAAA;IAEA,OAAA;IAEA,WAAA;IAEA,SAAA;IAEA,WAAA;IAEA,YAAY,EACV,MAAA,EACA,OAAA,EACA,KAAA,EACA,OAAA,EAMD,CAAE;QACD,KAAA,CAAM;YAAE,eAAe;QAAM,EAAC;QAC9B,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,UAAA,GAAa;IACnB;;;;;IAOD,WAAWC,CAAAA,EAAuB;QAChC,OAAO,QAAQ,OAAA,EAAS;IACzB;IAED,MAAM,YAAYC,GAAAA,EAAU;QAC1B,IAAI,IAAA,CAAK,MAAA,CACP,CAAA;QAGF,IAAA,CAAK,MAAA,GAAS,IAAI,EAAA;QAElB,IAAI,IAAA,CAAK,UAAA,EACP,MAAM,IAAA,CAAK,UAAA,CAAW,KAAK,IAAA,CAAK,MAAA,CAAO;IAE1C;IAED,MAAM,YAAYA,GAAAA,EAAU;QAC1B,IAAI,IAAI,EAAA,KAAO,IAAA,CAAK,MAAA,CAClB,CAAA;QAEF,IAAI,CAAC,IAAI,KAAA,EACP;gBAAI,IAAA,CAAK,QAAA,EACP,MAAM,IAAA,CAAK,QAAA,CAAS,KAAK,IAAA,CAAK,MAAA,CAAO;QACtC,OAAA,IACQ,IAAA,CAAK,UAAA,EACd,MAAM,IAAA,CAAK,UAAA,CAAW,KAAK,IAAA,CAAK,MAAA,CAAO;IAE1C;AACF"}},
    {"offset": {"line": 1513, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/base.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/base.ts"],"sourcesContent":["import { KVMap, BaseRun } from \"langsmith/schemas\";\nimport { RunTree, convertToDottedOrderFormat } from \"langsmith/run_trees\";\n\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { LLMResult } from \"../outputs.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"../callbacks/base.js\";\nimport type { Document } from \"../documents/document.js\";\nimport { getRuntimeEnvironment } from \"../utils/env.js\";\n\nexport type RunType = string;\n\n// TODO: Remove this type and just use the base LangSmith Run type.\nexport interface Run extends BaseRun {\n  // some optional fields are always present here\n  id: string;\n  start_time: number;\n  end_time?: number;\n  execution_order: number;\n  // some additional fields that don't exist in sdk runs\n  child_runs: this[];\n  child_execution_order: number;\n  events: Array<{\n    name: string;\n    time: string;\n    kwargs?: Record<string, unknown>;\n  }>;\n  trace_id?: string;\n  dotted_order?: string;\n  /** @internal */\n  _serialized_start_time?: string;\n}\n\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree?: RunTree): Run | undefined => {\n  if (!runTree) {\n    return undefined;\n  }\n  // Important that we return the raw run tree object since the reference\n  // is mutated in other places.\n  // TODO: Remove places where this is being done.\n\n  runTree.events = runTree.events ?? [];\n  runTree.child_runs = runTree.child_runs ?? [];\n  // TODO: Remove this cast and just use the LangSmith RunTree type.\n  return runTree as unknown as Run;\n};\n\nfunction convertRunToRunTree(run?: Run, parentRun?: Run): RunTree | undefined {\n  if (!run) {\n    return undefined;\n  }\n  return new RunTree({\n    ...run,\n    start_time: run._serialized_start_time ?? run.start_time,\n    parent_run: convertRunToRunTree(parentRun),\n    child_runs: run.child_runs\n      .map((r) => convertRunToRunTree(r))\n      .filter((r): r is RunTree => r !== undefined),\n    extra: {\n      ...run.extra,\n      runtime: getRuntimeEnvironment(),\n    },\n    tracingEnabled: false,\n  });\n}\n\nexport interface AgentRun extends Run {\n  actions: AgentAction[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value: any, defaultKey: string) {\n  return value && !Array.isArray(value) && typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport function isBaseTracer(x: BaseCallbackHandler): x is BaseTracer {\n  return typeof (x as BaseTracer)._addRunToRunMap === \"function\";\n}\n\nexport abstract class BaseTracer extends BaseCallbackHandler {\n  /** @deprecated Use `runTreeMap` instead. */\n  protected runMap: Map<string, Run> = new Map();\n\n  protected runTreeMap: Map<string, RunTree> = new Map();\n\n  protected usesRunTreeMap = false;\n\n  constructor(_fields?: BaseCallbackHandlerInput) {\n    super(...arguments);\n  }\n\n  copy(): this {\n    return this;\n  }\n\n  protected getRunById(runId?: string): Run | undefined {\n    if (runId === undefined) {\n      return undefined;\n    }\n    return this.usesRunTreeMap\n      ? convertRunTreeToRun(this.runTreeMap.get(runId))\n      : this.runMap.get(runId);\n  }\n\n  protected stringifyError(error: unknown) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (error instanceof Error) {\n      return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n    }\n\n    if (typeof error === \"string\") {\n      return error;\n    }\n\n    return `${error}`;\n  }\n\n  protected abstract persistRun(run: Run): Promise<void>;\n\n  protected _addChildRun(parentRun: Run, childRun: Run) {\n    parentRun.child_runs.push(childRun);\n  }\n\n  _addRunToRunMap(run: Run) {\n    const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } =\n      convertToDottedOrderFormat(\n        new Date(run.start_time).getTime(),\n        run.id,\n        run.execution_order\n      );\n    const storedRun = { ...run };\n    const parentRun = this.getRunById(storedRun.parent_run_id);\n    if (storedRun.parent_run_id !== undefined) {\n      if (parentRun) {\n        this._addChildRun(parentRun, storedRun);\n        parentRun.child_execution_order = Math.max(\n          parentRun.child_execution_order,\n          storedRun.child_execution_order\n        );\n        storedRun.trace_id = parentRun.trace_id;\n        if (parentRun.dotted_order !== undefined) {\n          storedRun.dotted_order = [\n            parentRun.dotted_order,\n            currentDottedOrder,\n          ].join(\".\");\n          storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        } else {\n          // This can happen naturally for callbacks added within a run\n          // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n        }\n      } else {\n        // This can happen naturally for callbacks added within a run\n        // console.debug(\n        //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n        // );\n      }\n    } else {\n      storedRun.trace_id = storedRun.id;\n      storedRun.dotted_order = currentDottedOrder;\n      storedRun._serialized_start_time = microsecondPrecisionDatestring;\n    }\n    if (this.usesRunTreeMap) {\n      const runTree = convertRunToRunTree(storedRun, parentRun);\n      if (runTree !== undefined) {\n        this.runTreeMap.set(storedRun.id, runTree);\n      }\n    } else {\n      this.runMap.set(storedRun.id, storedRun);\n    }\n    return storedRun;\n  }\n\n  protected async _endTrace(run: Run): Promise<void> {\n    const parentRun =\n      run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(\n        parentRun.child_execution_order,\n        run.child_execution_order\n      );\n    } else {\n      await this.persistRun(run);\n    }\n    await this.onRunUpdate?.(run);\n    if (this.usesRunTreeMap) {\n      this.runTreeMap.delete(run.id);\n    } else {\n      this.runMap.delete(run.id);\n    }\n  }\n\n  protected _getExecutionOrder(parentRunId: string | undefined): number {\n    const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n\n    return parentRun.child_execution_order + 1;\n  }\n\n  /**\n   * Create and add a run to the run map for LLM start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { prompts },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForLLMStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chat model start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { messages },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChatModelStart(\n        llm,\n        messages,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleLLMError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chain start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType ?? \"chain\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChainStart(\n        chain,\n        inputs,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        runType,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onChainStart?.(run);\n    return run;\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = _coerceToDict(outputs, \"output\");\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleChainError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for tool start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { input },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForToolStart(\n        tool,\n        input,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onToolStart?.(run);\n    return run;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { output };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleToolError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleAgentAction(action: AgentAction, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    const agentRun = run as AgentRun;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentAction?.(run as AgentRun);\n  }\n\n  async handleAgentEnd(action: AgentFinish, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentEnd?.(run);\n  }\n\n  /**\n   * Create and add a run to the run map for retriever start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { query },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForRetrieverStart(\n        retriever,\n        query,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onRetrieverStart?.(run);\n    return run;\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, unknown>>[],\n    runId: string\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { documents };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleRetrieverError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleText(text: string, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: new Date().toISOString(),\n      kwargs: { text },\n    });\n    await this.onText?.(run);\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\n        `Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`\n      );\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: new Date().toISOString(),\n      kwargs: { token, idx, chunk: fields?.chunk },\n    });\n    await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n    return run;\n  }\n\n  // custom event handlers\n\n  onRunCreate?(run: Run): void | Promise<void>;\n\n  onRunUpdate?(run: Run): void | Promise<void>;\n\n  onLLMStart?(run: Run): void | Promise<void>;\n\n  onLLMEnd?(run: Run): void | Promise<void>;\n\n  onLLMError?(run: Run): void | Promise<void>;\n\n  onChainStart?(run: Run): void | Promise<void>;\n\n  onChainEnd?(run: Run): void | Promise<void>;\n\n  onChainError?(run: Run): void | Promise<void>;\n\n  onToolStart?(run: Run): void | Promise<void>;\n\n  onToolEnd?(run: Run): void | Promise<void>;\n\n  onToolError?(run: Run): void | Promise<void>;\n\n  onAgentAction?(run: Run): void | Promise<void>;\n\n  onAgentEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverStart?(run: Run): void | Promise<void>;\n\n  onRetrieverEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverError?(run: Run): void | Promise<void>;\n\n  onText?(run: Run): void | Promise<void>;\n\n  onLLMNewToken?(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): void | Promise<void>;\n}\n"],"names":["runTree?: RunTree","run?: Run","parentRun?: Run","value: any","defaultKey: string","x: BaseCallbackHandler","_fields?: BaseCallbackHandlerInput","runId?: string","error: unknown","parentRun: Run","childRun: Run","run: Run","parentRunId: string | undefined","llm: Serialized","prompts: string[]","runId: string","parentRunId?: string","extraParams?: KVMap","tags?: string[]","metadata?: KVMap","name?: string","messages: BaseMessage[][]","output: LLMResult","_parentRunId?: string","_tags?: string[]","extraParams?: Record<string, unknown>","chain: Serialized","inputs: ChainValues","runType?: string","outputs: ChainValues","kwargs?: { inputs?: Record<string, unknown> }","tool: Serialized","input: string","output: any","action: AgentAction","action: AgentFinish","retriever: Serialized","query: string","documents: Document<Record<string, unknown>>[]","text: string","token: string","idx: NewTokenIndices","fields?: HandleLLMNewTokenCallbackFields"],"mappings":"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"}},
    {"offset": {"line": 2007, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/console.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/console.ts"],"sourcesContent":["import type { CSPair } from \"ansi-styles\";\nimport styles from \"ansi-styles\";\nimport { BaseTracer, type AgentRun, type Run } from \"./base.js\";\n\nfunction wrap(style: CSPair, text: string) {\n  return `${style.open}${text}${style.close}`;\n}\n\nfunction tryJsonStringify(obj: unknown, fallback: string) {\n  try {\n    return JSON.stringify(obj, null, 2);\n  } catch {\n    return fallback;\n  }\n}\n\nfunction formatKVMapItem(value: unknown) {\n  if (typeof value === \"string\") {\n    return value.trim();\n  }\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  return tryJsonStringify(value, value.toString());\n}\n\nfunction elapsed(run: Run): string {\n  if (!run.end_time) return \"\";\n  const elapsed = run.end_time - run.start_time;\n  if (elapsed < 1000) {\n    return `${elapsed}ms`;\n  }\n  return `${(elapsed / 1000).toFixed(2)}s`;\n}\n\nconst { color } = styles;\n\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nexport class ConsoleCallbackHandler extends BaseTracer {\n  name = \"console_callback_handler\" as const;\n\n  /**\n   * Method used to persist the run. In this case, it simply returns a\n   * resolved promise as there's no persistence logic.\n   * @param _run The run to persist.\n   * @returns A resolved promise.\n   */\n  protected persistRun(_run: Run) {\n    return Promise.resolve();\n  }\n\n  // utility methods\n\n  /**\n   * Method used to get all the parent runs of a given run.\n   * @param run The run whose parents are to be retrieved.\n   * @returns An array of parent runs.\n   */\n  getParents(run: Run) {\n    const parents: Run[] = [];\n    let currentRun = run;\n    while (currentRun.parent_run_id) {\n      const parent = this.runMap.get(currentRun.parent_run_id);\n      if (parent) {\n        parents.push(parent);\n        currentRun = parent;\n      } else {\n        break;\n      }\n    }\n    return parents;\n  }\n\n  /**\n   * Method used to get a string representation of the run's lineage, which\n   * is used in logging.\n   * @param run The run whose lineage is to be retrieved.\n   * @returns A string representation of the run's lineage.\n   */\n  getBreadcrumbs(run: Run) {\n    const parents = this.getParents(run).reverse();\n    const string = [...parents, run]\n      .map((parent, i, arr) => {\n        const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n        return i === arr.length - 1 ? wrap(styles.bold, name) : name;\n      })\n      .join(\" > \");\n    return wrap(color.grey, string);\n  }\n\n  // logging methods\n\n  /**\n   * Method used to log the start of a chain run.\n   * @param run The chain run that has started.\n   * @returns void\n   */\n  onChainStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[chain/start]\"\n      )} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(\n        run.inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of a chain run.\n   * @param run The chain run that has ended.\n   * @returns void\n   */\n  onChainEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Chain run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[outputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a chain run.\n   * @param run The chain run that has errored.\n   * @returns void\n   */\n  onChainError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Chain run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the start of an LLM run.\n   * @param run The LLM run that has started.\n   * @returns void\n   */\n  onLLMStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    const inputs =\n      \"prompts\" in run.inputs\n        ? { prompts: (run.inputs.prompts as string[]).map((p) => p.trim()) }\n        : run.inputs;\n    console.log(\n      `${wrap(\n        color.green,\n        \"[llm/start]\"\n      )} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(\n        inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of an LLM run.\n   * @param run The LLM run that has ended.\n   * @returns void\n   */\n  onLLMEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting LLM run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[response]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of an LLM run.\n   * @param run The LLM run that has errored.\n   * @returns void\n   */\n  onLLMError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`\n    );\n  }\n\n  /**\n   * Method used to log the start of a tool run.\n   * @param run The tool run that has started.\n   * @returns void\n   */\n  onToolStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[tool/start]\"\n      )} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(\n        run.inputs.input\n      )}\"`\n    );\n  }\n\n  /**\n   * Method used to log the end of a tool run.\n   * @param run The tool run that has ended.\n   * @returns void\n   */\n  onToolEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n\n    console.log(\n      `${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Tool run with output: \"${formatKVMapItem(\n        run.outputs?.output\n      )}\"`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a tool run.\n   * @param run The tool run that has errored.\n   * @returns void\n   */\n  onToolError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Tool run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the start of a retriever run.\n   * @param run The retriever run that has started.\n   * @returns void\n   */\n  onRetrieverStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[retriever/start]\"\n      )} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(\n        run.inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of a retriever run.\n   * @param run The retriever run that has ended.\n   * @returns void\n   */\n  onRetrieverEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Retriever run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[outputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a retriever run.\n   * @param run The retriever run that has errored.\n   * @returns void\n   */\n  onRetrieverError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Retriever run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the action selected by the agent.\n   * @param run The run in which the agent action occurred.\n   * @returns void\n   */\n  onAgentAction(run: Run) {\n    const agentRun = run as AgentRun;\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.blue,\n        \"[agent/action]\"\n      )} [${crumbs}] Agent selected action: ${tryJsonStringify(\n        agentRun.actions[agentRun.actions.length - 1],\n        \"[action]\"\n      )}`\n    );\n  }\n}\n"],"names":["style: CSPair","text: string","obj: unknown","fallback: string","value: unknown","run: Run","elapsed","_run: Run","parents: Run[]"],"mappings":"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"}},
    {"offset": {"line": 2217, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/tracer_langchain.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/tracer_langchain.ts"],"sourcesContent":["import {\n  type Client,\n  type LangSmithTracingClientInterface,\n  getDefaultProjectName,\n} from \"langsmith\";\nimport { RunTree, type RunTreeConfig } from \"langsmith/run_trees\";\nimport { getCurrentRunTree } from \"langsmith/singletons/traceable\";\n\nimport {\n  BaseRun,\n  RunCreate,\n  RunUpdate as BaseRunUpdate,\n  KVMap,\n} from \"langsmith/schemas\";\nimport { BaseTracer } from \"./base.js\";\nimport { BaseCallbackHandlerInput } from \"../callbacks/base.js\";\nimport { getDefaultLangChainClientSingleton } from \"../singletons/tracer.js\";\n\nexport interface Run extends BaseRun {\n  id: string;\n  child_runs: this[];\n  child_execution_order: number;\n  dotted_order?: string;\n  trace_id?: string;\n}\n\nexport interface RunCreate2 extends RunCreate {\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface RunUpdate extends BaseRunUpdate {\n  events: BaseRun[\"events\"];\n  inputs: KVMap;\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface LangChainTracerFields extends BaseCallbackHandlerInput {\n  exampleId?: string;\n  projectName?: string;\n  client?: LangSmithTracingClientInterface;\n  replicas?: RunTreeConfig[\"replicas\"];\n}\n\nexport class LangChainTracer\n  extends BaseTracer\n  implements LangChainTracerFields\n{\n  name = \"langchain_tracer\";\n\n  projectName?: string;\n\n  exampleId?: string;\n\n  client: LangSmithTracingClientInterface;\n\n  replicas?: RunTreeConfig[\"replicas\"];\n\n  usesRunTreeMap = true;\n\n  constructor(fields: LangChainTracerFields = {}) {\n    super(fields);\n    const { exampleId, projectName, client, replicas } = fields;\n\n    this.projectName = projectName ?? getDefaultProjectName();\n    this.replicas = replicas;\n    this.exampleId = exampleId;\n    this.client = client ?? getDefaultLangChainClientSingleton();\n\n    const traceableTree = LangChainTracer.getTraceableRunTree();\n    if (traceableTree) {\n      this.updateFromRunTree(traceableTree);\n    }\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // empty\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.postRun();\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.patchRun();\n  }\n\n  getRun(id: string): Run | undefined {\n    return this.runTreeMap.get(id);\n  }\n\n  updateFromRunTree(runTree: RunTree) {\n    this.runTreeMap.set(runTree.id, runTree);\n    let rootRun: RunTree = runTree;\n    const visited = new Set<string>();\n    while (rootRun.parent_run) {\n      if (visited.has(rootRun.id)) break;\n      visited.add(rootRun.id);\n\n      if (!rootRun.parent_run) break;\n      rootRun = rootRun.parent_run as RunTree;\n    }\n    visited.clear();\n\n    const queue = [rootRun];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      if (!current || visited.has(current.id)) continue;\n      visited.add(current.id);\n\n      this.runTreeMap.set(current.id, current);\n      if (current.child_runs) {\n        queue.push(...current.child_runs);\n      }\n    }\n\n    this.client = runTree.client ?? this.client;\n    this.replicas = runTree.replicas ?? this.replicas;\n    this.projectName = runTree.project_name ?? this.projectName;\n    this.exampleId = runTree.reference_example_id ?? this.exampleId;\n  }\n\n  getRunTreeWithTracingConfig(id: string): RunTree | undefined {\n    const runTree = this.runTreeMap.get(id);\n    if (!runTree) return undefined;\n\n    return new RunTree({\n      ...runTree,\n      client: this.client as Client,\n      project_name: this.projectName,\n      replicas: this.replicas,\n      reference_example_id: this.exampleId,\n      tracingEnabled: true,\n    });\n  }\n\n  static getTraceableRunTree(): RunTree | undefined {\n    try {\n      return (\n        // The type cast here provides forward compatibility. Old versions of LangSmith will just\n        // ignore the permitAbsentRunTree arg.\n        (\n          getCurrentRunTree as (\n            permitAbsentRunTree: boolean\n          ) => ReturnType<typeof getCurrentRunTree> | undefined\n        )(true)\n      );\n    } catch {\n      return undefined;\n    }\n  }\n}\n"],"names":["fields: LangChainTracerFields","_run: Run","run: Run","id: string","runTree: RunTree","rootRun: RunTree"],"mappings":"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"}},
    {"offset": {"line": 2324, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/log_stream.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/log_stream.ts"],"sourcesContent":["import {\n  applyPatch,\n  type Operation as JSONPatchOperation,\n} from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer, type Run } from \"./base.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  CallbackHandlerPrefersStreaming,\n  HandleLLMNewTokenCallbackFields,\n} from \"../callbacks/base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ChatGenerationChunk, GenerationChunk } from \"../outputs.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport type { StreamEvent, StreamEventData } from \"./event_stream.js\";\n\nexport type { StreamEvent, StreamEventData };\n\n/**\n * Interface that represents the structure of a log entry in the\n * `LogStreamCallbackHandler`.\n */\nexport type LogEntry = {\n  /** ID of the sub-run. */\n  id: string;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n  /** List of tags for the run. */\n  tags: string[];\n  /** Key-value pairs of metadata for the run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  /** ISO-8601 timestamp of when the run started. */\n  start_time: string;\n  /** List of general output chunks streamed by this run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** List of LLM tokens streamed by this run, if applicable. */\n  streamed_output_str: string[];\n  /** Inputs to this run. Not available currently via streamLog. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputs?: any;\n  /** Final output of this run. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /** ISO-8601 timestamp of when the run ended. Only available after the run has finished. */\n  end_time?: string;\n};\n\nexport type RunState = {\n  /** ID of the sub-run. */\n  id: string;\n  /** List of output chunks streamed by Runnable.stream() */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** Final output of the run, usually the result of aggregating streamed_output. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /**\n   * List of sub-runs contained in this run, if any, in the order they were started.\n   * If filters were supplied, this list will contain only the runs that matched the filters.\n   */\n  logs: Record<string, LogEntry>;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n};\n\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n  ops: JSONPatchOperation[];\n\n  constructor(fields: { ops?: JSONPatchOperation[] }) {\n    this.ops = fields.ops ?? [];\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch({}, ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport class RunLog extends RunLogPatch {\n  state: RunState;\n\n  constructor(fields: { ops?: JSONPatchOperation[]; state: RunState }) {\n    super(fields);\n    this.state = fields.state;\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch(this.state, other.ops);\n    return new RunLog({ ops, state: states[states.length - 1].newDocument });\n  }\n\n  static fromRunLogPatch(patch: RunLogPatch) {\n    const states = applyPatch({}, patch.ops);\n    return new RunLog({\n      ops: patch.ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport type SchemaFormat = \"original\" | \"streaming_events\";\n\nexport interface LogStreamCallbackHandlerInput\n  extends BaseCallbackHandlerInput {\n  autoClose?: boolean;\n  includeNames?: string[];\n  includeTypes?: string[];\n  includeTags?: string[];\n  excludeNames?: string[];\n  excludeTypes?: string[];\n  excludeTags?: string[];\n  _schemaFormat?: SchemaFormat;\n}\n\nexport const isLogStreamHandler = (\n  handler: BaseCallbackHandler\n): handler is LogStreamCallbackHandler => handler.name === \"log_stream_tracer\";\n\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run: Run, schemaFormat: SchemaFormat) {\n  if (schemaFormat === \"original\") {\n    throw new Error(\n      \"Do not assign inputs with original schema drop the key for now. \" +\n        \"When inputs are added to streamLog they should be added with \" +\n        \"standardized schema for streaming events.\"\n    );\n  }\n\n  const { inputs } = run;\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return inputs;\n  }\n\n  if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n    return undefined;\n  }\n\n  // new style chains\n  // These nest an additional 'input' key inside the 'inputs' to make sure\n  // the input is always a dict. We need to unpack and user the inner value.\n  // We should try to fix this in Runnables and callbacks/tracers\n  // Runnables should be using a null type here not a placeholder\n  // dict.\n  return inputs.input;\n}\n\nasync function _getStandardizedOutputs(run: Run, schemaFormat: SchemaFormat) {\n  const { outputs } = run;\n  if (schemaFormat === \"original\") {\n    // Return the old schema, without standardizing anything\n    return outputs;\n  }\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return outputs;\n  }\n\n  // TODO: Remove this hacky check\n  if (\n    outputs !== undefined &&\n    Object.keys(outputs).length === 1 &&\n    outputs?.output !== undefined\n  ) {\n    return outputs.output;\n  }\n\n  return outputs;\n}\n\nfunction isChatGenerationChunk(\n  x?: ChatGenerationChunk | GenerationChunk\n): x is ChatGenerationChunk {\n  return x !== undefined && (x as ChatGenerationChunk).message !== undefined;\n}\n\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler\n  extends BaseTracer\n  implements CallbackHandlerPrefersStreaming\n{\n  protected autoClose = true;\n\n  protected includeNames?: string[];\n\n  protected includeTypes?: string[];\n\n  protected includeTags?: string[];\n\n  protected excludeNames?: string[];\n\n  protected excludeTypes?: string[];\n\n  protected excludeTags?: string[];\n\n  protected _schemaFormat: SchemaFormat = \"original\";\n\n  protected rootId?: string;\n\n  private keyMapByRunId: Record<string, string> = {};\n\n  private counterMapByRunName: Record<string, number> = {};\n\n  protected transformStream: TransformStream;\n\n  public writer: WritableStreamDefaultWriter;\n\n  public receiveStream: IterableReadableStream<RunLogPatch>;\n\n  name = \"log_stream_tracer\";\n\n  lc_prefer_streaming = true;\n\n  constructor(fields?: LogStreamCallbackHandlerInput) {\n    super({ _awaitHandler: true, ...fields });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(\n      this.transformStream.readable\n    );\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n\n  _includeRun(run: Run): boolean {\n    if (run.id === this.rootId) {\n      return false;\n    }\n    const runTags = run.tags ?? [];\n    let include =\n      this.includeNames === undefined &&\n      this.includeTags === undefined &&\n      this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.run_type);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include ||\n        runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.run_type);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n\n  async *tapOutputIterable<T>(\n    runId: string,\n    output: AsyncGenerator<T>\n  ): AsyncGenerator<T> {\n    // Tap an output async iterator to stream its values to the log.\n    for await (const chunk of output) {\n      // root run is handled in .streamLog()\n      if (runId !== this.rootId) {\n        // if we can't find the run silently ignore\n        // eg. because this run wasn't included in the log\n        const key = this.keyMapByRunId[runId];\n        if (key) {\n          await this.writer.write(\n            new RunLogPatch({\n              ops: [\n                {\n                  op: \"add\",\n                  path: `/logs/${key}/streamed_output/-`,\n                  value: chunk,\n                },\n              ],\n            })\n          );\n        }\n      }\n      yield chunk;\n    }\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    if (this.rootId === undefined) {\n      this.rootId = run.id;\n      await this.writer.write(\n        new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"\",\n              value: {\n                id: run.id,\n                name: run.name,\n                type: run.run_type,\n                streamed_output: [],\n                final_output: undefined,\n                logs: {},\n              },\n            },\n          ],\n        })\n      );\n    }\n\n    if (!this._includeRun(run)) {\n      return;\n    }\n\n    if (this.counterMapByRunName[run.name] === undefined) {\n      this.counterMapByRunName[run.name] = 0;\n    }\n    this.counterMapByRunName[run.name] += 1;\n    const count = this.counterMapByRunName[run.name];\n    this.keyMapByRunId[run.id] =\n      count === 1 ? run.name : `${run.name}:${count}`;\n\n    const logEntry: LogEntry = {\n      id: run.id,\n      name: run.name,\n      type: run.run_type,\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      start_time: new Date(run.start_time).toISOString(),\n      streamed_output: [],\n      streamed_output_str: [],\n      final_output: undefined,\n      end_time: undefined,\n    };\n\n    if (this._schemaFormat === \"streaming_events\") {\n      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n    }\n\n    await this.writer.write(\n      new RunLogPatch({\n        ops: [\n          {\n            op: \"add\",\n            path: `/logs/${this.keyMapByRunId[run.id]}`,\n            value: logEntry,\n          },\n        ],\n      })\n    );\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    try {\n      const runName = this.keyMapByRunId[run.id];\n      if (runName === undefined) {\n        return;\n      }\n      const ops: JSONPatchOperation[] = [];\n      if (this._schemaFormat === \"streaming_events\") {\n        ops.push({\n          op: \"replace\",\n          path: `/logs/${runName}/inputs`,\n          value: await _getStandardizedInputs(run, this._schemaFormat),\n        });\n      }\n      ops.push({\n        op: \"add\",\n        path: `/logs/${runName}/final_output`,\n        value: await _getStandardizedOutputs(run, this._schemaFormat),\n      });\n      if (run.end_time !== undefined) {\n        ops.push({\n          op: \"add\",\n          path: `/logs/${runName}/end_time`,\n          value: new Date(run.end_time).toISOString(),\n        });\n      }\n      const patch = new RunLogPatch({ ops });\n      await this.writer.write(patch);\n    } finally {\n      if (run.id === this.rootId) {\n        const patch = new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"/final_output\",\n              value: await _getStandardizedOutputs(run, this._schemaFormat),\n            },\n          ],\n        });\n        await this.writer.write(patch);\n        if (this.autoClose) {\n          await this.writer.close();\n        }\n      }\n    }\n  }\n\n  async onLLMNewToken(\n    run: Run,\n    token: string,\n    kwargs?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    const runName = this.keyMapByRunId[run.id];\n    if (runName === undefined) {\n      return;\n    }\n    // TODO: Remove hack\n    const isChatModel = run.inputs.messages !== undefined;\n    let streamedOutputValue;\n    if (isChatModel) {\n      if (isChatGenerationChunk(kwargs?.chunk)) {\n        streamedOutputValue = kwargs?.chunk;\n      } else {\n        streamedOutputValue = new AIMessageChunk({\n          id: `run-${run.id}`,\n          content: token,\n        });\n      }\n    } else {\n      streamedOutputValue = token;\n    }\n    const patch = new RunLogPatch({\n      ops: [\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output_str/-`,\n          value: token,\n        },\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output/-`,\n          value: streamedOutputValue,\n        },\n      ],\n    });\n    await this.writer.write(patch);\n  }\n}\n"],"names":["fields: { ops?: JSONPatchOperation[] }","other: RunLogPatch","fields: { ops?: JSONPatchOperation[]; state: RunState }","patch: RunLogPatch","handler: BaseCallbackHandler","run: Run","schemaFormat: SchemaFormat","x?: ChatGenerationChunk | GenerationChunk","fields?: LogStreamCallbackHandlerInput","_run: Run","runId: string","output: AsyncGenerator<T>","logEntry: LogEntry","ops: JSONPatchOperation[]","token: string","kwargs?: HandleLLMNewTokenCallbackFields"],"mappings":"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"}},
    {"offset": {"line": 2629, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/event_stream.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/event_stream.ts"],"sourcesContent":["import { BaseTracer, type Run } from \"./base.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  CallbackHandlerPrefersStreaming,\n} from \"../callbacks/base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport { ChatGeneration, Generation, GenerationChunk } from \"../outputs.js\";\nimport { BaseMessage } from \"../messages/base.js\";\n\n/**\n * Data associated with a StreamEvent.\n */\nexport type StreamEventData = {\n  /**\n   * The input passed to the runnable that generated the event.\n   * Inputs will sometimes be available at the *START* of the runnable, and\n   * sometimes at the *END* of the runnable.\n   * If a runnable is able to stream its inputs, then its input by definition\n   * won't be known until the *END* of the runnable when it has finished streaming\n   * its inputs.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any;\n\n  /**\n   * The output of the runnable that generated the event.\n   * Outputs will only be available at the *END* of the runnable.\n   * For most runnables, this field can be inferred from the `chunk` field,\n   * though there might be some exceptions for special cased runnables (e.g., like\n   * chat models), which may return more information.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  output?: any;\n\n  /**\n   * A streaming chunk from the output that generated the event.\n   * chunks support addition in general, and adding them up should result\n   * in the output of the runnable that generated the event.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  chunk?: any;\n};\n\n/**\n * A streaming event.\n *\n * Schema of a streaming event which is produced from the streamEvents method.\n */\nexport type StreamEvent = {\n  /**\n   * Event names are of the format: on_[runnable_type]_(start|stream|end).\n   *\n   * Runnable types are one of:\n   * - llm - used by non chat models\n   * - chat_model - used by chat models\n   * - prompt --  e.g., ChatPromptTemplate\n   * - tool -- LangChain tools\n   * - chain - most Runnables are of this type\n   *\n   * Further, the events are categorized as one of:\n   * - start - when the runnable starts\n   * - stream - when the runnable is streaming\n   * - end - when the runnable ends\n   *\n   * start, stream and end are associated with slightly different `data` payload.\n   *\n   * Please see the documentation for `EventData` for more details.\n   */\n  event: string;\n  /** The name of the runnable that generated the event. */\n  name: string;\n  /**\n   * An randomly generated ID to keep track of the execution of the given runnable.\n   *\n   * Each child runnable that gets invoked as part of the execution of a parent runnable\n   * is assigned its own unique ID.\n   */\n  run_id: string;\n  /**\n   * Tags associated with the runnable that generated this event.\n   * Tags are always inherited from parent runnables.\n   */\n  tags?: string[];\n  /** Metadata associated with the runnable that generated this event. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  /**\n   * Event data.\n   *\n   * The contents of the event data depend on the event type.\n   */\n  data: StreamEventData;\n};\n\ntype RunInfo = {\n  name: string;\n  tags: string[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  runType: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputs?: Record<string, any>;\n};\n\nexport interface EventStreamCallbackHandlerInput\n  extends BaseCallbackHandlerInput {\n  autoClose?: boolean;\n  includeNames?: string[];\n  includeTypes?: string[];\n  includeTags?: string[];\n  excludeNames?: string[];\n  excludeTypes?: string[];\n  excludeTags?: string[];\n}\n\nfunction assignName({\n  name,\n  serialized,\n}: {\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serialized?: Record<string, any>;\n}): string {\n  if (name !== undefined) {\n    return name;\n  }\n  if (serialized?.name !== undefined) {\n    return serialized.name;\n  } else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n    return serialized.id[serialized.id.length - 1];\n  }\n  return \"Unnamed\";\n}\n\nexport const isStreamEventsHandler = (\n  handler: BaseCallbackHandler\n): handler is EventStreamCallbackHandler =>\n  handler.name === \"event_stream_tracer\";\n\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class EventStreamCallbackHandler\n  extends BaseTracer\n  implements CallbackHandlerPrefersStreaming\n{\n  protected autoClose = true;\n\n  protected includeNames?: string[];\n\n  protected includeTypes?: string[];\n\n  protected includeTags?: string[];\n\n  protected excludeNames?: string[];\n\n  protected excludeTypes?: string[];\n\n  protected excludeTags?: string[];\n\n  private runInfoMap: Map<string, RunInfo> = new Map();\n\n  private tappedPromises: Map<string, Promise<void>> = new Map();\n\n  protected transformStream: TransformStream;\n\n  public writer: WritableStreamDefaultWriter;\n\n  public receiveStream: IterableReadableStream<StreamEvent>;\n\n  name = \"event_stream_tracer\";\n\n  lc_prefer_streaming = true;\n\n  constructor(fields?: EventStreamCallbackHandlerInput) {\n    super({ _awaitHandler: true, ...fields });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(\n      this.transformStream.readable\n    );\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n\n  _includeRun(run: RunInfo): boolean {\n    const runTags = run.tags ?? [];\n    let include =\n      this.includeNames === undefined &&\n      this.includeTags === undefined &&\n      this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.runType);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include ||\n        runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.runType);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n\n  async *tapOutputIterable<T>(\n    runId: string,\n    outputStream: AsyncGenerator<T>\n  ): AsyncGenerator<T> {\n    const firstChunk = await outputStream.next();\n    if (firstChunk.done) {\n      return;\n    }\n    const runInfo = this.runInfoMap.get(runId);\n    // Run has finished, don't issue any stream events.\n    // An example of this is for runnables that use the default\n    // implementation of .stream(), which delegates to .invoke()\n    // and calls .onChainEnd() before passing it to the iterator.\n    if (runInfo === undefined) {\n      yield firstChunk.value;\n      return;\n    }\n    // Match format from handlers below\n    function _formatOutputChunk(eventType: string, data: unknown) {\n      if (eventType === \"llm\" && typeof data === \"string\") {\n        return new GenerationChunk({ text: data });\n      }\n      return data;\n    }\n    let tappedPromise = this.tappedPromises.get(runId);\n    // if we are the first to tap, issue stream events\n    if (tappedPromise === undefined) {\n      let tappedPromiseResolver: (() => void) | undefined;\n      tappedPromise = new Promise((resolve) => {\n        tappedPromiseResolver = resolve;\n      });\n      this.tappedPromises.set(runId, tappedPromise);\n      try {\n        const event: StreamEvent = {\n          event: `on_${runInfo.runType}_stream`,\n          run_id: runId,\n          name: runInfo.name,\n          tags: runInfo.tags,\n          metadata: runInfo.metadata,\n          data: {},\n        };\n        await this.send(\n          {\n            ...event,\n            data: {\n              chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n            },\n          },\n          runInfo\n        );\n        yield firstChunk.value;\n        for await (const chunk of outputStream) {\n          // Don't yield tool and retriever stream events\n          if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n            await this.send(\n              {\n                ...event,\n                data: {\n                  chunk: _formatOutputChunk(runInfo.runType, chunk),\n                },\n              },\n              runInfo\n            );\n          }\n          yield chunk;\n        }\n      } finally {\n        tappedPromiseResolver?.();\n        // Don't delete from the promises map to keep track of which runs have been tapped.\n      }\n    } else {\n      // otherwise just pass through\n      yield firstChunk.value;\n      for await (const chunk of outputStream) {\n        yield chunk;\n      }\n    }\n  }\n\n  async send(payload: StreamEvent, run: RunInfo) {\n    if (this._includeRun(run)) {\n      await this.writer.write(payload);\n    }\n  }\n\n  async sendEndEvent(payload: StreamEvent, run: RunInfo) {\n    const tappedPromise = this.tappedPromises.get(payload.run_id);\n    if (tappedPromise !== undefined) {\n      // eslint-disable-next-line no-void\n      void tappedPromise.then(() => {\n        // eslint-disable-next-line no-void\n        void this.send(payload, run);\n      });\n    } else {\n      await this.send(payload, run);\n    }\n  }\n\n  async onLLMStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: run.inputs,\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    const eventName = `on_${runType}_start`;\n    await this.send(\n      {\n        event: eventName,\n        data: {\n          input: run.inputs,\n        },\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onLLMNewToken(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    let chunk;\n    let eventName;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n    }\n    // Top-level streaming events are covered by tapOutputIterable\n    if (this.runInfoMap.size === 1) {\n      return;\n    }\n    if (runInfo.runType === \"chat_model\") {\n      eventName = \"on_chat_model_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new AIMessageChunk({ content: token, id: `run-${run.id}` });\n      } else {\n        chunk = kwargs.chunk.message;\n      }\n    } else if (runInfo.runType === \"llm\") {\n      eventName = \"on_llm_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new GenerationChunk({ text: token });\n      } else {\n        chunk = kwargs.chunk;\n      }\n    } else {\n      throw new Error(`Unexpected run type ${runInfo.runType}`);\n    }\n    await this.send(\n      {\n        event: eventName,\n        data: {\n          chunk,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onLLMEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    let eventName: string;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const generations: ChatGeneration[][] | Generation[][] | undefined =\n      run.outputs?.generations;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let output: BaseMessage | Record<string, any> | undefined;\n    if (runInfo.runType === \"chat_model\") {\n      for (const generation of generations ?? []) {\n        if (output !== undefined) {\n          break;\n        }\n        output = (generation[0] as ChatGeneration | undefined)?.message;\n      }\n      eventName = \"on_chat_model_end\";\n    } else if (runInfo.runType === \"llm\") {\n      output = {\n        generations: generations?.map((generation) => {\n          return generation.map((chunk) => {\n            return {\n              text: chunk.text,\n              generationInfo: chunk.generationInfo,\n            };\n          });\n        }),\n        llmOutput: run.outputs?.llmOutput ?? {},\n      };\n      eventName = \"on_llm_end\";\n    } else {\n      throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n    }\n    await this.sendEndEvent(\n      {\n        event: eventName,\n        data: {\n          output,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onChainStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = run.run_type ?? \"chain\";\n    const runInfo: RunInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: run.run_type,\n    };\n    let eventData: StreamEventData = {};\n    // Workaround Runnable core code not sending input when transform streaming.\n    if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n      eventData = {};\n      runInfo.inputs = {};\n    } else if (run.inputs.input !== undefined) {\n      eventData.input = run.inputs.input;\n      runInfo.inputs = run.inputs.input;\n    } else {\n      eventData.input = run.inputs;\n      runInfo.inputs = run.inputs;\n    }\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: `on_${runType}_start`,\n        data: eventData,\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onChainEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const eventName = `on_${run.run_type}_end`;\n    const inputs = run.inputs ?? runInfo.inputs ?? {};\n    const outputs = run.outputs?.output ?? run.outputs;\n    const data: StreamEventData = {\n      output: outputs,\n      input: inputs,\n    };\n    if (inputs.input && Object.keys(inputs).length === 1) {\n      data.input = inputs.input;\n      runInfo.inputs = inputs.input;\n    }\n    await this.sendEndEvent(\n      {\n        event: eventName,\n        data,\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onToolStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: \"tool\",\n      inputs: run.inputs ?? {},\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: \"on_tool_start\",\n        data: {\n          input: run.inputs ?? {},\n        },\n        name: runName,\n        run_id: run.id,\n        tags: run.tags ?? [],\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onToolEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n    }\n    if (runInfo.inputs === undefined) {\n      throw new Error(\n        `onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`\n      );\n    }\n    const output =\n      run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n    await this.sendEndEvent(\n      {\n        event: \"on_tool_end\",\n        data: {\n          output,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onRetrieverStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = \"retriever\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: {\n        query: run.inputs.query,\n      },\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: \"on_retriever_start\",\n        data: {\n          input: {\n            query: run.inputs.query,\n          },\n        },\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onRetrieverEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n    }\n    await this.sendEndEvent(\n      {\n        event: \"on_retriever_end\",\n        data: {\n          output: run.outputs?.documents ?? run.outputs,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleCustomEvent(eventName: string, data: any, runId: string) {\n    const runInfo = this.runInfoMap.get(runId);\n    if (runInfo === undefined) {\n      throw new Error(\n        `handleCustomEvent: Run ID ${runId} not found in run map.`\n      );\n    }\n    await this.send(\n      {\n        event: \"on_custom_event\",\n        run_id: runId,\n        name: eventName,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n        data,\n      },\n      runInfo\n    );\n  }\n\n  async finish() {\n    const pendingPromises = [...this.tappedPromises.values()];\n    // eslint-disable-next-line no-void\n    void Promise.all(pendingPromises).finally(() => {\n      // eslint-disable-next-line no-void\n      void this.writer.close();\n    });\n  }\n}\n"],"names":["handler: BaseCallbackHandler","fields?: EventStreamCallbackHandlerInput","_run: Run","run: RunInfo","runId: string","outputStream: AsyncGenerator<T>","eventType: string","data: unknown","tappedPromiseResolver: (() => void) | undefined","event: StreamEvent","payload: StreamEvent","run: Run","token: string","kwargs?: { chunk: any }","eventName: string","generations: ChatGeneration[][] | Generation[][] | undefined","output: BaseMessage | Record<string, any> | undefined","runInfo: RunInfo","eventData: StreamEventData","data: StreamEventData","data: any"],"mappings":"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"}},
    {"offset": {"line": 3021, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/tracers/root_listener.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/tracers/root_listener.ts"],"sourcesContent":["import { RunnableConfig } from \"../runnables/config.js\";\nimport { BaseTracer, Run } from \"./base.js\";\n\nexport class RootListenersTracer extends BaseTracer {\n  name = \"RootListenersTracer\";\n\n  /** The Run's ID. Type UUID */\n  rootId?: string;\n\n  config: RunnableConfig;\n\n  argOnStart?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  argOnEnd?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  argOnError?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  constructor({\n    config,\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    config: RunnableConfig;\n    onStart?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n  }) {\n    super({ _awaitHandler: true });\n    this.config = config;\n    this.argOnStart = onStart;\n    this.argOnEnd = onEnd;\n    this.argOnError = onError;\n  }\n\n  /**\n   * This is a legacy method only called once for an entire run tree\n   * therefore not useful here\n   * @param {Run} _ Not used\n   */\n  persistRun(_: Run): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async onRunCreate(run: Run) {\n    if (this.rootId) {\n      return;\n    }\n\n    this.rootId = run.id;\n\n    if (this.argOnStart) {\n      await this.argOnStart(run, this.config);\n    }\n  }\n\n  async onRunUpdate(run: Run) {\n    if (run.id !== this.rootId) {\n      return;\n    }\n    if (!run.error) {\n      if (this.argOnEnd) {\n        await this.argOnEnd(run, this.config);\n      }\n    } else if (this.argOnError) {\n      await this.argOnError(run, this.config);\n    }\n  }\n}\n"],"names":["_: Run","run: Run"],"mappings":";;;;;;;AAGA,IAAa,sBAAb,cAAyC,8KAAA,CAAW;IAClD,OAAO,sBAAA;mCAGP,OAAA;IAEA,OAAA;IAEA,WAAA;IAEA,SAAA;IAEA,WAAA;IAEA,YAAY,EACV,MAAA,EACA,OAAA,EACA,KAAA,EACA,OAAA,EAMD,CAAE;QACD,KAAA,CAAM;YAAE,eAAe;QAAM,EAAC;QAC9B,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,UAAA,GAAa;IACnB;;;;;IAOD,WAAWA,CAAAA,EAAuB;QAChC,OAAO,QAAQ,OAAA,EAAS;IACzB;IAED,MAAM,YAAYC,GAAAA,EAAU;QAC1B,IAAI,IAAA,CAAK,MAAA,CACP,CAAA;QAGF,IAAA,CAAK,MAAA,GAAS,IAAI,EAAA;QAElB,IAAI,IAAA,CAAK,UAAA,EACP,MAAM,IAAA,CAAK,UAAA,CAAW,KAAK,IAAA,CAAK,MAAA,CAAO;IAE1C;IAED,MAAM,YAAYA,GAAAA,EAAU;QAC1B,IAAI,IAAI,EAAA,KAAO,IAAA,CAAK,MAAA,CAClB,CAAA;QAEF,IAAI,CAAC,IAAI,KAAA,EACP;gBAAI,IAAA,CAAK,QAAA,EACP,MAAM,IAAA,CAAK,QAAA,CAAS,KAAK,IAAA,CAAK,MAAA,CAAO;QACtC,OAAA,IACQ,IAAA,CAAK,UAAA,EACd,MAAM,IAAA,CAAK,UAAA,CAAW,KAAK,IAAA,CAAK,MAAA,CAAO;IAE1C;AACF"}}]
}