{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/src/lib/qdrant.ts"],"sourcesContent":["import { QdrantClient } from \"@qdrant/js-client-rest\";\n\n// Qdrant configuration\nconst QDRANT_URL = process.env.QDRANT_URL || \"http://localhost:6333\";\nconst QDRANT_API_KEY = process.env.QDRANT_API_KEY;\nconst COLLECTION_NAME = process.env.QDRANT_COLLECTION_NAME || \"knowledge_base\";\n\n// OpenAI embedding dimension (text-embedding-3-small)\nconst EMBEDDING_DIMENSION = 1536;\n\nlet client: QdrantClient | null = null;\n\n/**\n * Get or create the Qdrant client singleton\n */\nexport function getClient(): QdrantClient {\n  if (!client) {\n    client = new QdrantClient({\n      url: QDRANT_URL,\n      apiKey: QDRANT_API_KEY,\n      // Skip version compatibility check (can fail behind reverse proxies)\n      checkCompatibility: false,\n      // Add headers for Cloudflare compatibility (undici/fetch needs these)\n      headers: {\n        \"User-Agent\": \"qdrant-js-client/1.16.1\",\n      },\n    });\n  }\n  return client;\n}\n\n/**\n * Get the collection name\n */\nexport function getCollectionName(): string {\n  return COLLECTION_NAME;\n}\n\n/**\n * Ensure the knowledge base collection exists with proper configuration\n */\nexport async function ensureCollection(): Promise<void> {\n  const qdrant = getClient();\n\n  try {\n    // Check if collection exists\n    const collections = await qdrant.getCollections();\n    const exists = collections.collections.some(\n      (c) => c.name === COLLECTION_NAME\n    );\n\n    if (!exists) {\n      // Create collection with cosine similarity for OpenAI embeddings\n      await qdrant.createCollection(COLLECTION_NAME, {\n        vectors: {\n          size: EMBEDDING_DIMENSION,\n          distance: \"Cosine\",\n        },\n        // Enable payload indexing for common filter fields\n        optimizers_config: {\n          indexing_threshold: 0,\n        },\n      });\n\n      // Create payload indexes for efficient filtering\n      await qdrant.createPayloadIndex(COLLECTION_NAME, {\n        field_name: \"doc_id\",\n        field_schema: \"keyword\",\n      });\n\n      await qdrant.createPayloadIndex(COLLECTION_NAME, {\n        field_name: \"status\",\n        field_schema: \"keyword\",\n      });\n\n      await qdrant.createPayloadIndex(COLLECTION_NAME, {\n        field_name: \"doc_type\",\n        field_schema: \"keyword\",\n      });\n\n      console.log(`Created Qdrant collection: ${COLLECTION_NAME}`);\n    }\n  } catch (error) {\n    console.error(\"Error ensuring Qdrant collection:\", error);\n    throw error;\n  }\n}\n\n/**\n * Upsert vectors into the collection\n */\nexport async function upsertVectors(\n  points: Array<{\n    id: string;\n    vector: number[];\n    payload: Record<string, unknown>;\n  }>\n): Promise<void> {\n  const qdrant = getClient();\n\n  await qdrant.upsert(COLLECTION_NAME, {\n    points: points.map((p) => ({\n      id: p.id,\n      vector: p.vector,\n      payload: p.payload,\n    })),\n  });\n}\n\n/**\n * Search for similar vectors\n */\nexport async function searchVectors(\n  vector: number[],\n  limit: number = 10,\n  filter?: Record<string, unknown>\n): Promise<\n  Array<{\n    id: string;\n    score: number;\n    payload: Record<string, unknown>;\n  }>\n> {\n  const qdrant = getClient();\n\n  const results = await qdrant.search(COLLECTION_NAME, {\n    vector,\n    limit,\n    filter: filter as never,\n    with_payload: true,\n    score_threshold: 0.5, // Only return relevant results\n  });\n\n  return results.map((r) => ({\n    id: String(r.id),\n    score: r.score,\n    payload: (r.payload as Record<string, unknown>) || {},\n  }));\n}\n\n/**\n * Delete vectors by filter (e.g., by doc_id)\n */\nexport async function deleteVectorsByFilter(\n  filter: Record<string, unknown>\n): Promise<void> {\n  const qdrant = getClient();\n\n  await qdrant.delete(COLLECTION_NAME, {\n    filter: filter as never,\n  });\n}\n\n/**\n * Get collection info for debugging\n */\nexport async function getCollectionInfo(): Promise<unknown> {\n  const qdrant = getClient();\n  return qdrant.getCollection(COLLECTION_NAME);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;AAEA,uBAAuB;AACvB,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAC7C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc;AACjD,MAAM,kBAAkB,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AAE9D,sDAAsD;AACtD,MAAM,sBAAsB;AAE5B,IAAI,SAA8B;AAK3B,SAAS;IACd,IAAI,CAAC,QAAQ;QACX,SAAS,IAAI,qMAAY,CAAC;YACxB,KAAK;YACL,QAAQ;YACR,qEAAqE;YACrE,oBAAoB;YACpB,sEAAsE;YACtE,SAAS;gBACP,cAAc;YAChB;QACF;IACF;IACA,OAAO;AACT;AAKO,SAAS;IACd,OAAO;AACT;AAKO,eAAe;IACpB,MAAM,SAAS;IAEf,IAAI;QACF,6BAA6B;QAC7B,MAAM,cAAc,MAAM,OAAO,cAAc;QAC/C,MAAM,SAAS,YAAY,WAAW,CAAC,IAAI,CACzC,CAAC,IAAM,EAAE,IAAI,KAAK;QAGpB,IAAI,CAAC,QAAQ;YACX,iEAAiE;YACjE,MAAM,OAAO,gBAAgB,CAAC,iBAAiB;gBAC7C,SAAS;oBACP,MAAM;oBACN,UAAU;gBACZ;gBACA,mDAAmD;gBACnD,mBAAmB;oBACjB,oBAAoB;gBACtB;YACF;YAEA,iDAAiD;YACjD,MAAM,OAAO,kBAAkB,CAAC,iBAAiB;gBAC/C,YAAY;gBACZ,cAAc;YAChB;YAEA,MAAM,OAAO,kBAAkB,CAAC,iBAAiB;gBAC/C,YAAY;gBACZ,cAAc;YAChB;YAEA,MAAM,OAAO,kBAAkB,CAAC,iBAAiB;gBAC/C,YAAY;gBACZ,cAAc;YAChB;YAEA,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,iBAAiB;QAC7D;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;QACnD,MAAM;IACR;AACF;AAKO,eAAe,cACpB,MAIE;IAEF,MAAM,SAAS;IAEf,MAAM,OAAO,MAAM,CAAC,iBAAiB;QACnC,QAAQ,OAAO,GAAG,CAAC,CAAC,IAAM,CAAC;gBACzB,IAAI,EAAE,EAAE;gBACR,QAAQ,EAAE,MAAM;gBAChB,SAAS,EAAE,OAAO;YACpB,CAAC;IACH;AACF;AAKO,eAAe,cACpB,MAAgB,EAChB,QAAgB,EAAE,EAClB,MAAgC;IAQhC,MAAM,SAAS;IAEf,MAAM,UAAU,MAAM,OAAO,MAAM,CAAC,iBAAiB;QACnD;QACA;QACA,QAAQ;QACR,cAAc;QACd,iBAAiB;IACnB;IAEA,OAAO,QAAQ,GAAG,CAAC,CAAC,IAAM,CAAC;YACzB,IAAI,OAAO,EAAE,EAAE;YACf,OAAO,EAAE,KAAK;YACd,SAAS,AAAC,EAAE,OAAO,IAAgC,CAAC;QACtD,CAAC;AACH;AAKO,eAAe,sBACpB,MAA+B;IAE/B,MAAM,SAAS;IAEf,MAAM,OAAO,MAAM,CAAC,iBAAiB;QACnC,QAAQ;IACV;AACF;AAKO,eAAe;IACpB,MAAM,SAAS;IACf,OAAO,OAAO,aAAa,CAAC;AAC9B"}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/src/app/api/health/qdrant/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getClient, getCollectionName } from \"@/lib/qdrant\";\n\nexport async function GET(): Promise<NextResponse> {\n  try {\n    const client = getClient();\n    const collection = getCollectionName();\n    const info = await client.getCollection(collection);\n\n    return NextResponse.json({\n      ok: true,\n      collection,\n      vectors_count: info.points_count ?? info.indexed_vectors_count ?? 0,\n      status: info.status,\n    });\n  } catch (error) {\n    return NextResponse.json(\n      {\n        ok: false,\n        error: (error as Error).message,\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,SAAS,IAAA,mIAAS;QACxB,MAAM,aAAa,IAAA,2IAAiB;QACpC,MAAM,OAAO,MAAM,OAAO,aAAa,CAAC;QAExC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,IAAI;YACJ;YACA,eAAe,KAAK,YAAY,IAAI,KAAK,qBAAqB,IAAI;YAClE,QAAQ,KAAK,MAAM;QACrB;IACF,EAAE,OAAO,OAAO;QACd,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,IAAI;YACJ,OAAO,AAAC,MAAgB,OAAO;QACjC,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}