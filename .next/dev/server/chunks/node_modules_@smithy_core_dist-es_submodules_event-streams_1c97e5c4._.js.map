{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                        break;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AACO,MAAM;IACT,WAAW;IACX,WAAW;IACX,aAAa;IACb,aAAa;IACb,mBAAmB;IACnB,YAAY,EAAE,UAAU,EAAE,UAAU,EAAE,YAAY,EAAE,YAAY,EAAE,kBAAkB,EAAG,CAAE;QACrF,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,kBAAkB,GAAG;IAC9B;IACA,MAAM,qBAAqB,EAAE,WAAW,EAAE,aAAa,EAAE,cAAc,EAAG,EAAE;QACxE,MAAM,aAAa,IAAI,CAAC,UAAU;QAClC,MAAM,oBAAoB,cAAc,oBAAoB;QAC5D,MAAM,cAAc,cAAc,eAAe,CAAC;QAClD,MAAM,aAAa,IAAI,CAAC,UAAU;QAClC,MAAM,qBAAqB,IAAI,CAAC,kBAAkB;QAClD,MAAM,uBAAuB,OAAO;QACpC,MAAM,sBAAsB;YACxB,OAAO,CAAC,OAAO,aAAa,CAAC;gBACzB,IAAI,gBAAgB;oBAChB,MAAM,UAAU;wBACZ,eAAe;4BAAE,MAAM;4BAAU,OAAO;wBAAkB;wBAC1D,iBAAiB;4BAAE,MAAM;4BAAU,OAAO;wBAAQ;wBAClD,iBAAiB;4BAAE,MAAM;4BAAU,OAAO;wBAAmB;oBACjE;oBACA,WAAW,KAAK,CAAC,eAAe;oBAChC,MAAM,OAAO,WAAW,KAAK;oBAC7B,MAAM;wBACF,CAAC,qBAAqB,EAAE;wBACxB;wBACA;oBACJ;gBACJ;gBACA,WAAW,MAAM,QAAQ,YAAa;oBAClC,MAAM;gBACV;YACJ;QACJ;QACA,OAAO,WAAW,SAAS,CAAC,qBAAqB,CAAC;YAC9C,IAAI,KAAK,CAAC,qBAAqB,EAAE;gBAC7B,OAAO;oBACH,SAAS,MAAM,OAAO;oBACtB,MAAM,MAAM,IAAI;gBACpB;YACJ;YACA,MAAM,cAAc,OAAO,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC;gBACzC,OAAO,QAAQ;YACnB,MAAM;YACN,MAAM,EAAE,iBAAiB,EAAE,IAAI,EAAE,SAAS,EAAE,0BAA0B,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,aAAa;YACzH,MAAM,UAAU;gBACZ,eAAe;oBAAE,MAAM;oBAAU,OAAO;gBAAU;gBAClD,iBAAiB;oBAAE,MAAM;oBAAU,OAAO;gBAAQ;gBAClD,iBAAiB;oBAAE,MAAM;oBAAU,OAAO,8BAA8B;gBAAmB;gBAC3F,GAAG,iBAAiB;YACxB;YACA,OAAO;gBACH;gBACA;YACJ;QACJ;IACJ;IACA,MAAM,uBAAuB,EAAE,QAAQ,EAAE,cAAc,EAAE,wBAAwB,EAAG,EAAE;QAClF,MAAM,aAAa,IAAI,CAAC,UAAU;QAClC,MAAM,oBAAoB,eAAe,oBAAoB;QAC7D,MAAM,cAAc,eAAe,eAAe,CAAC;QACnD,MAAM,gBAAgB,YAAY,gBAAgB;QAClD,MAAM,wBAAwB,OAAO;QACrC,MAAM,gBAAgB,WAAW,WAAW,CAAC,SAAS,IAAI,EAAE,OAAO;YAC/D,MAAM,cAAc,OAAO,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC;gBACzC,OAAO,QAAQ;YACnB,MAAM;YACN,MAAM,OAAO,KAAK,CAAC,YAAY,CAAC,IAAI;YACpC,IAAI,gBAAgB,oBAAoB;gBACpC,MAAM,aAAa,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,gBAAgB;gBAChE,OAAO,UAAU,CAAC,kBAAkB;gBACpC,OAAO;oBACH,CAAC,sBAAsB,EAAE;oBACzB,GAAG,UAAU;gBACjB;YACJ,OACK,IAAI,eAAe,eAAe;gBACnC,MAAM,oBAAoB,aAAa,CAAC,YAAY;gBACpD,IAAI,kBAAkB,cAAc,IAAI;oBACpC,MAAM,MAAM,CAAC;oBACb,IAAI,cAAc;oBAClB,KAAK,MAAM,CAAC,MAAM,OAAO,IAAI,kBAAkB,cAAc,GAAI;wBAC7D,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,GAAG,OAAO,eAAe;wBAC5D,cAAc,eAAe,QAAQ,eAAe;wBACpD,IAAI,cAAc;4BACd,IAAI,OAAO,YAAY,IAAI;gCACvB,GAAG,CAAC,KAAK,GAAG;4BAChB,OACK,IAAI,OAAO,cAAc,IAAI;gCAC9B,GAAG,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,YAAY,EAAE,eAAe,4KAAM,EAAE;4BAC3D,OACK,IAAI,OAAO,cAAc,IAAI;gCAC9B,GAAG,CAAC,KAAK,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ;4BACrD;wBACJ,OACK,IAAI,aAAa;4BAClB,MAAM,QAAQ,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,EAAE;4BAChD,IAAI,SAAS,MAAM;gCACf,IAAI,OAAO,eAAe,IAAI;oCAC1B,IAAI,SAAS,OAAO,UAAU,YAAY,WAAW,OAAO;wCACxD,GAAG,CAAC,KAAK,GAAG,OAAO,MAAM,QAAQ;oCACrC,OACK;wCACD,GAAG,CAAC,KAAK,GAAG,OAAO;oCACvB;gCACJ,OACK;oCACD,GAAG,CAAC,KAAK,GAAG;gCAChB;4BACJ;wBACJ;oBACJ;oBACA,IAAI,aAAa;wBACb,OAAO;4BACH,CAAC,YAAY,EAAE;wBACnB;oBACJ;gBACJ;gBACA,OAAO;oBACH,CAAC,YAAY,EAAE,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,mBAAmB;gBACnE;YACJ,OACK;gBACD,OAAO;oBACH,UAAU;gBACd;YACJ;QACJ;QACA,MAAM,gBAAgB,aAAa,CAAC,OAAO,aAAa,CAAC;QACzD,MAAM,aAAa,MAAM,cAAc,IAAI;QAC3C,IAAI,WAAW,IAAI,EAAE;YACjB,OAAO;QACX;QACA,IAAI,WAAW,KAAK,EAAE,CAAC,sBAAsB,EAAE;YAC3C,IAAI,CAAC,gBAAgB;gBACjB,MAAM,IAAI,MAAM;YACpB;YACA,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,WAAW,KAAK,EAAG;gBACzD,wBAAwB,CAAC,IAAI,GAAG;YACpC;QACJ;QACA,OAAO;YACH,OAAO,CAAC,OAAO,aAAa,CAAC;gBACzB,IAAI,CAAC,YAAY,OAAO,CAAC,sBAAsB,EAAE;oBAC7C,MAAM,WAAW,KAAK;gBAC1B;gBACA,MAAO,KAAM;oBACT,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,cAAc,IAAI;oBAChD,IAAI,MAAM;wBACN;oBACJ;oBACA,MAAM;gBACV;YACJ;QACJ;IACJ;IACA,eAAe,WAAW,EAAE,WAAW,EAAE,KAAK,EAAE;QAC5C,MAAM,aAAa,IAAI,CAAC,UAAU;QAClC,IAAI,YAAY;QAChB,IAAI,wBAAwB;QAC5B,IAAI;QACJ,MAAM,gBAAgB,CAAC;YACnB,MAAM,SAAS,YAAY,SAAS;YACpC,OAAO,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC;QAC9B,CAAC;QACD,MAAM,oBAAoB,CAAC;QAC3B,IAAI,CAAC,eAAe;YAChB,MAAM,CAAC,MAAM,MAAM,GAAG,KAAK,CAAC,YAAY;YACxC,YAAY;YACZ,WAAW,KAAK,CAAC,IAAI;QACzB,OACK;YACD,MAAM,cAAc,YAAY,eAAe,CAAC;YAChD,IAAI,YAAY,cAAc,IAAI;gBAC9B,KAAK,MAAM,CAAC,YAAY,aAAa,IAAI,YAAY,cAAc,GAAI;oBACnE,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,GAAG,aAAa,eAAe;oBAClE,IAAI,cAAc;wBACd,wBAAwB;wBACxB;oBACJ,OACK,IAAI,aAAa;wBAClB,MAAM,QAAQ,KAAK,CAAC,YAAY,CAAC,WAAW;wBAC5C,IAAI,OAAO;wBACX,IAAI,aAAa,eAAe,IAAI;4BAChC,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,SAAS,SAAS,KAAK,KAAK,GAAG;gCAC7C,OAAO;4BACX,OACK;gCACD,OAAO;4BACX;wBACJ,OACK,IAAI,aAAa,iBAAiB,IAAI;4BACvC,OAAO;wBACX,OACK,IAAI,aAAa,cAAc,IAAI;4BACpC,OAAO;wBACX,OACK,IAAI,aAAa,eAAe,IAAI;4BACrC,OAAO;wBACX;wBACA,IAAI,SAAS,MAAM;4BACf,iBAAiB,CAAC,WAAW,GAAG;gCAC5B;gCACA;4BACJ;4BACA,OAAO,KAAK,CAAC,YAAY,CAAC,WAAW;wBACzC;oBACJ;gBACJ;gBACA,IAAI,0BAA0B,MAAM;oBAChC,MAAM,gBAAgB,YAAY,eAAe,CAAC;oBAClD,IAAI,cAAc,YAAY,IAAI;wBAC9B,6BAA6B;oBACjC,OACK,IAAI,cAAc,cAAc,IAAI;wBACrC,6BAA6B;oBACjC;oBACA,WAAW,KAAK,CAAC,eAAe,KAAK,CAAC,YAAY,CAAC,sBAAsB;gBAC7E,OACK;oBACD,WAAW,KAAK,CAAC,aAAa,KAAK,CAAC,YAAY;gBACpD;YACJ,OACK;gBACD,MAAM,IAAI,MAAM;YACpB;QACJ;QACA,MAAM,uBAAuB,WAAW,KAAK;QAC7C,MAAM,OAAO,OAAO,yBAAyB,WACvC,CAAC,IAAI,CAAC,YAAY,EAAE,eAAe,gLAAQ,EAAE,wBAC7C;QACN,OAAO;YACH;YACA;YACA;YACA;QACJ;IACJ;AACJ","ignoreList":[0]}}]
}