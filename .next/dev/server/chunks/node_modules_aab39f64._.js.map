{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/singletons/fetch.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"lg:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch function to use.\n */\nexport const overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\n/**\n * @internal\n */\nexport const _getFetchImplementation = () => {\n    return (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n        DEFAULT_FETCH_IMPLEMENTATION);\n};\n"],"names":[],"mappings":"AAAA,qDAAqD,GACrD,qEAAqE;AACrE,wBAAwB;AACxB,0HAA0H;AAC1H,4EAA4E;;;;;;;AAC5E,MAAM,+BAA+B,CAAC,GAAG,OAAS,SAAS;AAC3D,MAAM,qCAAqC,OAAO,GAAG,CAAC;AAO/C,MAAM,8BAA8B,CAAC;IACxC,UAAU,CAAC,mCAAmC,GAAG;AACrD;AAIO,MAAM,0BAA0B;IACnC,OAAQ,UAAU,CAAC,mCAAmC,IAClD;AACR","ignoreList":[0]}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/utils/async_caller.js"],"sourcesContent":["import pRetry from \"p-retry\";\nimport PQueueMod from \"p-queue\";\nimport { _getFetchImplementation } from \"../singletons/fetch.js\";\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    408, // Request Timeout\n    409, // Conflict\n    422, // Unprocessable Entity\n];\n/**\n * Do not rely on globalThis.Response, rather just\n * do duck typing\n */\nfunction isResponse(x) {\n    if (x == null || typeof x !== \"object\")\n        return false;\n    return \"status\" in x && \"statusText\" in x && \"text\" in x;\n}\n/**\n * Utility error to properly handle failed requests\n */\nclass HTTPError extends Error {\n    constructor(status, message, response) {\n        super(`HTTP ${status}: ${message}`);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.status = status;\n        this.text = message;\n        this.response = response;\n    }\n    static async fromResponse(response, options) {\n        try {\n            return new HTTPError(response.status, await response.text(), options?.includeResponse ? response : undefined);\n        }\n        catch {\n            return new HTTPError(response.status, response.statusText, options?.includeResponse ? response : undefined);\n        }\n    }\n}\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 5. This\n * means that by default, each call will be retried up to 5 times, with an\n * exponential backoff between each attempt.\n */\nexport class AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"customFetch\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 4;\n        if (\"default\" in PQueueMod) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new PQueueMod.default({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new PQueueMod({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n        this.customFetch = params.fetch;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const { onFailedResponseHook } = this;\n        return this.queue.add(() => pRetry(() => callable(...args).catch(async (error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else if (isResponse(error)) {\n                throw await HTTPError.fromResponse(error, {\n                    includeResponse: !!onFailedResponseHook,\n                });\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt(error) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (error instanceof HTTPError) {\n                    if (STATUS_NO_RETRY.includes(error.status)) {\n                        throw error;\n                    }\n                    if (onFailedResponseHook && error.response) {\n                        await onFailedResponseHook(error.response);\n                    }\n                }\n            },\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        const fetchFn = this.customFetch ?? _getFetchImplementation();\n        return this.call(() => fetchFn(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/utils/env.js"],"sourcesContent":["export function getEnvironmentVariable(name) {\n    // Certain setups (Deno, frontend) will throw an error if you try to access environment variables\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,uBAAuB,IAAI;IACvC,iGAAiG;IACjG,IAAI;QACA,OAAO,OAAO,YAAY,cAElB,QAAQ,GAAG,EAAE,CAAC,KAAK,GACrB;IACV,EACA,OAAO,GAAG;QACN,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 221, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/utils/signals.js"],"sourcesContent":["export function mergeSignals(...signals) {\n    const nonZeroSignals = signals.filter((signal) => signal != null);\n    if (nonZeroSignals.length === 0)\n        return undefined;\n    if (nonZeroSignals.length === 1)\n        return nonZeroSignals[0];\n    const controller = new AbortController();\n    for (const signal of signals) {\n        if (signal?.aborted) {\n            controller.abort(signal.reason);\n            return controller.signal;\n        }\n        signal?.addEventListener(\"abort\", () => controller.abort(signal.reason), {\n            once: true,\n        });\n    }\n    return controller.signal;\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,aAAa,GAAG,OAAO;IACnC,MAAM,iBAAiB,QAAQ,MAAM,CAAC,CAAC,SAAW,UAAU;IAC5D,IAAI,eAAe,MAAM,KAAK,GAC1B,OAAO;IACX,IAAI,eAAe,MAAM,KAAK,GAC1B,OAAO,cAAc,CAAC,EAAE;IAC5B,MAAM,aAAa,IAAI;IACvB,KAAK,MAAM,UAAU,QAAS;QAC1B,IAAI,QAAQ,SAAS;YACjB,WAAW,KAAK,CAAC,OAAO,MAAM;YAC9B,OAAO,WAAW,MAAM;QAC5B;QACA,QAAQ,iBAAiB,SAAS,IAAM,WAAW,KAAK,CAAC,OAAO,MAAM,GAAG;YACrE,MAAM;QACV;IACJ;IACA,OAAO,WAAW,MAAM;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/utils/sse.js"],"sourcesContent":["const CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\nconst NULL = \"\\0\".charCodeAt(0);\nconst COLON = \":\".charCodeAt(0);\nconst SPACE = \" \".charCodeAt(0);\nconst TRAILING_NEWLINE = [CR, LF];\nexport function BytesLineDecoder() {\n    let buffer = [];\n    let trailingCr = false;\n    return new TransformStream({\n        start() {\n            buffer = [];\n            trailingCr = false;\n        },\n        transform(chunk, controller) {\n            // See https://docs.python.org/3/glossary.html#term-universal-newlines\n            let text = chunk;\n            // Handle trailing CR from previous chunk\n            if (trailingCr) {\n                text = joinArrays([[CR], text]);\n                trailingCr = false;\n            }\n            // Check for trailing CR in current chunk\n            if (text.length > 0 && text.at(-1) === CR) {\n                trailingCr = true;\n                text = text.subarray(0, -1);\n            }\n            if (!text.length)\n                return;\n            const trailingNewline = TRAILING_NEWLINE.includes(text.at(-1));\n            const lastIdx = text.length - 1;\n            const { lines } = text.reduce((acc, cur, idx) => {\n                if (acc.from > idx)\n                    return acc;\n                if (cur === CR || cur === LF) {\n                    acc.lines.push(text.subarray(acc.from, idx));\n                    if (cur === CR && text[idx + 1] === LF) {\n                        acc.from = idx + 2;\n                    }\n                    else {\n                        acc.from = idx + 1;\n                    }\n                }\n                if (idx === lastIdx && acc.from <= lastIdx) {\n                    acc.lines.push(text.subarray(acc.from));\n                }\n                return acc;\n            }, { lines: [], from: 0 });\n            if (lines.length === 1 && !trailingNewline) {\n                buffer.push(lines[0]);\n                return;\n            }\n            if (buffer.length) {\n                // Include existing buffer in first line\n                buffer.push(lines[0]);\n                lines[0] = joinArrays(buffer);\n                buffer = [];\n            }\n            if (!trailingNewline) {\n                // If the last segment is not newline terminated,\n                // buffer it for the next chunk\n                if (lines.length)\n                    buffer = [lines.pop()];\n            }\n            // Enqueue complete lines\n            for (const line of lines) {\n                controller.enqueue(line);\n            }\n        },\n        flush(controller) {\n            if (buffer.length) {\n                controller.enqueue(joinArrays(buffer));\n            }\n        },\n    });\n}\nexport function SSEDecoder() {\n    let event = \"\";\n    let data = [];\n    let lastEventId = \"\";\n    let retry = null;\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            // Handle empty line case\n            if (!chunk.length) {\n                if (!event && !data.length && !lastEventId && retry == null)\n                    return;\n                const sse = {\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                };\n                // NOTE: as per the SSE spec, do not reset lastEventId\n                event = \"\";\n                data = [];\n                retry = null;\n                controller.enqueue(sse);\n                return;\n            }\n            // Ignore comments\n            if (chunk[0] === COLON)\n                return;\n            const sepIdx = chunk.indexOf(COLON);\n            if (sepIdx === -1)\n                return;\n            const fieldName = decoder.decode(chunk.subarray(0, sepIdx));\n            let value = chunk.subarray(sepIdx + 1);\n            if (value[0] === SPACE)\n                value = value.subarray(1);\n            if (fieldName === \"event\") {\n                event = decoder.decode(value);\n            }\n            else if (fieldName === \"data\") {\n                data.push(value);\n            }\n            else if (fieldName === \"id\") {\n                if (value.indexOf(NULL) === -1)\n                    lastEventId = decoder.decode(value);\n            }\n            else if (fieldName === \"retry\") {\n                const retryNum = Number.parseInt(decoder.decode(value), 10);\n                if (!Number.isNaN(retryNum))\n                    retry = retryNum;\n            }\n        },\n        flush(controller) {\n            if (event) {\n                controller.enqueue({\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                });\n            }\n        },\n    });\n}\nfunction joinArrays(data) {\n    const totalLength = data.reduce((acc, curr) => acc + curr.length, 0);\n    const merged = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const c of data) {\n        merged.set(c, offset);\n        offset += c.length;\n    }\n    return merged;\n}\nfunction decodeArraysToJson(decoder, data) {\n    return JSON.parse(decoder.decode(joinArrays(data)));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/utils/stream.js"],"sourcesContent":["/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport class IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACM,MAAM,+BAA+B;IACxC,aAAc;QACV,KAAK,IAAI;QACT,OAAO,cAAc,CAAC,IAAI,EAAE,UAAU;YAClC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;IACJ;IACA,eAAe;QACX,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACd,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS;QAChC;IACJ;IACA,MAAM,OAAO;QACT,IAAI,CAAC,YAAY;QACjB,IAAI;YACA,MAAM,SAAS,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI;YACrC,IAAI,OAAO,IAAI,EAAE;gBACb,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,0CAA0C;gBACrE,OAAO;oBACH,MAAM;oBACN,OAAO;gBACX;YACJ,OACK;gBACD,OAAO;oBACH,MAAM;oBACN,OAAO,OAAO,KAAK;gBACvB;YACJ;QACJ,EACA,OAAO,GAAG;YACN,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,2CAA2C;YACtE,MAAM;QACV;IACJ;IACA,MAAM,SAAS;QACX,IAAI,CAAC,YAAY;QACjB,yDAAyD;QACzD,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,MAAM,gBAAgB,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,oCAAoC;YAChF,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,qBAAqB;YAChD,MAAM,eAAe,eAAe;QACxC;QACA,OAAO;YAAE,MAAM;YAAM,OAAO;QAAU;IAC1C;IACA,8DAA8D;IAC9D,MAAM,MAAM,CAAC,EAAE;QACX,IAAI,CAAC,YAAY;QACjB,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,MAAM,gBAAgB,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,oCAAoC;YAChF,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,qBAAqB;YAChD,MAAM,eAAe,eAAe;QACxC;QACA,MAAM;IACV;IACA,6DAA6D;IAC7D,sEAAsE;IACtE,MAAM,CAAC,OAAO,YAAY,CAAC,GAAG;QAC1B,MAAM,IAAI,CAAC,MAAM;IACrB;IACA,CAAC,OAAO,aAAa,CAAC,GAAG;QACrB,OAAO,IAAI;IACf;IACA,OAAO,mBAAmB,MAAM,EAAE;QAC9B,8GAA8G;QAC9G,MAAM,SAAS,OAAO,SAAS;QAC/B,OAAO,IAAI,uBAAuB;YAC9B,OAAM,UAAU;gBACZ,OAAO;;;gBACP,SAAS;oBACL,OAAO,OAAO,IAAI,GAAG,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;wBACtC,2DAA2D;wBAC3D,IAAI,MAAM;4BACN,WAAW,KAAK;4BAChB;wBACJ;wBACA,qDAAqD;wBACrD,WAAW,OAAO,CAAC;wBACnB,OAAO;oBACX;gBACJ;YACJ;YACA;gBACI,OAAO,WAAW;YACtB;QACJ;IACJ;IACA,OAAO,mBAAmB,SAAS,EAAE;QACjC,OAAO,IAAI,uBAAuB;YAC9B,MAAM,MAAK,UAAU;gBACjB,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,MAAM,UAAU,IAAI;gBAC5C,2DAA2D;gBAC3D,IAAI,MAAM;oBACN,WAAW,KAAK;gBACpB;gBACA,kGAAkG;gBAClG,WAAW,OAAO,CAAC;YACvB;YACA,MAAM,QAAO,MAAM;gBACf,MAAM,UAAU,MAAM,CAAC;YAC3B;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/client.js"],"sourcesContent":["import { AsyncCaller } from \"./utils/async_caller.js\";\nimport { getEnvironmentVariable } from \"./utils/env.js\";\nimport { mergeSignals } from \"./utils/signals.js\";\nimport { BytesLineDecoder, SSEDecoder } from \"./utils/sse.js\";\nimport { IterableReadableStream } from \"./utils/stream.js\";\nfunction* iterateHeaders(headers) {\n    let iter;\n    let shouldClear = false;\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (headers instanceof Headers) {\n        const entries = [];\n        headers.forEach((value, name) => {\n            entries.push([name, value]);\n        });\n        iter = entries;\n    }\n    else if (Array.isArray(headers)) {\n        iter = headers;\n    }\n    else {\n        shouldClear = true;\n        iter = Object.entries(headers ?? {});\n    }\n    for (const item of iter) {\n        const name = item[0];\n        if (typeof name !== \"string\")\n            throw new TypeError(`Expected header name to be a string, got ${typeof name}`);\n        const values = Array.isArray(item[1]) ? item[1] : [item[1]];\n        let didClear = false;\n        for (const value of values) {\n            if (value === undefined)\n                continue;\n            // New object keys should always overwrite older headers\n            // Yield a null to clear the header in the headers object\n            // before adding the new value\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [name, null];\n            }\n            yield [name, value];\n        }\n    }\n}\nfunction mergeHeaders(...headerObjects) {\n    const outputHeaders = new Headers();\n    for (const headers of headerObjects) {\n        if (!headers)\n            continue;\n        for (const [name, value] of iterateHeaders(headers)) {\n            if (value === null)\n                outputHeaders.delete(name);\n            else\n                outputHeaders.append(name, value);\n        }\n    }\n    const headerEntries = [];\n    outputHeaders.forEach((value, name) => {\n        headerEntries.push([name, value]);\n    });\n    return Object.fromEntries(headerEntries);\n}\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nexport function getApiKey(apiKey) {\n    if (apiKey) {\n        return apiKey;\n    }\n    const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n    for (const prefix of prefixes) {\n        const envKey = getEnvironmentVariable(`${prefix}_API_KEY`);\n        if (envKey) {\n            // Remove surrounding quotes\n            return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n        }\n    }\n    return undefined;\n}\nconst REGEX_RUN_METADATA = /(\\/threads\\/(?<thread_id>.+))?\\/runs\\/(?<run_id>.+)/;\nfunction getRunMetadataFromResponse(response) {\n    const contentLocation = response.headers.get(\"Content-Location\");\n    if (!contentLocation)\n        return undefined;\n    const match = REGEX_RUN_METADATA.exec(contentLocation);\n    if (!match?.groups?.run_id)\n        return undefined;\n    return {\n        run_id: match.groups.run_id,\n        thread_id: match.groups.thread_id || undefined,\n    };\n}\nclass BaseClient {\n    constructor(config) {\n        Object.defineProperty(this, \"asyncCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeoutMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultHeaders\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onRequest\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const callerOptions = {\n            maxRetries: 4,\n            maxConcurrency: 4,\n            ...config?.callerOptions,\n        };\n        let defaultApiUrl = \"http://localhost:8123\";\n        if (!config?.apiUrl &&\n            typeof globalThis === \"object\" &&\n            globalThis != null) {\n            const fetchSmb = Symbol.for(\"langgraph_api:fetch\");\n            const urlSmb = Symbol.for(\"langgraph_api:url\");\n            const global = globalThis;\n            if (global[fetchSmb])\n                callerOptions.fetch ??= global[fetchSmb];\n            if (global[urlSmb])\n                defaultApiUrl = global[urlSmb];\n        }\n        this.asyncCaller = new AsyncCaller(callerOptions);\n        this.timeoutMs = config?.timeoutMs;\n        // default limit being capped by Chrome\n        // https://github.com/nodejs/undici/issues/1373\n        // Regex to remove trailing slash, if present\n        this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || defaultApiUrl;\n        this.defaultHeaders = config?.defaultHeaders || {};\n        this.onRequest = config?.onRequest;\n        const apiKey = getApiKey(config?.apiKey);\n        if (apiKey) {\n            this.defaultHeaders[\"x-api-key\"] = apiKey;\n        }\n    }\n    prepareFetchOptions(path, options) {\n        const mutatedOptions = {\n            ...options,\n            headers: mergeHeaders(this.defaultHeaders, options?.headers),\n        };\n        if (mutatedOptions.json) {\n            mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n            mutatedOptions.headers = mergeHeaders(mutatedOptions.headers, {\n                \"content-type\": \"application/json\",\n            });\n            delete mutatedOptions.json;\n        }\n        if (mutatedOptions.withResponse) {\n            delete mutatedOptions.withResponse;\n        }\n        let timeoutSignal = null;\n        if (typeof options?.timeoutMs !== \"undefined\") {\n            if (options.timeoutMs != null) {\n                timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n            }\n        }\n        else if (this.timeoutMs != null) {\n            timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n        }\n        mutatedOptions.signal = mergeSignals(timeoutSignal, mutatedOptions.signal);\n        const targetUrl = new URL(`${this.apiUrl}${path}`);\n        if (mutatedOptions.params) {\n            for (const [key, value] of Object.entries(mutatedOptions.params)) {\n                if (value == null)\n                    continue;\n                const strValue = typeof value === \"string\" || typeof value === \"number\"\n                    ? value.toString()\n                    : JSON.stringify(value);\n                targetUrl.searchParams.append(key, strValue);\n            }\n            delete mutatedOptions.params;\n        }\n        return [targetUrl, mutatedOptions];\n    }\n    async fetch(path, options) {\n        const [url, init] = this.prepareFetchOptions(path, options);\n        let finalInit = init;\n        if (this.onRequest) {\n            finalInit = await this.onRequest(url, init);\n        }\n        const response = await this.asyncCaller.fetch(url, finalInit);\n        const body = (() => {\n            if (response.status === 202 || response.status === 204) {\n                return undefined;\n            }\n            return response.json();\n        })();\n        if (options?.withResponse) {\n            return [await body, response];\n        }\n        return body;\n    }\n}\nexport class CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    async createForThread(threadId, assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        return this.fetch(`/threads/${threadId}/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    async create(assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        return this.fetch(`/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    async delete(cronId) {\n        await this.fetch(`/runs/crons/${cronId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    async search(query) {\n        return this.fetch(\"/runs/crons/search\", {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/runs/crons/count`, {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n            },\n        });\n    }\n}\nexport class AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    async get(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`);\n    }\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    async getGraph(assistantId, options) {\n        return this.fetch(`/assistants/${assistantId}/graph`, {\n            params: { xray: options?.xray },\n        });\n    }\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    async getSchemas(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/schemas`);\n    }\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    async getSubgraphs(assistantId, options) {\n        if (options?.namespace) {\n            return this.fetch(`/assistants/${assistantId}/subgraphs/${options.namespace}`, { params: { recurse: options?.recurse } });\n        }\n        return this.fetch(`/assistants/${assistantId}/subgraphs`, {\n            params: { recurse: options?.recurse },\n        });\n    }\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    async create(payload) {\n        return this.fetch(\"/assistants\", {\n            method: \"POST\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                assistant_id: payload.assistantId,\n                if_exists: payload.ifExists,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    async update(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"PATCH\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    async delete(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    async search(query) {\n        return this.fetch(\"/assistants/search\", {\n            method: \"POST\",\n            json: {\n                graph_id: query?.graphId ?? undefined,\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/assistants/count`, {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                graph_id: query?.graphId ?? undefined,\n            },\n        });\n    }\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    async getVersions(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}/versions`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata ?? undefined,\n                limit: payload?.limit ?? 10,\n                offset: payload?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    async setLatest(assistantId, version) {\n        return this.fetch(`/assistants/${assistantId}/latest`, {\n            method: \"POST\",\n            json: { version },\n        });\n    }\n}\nexport class ThreadsClient extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    async get(threadId) {\n        return this.fetch(`/threads/${threadId}`);\n    }\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    async create(payload) {\n        // Normalize ttl to an object if a number is provided\n        const ttlPayload = typeof payload?.ttl === \"number\"\n            ? { ttl: payload.ttl, strategy: \"delete\" }\n            : payload?.ttl;\n        return this.fetch(`/threads`, {\n            method: \"POST\",\n            json: {\n                metadata: {\n                    ...payload?.metadata,\n                    graph_id: payload?.graphId,\n                },\n                thread_id: payload?.threadId,\n                if_exists: payload?.ifExists,\n                supersteps: payload?.supersteps?.map((s) => ({\n                    updates: s.updates.map((u) => ({\n                        values: u.values,\n                        command: u.command,\n                        as_node: u.asNode,\n                    })),\n                })),\n                ttl: ttlPayload,\n            },\n        });\n    }\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    async copy(threadId) {\n        return this.fetch(`/threads/${threadId}/copy`, {\n            method: \"POST\",\n        });\n    }\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    async update(threadId, payload) {\n        const ttlPayload = typeof payload?.ttl === \"number\"\n            ? { ttl: payload.ttl, strategy: \"delete\" }\n            : payload?.ttl;\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"PATCH\",\n            json: { metadata: payload?.metadata, ttl: ttlPayload },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    async delete(threadId) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    async search(query) {\n        return this.fetch(\"/threads/search\", {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                ids: query?.ids ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                status: query?.status,\n                sort_by: query?.sortBy,\n                sort_order: query?.sortOrder,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/threads/count`, {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                values: query?.values ?? undefined,\n                status: query?.status ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    async getState(threadId, checkpoint, options) {\n        if (checkpoint != null) {\n            if (typeof checkpoint !== \"string\") {\n                return this.fetch(`/threads/${threadId}/state/checkpoint`, {\n                    method: \"POST\",\n                    json: { checkpoint, subgraphs: options?.subgraphs },\n                });\n            }\n            // deprecated\n            return this.fetch(`/threads/${threadId}/state/${checkpoint}`, { params: { subgraphs: options?.subgraphs } });\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            params: { subgraphs: options?.subgraphs },\n        });\n    }\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    async updateState(threadId, options) {\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"POST\",\n            json: {\n                values: options.values,\n                checkpoint_id: options.checkpointId,\n                checkpoint: options.checkpoint,\n                as_node: options?.asNode,\n            },\n        });\n    }\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    async patchState(threadIdOrConfig, metadata) {\n        let threadId;\n        if (typeof threadIdOrConfig !== \"string\") {\n            if (typeof threadIdOrConfig.configurable?.thread_id !== \"string\") {\n                throw new Error(\"Thread ID is required when updating state with a config.\");\n            }\n            threadId = threadIdOrConfig.configurable.thread_id;\n        }\n        else {\n            threadId = threadIdOrConfig;\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"PATCH\",\n            json: { metadata },\n        });\n    }\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    async getHistory(threadId, options) {\n        return this.fetch(`/threads/${threadId}/history`, {\n            method: \"POST\",\n            json: {\n                limit: options?.limit ?? 10,\n                before: options?.before,\n                metadata: options?.metadata,\n                checkpoint: options?.checkpoint,\n            },\n        });\n    }\n    async *joinStream(threadId, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        let [url, init] = this.prepareFetchOptions(`/threads/${threadId}/stream`, {\n            method: \"GET\",\n            headers: options?.lastEventId\n                ? { \"Last-Event-ID\": options.lastEventId }\n                : undefined,\n            params: options?.streamMode\n                ? { stream_mode: options.streamMode }\n                : undefined,\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough(BytesLineDecoder())\n            .pipeThrough(SSEDecoder());\n        yield* IterableReadableStream.fromReadableStream(stream);\n    }\n}\nexport class RunsClient extends BaseClient {\n    /**\n     * Create a run and stream the results.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     */\n    async *stream(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            feedback_keys: payload?.feedbackKeys,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n        let [url, init] = this.prepareFetchOptions(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough(BytesLineDecoder())\n            .pipeThrough(SSEDecoder());\n        yield* IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    async create(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            multitask_strategy: payload?.multitaskStrategy,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const endpoint = threadId === null ? \"/runs\" : `/threads/${threadId}/runs`;\n        const [run, response] = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        return run;\n    }\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    async createBatch(payloads) {\n        const filteredPayloads = payloads\n            .map((payload) => ({ ...payload, assistant_id: payload.assistantId }))\n            .map((payload) => {\n            return Object.fromEntries(Object.entries(payload).filter(([_, v]) => v !== undefined));\n        });\n        return this.fetch(\"/runs/batch\", {\n            method: \"POST\",\n            json: filteredPayloads,\n        });\n    }\n    /**\n     * Create a run and wait for it to complete.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The last values chunk of the thread.\n     */\n    async wait(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n        const [run, response] = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        const raiseError = payload?.raiseError !== undefined ? payload.raiseError : true;\n        if (raiseError &&\n            \"__error__\" in run &&\n            typeof run.__error__ === \"object\" &&\n            run.__error__ &&\n            \"error\" in run.__error__ &&\n            \"message\" in run.__error__) {\n            throw new Error(`${run.__error__?.error}: ${run.__error__?.message}`);\n        }\n        return run;\n    }\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    async list(threadId, options) {\n        return this.fetch(`/threads/${threadId}/runs`, {\n            params: {\n                limit: options?.limit ?? 10,\n                offset: options?.offset ?? 0,\n                status: options?.status ?? undefined,\n                select: options?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    async get(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`);\n    }\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    async cancel(threadId, runId, wait = false, action = \"interrupt\") {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n            method: \"POST\",\n            params: {\n                wait: wait ? \"1\" : \"0\",\n                action,\n            },\n        });\n    }\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async join(threadId, runId, options) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/join`, {\n            timeoutMs: null,\n            signal: options?.signal,\n        });\n    }\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    async *joinStream(threadId, runId, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const opts = typeof options === \"object\" &&\n            options != null &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            options instanceof AbortSignal\n            ? { signal: options }\n            : options;\n        let [url, init] = this.prepareFetchOptions(threadId != null\n            ? `/threads/${threadId}/runs/${runId}/stream`\n            : `/runs/${runId}/stream`, {\n            method: \"GET\",\n            timeoutMs: null,\n            signal: opts?.signal,\n            headers: opts?.lastEventId\n                ? { \"Last-Event-ID\": opts.lastEventId }\n                : undefined,\n            params: {\n                cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\",\n                stream_mode: opts?.streamMode,\n            },\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough(BytesLineDecoder())\n            .pipeThrough(SSEDecoder());\n        yield* IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async delete(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n            method: \"DELETE\",\n        });\n    }\n}\nexport class StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    async putItem(namespace, key, value, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const payload = {\n            namespace,\n            key,\n            value,\n            index: options?.index,\n            ttl: options?.ttl,\n        };\n        return this.fetch(\"/store/items\", {\n            method: \"PUT\",\n            json: payload,\n        });\n    }\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    async getItem(namespace, key, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const params = {\n            namespace: namespace.join(\".\"),\n            key,\n        };\n        if (options?.refreshTtl !== undefined) {\n            params.refresh_ttl = options.refreshTtl;\n        }\n        const response = await this.fetch(\"/store/items\", {\n            params,\n        });\n        return response\n            ? {\n                ...response,\n                createdAt: response.created_at,\n                updatedAt: response.updated_at,\n            }\n            : null;\n    }\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    async deleteItem(namespace, key) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        return this.fetch(\"/store/items\", {\n            method: \"DELETE\",\n            json: { namespace, key },\n        });\n    }\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    async searchItems(namespacePrefix, options) {\n        const payload = {\n            namespace_prefix: namespacePrefix,\n            filter: options?.filter,\n            limit: options?.limit ?? 10,\n            offset: options?.offset ?? 0,\n            query: options?.query,\n            refresh_ttl: options?.refreshTtl,\n        };\n        const response = await this.fetch(\"/store/items/search\", {\n            method: \"POST\",\n            json: payload,\n        });\n        return {\n            items: response.items.map((item) => ({\n                ...item,\n                createdAt: item.created_at,\n                updatedAt: item.updated_at,\n            })),\n        };\n    }\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    async listNamespaces(options) {\n        const payload = {\n            prefix: options?.prefix,\n            suffix: options?.suffix,\n            max_depth: options?.maxDepth,\n            limit: options?.limit ?? 100,\n            offset: options?.offset ?? 0,\n        };\n        return this.fetch(\"/store/namespaces\", {\n            method: \"POST\",\n            json: payload,\n        });\n    }\n}\nclass UiClient extends BaseClient {\n    static getOrCached(key, fn) {\n        if (UiClient.promiseCache[key] != null) {\n            return UiClient.promiseCache[key];\n        }\n        const promise = fn();\n        UiClient.promiseCache[key] = promise;\n        return promise;\n    }\n    async getComponent(assistantId, agentName) {\n        return UiClient.getOrCached(`${this.apiUrl}-${assistantId}-${agentName}`, async () => {\n            let [url, init] = this.prepareFetchOptions(`/ui/${assistantId}`, {\n                headers: {\n                    Accept: \"text/html\",\n                    \"Content-Type\": \"application/json\",\n                },\n                method: \"POST\",\n                json: { name: agentName },\n            });\n            if (this.onRequest != null)\n                init = await this.onRequest(url, init);\n            const response = await this.asyncCaller.fetch(url, init);\n            return response.text();\n        });\n    }\n}\nObject.defineProperty(UiClient, \"promiseCache\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {}\n});\nexport class Client {\n    constructor(config) {\n        /**\n         * The client for interacting with assistants.\n         */\n        Object.defineProperty(this, \"assistants\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with threads.\n         */\n        Object.defineProperty(this, \"threads\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with runs.\n         */\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with cron runs.\n         */\n        Object.defineProperty(this, \"crons\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the KV store.\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the UI.\n         * @internal Used by LoadExternalComponent and the API might change in the future.\n         */\n        Object.defineProperty(this, \"~ui\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @internal Used to obtain a stable key representing the client.\n         */\n        Object.defineProperty(this, \"~configHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[\"~configHash\"] = (() => JSON.stringify({\n            apiUrl: config?.apiUrl,\n            apiKey: config?.apiKey,\n            timeoutMs: config?.timeoutMs,\n            defaultHeaders: config?.defaultHeaders,\n            maxConcurrency: config?.callerOptions?.maxConcurrency,\n            maxRetries: config?.callerOptions?.maxRetries,\n            callbacks: {\n                onFailedResponseHook: config?.callerOptions?.onFailedResponseHook != null,\n                onRequest: config?.onRequest != null,\n                fetch: config?.callerOptions?.fetch != null,\n            },\n        }))();\n        this.assistants = new AssistantsClient(config);\n        this.threads = new ThreadsClient(config);\n        this.runs = new RunsClient(config);\n        this.crons = new CronsClient(config);\n        this.store = new StoreClient(config);\n        this[\"~ui\"] = new UiClient(config);\n    }\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport function getClientConfigHash(client) {\n    return client[\"~configHash\"];\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1799, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/dist/index.js"],"sourcesContent":["export { Client, getApiKey } from \"./client.js\";\nexport { overrideFetchImplementation } from \"./singletons/fetch.js\";\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0]}},
    {"offset": {"line": 1808, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40ag-ui/langgraph/node_modules/%40langchain/langgraph-sdk/index.js"],"sourcesContent":["export * from './dist/index.js'"],"names":[],"mappings":";AAAA","ignoreList":[0]}},
    {"offset": {"line": 1830, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/singletons/fetch.cjs"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._getFetchImplementation = exports.overrideFetchImplementation = void 0;\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"lg:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch function to use.\n */\nconst overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\nexports.overrideFetchImplementation = overrideFetchImplementation;\n/**\n * @internal\n */\nconst _getFetchImplementation = () => {\n    return (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n        DEFAULT_FETCH_IMPLEMENTATION);\n};\nexports._getFetchImplementation = _getFetchImplementation;\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,uBAAuB,GAAG,QAAQ,2BAA2B,GAAG,KAAK;AAC7E,qEAAqE;AACrE,wBAAwB;AACxB,0HAA0H;AAC1H,4EAA4E;AAC5E,MAAM,+BAA+B,CAAC,GAAG,OAAS,SAAS;AAC3D,MAAM,qCAAqC,OAAO,GAAG,CAAC;AACtD;;;;;CAKC,GACD,MAAM,8BAA8B,CAAC;IACjC,UAAU,CAAC,mCAAmC,GAAG;AACrD;AACA,QAAQ,2BAA2B,GAAG;AACtC;;CAEC,GACD,MAAM,0BAA0B;IAC5B,OAAQ,UAAU,CAAC,mCAAmC,IAClD;AACR;AACA,QAAQ,uBAAuB,GAAG","ignoreList":[0]}},
    {"offset": {"line": 1859, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/utils/async_caller.cjs"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncCaller = void 0;\nconst p_retry_1 = __importDefault(require(\"p-retry\"));\nconst p_queue_1 = __importDefault(require(\"p-queue\"));\nconst fetch_js_1 = require(\"../singletons/fetch.cjs\");\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    408, // Request Timeout\n    409, // Conflict\n    422, // Unprocessable Entity\n];\n/**\n * Do not rely on globalThis.Response, rather just\n * do duck typing\n */\nfunction isResponse(x) {\n    if (x == null || typeof x !== \"object\")\n        return false;\n    return \"status\" in x && \"statusText\" in x && \"text\" in x;\n}\n/**\n * Utility error to properly handle failed requests\n */\nclass HTTPError extends Error {\n    constructor(status, message, response) {\n        super(`HTTP ${status}: ${message}`);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.status = status;\n        this.text = message;\n        this.response = response;\n    }\n    static async fromResponse(response, options) {\n        try {\n            return new HTTPError(response.status, await response.text(), options?.includeResponse ? response : undefined);\n        }\n        catch {\n            return new HTTPError(response.status, response.statusText, options?.includeResponse ? response : undefined);\n        }\n    }\n}\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 5. This\n * means that by default, each call will be retried up to 5 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"customFetch\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 4;\n        if (\"default\" in p_queue_1.default) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue_1.default.default({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue_1.default({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n        this.customFetch = params.fetch;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(() => (0, p_retry_1.default)(() => callable(...args).catch(async (error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else if (isResponse(error)) {\n                throw await HTTPError.fromResponse(error, {\n                    includeResponse: !!onFailedResponseHook,\n                });\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt(error) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                if (error instanceof HTTPError) {\n                    if (STATUS_NO_RETRY.includes(error.status)) {\n                        throw error;\n                    }\n                    if (onFailedResponseHook && error.response) {\n                        await onFailedResponseHook(error.response);\n                    }\n                }\n            },\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        const fetchFn = this.customFetch ?? (0, fetch_js_1._getFetchImplementation)();\n        return this.call(() => fetchFn(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\nexports.AsyncCaller = AsyncCaller;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2052, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/utils/env.cjs"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getEnvironmentVariable = void 0;\nfunction getEnvironmentVariable(name) {\n    // Certain setups (Deno, frontend) will throw an error if you try to access environment variables\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nexports.getEnvironmentVariable = getEnvironmentVariable;\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,sBAAsB,GAAG,KAAK;AACtC,SAAS,uBAAuB,IAAI;IAChC,iGAAiG;IACjG,IAAI;QACA,OAAO,OAAO,YAAY,cAElB,QAAQ,GAAG,EAAE,CAAC,KAAK,GACrB;IACV,EACA,OAAO,GAAG;QACN,OAAO;IACX;AACJ;AACA,QAAQ,sBAAsB,GAAG","ignoreList":[0]}},
    {"offset": {"line": 2069, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/utils/signals.cjs"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeSignals = void 0;\nfunction mergeSignals(...signals) {\n    const nonZeroSignals = signals.filter((signal) => signal != null);\n    if (nonZeroSignals.length === 0)\n        return undefined;\n    if (nonZeroSignals.length === 1)\n        return nonZeroSignals[0];\n    const controller = new AbortController();\n    for (const signal of signals) {\n        if (signal?.aborted) {\n            controller.abort(signal.reason);\n            return controller.signal;\n        }\n        signal?.addEventListener(\"abort\", () => controller.abort(signal.reason), {\n            once: true,\n        });\n    }\n    return controller.signal;\n}\nexports.mergeSignals = mergeSignals;\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,YAAY,GAAG,KAAK;AAC5B,SAAS,aAAa,GAAG,OAAO;IAC5B,MAAM,iBAAiB,QAAQ,MAAM,CAAC,CAAC,SAAW,UAAU;IAC5D,IAAI,eAAe,MAAM,KAAK,GAC1B,OAAO;IACX,IAAI,eAAe,MAAM,KAAK,GAC1B,OAAO,cAAc,CAAC,EAAE;IAC5B,MAAM,aAAa,IAAI;IACvB,KAAK,MAAM,UAAU,QAAS;QAC1B,IAAI,QAAQ,SAAS;YACjB,WAAW,KAAK,CAAC,OAAO,MAAM;YAC9B,OAAO,WAAW,MAAM;QAC5B;QACA,QAAQ,iBAAiB,SAAS,IAAM,WAAW,KAAK,CAAC,OAAO,MAAM,GAAG;YACrE,MAAM;QACV;IACJ;IACA,OAAO,WAAW,MAAM;AAC5B;AACA,QAAQ,YAAY,GAAG","ignoreList":[0]}},
    {"offset": {"line": 2094, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/utils/sse.cjs"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SSEDecoder = exports.BytesLineDecoder = void 0;\nconst CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\nconst NULL = \"\\0\".charCodeAt(0);\nconst COLON = \":\".charCodeAt(0);\nconst SPACE = \" \".charCodeAt(0);\nconst TRAILING_NEWLINE = [CR, LF];\nclass BytesLineDecoder extends TransformStream {\n    constructor() {\n        let buffer = [];\n        let trailingCr = false;\n        super({\n            start() {\n                buffer = [];\n                trailingCr = false;\n            },\n            transform(chunk, controller) {\n                // See https://docs.python.org/3/glossary.html#term-universal-newlines\n                let text = chunk;\n                // Handle trailing CR from previous chunk\n                if (trailingCr) {\n                    text = joinArrays([[CR], text]);\n                    trailingCr = false;\n                }\n                // Check for trailing CR in current chunk\n                if (text.length > 0 && text.at(-1) === CR) {\n                    trailingCr = true;\n                    text = text.subarray(0, -1);\n                }\n                if (!text.length)\n                    return;\n                const trailingNewline = TRAILING_NEWLINE.includes(text.at(-1));\n                const lastIdx = text.length - 1;\n                const { lines } = text.reduce((acc, cur, idx) => {\n                    if (acc.from > idx)\n                        return acc;\n                    if (cur === CR || cur === LF) {\n                        acc.lines.push(text.subarray(acc.from, idx));\n                        if (cur === CR && text[idx + 1] === LF) {\n                            acc.from = idx + 2;\n                        }\n                        else {\n                            acc.from = idx + 1;\n                        }\n                    }\n                    if (idx === lastIdx && acc.from <= lastIdx) {\n                        acc.lines.push(text.subarray(acc.from));\n                    }\n                    return acc;\n                }, { lines: [], from: 0 });\n                if (lines.length === 1 && !trailingNewline) {\n                    buffer.push(lines[0]);\n                    return;\n                }\n                if (buffer.length) {\n                    // Include existing buffer in first line\n                    buffer.push(lines[0]);\n                    lines[0] = joinArrays(buffer);\n                    buffer = [];\n                }\n                if (!trailingNewline) {\n                    // If the last segment is not newline terminated,\n                    // buffer it for the next chunk\n                    if (lines.length)\n                        buffer = [lines.pop()];\n                }\n                // Enqueue complete lines\n                for (const line of lines) {\n                    controller.enqueue(line);\n                }\n            },\n            flush(controller) {\n                if (buffer.length) {\n                    controller.enqueue(joinArrays(buffer));\n                }\n            },\n        });\n    }\n}\nexports.BytesLineDecoder = BytesLineDecoder;\nclass SSEDecoder extends TransformStream {\n    constructor() {\n        let event = \"\";\n        let data = [];\n        let lastEventId = \"\";\n        let retry = null;\n        const decoder = new TextDecoder();\n        super({\n            transform(chunk, controller) {\n                // Handle empty line case\n                if (!chunk.length) {\n                    if (!event && !data.length && !lastEventId && retry == null)\n                        return;\n                    const sse = {\n                        event,\n                        data: data.length ? decodeArraysToJson(decoder, data) : null,\n                    };\n                    // NOTE: as per the SSE spec, do not reset lastEventId\n                    event = \"\";\n                    data = [];\n                    retry = null;\n                    controller.enqueue(sse);\n                    return;\n                }\n                // Ignore comments\n                if (chunk[0] === COLON)\n                    return;\n                const sepIdx = chunk.indexOf(COLON);\n                if (sepIdx === -1)\n                    return;\n                const fieldName = decoder.decode(chunk.subarray(0, sepIdx));\n                let value = chunk.subarray(sepIdx + 1);\n                if (value[0] === SPACE)\n                    value = value.subarray(1);\n                if (fieldName === \"event\") {\n                    event = decoder.decode(value);\n                }\n                else if (fieldName === \"data\") {\n                    data.push(value);\n                }\n                else if (fieldName === \"id\") {\n                    if (value.indexOf(NULL) === -1)\n                        lastEventId = decoder.decode(value);\n                }\n                else if (fieldName === \"retry\") {\n                    const retryNum = Number.parseInt(decoder.decode(value));\n                    if (!Number.isNaN(retryNum))\n                        retry = retryNum;\n                }\n            },\n            flush(controller) {\n                if (event) {\n                    controller.enqueue({\n                        event,\n                        data: data.length ? decodeArraysToJson(decoder, data) : null,\n                    });\n                }\n            },\n        });\n    }\n}\nexports.SSEDecoder = SSEDecoder;\nfunction joinArrays(data) {\n    const totalLength = data.reduce((acc, curr) => acc + curr.length, 0);\n    let merged = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const c of data) {\n        merged.set(c, offset);\n        offset += c.length;\n    }\n    return merged;\n}\nfunction decodeArraysToJson(decoder, data) {\n    return JSON.parse(decoder.decode(joinArrays(data)));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2256, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/utils/stream.cjs"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IterableReadableStream = void 0;\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\nexports.IterableReadableStream = IterableReadableStream;\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,sBAAsB,GAAG,KAAK;AACtC;;;CAGC,GACD,MAAM,+BAA+B;IACjC,aAAc;QACV,KAAK,IAAI;QACT,OAAO,cAAc,CAAC,IAAI,EAAE,UAAU;YAClC,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;IACJ;IACA,eAAe;QACX,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACd,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS;QAChC;IACJ;IACA,MAAM,OAAO;QACT,IAAI,CAAC,YAAY;QACjB,IAAI;YACA,MAAM,SAAS,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI;YACrC,IAAI,OAAO,IAAI,EAAE;gBACb,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,0CAA0C;gBACrE,OAAO;oBACH,MAAM;oBACN,OAAO;gBACX;YACJ,OACK;gBACD,OAAO;oBACH,MAAM;oBACN,OAAO,OAAO,KAAK;gBACvB;YACJ;QACJ,EACA,OAAO,GAAG;YACN,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,2CAA2C;YACtE,MAAM;QACV;IACJ;IACA,MAAM,SAAS;QACX,IAAI,CAAC,YAAY;QACjB,yDAAyD;QACzD,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,MAAM,gBAAgB,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,oCAAoC;YAChF,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,qBAAqB;YAChD,MAAM,eAAe,eAAe;QACxC;QACA,OAAO;YAAE,MAAM;YAAM,OAAO;QAAU;IAC1C;IACA,8DAA8D;IAC9D,MAAM,MAAM,CAAC,EAAE;QACX,IAAI,CAAC,YAAY;QACjB,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,MAAM,gBAAgB,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,oCAAoC;YAChF,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,qBAAqB;YAChD,MAAM,eAAe,eAAe;QACxC;QACA,MAAM;IACV;IACA,6DAA6D;IAC7D,sEAAsE;IACtE,MAAM,CAAC,OAAO,YAAY,CAAC,GAAG;QAC1B,MAAM,IAAI,CAAC,MAAM;IACrB;IACA,CAAC,OAAO,aAAa,CAAC,GAAG;QACrB,OAAO,IAAI;IACf;IACA,OAAO,mBAAmB,MAAM,EAAE;QAC9B,8GAA8G;QAC9G,MAAM,SAAS,OAAO,SAAS;QAC/B,OAAO,IAAI,uBAAuB;YAC9B,OAAM,UAAU;gBACZ,OAAO;;;gBACP,SAAS;oBACL,OAAO,OAAO,IAAI,GAAG,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;wBACtC,2DAA2D;wBAC3D,IAAI,MAAM;4BACN,WAAW,KAAK;4BAChB;wBACJ;wBACA,qDAAqD;wBACrD,WAAW,OAAO,CAAC;wBACnB,OAAO;oBACX;gBACJ;YACJ;YACA;gBACI,OAAO,WAAW;YACtB;QACJ;IACJ;IACA,OAAO,mBAAmB,SAAS,EAAE;QACjC,OAAO,IAAI,uBAAuB;YAC9B,MAAM,MAAK,UAAU;gBACjB,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,MAAM,UAAU,IAAI;gBAC5C,2DAA2D;gBAC3D,IAAI,MAAM;oBACN,WAAW,KAAK;gBACpB;gBACA,kGAAkG;gBAClG,WAAW,OAAO,CAAC;YACvB;YACA,MAAM,QAAO,MAAM;gBACf,MAAM,UAAU,MAAM,CAAC;YAC3B;QACJ;IACJ;AACJ;AACA,QAAQ,sBAAsB,GAAG","ignoreList":[0]}},
    {"offset": {"line": 2378, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/client.cjs"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = exports.StoreClient = exports.RunsClient = exports.ThreadsClient = exports.AssistantsClient = exports.CronsClient = exports.getApiKey = void 0;\nconst async_caller_js_1 = require(\"./utils/async_caller.cjs\");\nconst env_js_1 = require(\"./utils/env.cjs\");\nconst signals_js_1 = require(\"./utils/signals.cjs\");\nconst sse_js_1 = require(\"./utils/sse.cjs\");\nconst stream_js_1 = require(\"./utils/stream.cjs\");\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nfunction getApiKey(apiKey) {\n    if (apiKey) {\n        return apiKey;\n    }\n    const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n    for (const prefix of prefixes) {\n        const envKey = (0, env_js_1.getEnvironmentVariable)(`${prefix}_API_KEY`);\n        if (envKey) {\n            // Remove surrounding quotes\n            return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n        }\n    }\n    return undefined;\n}\nexports.getApiKey = getApiKey;\nclass BaseClient {\n    constructor(config) {\n        Object.defineProperty(this, \"asyncCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeoutMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultHeaders\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const callerOptions = {\n            maxRetries: 4,\n            maxConcurrency: 4,\n            ...config?.callerOptions,\n        };\n        let defaultApiUrl = \"http://localhost:8123\";\n        if (!config?.apiUrl &&\n            typeof globalThis === \"object\" &&\n            globalThis != null) {\n            const fetchSmb = Symbol.for(\"langgraph_api:fetch\");\n            const urlSmb = Symbol.for(\"langgraph_api:url\");\n            const global = globalThis;\n            if (global[fetchSmb])\n                callerOptions.fetch ??= global[fetchSmb];\n            if (global[urlSmb])\n                defaultApiUrl = global[urlSmb];\n        }\n        this.asyncCaller = new async_caller_js_1.AsyncCaller(callerOptions);\n        this.timeoutMs = config?.timeoutMs;\n        // default limit being capped by Chrome\n        // https://github.com/nodejs/undici/issues/1373\n        // Regex to remove trailing slash, if present\n        this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || defaultApiUrl;\n        this.defaultHeaders = config?.defaultHeaders || {};\n        const apiKey = getApiKey(config?.apiKey);\n        if (apiKey) {\n            this.defaultHeaders[\"X-Api-Key\"] = apiKey;\n        }\n    }\n    prepareFetchOptions(path, options) {\n        const mutatedOptions = {\n            ...options,\n            headers: { ...this.defaultHeaders, ...options?.headers },\n        };\n        if (mutatedOptions.json) {\n            mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n            mutatedOptions.headers = {\n                ...mutatedOptions.headers,\n                \"Content-Type\": \"application/json\",\n            };\n            delete mutatedOptions.json;\n        }\n        let timeoutSignal = null;\n        if (typeof options?.timeoutMs !== \"undefined\") {\n            if (options.timeoutMs != null) {\n                timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n            }\n        }\n        else if (this.timeoutMs != null) {\n            timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n        }\n        mutatedOptions.signal = (0, signals_js_1.mergeSignals)(timeoutSignal, mutatedOptions.signal);\n        const targetUrl = new URL(`${this.apiUrl}${path}`);\n        if (mutatedOptions.params) {\n            for (const [key, value] of Object.entries(mutatedOptions.params)) {\n                if (value == null)\n                    continue;\n                let strValue = typeof value === \"string\" || typeof value === \"number\"\n                    ? value.toString()\n                    : JSON.stringify(value);\n                targetUrl.searchParams.append(key, strValue);\n            }\n            delete mutatedOptions.params;\n        }\n        return [targetUrl, mutatedOptions];\n    }\n    async fetch(path, options) {\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(path, options));\n        if (response.status === 202 || response.status === 204) {\n            return undefined;\n        }\n        return response.json();\n    }\n}\nclass CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    async createForThread(threadId, assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n        };\n        return this.fetch(`/threads/${threadId}/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    async create(assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n        };\n        return this.fetch(`/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    async delete(cronId) {\n        await this.fetch(`/runs/crons/${cronId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    async search(query) {\n        return this.fetch(\"/runs/crons/search\", {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n            },\n        });\n    }\n}\nexports.CronsClient = CronsClient;\nclass AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    async get(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`);\n    }\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    async getGraph(assistantId, options) {\n        return this.fetch(`/assistants/${assistantId}/graph`, {\n            params: { xray: options?.xray },\n        });\n    }\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    async getSchemas(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/schemas`);\n    }\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    async getSubgraphs(assistantId, options) {\n        if (options?.namespace) {\n            return this.fetch(`/assistants/${assistantId}/subgraphs/${options.namespace}`, { params: { recurse: options?.recurse } });\n        }\n        return this.fetch(`/assistants/${assistantId}/subgraphs`, {\n            params: { recurse: options?.recurse },\n        });\n    }\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    async create(payload) {\n        return this.fetch(\"/assistants\", {\n            method: \"POST\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                metadata: payload.metadata,\n                assistant_id: payload.assistantId,\n                if_exists: payload.ifExists,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    async update(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"PATCH\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                metadata: payload.metadata,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    async delete(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    async search(query) {\n        return this.fetch(\"/assistants/search\", {\n            method: \"POST\",\n            json: {\n                graph_id: query?.graphId ?? undefined,\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    async getVersions(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}/versions`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata ?? undefined,\n                limit: payload?.limit ?? 10,\n                offset: payload?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    async setLatest(assistantId, version) {\n        return this.fetch(`/assistants/${assistantId}/latest`, {\n            method: \"POST\",\n            json: { version },\n        });\n    }\n}\nexports.AssistantsClient = AssistantsClient;\nclass ThreadsClient extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    async get(threadId) {\n        return this.fetch(`/threads/${threadId}`);\n    }\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    async create(payload) {\n        return this.fetch(`/threads`, {\n            method: \"POST\",\n            json: {\n                metadata: {\n                    ...payload?.metadata,\n                    graph_id: payload?.graphId,\n                },\n                thread_id: payload?.threadId,\n                if_exists: payload?.ifExists,\n                supersteps: payload?.supersteps?.map((s) => ({\n                    updates: s.updates.map((u) => ({\n                        values: u.values,\n                        command: u.command,\n                        as_node: u.asNode,\n                    })),\n                })),\n            },\n        });\n    }\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    async copy(threadId) {\n        return this.fetch(`/threads/${threadId}/copy`, {\n            method: \"POST\",\n        });\n    }\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    async update(threadId, payload) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"PATCH\",\n            json: { metadata: payload?.metadata },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    async delete(threadId) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    async search(query) {\n        return this.fetch(\"/threads/search\", {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                status: query?.status,\n                sort_by: query?.sortBy,\n                sort_order: query?.sortOrder,\n            },\n        });\n    }\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    async getState(threadId, checkpoint, options) {\n        if (checkpoint != null) {\n            if (typeof checkpoint !== \"string\") {\n                return this.fetch(`/threads/${threadId}/state/checkpoint`, {\n                    method: \"POST\",\n                    json: { checkpoint, subgraphs: options?.subgraphs },\n                });\n            }\n            // deprecated\n            return this.fetch(`/threads/${threadId}/state/${checkpoint}`, { params: { subgraphs: options?.subgraphs } });\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            params: { subgraphs: options?.subgraphs },\n        });\n    }\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    async updateState(threadId, options) {\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"POST\",\n            json: {\n                values: options.values,\n                checkpoint_id: options.checkpointId,\n                checkpoint: options.checkpoint,\n                as_node: options?.asNode,\n            },\n        });\n    }\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    async patchState(threadIdOrConfig, metadata) {\n        let threadId;\n        if (typeof threadIdOrConfig !== \"string\") {\n            if (typeof threadIdOrConfig.configurable?.thread_id !== \"string\") {\n                throw new Error(\"Thread ID is required when updating state with a config.\");\n            }\n            threadId = threadIdOrConfig.configurable.thread_id;\n        }\n        else {\n            threadId = threadIdOrConfig;\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"PATCH\",\n            json: { metadata: metadata },\n        });\n    }\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    async getHistory(threadId, options) {\n        return this.fetch(`/threads/${threadId}/history`, {\n            method: \"POST\",\n            json: {\n                limit: options?.limit ?? 10,\n                before: options?.before,\n                metadata: options?.metadata,\n                checkpoint: options?.checkpoint,\n            },\n        });\n    }\n}\nexports.ThreadsClient = ThreadsClient;\nclass RunsClient extends BaseClient {\n    /**\n     * Create a run and stream the results.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     */\n    async *stream(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            feedback_keys: payload?.feedbackKeys,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n        };\n        const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        }));\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough(new sse_js_1.BytesLineDecoder())\n            .pipeThrough(new sse_js_1.SSEDecoder());\n        yield* stream_js_1.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    async create(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            multitask_strategy: payload?.multitaskStrategy,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n        };\n        return this.fetch(`/threads/${threadId}/runs`, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n        });\n    }\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    async createBatch(payloads) {\n        const filteredPayloads = payloads\n            .map((payload) => ({ ...payload, assistant_id: payload.assistantId }))\n            .map((payload) => {\n            return Object.fromEntries(Object.entries(payload).filter(([_, v]) => v !== undefined));\n        });\n        return this.fetch(\"/runs/batch\", {\n            method: \"POST\",\n            json: filteredPayloads,\n        });\n    }\n    /**\n     * Create a run and wait for it to complete.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The last values chunk of the thread.\n     */\n    async wait(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n        };\n        const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n        const response = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        });\n        const raiseError = payload?.raiseError !== undefined ? payload.raiseError : true;\n        if (raiseError &&\n            \"__error__\" in response &&\n            typeof response.__error__ === \"object\" &&\n            response.__error__ &&\n            \"error\" in response.__error__ &&\n            \"message\" in response.__error__) {\n            throw new Error(`${response.__error__?.error}: ${response.__error__?.message}`);\n        }\n        return response;\n    }\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    async list(threadId, options) {\n        return this.fetch(`/threads/${threadId}/runs`, {\n            params: {\n                limit: options?.limit ?? 10,\n                offset: options?.offset ?? 0,\n                status: options?.status ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    async get(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`);\n    }\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    async cancel(threadId, runId, wait = false, action = \"interrupt\") {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n            method: \"POST\",\n            params: {\n                wait: wait ? \"1\" : \"0\",\n                action: action,\n            },\n        });\n    }\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async join(threadId, runId, options) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/join`, {\n            timeoutMs: null,\n            signal: options?.signal,\n        });\n    }\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     * Output is not buffered, so any output produced before this call will\n     * not be received here.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    async *joinStream(threadId, runId, options) {\n        const opts = typeof options === \"object\" &&\n            options != null &&\n            options instanceof AbortSignal\n            ? { signal: options }\n            : options;\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(`/threads/${threadId}/runs/${runId}/stream`, {\n            method: \"GET\",\n            timeoutMs: null,\n            signal: opts?.signal,\n            params: {\n                cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\",\n                stream_mode: opts?.streamMode,\n            },\n        }));\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough(new sse_js_1.BytesLineDecoder())\n            .pipeThrough(new sse_js_1.SSEDecoder());\n        yield* stream_js_1.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async delete(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n            method: \"DELETE\",\n        });\n    }\n}\nexports.RunsClient = RunsClient;\nclass StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    async putItem(namespace, key, value, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const payload = {\n            namespace,\n            key,\n            value,\n            index: options?.index,\n            ttl: options?.ttl,\n        };\n        return this.fetch(\"/store/items\", {\n            method: \"PUT\",\n            json: payload,\n        });\n    }\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    async getItem(namespace, key, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const params = {\n            namespace: namespace.join(\".\"),\n            key,\n        };\n        if (options?.refreshTtl !== undefined) {\n            params.refresh_ttl = options.refreshTtl;\n        }\n        const response = await this.fetch(\"/store/items\", {\n            params,\n        });\n        return response\n            ? {\n                ...response,\n                createdAt: response.created_at,\n                updatedAt: response.updated_at,\n            }\n            : null;\n    }\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    async deleteItem(namespace, key) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        return this.fetch(\"/store/items\", {\n            method: \"DELETE\",\n            json: { namespace, key },\n        });\n    }\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    async searchItems(namespacePrefix, options) {\n        const payload = {\n            namespace_prefix: namespacePrefix,\n            filter: options?.filter,\n            limit: options?.limit ?? 10,\n            offset: options?.offset ?? 0,\n            query: options?.query,\n            refresh_ttl: options?.refreshTtl,\n        };\n        const response = await this.fetch(\"/store/items/search\", {\n            method: \"POST\",\n            json: payload,\n        });\n        return {\n            items: response.items.map((item) => ({\n                ...item,\n                createdAt: item.created_at,\n                updatedAt: item.updated_at,\n            })),\n        };\n    }\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    async listNamespaces(options) {\n        const payload = {\n            prefix: options?.prefix,\n            suffix: options?.suffix,\n            max_depth: options?.maxDepth,\n            limit: options?.limit ?? 100,\n            offset: options?.offset ?? 0,\n        };\n        return this.fetch(\"/store/namespaces\", {\n            method: \"POST\",\n            json: payload,\n        });\n    }\n}\nexports.StoreClient = StoreClient;\nclass UiClient extends BaseClient {\n    static getOrCached(key, fn) {\n        if (UiClient.promiseCache[key] != null) {\n            return UiClient.promiseCache[key];\n        }\n        const promise = fn();\n        UiClient.promiseCache[key] = promise;\n        return promise;\n    }\n    async getComponent(assistantId, agentName) {\n        return UiClient[\"getOrCached\"](`${this.apiUrl}-${assistantId}-${agentName}`, async () => {\n            const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(`/ui/${assistantId}`, {\n                headers: {\n                    Accept: \"text/html\",\n                    \"Content-Type\": \"application/json\",\n                },\n                method: \"POST\",\n                json: { name: agentName },\n            }));\n            return response.text();\n        });\n    }\n}\nObject.defineProperty(UiClient, \"promiseCache\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {}\n});\nclass Client {\n    constructor(config) {\n        /**\n         * The client for interacting with assistants.\n         */\n        Object.defineProperty(this, \"assistants\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with threads.\n         */\n        Object.defineProperty(this, \"threads\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with runs.\n         */\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with cron runs.\n         */\n        Object.defineProperty(this, \"crons\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the KV store.\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the UI.\n         * @internal Used by LoadExternalComponent and the API might change in the future.\n         */\n        Object.defineProperty(this, \"~ui\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.assistants = new AssistantsClient(config);\n        this.threads = new ThreadsClient(config);\n        this.runs = new RunsClient(config);\n        this.crons = new CronsClient(config);\n        this.store = new StoreClient(config);\n        this[\"~ui\"] = new UiClient(config);\n    }\n}\nexports.Client = Client;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3398, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/dist/index.cjs"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.overrideFetchImplementation = exports.Client = void 0;\nvar client_js_1 = require(\"./client.cjs\");\nObject.defineProperty(exports, \"Client\", { enumerable: true, get: function () { return client_js_1.Client; } });\nvar fetch_js_1 = require(\"./singletons/fetch.cjs\");\nObject.defineProperty(exports, \"overrideFetchImplementation\", { enumerable: true, get: function () { return fetch_js_1.overrideFetchImplementation; } });\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,2BAA2B,GAAG,QAAQ,MAAM,GAAG,KAAK;AAC5D,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,UAAU;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,YAAY,MAAM;IAAE;AAAE;AAC7G,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,+BAA+B;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,WAAW,2BAA2B;IAAE;AAAE","ignoreList":[0]}},
    {"offset": {"line": 3419, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/langgraph-sdk/index.cjs"],"sourcesContent":["module.exports = require('./dist/index.cjs');"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0]}}]
}