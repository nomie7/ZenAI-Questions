module.exports = [
"[project]/node_modules/@whatwg-node/events/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomEvent = void 0;
exports.CustomEvent = globalThis.CustomEvent || class PonyfillCustomEvent extends Event {
    detail = null;
    constructor(type, eventInitDict){
        super(type, eventInitDict);
        if (eventInitDict?.detail != null) {
            this.detail = eventInitDict.detail;
        }
    }
    initCustomEvent(type, bubbles, cancelable, detail) {
        this.initEvent(type, bubbles, cancelable);
        if (detail != null) {
            this.detail = detail;
        }
    }
};
}),
"[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPromise = isPromise;
exports.isActualPromise = isActualPromise;
exports.handleMaybePromise = handleMaybePromise;
exports.fakePromise = fakePromise;
exports.createDeferredPromise = createDeferredPromise;
exports.iterateAsync = iterateAsync;
exports.iterateAsyncVoid = iterateAsync;
exports.fakeRejectPromise = fakeRejectPromise;
exports.mapMaybePromise = mapMaybePromise;
exports.mapAsyncIterator = mapAsyncIterator;
exports.promiseLikeFinally = promiseLikeFinally;
exports.unfakePromise = unfakePromise;
const kFakePromise = Symbol.for('@whatwg-node/promise-helpers/FakePromise');
function isPromise(value) {
    return value?.then != null;
}
function isActualPromise(value) {
    const maybePromise = value;
    return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;
}
function handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {
    let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);
    if (finallyFactory) {
        result$ = result$.finally(finallyFactory);
    }
    return unfakePromise(result$);
}
function fakePromise(value) {
    if (value && isActualPromise(value)) {
        return value;
    }
    if (isPromise(value)) {
        return {
            then: (resolve, reject)=>fakePromise(value.then(resolve, reject)),
            catch: (reject)=>fakePromise(value.then((res)=>res, reject)),
            finally: (cb)=>fakePromise(cb ? promiseLikeFinally(value, cb) : value),
            [Symbol.toStringTag]: 'Promise'
        };
    }
    // Write a fake promise to avoid the promise constructor
    // being called with `new Promise` in the browser.
    return {
        then (resolve) {
            if (resolve) {
                try {
                    return fakePromise(resolve(value));
                } catch (err) {
                    return fakeRejectPromise(err);
                }
            }
            return this;
        },
        catch () {
            return this;
        },
        finally (cb) {
            if (cb) {
                try {
                    return fakePromise(cb()).then(()=>value, ()=>value);
                } catch (err) {
                    return fakeRejectPromise(err);
                }
            }
            return this;
        },
        [Symbol.toStringTag]: 'Promise',
        __fakePromiseValue: value,
        [kFakePromise]: 'resolved'
    };
}
function createDeferredPromise() {
    if (Promise.withResolvers) {
        return Promise.withResolvers();
    }
    let resolveFn;
    let rejectFn;
    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
        resolveFn = resolve;
        rejectFn = reject;
    });
    return {
        promise,
        get resolve () {
            return resolveFn;
        },
        get reject () {
            return rejectFn;
        }
    };
}
function iterateAsync(iterable, callback, results) {
    if (iterable?.length === 0) {
        return;
    }
    const iterator = iterable[Symbol.iterator]();
    let index = 0;
    function iterate() {
        const { done: endOfIterator, value } = iterator.next();
        if (endOfIterator) {
            return;
        }
        let endedEarly = false;
        function endEarly() {
            endedEarly = true;
        }
        return handleMaybePromise(function handleCallback() {
            return callback(value, endEarly, index++);
        }, function handleCallbackResult(result) {
            if (result) {
                results?.push(result);
            }
            if (endedEarly) {
                return;
            }
            return iterate();
        });
    }
    return iterate();
}
function fakeRejectPromise(error) {
    return {
        then (_resolve, reject) {
            if (reject) {
                try {
                    return fakePromise(reject(error));
                } catch (err) {
                    return fakeRejectPromise(err);
                }
            }
            return this;
        },
        catch (reject) {
            if (reject) {
                try {
                    return fakePromise(reject(error));
                } catch (err) {
                    return fakeRejectPromise(err);
                }
            }
            return this;
        },
        finally (cb) {
            if (cb) {
                try {
                    cb();
                } catch (err) {
                    return fakeRejectPromise(err);
                }
            }
            return this;
        },
        __fakeRejectError: error,
        [Symbol.toStringTag]: 'Promise',
        [kFakePromise]: 'rejected'
    };
}
function mapMaybePromise(input, onSuccess, onError) {
    return handleMaybePromise(()=>input, onSuccess, onError);
}
/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */ function mapAsyncIterator(iterator, onNext, onError, onEnd) {
    if (Symbol.asyncIterator in iterator) {
        iterator = iterator[Symbol.asyncIterator]();
    }
    let $return;
    let abruptClose;
    let onEndWithValue;
    if (onEnd) {
        let onEndWithValueResult /** R in onEndWithValue */ ;
        onEndWithValue = (value)=>{
            onEndWithValueResult ||= handleMaybePromise(onEnd, ()=>value, ()=>value);
            return onEndWithValueResult;
        };
    }
    if (typeof iterator.return === 'function') {
        $return = iterator.return;
        abruptClose = (error)=>{
            const rethrow = ()=>{
                throw error;
            };
            return $return.call(iterator).then(rethrow, rethrow);
        };
    }
    function mapResult(result) {
        if (result.done) {
            return onEndWithValue ? onEndWithValue(result) : result;
        }
        return handleMaybePromise(()=>result.value, (value)=>handleMaybePromise(()=>onNext(value), iteratorResult, abruptClose));
    }
    let mapReject;
    if (onError) {
        let onErrorResult;
        // Capture rejectCallback to ensure it cannot be null.
        const reject = onError;
        mapReject = (error)=>{
            onErrorResult ||= handleMaybePromise(()=>error, (error)=>handleMaybePromise(()=>reject(error), iteratorResult, abruptClose));
            return onErrorResult;
        };
    }
    return {
        next () {
            return iterator.next().then(mapResult, mapReject);
        },
        return () {
            const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : fakePromise({
                value: undefined,
                done: true
            });
            return onEndWithValue ? res$.then(onEndWithValue) : res$;
        },
        throw (error) {
            if (typeof iterator.throw === 'function') {
                return iterator.throw(error).then(mapResult, mapReject);
            }
            if (abruptClose) {
                return abruptClose(error);
            }
            return fakeRejectPromise(error);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
function iteratorResult(value) {
    return {
        value,
        done: false
    };
}
function isFakePromise(value) {
    return value?.[kFakePromise] === 'resolved';
}
function isFakeRejectPromise(value) {
    return value?.[kFakePromise] === 'rejected';
}
function promiseLikeFinally(value, onFinally) {
    if ('finally' in value) {
        return value.finally(onFinally);
    }
    return value.then((res)=>{
        const finallyRes = onFinally();
        return isPromise(finallyRes) ? finallyRes.then(()=>res) : res;
    }, (err)=>{
        const finallyRes = onFinally();
        if (isPromise(finallyRes)) {
            return finallyRes.then(()=>{
                throw err;
            });
        } else {
            throw err;
        }
    });
}
function unfakePromise(promise) {
    if (isFakePromise(promise)) {
        return promise.__fakePromiseValue;
    }
    if (isFakeRejectPromise(promise)) {
        throw promise.__fakeRejectError;
    }
    return promise;
}
}),
"[project]/node_modules/@whatwg-node/disposablestack/cjs/SupressedError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillSuppressedError = void 0;
class PonyfillSuppressedError extends Error {
    error;
    suppressed;
    // eslint-disable-next-line n/handle-callback-err
    constructor(error, suppressed, message){
        super(message);
        this.error = error;
        this.suppressed = suppressed;
        this.name = 'SuppressedError';
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.PonyfillSuppressedError = PonyfillSuppressedError;
}),
"[project]/node_modules/@whatwg-node/disposablestack/cjs/symbols.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DisposableSymbols = void 0;
exports.patchSymbols = patchSymbols;
exports.DisposableSymbols = {
    get dispose () {
        return Symbol.dispose || Symbol.for('dispose');
    },
    get asyncDispose () {
        return Symbol.asyncDispose || Symbol.for('asyncDispose');
    }
};
function patchSymbols() {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore - we ponyfill these symbols
    Symbol.dispose ||= Symbol.for('dispose');
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore - we ponyfill these symbols
    Symbol.asyncDispose ||= Symbol.for('asyncDispose');
}
}),
"[project]/node_modules/@whatwg-node/disposablestack/cjs/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isSyncDisposable = isSyncDisposable;
exports.isAsyncDisposable = isAsyncDisposable;
const symbols_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/symbols.js [app-route] (ecmascript)");
function isSyncDisposable(obj) {
    return obj?.[symbols_js_1.DisposableSymbols.dispose] != null;
}
function isAsyncDisposable(obj) {
    return obj?.[symbols_js_1.DisposableSymbols.asyncDispose] != null;
}
}),
"[project]/node_modules/@whatwg-node/disposablestack/cjs/AsyncDisposableStack.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillAsyncDisposableStack = void 0;
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
const SupressedError_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/SupressedError.js [app-route] (ecmascript)");
const symbols_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/symbols.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/utils.js [app-route] (ecmascript)");
const SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;
class PonyfillAsyncDisposableStack {
    callbacks = [];
    get disposed() {
        return this.callbacks.length === 0;
    }
    use(value) {
        if ((0, utils_js_1.isAsyncDisposable)(value)) {
            this.callbacks.push(()=>value[symbols_js_1.DisposableSymbols.asyncDispose]());
        } else if ((0, utils_js_1.isSyncDisposable)(value)) {
            this.callbacks.push(()=>value[symbols_js_1.DisposableSymbols.dispose]());
        }
        return value;
    }
    adopt(value, onDisposeAsync) {
        if (onDisposeAsync) {
            this.callbacks.push(()=>onDisposeAsync(value));
        }
        return value;
    }
    defer(onDisposeAsync) {
        if (onDisposeAsync) {
            this.callbacks.push(onDisposeAsync);
        }
    }
    move() {
        const stack = new PonyfillAsyncDisposableStack();
        stack.callbacks = this.callbacks;
        this.callbacks = [];
        return stack;
    }
    disposeAsync() {
        return this[symbols_js_1.DisposableSymbols.asyncDispose]();
    }
    _error;
    _iterateCallbacks() {
        const cb = this.callbacks.pop();
        if (cb) {
            return (0, promise_helpers_1.handleMaybePromise)(cb, ()=>this._iterateCallbacks(), (error)=>{
                this._error = this._error ? new SuppressedError(error, this._error) : error;
                return this._iterateCallbacks();
            });
        }
    }
    [symbols_js_1.DisposableSymbols.asyncDispose]() {
        const res$ = this._iterateCallbacks();
        if (res$?.then) {
            return res$.then(()=>{
                if (this._error) {
                    const error = this._error;
                    this._error = undefined;
                    throw error;
                }
            });
        }
        if (this._error) {
            const error = this._error;
            this._error = undefined;
            throw error;
        }
        return undefined;
    }
    [Symbol.toStringTag] = 'AsyncDisposableStack';
}
exports.PonyfillAsyncDisposableStack = PonyfillAsyncDisposableStack;
}),
"[project]/node_modules/@whatwg-node/disposablestack/cjs/DisposableStack.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillDisposableStack = void 0;
const SupressedError_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/SupressedError.js [app-route] (ecmascript)");
const symbols_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/symbols.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/utils.js [app-route] (ecmascript)");
const SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;
class PonyfillDisposableStack {
    callbacks = [];
    get disposed() {
        return this.callbacks.length === 0;
    }
    use(value) {
        if ((0, utils_js_1.isSyncDisposable)(value)) {
            this.callbacks.push(()=>value[symbols_js_1.DisposableSymbols.dispose]());
        }
        return value;
    }
    adopt(value, onDispose) {
        if (onDispose) {
            this.callbacks.push(()=>onDispose(value));
        }
        return value;
    }
    defer(onDispose) {
        if (onDispose) {
            this.callbacks.push(onDispose);
        }
    }
    move() {
        const stack = new PonyfillDisposableStack();
        stack.callbacks = this.callbacks;
        this.callbacks = [];
        return stack;
    }
    dispose() {
        return this[symbols_js_1.DisposableSymbols.dispose]();
    }
    _error;
    _iterateCallbacks() {
        const cb = this.callbacks.pop();
        if (cb) {
            try {
                cb();
            } catch (error) {
                this._error = this._error ? new SuppressedError(error, this._error) : error;
            }
            return this._iterateCallbacks();
        }
    }
    [symbols_js_1.DisposableSymbols.dispose]() {
        this._iterateCallbacks();
        if (this._error) {
            const error = this._error;
            this._error = undefined;
            throw error;
        }
    }
    [Symbol.toStringTag] = 'DisposableStack';
}
exports.PonyfillDisposableStack = PonyfillDisposableStack;
}),
"[project]/node_modules/@whatwg-node/disposablestack/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SuppressedError = exports.AsyncDisposableStack = exports.DisposableStack = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const AsyncDisposableStack_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/AsyncDisposableStack.js [app-route] (ecmascript)");
const DisposableStack_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/DisposableStack.js [app-route] (ecmascript)");
const SupressedError_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/SupressedError.js [app-route] (ecmascript)");
exports.DisposableStack = globalThis.DisposableStack || DisposableStack_js_1.PonyfillDisposableStack;
exports.AsyncDisposableStack = globalThis.AsyncDisposableStack || AsyncDisposableStack_js_1.PonyfillAsyncDisposableStack;
exports.SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/symbols.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function isNextJs() {
    return Object.keys(globalThis).some((key)=>key.startsWith('__NEXT'));
}
module.exports = function shouldSkipPonyfill() {
    if (globalThis.Deno) {
        return true;
    }
    if (globalThis.Bun) {
        return true;
    }
    if (isNextJs()) {
        return true;
    }
    return false;
};
}),
"[project]/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const shouldSkipPonyfill = __turbopack_context__.r("[project]/node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js [app-route] (ecmascript)");
let newNodeFetch;
module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    ponyfills.URLPattern = globalThis.URLPattern;
    // We call this previously to patch `Bun`
    if (!ponyfills.URLPattern) {
        const urlPatternModule = __turbopack_context__.r("[project]/node_modules/urlpattern-polyfill/index.cjs [app-route] (ecmascript)");
        ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    if (opts.skipPonyfill || shouldSkipPonyfill()) {
        return {
            fetch: globalThis.fetch,
            Headers: globalThis.Headers,
            Request: globalThis.Request,
            Response: globalThis.Response,
            FormData: globalThis.FormData,
            ReadableStream: globalThis.ReadableStream,
            WritableStream: globalThis.WritableStream,
            TransformStream: globalThis.TransformStream,
            CompressionStream: globalThis.CompressionStream,
            DecompressionStream: globalThis.DecompressionStream,
            TextDecoderStream: globalThis.TextDecoderStream,
            TextEncoderStream: globalThis.TextEncoderStream,
            Blob: globalThis.Blob,
            File: globalThis.File,
            crypto: globalThis.crypto,
            btoa: globalThis.btoa,
            TextEncoder: globalThis.TextEncoder,
            TextDecoder: globalThis.TextDecoder,
            URLPattern: ponyfills.URLPattern,
            URL: globalThis.URL,
            URLSearchParams: globalThis.URLSearchParams
        };
    }
    newNodeFetch ||= __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/index.js [app-route] (ecmascript)");
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = newNodeFetch.WritableStream;
    ponyfills.TransformStream = newNodeFetch.TransformStream;
    ponyfills.CompressionStream = newNodeFetch.CompressionStream;
    ponyfills.DecompressionStream = newNodeFetch.DecompressionStream;
    ponyfills.TextDecoderStream = newNodeFetch.TextDecoderStream;
    ponyfills.TextEncoderStream = newNodeFetch.TextEncoderStream;
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
        ponyfills.Body = class Body extends newNodeFetch.Body {
            constructor(body, userOpts){
                super(body, {
                    formDataLimits: opts.formDataLimits,
                    ...userOpts
                });
            }
        };
        ponyfills.Request = class Request extends newNodeFetch.Request {
            constructor(input, userOpts){
                super(input, {
                    formDataLimits: opts.formDataLimits,
                    ...userOpts
                });
            }
        };
        ponyfills.Response = class Response extends newNodeFetch.Response {
            constructor(body, userOpts){
                super(body, {
                    formDataLimits: opts.formDataLimits,
                    ...userOpts
                });
            }
        };
    }
    if (!ponyfills.crypto) {
        const cryptoModule = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
        ponyfills.crypto = cryptoModule.webcrypto;
    }
    return ponyfills;
};
}),
"[project]/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const createNodePonyfill = __turbopack_context__.r("[project]/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js [app-route] (ecmascript)");
const shouldSkipPonyfill = __turbopack_context__.r("[project]/node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js [app-route] (ecmascript)");
const ponyfills = createNodePonyfill();
if (!shouldSkipPonyfill()) {
    try {
        const nodelibcurlName = 'node-libcurl';
        globalThis.libcurl = globalThis.libcurl || (()=>{
            const e = new Error("Cannot find module 'node-libcurl'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (e) {}
}
module.exports.fetch = ponyfills.fetch;
module.exports.Headers = ponyfills.Headers;
module.exports.Request = ponyfills.Request;
module.exports.Response = ponyfills.Response;
module.exports.FormData = ponyfills.FormData;
module.exports.ReadableStream = ponyfills.ReadableStream;
module.exports.WritableStream = ponyfills.WritableStream;
module.exports.TransformStream = ponyfills.TransformStream;
module.exports.CompressionStream = ponyfills.CompressionStream;
module.exports.DecompressionStream = ponyfills.DecompressionStream;
module.exports.TextDecoderStream = ponyfills.TextDecoderStream;
module.exports.TextEncoderStream = ponyfills.TextEncoderStream;
module.exports.Blob = ponyfills.Blob;
module.exports.File = ponyfills.File;
module.exports.crypto = ponyfills.crypto;
module.exports.btoa = ponyfills.btoa;
module.exports.TextEncoder = ponyfills.TextEncoder;
module.exports.TextDecoder = ponyfills.TextDecoder;
module.exports.URLPattern = ponyfills.URLPattern;
module.exports.URL = ponyfills.URL;
module.exports.URLSearchParams = ponyfills.URLSearchParams;
exports.createFetch = createNodePonyfill;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_ACCEPT_ENCODING = exports.fakePromise = void 0;
exports.getHeadersObj = getHeadersObj;
exports.defaultHeadersSerializer = defaultHeadersSerializer;
exports.isArrayBufferView = isArrayBufferView;
exports.isNodeReadable = isNodeReadable;
exports.isIterable = isIterable;
exports.shouldRedirect = shouldRedirect;
exports.pipeThrough = pipeThrough;
exports.endStream = endStream;
exports.safeWrite = safeWrite;
exports.getSupportedFormats = getSupportedFormats;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_events_1 = __turbopack_context__.r("[externals]/node:events [external] (node:events, cjs)");
const node_zlib_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:zlib [external] (node:zlib, cjs)"));
function isHeadersInstance(obj) {
    return obj?.forEach != null;
}
function getHeadersObj(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
        return headers;
    }
    // @ts-expect-error - `headersInit` is not a public property
    if (headers.headersInit && !headers._map && !isHeadersInstance(headers.headersInit)) {
        // @ts-expect-error - `headersInit` is not a public property
        return headers.headersInit;
    }
    return Object.fromEntries(headers.entries());
}
function defaultHeadersSerializer(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value, key)=>{
        if (onContentLength && key === 'content-length') {
            onContentLength(value);
        }
        headerArray.push(`${key}: ${value}`);
    });
    return headerArray;
}
var promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "fakePromise", {
    enumerable: true,
    get: function() {
        return promise_helpers_1.fakePromise;
    }
});
function isArrayBufferView(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
}
function isNodeReadable(obj) {
    return obj != null && obj.pipe != null;
}
function isIterable(value) {
    return value?.[Symbol.iterator] != null;
}
function shouldRedirect(status) {
    return status === 301 || status === 302 || status === 303 || status === 307 || status === 308;
}
function pipeThrough({ src, dest, signal, onError }) {
    if (onError) {
        // listen for errors on the destination stream if necessary. if the readable
        // stream (src) emits an error, the writable destination (dest) will be
        // destroyed with that error (see below)
        dest.once('error', onError);
    }
    src.once('error', (e)=>{
        // if the readable stream (src) emits an error during pipe, the writable
        // destination (dest) is not closed automatically. that needs to be
        // done manually. the readable stream is closed when error is emitted,
        // so only the writable destination needs to be destroyed
        dest.destroy(e);
    });
    dest.once('close', ()=>{
        // if the writable destination (dest) is closed, the readable stream (src)
        // is not closed automatically. that needs to be done manually
        if (!src.destroyed) {
            src.destroy();
        }
    });
    if (signal) {
        // this is faster than `import('node:signal').addAbortSignal(signal, src)`
        const srcRef = new WeakRef(src);
        const signalRef = new WeakRef(signal);
        function cleanup() {
            signalRef.deref()?.removeEventListener('abort', onAbort);
            srcRef.deref()?.removeListener('end', cleanup);
            srcRef.deref()?.removeListener('error', cleanup);
            srcRef.deref()?.removeListener('close', cleanup);
        }
        function onAbort() {
            srcRef.deref()?.destroy(new AbortError());
            cleanup();
        }
        signal.addEventListener('abort', onAbort, {
            once: true
        });
        // this is faster than `import('node:signal').finished(src, cleanup)`
        src.once('end', cleanup);
        src.once('error', cleanup);
        src.once('close', cleanup);
    }
    src.pipe(dest, {
        end: true
    });
}
function endStream(stream) {
    // @ts-expect-error Avoid arguments adaptor trampoline https://v8.dev/blog/adaptor-frame
    return stream.end(null, null, null);
}
function safeWrite(chunk, stream) {
    const result = stream.write(chunk);
    if (!result) {
        return (0, node_events_1.once)(stream, 'drain');
    }
}
// https://github.com/nodejs/node/blob/f692878dec6354c0a82241f224906981861bc840/lib/internal/errors.js#L961-L973
class AbortError extends Error {
    constructor(message = 'The operation was aborted', options = undefined){
        super(message, options);
        this.name = 'AbortError';
    }
}
exports.DEFAULT_ACCEPT_ENCODING = getSupportedFormats().join(', ');
function getSupportedFormats() {
    const baseFormats = [
        'gzip',
        'deflate',
        'br'
    ];
    if (!globalThis.process?.versions?.node?.startsWith('2')) {
        baseFormats.push('deflate-raw');
    }
    if (node_zlib_1.default.createZstdCompress != null) {
        baseFormats.push('zstd');
    }
    return baseFormats;
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillReadableStream = void 0;
const node_buffer_1 = __turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)");
const node_events_1 = __turbopack_context__.r("[externals]/node:events [external] (node:events, cjs)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const promises_1 = __turbopack_context__.r("[externals]/node:stream/promises [external] (node:stream/promises, cjs)");
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
function createController(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
        desiredSize,
        enqueue (chunk) {
            const buf = typeof chunk === 'string' ? node_buffer_1.Buffer.from(chunk) : chunk;
            if (!flushed) {
                chunks.push(buf);
            } else {
                readable.push(buf);
            }
        },
        close () {
            if (chunks.length > 0) {
                this._flush();
            }
            readable.push(null);
            _closed = true;
        },
        error (error) {
            if (chunks.length > 0) {
                this._flush();
            }
            readable.destroy(error);
        },
        get _closed () {
            return _closed;
        },
        _flush () {
            flushed = true;
            if (chunks.length > 0) {
                const concatenated = chunks.length > 1 ? node_buffer_1.Buffer.concat(chunks) : chunks[0];
                readable.push(concatenated);
                chunks = [];
            }
        }
    };
}
function isNodeReadable(obj) {
    return obj?.read != null;
}
function isReadableStream(obj) {
    return obj?.getReader != null;
}
class PonyfillReadableStream {
    readable;
    constructor(underlyingSource){
        if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {
            this.readable = underlyingSource.readable;
        } else if (isNodeReadable(underlyingSource)) {
            this.readable = underlyingSource;
        } else if (isReadableStream(underlyingSource)) {
            this.readable = node_stream_1.Readable.fromWeb(underlyingSource);
        } else {
            let started = false;
            let ongoing = false;
            const handleStart = (desiredSize)=>{
                if (!started) {
                    const controller = createController(desiredSize, this.readable);
                    started = true;
                    return (0, promise_helpers_1.handleMaybePromise)(()=>underlyingSource?.start?.(controller), ()=>{
                        controller._flush();
                        if (controller._closed) {
                            return false;
                        }
                        return true;
                    });
                }
                return true;
            };
            const readImpl = (desiredSize)=>{
                return (0, promise_helpers_1.handleMaybePromise)(()=>handleStart(desiredSize), (shouldContinue)=>{
                    if (!shouldContinue) {
                        return;
                    }
                    const controller = createController(desiredSize, this.readable);
                    return (0, promise_helpers_1.handleMaybePromise)(()=>underlyingSource?.pull?.(controller), ()=>{
                        controller._flush();
                        ongoing = false;
                    });
                });
            };
            this.readable = new node_stream_1.Readable({
                read (desiredSize) {
                    if (ongoing) {
                        return;
                    }
                    ongoing = true;
                    return readImpl(desiredSize);
                },
                destroy (err, callback) {
                    if (underlyingSource?.cancel) {
                        try {
                            const res$ = underlyingSource.cancel(err);
                            if (res$?.then) {
                                return res$.then(()=>{
                                    callback(null);
                                }, (err)=>{
                                    callback(err);
                                });
                            }
                        } catch (err) {
                            callback(err);
                            return;
                        }
                    }
                    callback(null);
                }
            });
        }
    }
    cancel(reason) {
        this.readable.destroy(reason);
        // @ts-expect-error - we know it is void
        return (0, node_events_1.once)(this.readable, 'close');
    }
    locked = false;
    getReader(_options) {
        const iterator = this.readable[Symbol.asyncIterator]();
        this.locked = true;
        const thisReadable = this.readable;
        return {
            read () {
                return iterator.next();
            },
            releaseLock: ()=>{
                if (iterator.return) {
                    const retResult$ = iterator.return();
                    if (retResult$.then) {
                        retResult$.then(()=>{
                            this.locked = false;
                        });
                        return;
                    }
                }
                this.locked = false;
            },
            cancel: (reason)=>{
                if (iterator.return) {
                    const retResult$ = iterator.return(reason);
                    if (retResult$.then) {
                        return retResult$.then(()=>{
                            this.locked = false;
                        });
                    }
                }
                this.locked = false;
                return (0, utils_js_1.fakePromise)();
            },
            get closed () {
                return Promise.race([
                    (0, node_events_1.once)(thisReadable, 'end'),
                    (0, node_events_1.once)(thisReadable, 'error').then((err)=>Promise.reject(err))
                ]);
            }
        };
    }
    [Symbol.asyncIterator]() {
        const iterator = this.readable[Symbol.asyncIterator]();
        return {
            [Symbol.asyncIterator] () {
                return this;
            },
            next: ()=>iterator.next(),
            return: ()=>{
                if (!this.readable.destroyed) {
                    this.readable.destroy();
                }
                return iterator.return?.() || (0, utils_js_1.fakePromise)({
                    done: true,
                    value: undefined
                });
            },
            throw: (err)=>{
                if (!this.readable.destroyed) {
                    this.readable.destroy(err);
                }
                return iterator.throw?.(err) || (0, utils_js_1.fakePromise)({
                    done: true,
                    value: undefined
                });
            }
        };
    }
    tee() {
        throw new Error('Not implemented');
    }
    async pipeToWriter(writer) {
        try {
            for await (const chunk of this){
                await writer.write(chunk);
            }
            await writer.close();
        } catch (err) {
            await writer.abort(err);
        }
    }
    pipeTo(destination) {
        if (isPonyfillWritableStream(destination)) {
            return (0, promises_1.pipeline)(this.readable, destination.writable, {
                end: true
            });
        } else {
            const writer = destination.getWriter();
            return this.pipeToWriter(writer);
        }
    }
    pipeThrough({ writable, readable }) {
        this.pipeTo(writable).catch((err)=>{
            this.readable.destroy(err);
        });
        if (isPonyfillReadableStream(readable)) {
            readable.readable.once('error', (err)=>this.readable.destroy(err));
            readable.readable.once('finish', ()=>this.readable.push(null));
            readable.readable.once('close', ()=>this.readable.push(null));
        }
        return readable;
    }
    static [Symbol.hasInstance](instance) {
        return isReadableStream(instance);
    }
    static from(iterable) {
        return new PonyfillReadableStream(node_stream_1.Readable.from(iterable));
    }
    [Symbol.toStringTag] = 'ReadableStream';
}
exports.PonyfillReadableStream = PonyfillReadableStream;
function isPonyfillReadableStream(obj) {
    return obj?.readable != null;
}
function isPonyfillWritableStream(obj) {
    return obj?.writable != null;
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/Blob.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillBlob = void 0;
exports.hasBufferMethod = hasBufferMethod;
exports.hasArrayBufferMethod = hasArrayBufferMethod;
exports.hasBytesMethod = hasBytesMethod;
exports.hasTextMethod = hasTextMethod;
exports.hasSizeProperty = hasSizeProperty;
exports.hasStreamMethod = hasStreamMethod;
exports.hasBlobSignature = hasBlobSignature;
exports.isArrayBuffer = isArrayBuffer;
/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */ /* eslint-disable @typescript-eslint/ban-ts-comment */ const node_buffer_1 = __turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)");
const ReadableStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
function getBlobPartAsBuffer(blobPart) {
    if (typeof blobPart === 'string') {
        return node_buffer_1.Buffer.from(blobPart);
    } else if (node_buffer_1.Buffer.isBuffer(blobPart)) {
        return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
        return node_buffer_1.Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
        return node_buffer_1.Buffer.from(blobPart);
    }
}
function hasBufferMethod(obj) {
    return obj != null && obj.buffer != null && typeof obj.buffer === 'function';
}
function hasArrayBufferMethod(obj) {
    return obj != null && obj.arrayBuffer != null && typeof obj.arrayBuffer === 'function';
}
function hasBytesMethod(obj) {
    return obj != null && obj.bytes != null && typeof obj.bytes === 'function';
}
function hasTextMethod(obj) {
    return obj != null && obj.text != null && typeof obj.text === 'function';
}
function hasSizeProperty(obj) {
    return obj != null && typeof obj.size === 'number';
}
function hasStreamMethod(obj) {
    return obj != null && obj.stream != null && typeof obj.stream === 'function';
}
function hasBlobSignature(obj) {
    return obj != null && obj[Symbol.toStringTag] === 'Blob';
}
function isArrayBuffer(obj) {
    return obj != null && obj.byteLength != null && obj.slice != null;
}
// Will be removed after v14 reaches EOL
// Needed because v14 doesn't have .stream() implemented
class PonyfillBlob {
    blobParts;
    type;
    encoding;
    _size = null;
    constructor(blobParts = [], options){
        this.blobParts = blobParts;
        this.type = options?.type || 'application/octet-stream';
        this.encoding = options?.encoding || 'utf8';
        this._size = options?.size || null;
        if (blobParts.length === 1 && hasBlobSignature(blobParts[0])) {
            return blobParts[0];
        }
    }
    _buffer = null;
    buffer() {
        if (this._buffer) {
            return (0, utils_js_1.fakePromise)(this._buffer);
        }
        if (this.blobParts.length === 1) {
            const blobPart = this.blobParts[0];
            if (hasBufferMethod(blobPart)) {
                return blobPart.buffer().then((buf)=>{
                    this._buffer = buf;
                    return this._buffer;
                });
            }
            if (hasBytesMethod(blobPart)) {
                return blobPart.bytes().then((bytes)=>{
                    this._buffer = node_buffer_1.Buffer.from(bytes);
                    return this._buffer;
                });
            }
            if (hasArrayBufferMethod(blobPart)) {
                return blobPart.arrayBuffer().then((arrayBuf)=>{
                    this._buffer = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);
                    return this._buffer;
                });
            }
            this._buffer = getBlobPartAsBuffer(blobPart);
            return (0, utils_js_1.fakePromise)(this._buffer);
        }
        const jobs = [];
        const bufferChunks = this.blobParts.map((blobPart, i)=>{
            if (hasBufferMethod(blobPart)) {
                jobs.push(blobPart.buffer().then((buf)=>{
                    bufferChunks[i] = buf;
                }));
                return undefined;
            } else if (hasArrayBufferMethod(blobPart)) {
                jobs.push(blobPart.arrayBuffer().then((arrayBuf)=>{
                    bufferChunks[i] = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);
                }));
                return undefined;
            } else if (hasBytesMethod(blobPart)) {
                jobs.push(blobPart.bytes().then((bytes)=>{
                    bufferChunks[i] = node_buffer_1.Buffer.from(bytes);
                }));
                return undefined;
            } else {
                return getBlobPartAsBuffer(blobPart);
            }
        });
        if (jobs.length > 0) {
            return Promise.all(jobs).then(()=>node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));
        }
        return (0, utils_js_1.fakePromise)(node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));
    }
    arrayBuffer() {
        if (this._buffer) {
            // @ts-ignore - Mismatch between Buffer and ArrayBuffer
            return (0, utils_js_1.fakePromise)(this._buffer);
        }
        if (this.blobParts.length === 1) {
            if (isArrayBuffer(this.blobParts[0])) {
                return (0, utils_js_1.fakePromise)(this.blobParts[0]);
            }
            if (hasArrayBufferMethod(this.blobParts[0])) {
                return this.blobParts[0].arrayBuffer();
            }
        }
        // @ts-ignore - Mismatch between Buffer and ArrayBuffer
        return this.buffer();
    }
    bytes() {
        if (this._buffer) {
            return (0, utils_js_1.fakePromise)(this._buffer);
        }
        if (this.blobParts.length === 1) {
            if (node_buffer_1.Buffer.isBuffer(this.blobParts[0])) {
                this._buffer = this.blobParts[0];
                return (0, utils_js_1.fakePromise)(this._buffer);
            }
            if (this.blobParts[0] instanceof Uint8Array) {
                this._buffer = node_buffer_1.Buffer.from(this.blobParts[0]);
                return (0, utils_js_1.fakePromise)(this._buffer);
            }
            if (hasBytesMethod(this.blobParts[0])) {
                return this.blobParts[0].bytes();
            }
            if (hasBufferMethod(this.blobParts[0])) {
                return this.blobParts[0].buffer();
            }
        }
        return this.buffer();
    }
    _text = null;
    text() {
        if (this._text) {
            return (0, utils_js_1.fakePromise)(this._text);
        }
        if (this.blobParts.length === 1) {
            const blobPart = this.blobParts[0];
            if (typeof blobPart === 'string') {
                this._text = blobPart;
                return (0, utils_js_1.fakePromise)(this._text);
            }
            if (hasTextMethod(blobPart)) {
                return blobPart.text().then((text)=>{
                    this._text = text;
                    return this._text;
                });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            this._text = buf.toString(this.encoding);
            return (0, utils_js_1.fakePromise)(this._text);
        }
        return this.buffer().then((buf)=>{
            this._text = buf.toString(this.encoding);
            return this._text;
        });
    }
    _json = null;
    json() {
        if (this._json) {
            return (0, utils_js_1.fakePromise)(this._json);
        }
        return this.text().then((text)=>{
            this._json = JSON.parse(text);
            return this._json;
        });
    }
    _formData = null;
    formData() {
        if (this._formData) {
            return (0, utils_js_1.fakePromise)(this._formData);
        }
        throw new Error('Not implemented');
    }
    get size() {
        if (this._size == null) {
            this._size = 0;
            for (const blobPart of this.blobParts){
                if (typeof blobPart === 'string') {
                    this._size += node_buffer_1.Buffer.byteLength(blobPart);
                } else if (hasSizeProperty(blobPart)) {
                    this._size += blobPart.size;
                } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
                    this._size += blobPart.byteLength;
                }
            }
        }
        return this._size;
    }
    stream() {
        if (this.blobParts.length === 1) {
            const blobPart = this.blobParts[0];
            if (hasStreamMethod(blobPart)) {
                return blobPart.stream();
            }
            const buf = getBlobPartAsBuffer(blobPart);
            return new ReadableStream_js_1.PonyfillReadableStream({
                start: (controller)=>{
                    controller.enqueue(buf);
                    controller.close();
                }
            });
        }
        if (this._buffer != null) {
            return new ReadableStream_js_1.PonyfillReadableStream({
                start: (controller)=>{
                    controller.enqueue(this._buffer);
                    controller.close();
                }
            });
        }
        let blobPartIterator;
        return new ReadableStream_js_1.PonyfillReadableStream({
            start: (controller)=>{
                if (this.blobParts.length === 0) {
                    controller.close();
                    return;
                }
                blobPartIterator = this.blobParts[Symbol.iterator]();
            },
            pull: (controller)=>{
                const { value: blobPart, done } = blobPartIterator.next();
                if (done) {
                    controller.close();
                    return;
                }
                if (blobPart) {
                    if (hasBufferMethod(blobPart)) {
                        return blobPart.buffer().then((buf)=>{
                            controller.enqueue(buf);
                        });
                    }
                    if (hasBytesMethod(blobPart)) {
                        return blobPart.bytes().then((bytes)=>{
                            const buf = node_buffer_1.Buffer.from(bytes);
                            controller.enqueue(buf);
                        });
                    }
                    if (hasArrayBufferMethod(blobPart)) {
                        return blobPart.arrayBuffer().then((arrayBuffer)=>{
                            const buf = node_buffer_1.Buffer.from(arrayBuffer, undefined, blobPart.size);
                            controller.enqueue(buf);
                        });
                    }
                    const buf = getBlobPartAsBuffer(blobPart);
                    controller.enqueue(buf);
                }
            }
        });
    }
    slice() {
        throw new Error('Not implemented');
    }
}
exports.PonyfillBlob = PonyfillBlob;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/File.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillFile = void 0;
const Blob_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Blob.js [app-route] (ecmascript)");
class PonyfillFile extends Blob_js_1.PonyfillBlob {
    name;
    lastModified;
    constructor(fileBits, name, options){
        super(fileBits, options);
        this.name = name;
        this.lastModified = options?.lastModified || Date.now();
    }
    webkitRelativePath = '';
}
exports.PonyfillFile = PonyfillFile;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/IteratorObject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillIteratorObject = void 0;
const node_util_1 = __turbopack_context__.r("[externals]/node:util [external] (node:util, cjs)");
const disposablestack_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/index.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
class PonyfillIteratorObject {
    iterableIterator;
    [Symbol.toStringTag] = 'IteratorObject';
    constructor(iterableIterator, className){
        this.iterableIterator = iterableIterator;
        this[Symbol.toStringTag] = className;
    }
    *map(callbackfn) {
        let index = 0;
        for (const value of this.iterableIterator){
            yield callbackfn(value, index++);
        }
        return undefined;
    }
    *filter(callbackfn) {
        let index = 0;
        for (const value of this.iterableIterator){
            if (callbackfn(value, index++)) {
                yield value;
            }
        }
        return undefined;
    }
    reduce(callbackfn, initialValue) {
        let index = 0;
        let accumulator = initialValue;
        for (const value of this.iterableIterator){
            accumulator = callbackfn(accumulator, value, index++);
        }
        return accumulator;
    }
    forEach(callbackfn) {
        let index = 0;
        for (const value of this.iterableIterator){
            callbackfn(value, index++);
        }
    }
    *take(limit) {
        let index = 0;
        for (const value of this.iterableIterator){
            if (index >= limit) {
                break;
            }
            yield value;
            index++;
        }
        return undefined;
    }
    *drop(count) {
        let index = 0;
        for (const value of this.iterableIterator){
            if (index >= count) {
                yield value;
            }
            index++;
        }
        return undefined;
    }
    *flatMap(callback) {
        let index = 0;
        for (const value of this.iterableIterator){
            const iteratorOrIterable = callback(value, index++);
            if ((0, utils_js_1.isIterable)(iteratorOrIterable)) {
                for (const innerValue of iteratorOrIterable){
                    yield innerValue;
                }
            } else {
                for (const innerValue of {
                    [Symbol.iterator]: ()=>iteratorOrIterable
                }){
                    yield innerValue;
                }
            }
        }
        return undefined;
    }
    some(predicate) {
        let index = 0;
        for (const value of this.iterableIterator){
            if (predicate(value, index++)) {
                return true;
            }
        }
        return false;
    }
    every(predicate) {
        let index = 0;
        for (const value of this.iterableIterator){
            if (!predicate(value, index++)) {
                return false;
            }
        }
        return true;
    }
    find(predicate) {
        let index = 0;
        for (const value of this.iterableIterator){
            if (predicate(value, index++)) {
                return value;
            }
        }
        return undefined;
    }
    toArray() {
        return Array.from(this.iterableIterator);
    }
    [disposablestack_1.DisposableSymbols.dispose]() {
        this.iterableIterator.return?.();
    }
    next(...[value]) {
        return this.iterableIterator.next(value);
    }
    [Symbol.iterator]() {
        return this;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        const record = {};
        this.forEach((value, key)=>{
            const inspectedValue = (0, node_util_1.inspect)(value);
            record[key] = inspectedValue.includes(',') ? inspectedValue.split(',').map((el)=>el.trim()) : inspectedValue;
        });
        return `${this[Symbol.toStringTag]} ${(0, node_util_1.inspect)(record)}`;
    }
}
exports.PonyfillIteratorObject = PonyfillIteratorObject;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/FormData.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillFormData = void 0;
exports.getStreamFromFormData = getStreamFromFormData;
const node_buffer_1 = __turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)");
const IteratorObject_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/IteratorObject.js [app-route] (ecmascript)");
const ReadableStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js [app-route] (ecmascript)");
class PonyfillFormData {
    map = new Map();
    append(name, value, fileName) {
        let values = this.map.get(name);
        if (!values) {
            values = [];
            this.map.set(name, values);
        }
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        values.push(entry);
    }
    delete(name) {
        this.map.delete(name);
    }
    get(name) {
        const values = this.map.get(name);
        return values ? values[0] : null;
    }
    getAll(name) {
        return this.map.get(name) || [];
    }
    has(name) {
        return this.map.has(name);
    }
    set(name, value, fileName) {
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        this.map.set(name, [
            entry
        ]);
    }
    [Symbol.iterator]() {
        return this._entries();
    }
    *_entries() {
        for (const [key, values] of this.map){
            for (const value of values){
                yield [
                    key,
                    value
                ];
            }
        }
    }
    entries() {
        return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), 'FormDataIterator');
    }
    _keys() {
        return this.map.keys();
    }
    keys() {
        return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), 'FormDataIterator');
    }
    *_values() {
        for (const values of this.map.values()){
            for (const value of values){
                yield value;
            }
        }
    }
    values() {
        return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), 'FormDataIterator');
    }
    forEach(callback) {
        for (const [key, value] of this){
            callback(value, key, this);
        }
    }
}
exports.PonyfillFormData = PonyfillFormData;
function getStreamFromFormData(formData, boundary = '---') {
    let entriesIterator;
    let sentInitialHeader = false;
    let currentAsyncIterator;
    let hasBefore = false;
    function handleNextEntry(controller) {
        const { done, value } = entriesIterator.next();
        if (done) {
            controller.enqueue(node_buffer_1.Buffer.from(`\r\n--${boundary}--\r\n`));
            return controller.close();
        }
        if (hasBefore) {
            controller.enqueue(node_buffer_1.Buffer.from(`\r\n--${boundary}\r\n`));
        }
        if (value) {
            const [key, blobOrString] = value;
            if (typeof blobOrString === 'string') {
                controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
                controller.enqueue(node_buffer_1.Buffer.from(blobOrString));
            } else {
                let filenamePart = '';
                if (blobOrString.name) {
                    filenamePart = `; filename="${blobOrString.name}"`;
                }
                controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
                controller.enqueue(node_buffer_1.Buffer.from(`Content-Type: ${blobOrString.type || 'application/octet-stream'}\r\n\r\n`));
                const entryStream = blobOrString.stream();
                // @ts-expect-error - ReadableStream is async iterable
                currentAsyncIterator = entryStream[Symbol.asyncIterator]();
            }
            hasBefore = true;
        }
    }
    return new ReadableStream_js_1.PonyfillReadableStream({
        start: ()=>{
            entriesIterator = formData.entries();
        },
        pull: (controller)=>{
            if (!sentInitialHeader) {
                sentInitialHeader = true;
                return controller.enqueue(node_buffer_1.Buffer.from(`--${boundary}\r\n`));
            }
            if (currentAsyncIterator) {
                return currentAsyncIterator.next().then(({ done, value })=>{
                    if (done) {
                        currentAsyncIterator = undefined;
                    }
                    if (value) {
                        return controller.enqueue(value);
                    } else {
                        return handleNextEntry(controller);
                    }
                });
            }
            return handleNextEntry(controller);
        },
        cancel: (err)=>{
            entriesIterator?.return?.(err);
            currentAsyncIterator?.return?.(err);
        }
    });
}
function getNormalizedFile(name, blob, fileName) {
    Object.defineProperty(blob, 'name', {
        configurable: true,
        enumerable: true,
        value: fileName || blob.name || name
    });
    return blob;
}
function isBlob(value) {
    return value?.arrayBuffer != null;
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/Body.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillBody = void 0;
/* eslint-disable @typescript-eslint/ban-ts-comment */ const node_buffer_1 = __turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const busboy_1 = __turbopack_context__.r("[project]/node_modules/@fastify/busboy/lib/main.js [app-route] (ecmascript)");
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
const Blob_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Blob.js [app-route] (ecmascript)");
const File_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/File.js [app-route] (ecmascript)");
const FormData_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/FormData.js [app-route] (ecmascript)");
const ReadableStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
var BodyInitType;
(function(BodyInitType) {
    BodyInitType["ReadableStream"] = "ReadableStream";
    BodyInitType["Blob"] = "Blob";
    BodyInitType["FormData"] = "FormData";
    BodyInitType["String"] = "String";
    BodyInitType["Readable"] = "Readable";
    BodyInitType["Buffer"] = "Buffer";
    BodyInitType["AsyncIterable"] = "AsyncIterable";
})(BodyInitType || (BodyInitType = {}));
class PonyfillBody {
    bodyInit;
    options;
    bodyUsed = false;
    contentType = null;
    contentLength = null;
    constructor(bodyInit, options = {}){
        this.bodyInit = bodyInit;
        this.options = options;
        const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
        this._bodyFactory = bodyFactory;
        this.contentType = contentType;
        this.contentLength = contentLength;
        this.bodyType = bodyType;
        this._buffer = buffer;
        this._signal = options.signal;
    }
    bodyType;
    _bodyFactory = ()=>null;
    _generatedBody = null;
    _buffer;
    _signal;
    generateBody() {
        if (this._generatedBody?.readable?.destroyed && this._buffer) {
            this._generatedBody.readable = node_stream_1.Readable.from(this._buffer);
        }
        if (this._generatedBody) {
            return this._generatedBody;
        }
        const body = this._bodyFactory();
        this._generatedBody = body;
        return body;
    }
    handleContentLengthHeader(forceSet = false) {
        const contentTypeInHeaders = this.headers.get('content-type');
        if (!contentTypeInHeaders) {
            if (this.contentType) {
                this.headers.set('content-type', this.contentType);
            }
        } else {
            this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get('content-length');
        if (forceSet && this.bodyInit == null && !contentLengthInHeaders) {
            this.contentLength = 0;
            this.headers.set('content-length', '0');
        }
        if (!contentLengthInHeaders) {
            if (this.contentLength) {
                this.headers.set('content-length', this.contentLength.toString());
            }
        } else {
            this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
    }
    get body() {
        const _body = this.generateBody();
        if (_body != null) {
            const ponyfillReadableStream = _body;
            const readable = _body.readable;
            return new Proxy(_body.readable, {
                get (_, prop) {
                    if (prop in ponyfillReadableStream) {
                        const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
                        if (typeof ponyfillReadableStreamProp === 'function') {
                            return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
                        }
                        return ponyfillReadableStreamProp;
                    }
                    if (prop in readable) {
                        const readableProp = readable[prop];
                        if (typeof readableProp === 'function') {
                            return readableProp.bind(readable);
                        }
                        return readableProp;
                    }
                }
            });
        }
        return null;
    }
    _chunks = null;
    _doCollectChunksFromReadableJob() {
        if (this.bodyType === BodyInitType.AsyncIterable) {
            if (Array.fromAsync) {
                return (0, promise_helpers_1.handleMaybePromise)(()=>Array.fromAsync(this.bodyInit), (chunks)=>{
                    this._chunks = chunks;
                    return this._chunks;
                });
            }
            const iterator = this.bodyInit[Symbol.asyncIterator]();
            const chunks = [];
            const collectValue = ()=>(0, promise_helpers_1.handleMaybePromise)(()=>iterator.next(), ({ value, done })=>{
                    if (value) {
                        chunks.push(value);
                    }
                    if (!done) {
                        return collectValue();
                    }
                    this._chunks = chunks;
                    return this._chunks;
                });
            return collectValue();
        }
        const _body = this.generateBody();
        if (!_body) {
            this._chunks = [];
            return (0, utils_js_1.fakePromise)(this._chunks);
        }
        if (_body.readable.destroyed) {
            return (0, utils_js_1.fakePromise)(this._chunks = []);
        }
        const chunks = [];
        return new Promise((resolve, reject)=>{
            _body.readable.on('data', (chunk)=>{
                chunks.push(chunk);
            });
            _body.readable.once('error', reject);
            _body.readable.once('end', ()=>{
                resolve(this._chunks = chunks);
            });
        });
    }
    _collectChunksFromReadable() {
        if (this._chunks) {
            return (0, utils_js_1.fakePromise)(this._chunks);
        }
        this._chunks ||= this._doCollectChunksFromReadableJob();
        return this._chunks;
    }
    _blob = null;
    blob() {
        if (this._blob) {
            return (0, utils_js_1.fakePromise)(this._blob);
        }
        if (this.bodyType === BodyInitType.String) {
            this._text = this.bodyInit;
            this._blob = new Blob_js_1.PonyfillBlob([
                this._text
            ], {
                type: this.contentType || 'text/plain;charset=UTF-8',
                size: this.contentLength
            });
        }
        if (this.bodyType === BodyInitType.Blob) {
            this._blob = this.bodyInit;
            return (0, utils_js_1.fakePromise)(this._blob);
        }
        if (this._buffer) {
            this._blob = new Blob_js_1.PonyfillBlob([
                this._buffer
            ], {
                type: this.contentType || '',
                size: this.contentLength
            });
            return (0, utils_js_1.fakePromise)(this._blob);
        }
        return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(()=>this._collectChunksFromReadable(), (chunks)=>{
            this._blob = new Blob_js_1.PonyfillBlob(chunks, {
                type: this.contentType || '',
                size: this.contentLength
            });
            return this._blob;
        }));
    }
    _formData = null;
    formData(opts) {
        if (this._formData) {
            return (0, utils_js_1.fakePromise)(this._formData);
        }
        if (this.bodyType === BodyInitType.FormData) {
            this._formData = this.bodyInit;
            return (0, utils_js_1.fakePromise)(this._formData);
        }
        this._formData = new FormData_js_1.PonyfillFormData();
        const _body = this.generateBody();
        if (_body == null) {
            return (0, utils_js_1.fakePromise)(this._formData);
        }
        const formDataLimits = {
            ...this.options.formDataLimits,
            ...opts?.formDataLimits
        };
        return new Promise((resolve, reject)=>{
            const stream = this.body?.readable;
            if (!stream) {
                return reject(new Error('No stream available'));
            }
            // form data file that is currently being processed, it's
            // important to keep track of it in case the stream ends early
            let currFile = null;
            const bb = new busboy_1.Busboy({
                headers: {
                    'content-length': typeof this.contentLength === 'number' ? this.contentLength.toString() : this.contentLength || '',
                    'content-type': this.contentType || ''
                },
                limits: formDataLimits,
                defCharset: 'utf-8'
            });
            if (this._signal) {
                (0, node_stream_1.addAbortSignal)(this._signal, bb);
            }
            let completed = false;
            const complete = (err)=>{
                if (completed) return;
                completed = true;
                stream.unpipe(bb);
                bb.destroy();
                if (currFile) {
                    currFile.destroy();
                    currFile = null;
                }
                if (err) {
                    reject(err);
                } else {
                    // no error occured, this is a successful end/complete/finish
                    resolve(this._formData);
                }
            };
            // we dont need to listen to the stream close event because bb will close or error when necessary
            // stream.on('close', complete);
            // stream can be aborted, for example
            stream.on('error', complete);
            bb.on('field', (name, value, fieldnameTruncated, valueTruncated)=>{
                if (fieldnameTruncated) {
                    return complete(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
                }
                if (valueTruncated) {
                    return complete(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
                }
                this._formData.set(name, value);
            });
            bb.on('file', (name, fileStream, filename, _transferEncoding, mimeType)=>{
                currFile = fileStream;
                const chunks = [];
                fileStream.on('data', (chunk)=>{
                    chunks.push(chunk);
                });
                fileStream.on('error', complete);
                fileStream.on('limit', ()=>{
                    complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
                });
                fileStream.on('close', ()=>{
                    if (fileStream.truncated) {
                        complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
                    }
                    currFile = null;
                    const file = new File_js_1.PonyfillFile(chunks, filename, {
                        type: mimeType
                    });
                    this._formData.set(name, file);
                });
            });
            bb.on('fieldsLimit', ()=>{
                complete(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
            });
            bb.on('filesLimit', ()=>{
                complete(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
            });
            bb.on('partsLimit', ()=>{
                complete(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
            });
            bb.on('end', complete);
            bb.on('finish', complete);
            bb.on('close', complete);
            bb.on('error', complete);
            stream.pipe(bb);
        });
    }
    buffer() {
        if (this._buffer) {
            return (0, utils_js_1.fakePromise)(this._buffer);
        }
        if (this._text) {
            this._buffer = node_buffer_1.Buffer.from(this._text, 'utf-8');
            return (0, utils_js_1.fakePromise)(this._buffer);
        }
        if (this.bodyType === BodyInitType.String) {
            return this.text().then((text)=>{
                this._text = text;
                this._buffer = node_buffer_1.Buffer.from(text, 'utf-8');
                return this._buffer;
            });
        }
        if (this.bodyType === BodyInitType.Blob) {
            if ((0, Blob_js_1.hasBufferMethod)(this.bodyInit)) {
                return this.bodyInit.buffer().then((buf)=>{
                    this._buffer = buf;
                    return this._buffer;
                });
            }
            if ((0, Blob_js_1.hasBytesMethod)(this.bodyInit)) {
                return this.bodyInit.bytes().then((bytes)=>{
                    this._buffer = node_buffer_1.Buffer.from(bytes);
                    return this._buffer;
                });
            }
            if ((0, Blob_js_1.hasArrayBufferMethod)(this.bodyInit)) {
                return this.bodyInit.arrayBuffer().then((buf)=>{
                    this._buffer = node_buffer_1.Buffer.from(buf, undefined, buf.byteLength);
                    return this._buffer;
                });
            }
        }
        return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(()=>this._collectChunksFromReadable(), (chunks)=>{
            if (chunks.length === 1) {
                this._buffer = chunks[0];
                return this._buffer;
            }
            this._buffer = node_buffer_1.Buffer.concat(chunks);
            return this._buffer;
        }));
    }
    bytes() {
        return this.buffer();
    }
    arrayBuffer() {
        // @ts-ignore - Mismatch between Buffer and ArrayBuffer
        return this.buffer();
    }
    _json = null;
    json() {
        if (this._json) {
            return (0, utils_js_1.fakePromise)(this._json);
        }
        return this.text().then((text)=>{
            try {
                this._json = JSON.parse(text);
            } catch (e) {
                if (e instanceof SyntaxError) {
                    e.message += `, "${text}" is not valid JSON`;
                }
                throw e;
            }
            return this._json;
        });
    }
    _text = null;
    text() {
        if (this._text) {
            return (0, utils_js_1.fakePromise)(this._text);
        }
        if (this.bodyType === BodyInitType.String) {
            this._text = this.bodyInit;
            return (0, utils_js_1.fakePromise)(this._text);
        }
        return this.buffer().then((buffer)=>{
            this._text = buffer.toString('utf-8');
            return this._text;
        });
    }
}
exports.PonyfillBody = PonyfillBody;
function processBodyInit(bodyInit) {
    if (bodyInit == null) {
        return {
            bodyFactory: ()=>null,
            contentType: null,
            contentLength: null
        };
    }
    if (typeof bodyInit === 'string') {
        const contentLength = node_buffer_1.Buffer.byteLength(bodyInit);
        return {
            bodyType: BodyInitType.String,
            contentType: 'text/plain;charset=UTF-8',
            contentLength,
            bodyFactory () {
                const readable = node_stream_1.Readable.from(node_buffer_1.Buffer.from(bodyInit, 'utf-8'));
                return new ReadableStream_js_1.PonyfillReadableStream(readable);
            }
        };
    }
    if (node_buffer_1.Buffer.isBuffer(bodyInit)) {
        const buffer = bodyInit;
        return {
            bodyType: BodyInitType.Buffer,
            contentType: null,
            contentLength: bodyInit.length,
            buffer: bodyInit,
            bodyFactory () {
                const readable = node_stream_1.Readable.from(buffer);
                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
                return body;
            }
        };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
        const buffer = node_buffer_1.Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
        return {
            bodyType: BodyInitType.Buffer,
            contentLength: bodyInit.byteLength,
            contentType: null,
            buffer,
            bodyFactory () {
                const readable = node_stream_1.Readable.from(buffer);
                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
                return body;
            }
        };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {
        const readableStream = bodyInit;
        return {
            bodyType: BodyInitType.ReadableStream,
            bodyFactory: ()=>readableStream,
            contentType: null,
            contentLength: null
        };
    }
    if (isBlob(bodyInit)) {
        const blob = bodyInit;
        return {
            bodyType: BodyInitType.Blob,
            contentType: bodyInit.type,
            contentLength: bodyInit.size,
            bodyFactory () {
                return blob.stream();
            }
        };
    }
    if (bodyInit instanceof ArrayBuffer) {
        const contentLength = bodyInit.byteLength;
        const buffer = node_buffer_1.Buffer.from(bodyInit, undefined, bodyInit.byteLength);
        return {
            bodyType: BodyInitType.Buffer,
            contentType: null,
            contentLength,
            buffer,
            bodyFactory () {
                const readable = node_stream_1.Readable.from(buffer);
                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
                return body;
            }
        };
    }
    if (bodyInit instanceof node_stream_1.Readable) {
        return {
            bodyType: BodyInitType.Readable,
            contentType: null,
            contentLength: null,
            bodyFactory () {
                const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
                return body;
            }
        };
    }
    if (isURLSearchParams(bodyInit)) {
        const contentType = 'application/x-www-form-urlencoded;charset=UTF-8';
        return {
            bodyType: BodyInitType.String,
            contentType,
            contentLength: null,
            bodyFactory () {
                const body = new ReadableStream_js_1.PonyfillReadableStream(node_stream_1.Readable.from(bodyInit.toString()));
                return body;
            }
        };
    }
    if (isFormData(bodyInit)) {
        const boundary = Math.random().toString(36).substr(2);
        const contentType = `multipart/form-data; boundary=${boundary}`;
        return {
            bodyType: BodyInitType.FormData,
            contentType,
            contentLength: null,
            bodyFactory () {
                return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
            }
        };
    }
    if (isReadableStream(bodyInit)) {
        return {
            contentType: null,
            contentLength: null,
            bodyFactory () {
                return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
            }
        };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
        return {
            contentType: null,
            contentLength: null,
            bodyType: BodyInitType.AsyncIterable,
            bodyFactory () {
                const readable = node_stream_1.Readable.from(bodyInit);
                return new ReadableStream_js_1.PonyfillReadableStream(readable);
            }
        };
    }
    throw new Error('Unknown body type');
}
function isFormData(value) {
    return value?.forEach != null;
}
function isBlob(value) {
    return value?.stream != null && typeof value.stream === 'function';
}
function isURLSearchParams(value) {
    return value?.sort != null;
}
function isReadableStream(value) {
    return value?.getReader != null;
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/Headers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillHeaders = void 0;
exports.isHeadersLike = isHeadersLike;
const node_util_1 = __turbopack_context__.r("[externals]/node:util [external] (node:util, cjs)");
const IteratorObject_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/IteratorObject.js [app-route] (ecmascript)");
function isHeadersLike(headers) {
    return headers?.get && headers?.forEach;
}
class PonyfillHeaders {
    headersInit;
    _map;
    objectNormalizedKeysOfHeadersInit = [];
    objectOriginalKeysOfHeadersInit = [];
    _setCookies;
    constructor(headersInit){
        this.headersInit = headersInit;
    }
    // perf: we don't need to build `this.map` for Requests, as we can access the headers directly
    _get(key) {
        const normalized = key.toLowerCase();
        if (normalized === 'set-cookie' && this._setCookies?.length) {
            return this._setCookies.join(', ');
        }
        // If the map is built, reuse it
        if (this._map) {
            return this._map.get(normalized) || null;
        }
        // If the map is not built, try to get the value from the this.headersInit
        if (this.headersInit == null) {
            return null;
        }
        if (Array.isArray(this.headersInit)) {
            const found = this.headersInit.filter(([headerKey])=>headerKey.toLowerCase() === normalized);
            if (found.length === 0) {
                return null;
            }
            if (found.length === 1) {
                return found[0][1];
            }
            return found.map(([, value])=>value).join(', ');
        } else if (isHeadersLike(this.headersInit)) {
            return this.headersInit.get(normalized);
        } else {
            const initValue = this.headersInit[key] || this.headersInit[normalized];
            if (initValue != null) {
                return initValue;
            }
            if (!this.objectNormalizedKeysOfHeadersInit.length) {
                Object.keys(this.headersInit).forEach((k)=>{
                    this.objectOriginalKeysOfHeadersInit.push(k);
                    this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
                });
            }
            const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
            if (index === -1) {
                return null;
            }
            const originalKey = this.objectOriginalKeysOfHeadersInit[index];
            return this.headersInit[originalKey];
        }
    }
    // perf: Build the map of headers lazily, only when we need to access all headers or write to it.
    // I could do a getter here, but I'm too lazy to type `getter`.
    getMap() {
        if (!this._map) {
            this._setCookies ||= [];
            if (this.headersInit != null) {
                if (Array.isArray(this.headersInit)) {
                    this._map = new Map();
                    for (const [key, value] of this.headersInit){
                        const normalizedKey = key.toLowerCase();
                        if (normalizedKey === 'set-cookie') {
                            if (Array.isArray(value)) {
                                this._setCookies.push(...value);
                            } else if (value != null) {
                                this._setCookies.push(value);
                            }
                            continue;
                        }
                        this._map.set(normalizedKey, value);
                    }
                } else if (isHeadersLike(this.headersInit)) {
                    this._map = new Map();
                    this.headersInit.forEach((value, key)=>{
                        if (key === 'set-cookie') {
                            this._setCookies ||= [];
                            if (Array.isArray(value)) {
                                this._setCookies.push(...value);
                            } else if (value != null) {
                                this._setCookies.push(value);
                            }
                            return;
                        }
                        this._map.set(key, value);
                    });
                } else {
                    this._map = new Map();
                    for(const initKey in this.headersInit){
                        const initValue = this.headersInit[initKey];
                        if (initValue != null) {
                            const normalizedKey = initKey.toLowerCase();
                            if (normalizedKey === 'set-cookie') {
                                this._setCookies ||= [];
                                if (Array.isArray(initValue)) {
                                    this._setCookies.push(...initValue);
                                    continue;
                                }
                                this._setCookies.push(initValue);
                                continue;
                            }
                            this._map.set(normalizedKey, initValue);
                        }
                    }
                }
            } else {
                this._map = new Map();
            }
        }
        return this._map;
    }
    append(name, value) {
        const key = name.toLowerCase();
        if (key === 'set-cookie') {
            this._setCookies ||= [];
            this._setCookies.push(value);
            return;
        }
        const existingValue = this.getMap().get(key);
        const finalValue = existingValue ? `${existingValue}, ${value}` : value;
        this.getMap().set(key, finalValue);
    }
    get(name) {
        const value = this._get(name);
        if (value == null) {
            return null;
        }
        return value.toString();
    }
    has(name) {
        const key = name.toLowerCase();
        if (key === 'set-cookie') {
            return !!this._setCookies?.length;
        }
        return !!this._get(name); // we might need to check if header exists and not just check if it's not nullable
    }
    set(name, value) {
        const key = name.toLowerCase();
        if (key === 'set-cookie') {
            this._setCookies = [
                value
            ];
            return;
        }
        if (!this._map && this.headersInit != null) {
            if (Array.isArray(this.headersInit)) {
                const found = this.headersInit.find(([headerKey])=>headerKey.toLowerCase() === key);
                if (found) {
                    found[1] = value;
                } else {
                    this.headersInit.push([
                        key,
                        value
                    ]);
                }
                return;
            } else if (isHeadersLike(this.headersInit)) {
                this.headersInit.set(key, value);
                return;
            } else {
                this.headersInit[key] = value;
                return;
            }
        }
        this.getMap().set(key, value);
    }
    delete(name) {
        const key = name.toLowerCase();
        if (key === 'set-cookie') {
            this._setCookies = [];
            return;
        }
        this.getMap().delete(key);
    }
    forEach(callback) {
        this._setCookies?.forEach((setCookie)=>{
            callback(setCookie, 'set-cookie', this);
        });
        if (!this._map) {
            if (this.headersInit) {
                if (Array.isArray(this.headersInit)) {
                    this.headersInit.forEach(([key, value])=>{
                        callback(value, key, this);
                    });
                    return;
                }
                if (isHeadersLike(this.headersInit)) {
                    this.headersInit.forEach(callback);
                    return;
                }
                Object.entries(this.headersInit).forEach(([key, value])=>{
                    if (value != null) {
                        callback(value, key, this);
                    }
                });
            }
            return;
        }
        this.getMap().forEach((value, key)=>{
            callback(value, key, this);
        });
    }
    *_keys() {
        if (this._setCookies?.length) {
            yield 'set-cookie';
        }
        if (!this._map) {
            if (this.headersInit) {
                if (Array.isArray(this.headersInit)) {
                    yield* this.headersInit.map(([key])=>key)[Symbol.iterator]();
                    return;
                }
                if (isHeadersLike(this.headersInit)) {
                    yield* this.headersInit.keys();
                    return;
                }
                yield* Object.keys(this.headersInit)[Symbol.iterator]();
                return;
            }
        }
        yield* this.getMap().keys();
    }
    keys() {
        return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), 'HeadersIterator');
    }
    *_values() {
        if (this._setCookies?.length) {
            yield* this._setCookies;
        }
        if (!this._map) {
            if (this.headersInit) {
                if (Array.isArray(this.headersInit)) {
                    yield* this.headersInit.map(([, value])=>value)[Symbol.iterator]();
                    return;
                }
                if (isHeadersLike(this.headersInit)) {
                    yield* this.headersInit.values();
                    return;
                }
                yield* Object.values(this.headersInit)[Symbol.iterator]();
                return;
            }
        }
        yield* this.getMap().values();
    }
    values() {
        return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), 'HeadersIterator');
    }
    *_entries() {
        if (this._setCookies?.length) {
            yield* this._setCookies.map((cookie)=>[
                    'set-cookie',
                    cookie
                ]);
        }
        if (!this._map) {
            if (this.headersInit) {
                if (Array.isArray(this.headersInit)) {
                    yield* this.headersInit;
                    return;
                }
                if (isHeadersLike(this.headersInit)) {
                    yield* this.headersInit.entries();
                    return;
                }
                yield* Object.entries(this.headersInit);
                return;
            }
        }
        yield* this.getMap().entries();
    }
    entries() {
        return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), 'HeadersIterator');
    }
    getSetCookie() {
        if (!this._setCookies) {
            this.getMap();
        }
        return this._setCookies;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        const record = {};
        this.forEach((value, key)=>{
            if (key === 'set-cookie') {
                record['set-cookie'] = this._setCookies || [];
            } else {
                record[key] = value?.includes(',') ? value.split(',').map((el)=>el.trim()) : value;
            }
        });
        return `Headers ${(0, node_util_1.inspect)(record)}`;
    }
}
exports.PonyfillHeaders = PonyfillHeaders;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/Response.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillResponse = void 0;
const node_http_1 = __turbopack_context__.r("[externals]/node:http [external] (node:http, cjs)");
const Body_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Body.js [app-route] (ecmascript)");
const Headers_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Headers.js [app-route] (ecmascript)");
const JSON_CONTENT_TYPE = 'application/json; charset=utf-8';
class PonyfillResponse extends Body_js_1.PonyfillBody {
    headers;
    constructor(body, init){
        super(body || null, init);
        this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
        this.status = init?.status || 200;
        this.statusText = init?.statusText || node_http_1.STATUS_CODES[this.status] || 'OK';
        this.url = init?.url || '';
        this.redirected = init?.redirected || false;
        this.type = init?.type || 'default';
        this.handleContentLengthHeader();
    }
    get ok() {
        return this.status >= 200 && this.status < 300;
    }
    status;
    statusText;
    url;
    redirected;
    type;
    clone() {
        return this;
    }
    static error() {
        return new PonyfillResponse(null, {
            status: 500,
            statusText: 'Internal Server Error'
        });
    }
    static redirect(url, status = 302) {
        if (status < 300 || status > 399) {
            throw new RangeError('Invalid status code');
        }
        return new PonyfillResponse(null, {
            headers: {
                location: url
            },
            status
        });
    }
    static json(data, init) {
        const bodyInit = JSON.stringify(data);
        if (!init) {
            init = {
                headers: {
                    'content-type': JSON_CONTENT_TYPE,
                    'content-length': Buffer.byteLength(bodyInit).toString()
                }
            };
        } else if (!init.headers) {
            init.headers = {
                'content-type': JSON_CONTENT_TYPE,
                'content-length': Buffer.byteLength(bodyInit).toString()
            };
        } else if ((0, Headers_js_1.isHeadersLike)(init.headers)) {
            if (!init.headers.has('content-type')) {
                init.headers.set('content-type', JSON_CONTENT_TYPE);
            }
            if (!init.headers.has('content-length')) {
                init.headers.set('content-length', Buffer.byteLength(bodyInit).toString());
            }
        } else if (Array.isArray(init.headers)) {
            let contentTypeExists = false;
            let contentLengthExists = false;
            for (const [key] of init.headers){
                if (contentLengthExists && contentTypeExists) {
                    break;
                }
                if (!contentTypeExists && key.toLowerCase() === 'content-type') {
                    contentTypeExists = true;
                } else if (!contentLengthExists && key.toLowerCase() === 'content-length') {
                    contentLengthExists = true;
                }
            }
            if (!contentTypeExists) {
                init.headers.push([
                    'content-type',
                    JSON_CONTENT_TYPE
                ]);
            }
            if (!contentLengthExists) {
                init.headers.push([
                    'content-length',
                    Buffer.byteLength(bodyInit).toString()
                ]);
            }
        } else if (typeof init.headers === 'object') {
            if (init.headers?.['content-type'] == null) {
                init.headers['content-type'] = JSON_CONTENT_TYPE;
            }
            if (init.headers?.['content-length'] == null) {
                init.headers['content-length'] = Buffer.byteLength(bodyInit).toString();
            }
        }
        return new PonyfillResponse(bodyInit, init);
    }
    [Symbol.toStringTag] = 'Response';
}
exports.PonyfillResponse = PonyfillResponse;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchCurl = fetchCurl;
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const node_tls_1 = __turbopack_context__.r("[externals]/node:tls [external] (node:tls, cjs)");
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
const Response_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Response.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
function fetchCurl(fetchRequest) {
    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis['libcurl'];
    const curlHandle = new Curl();
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt('URL', fetchRequest.url);
    if (process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0') {
        curlHandle.setOpt('SSL_VERIFYPEER', false);
    }
    if (process.env.NODE_EXTRA_CA_CERTS) {
        curlHandle.setOpt('CAINFO', process.env.NODE_EXTRA_CA_CERTS);
    } else {
        curlHandle.setOpt('CAINFO_BLOB', node_tls_1.rootCertificates.join('\n'));
    }
    curlHandle.enable(CurlFeature.StreamResponse);
    let signal;
    if (fetchRequest._signal === null) {
        signal = undefined;
    } else if (fetchRequest._signal) {
        signal = fetchRequest._signal;
    }
    curlHandle.setStreamProgressCallback(function() {
        return signal?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest['bodyType'] === 'String') {
        curlHandle.setOpt('POSTFIELDS', fetchRequest['bodyInit']);
    } else {
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;
        if (nodeReadable) {
            curlHandle.setOpt('UPLOAD', true);
            curlHandle.setUploadStream(nodeReadable);
        }
    }
    if (process.env.DEBUG) {
        curlHandle.setOpt('VERBOSE', true);
    }
    curlHandle.setOpt('TRANSFER_ENCODING', false);
    curlHandle.setOpt('HTTP_TRANSFER_DECODING', true);
    curlHandle.setOpt('FOLLOWLOCATION', fetchRequest.redirect === 'follow');
    curlHandle.setOpt('MAXREDIRS', 20);
    curlHandle.setOpt('ACCEPT_ENCODING', '');
    curlHandle.setOpt('CUSTOMREQUEST', fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value)=>{
        size = Number(value);
    });
    if (size != null) {
        curlHandle.setOpt('INFILESIZE', size);
    }
    curlHandle.setOpt('HTTPHEADER', curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    const deferredPromise = (0, promise_helpers_1.createDeferredPromise)();
    let streamResolved;
    function onAbort() {
        if (curlHandle.isOpen) {
            try {
                curlHandle.pause(CurlPause.Recv);
            } catch (e) {
                deferredPromise.reject(e);
            }
        }
    }
    signal?.addEventListener('abort', onAbort, {
        once: true
    });
    curlHandle.once('end', function endListener() {
        try {
            curlHandle.close();
        } catch (e) {
            deferredPromise.reject(e);
        }
        signal?.removeEventListener('abort', onAbort);
    });
    curlHandle.once('error', function errorListener(error) {
        if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {
            streamResolved.destroy(error);
        } else {
            if (error.message === 'Operation was aborted by an application callback') {
                error.message = 'The operation was aborted.';
            }
            deferredPromise.reject(error);
        }
        try {
            curlHandle.close();
        } catch (e) {
            deferredPromise.reject(e);
        }
    });
    curlHandle.once('stream', function streamListener(stream, status, headersBuf) {
        const outputStream = stream.pipe(new node_stream_1.PassThrough(), {
            end: true
        });
        const headersFlat = headersBuf.toString('utf8').split(/\r?\n|\r/g).filter((headerFilter)=>{
            if (headerFilter && !headerFilter.startsWith('HTTP/')) {
                if (fetchRequest.redirect === 'error' && headerFilter.toLowerCase().includes('location') && (0, utils_js_1.shouldRedirect)(status)) {
                    if (!stream.destroyed) {
                        stream.resume();
                    }
                    outputStream.destroy();
                    deferredPromise.reject(new Error('redirect is not allowed'));
                }
                return true;
            }
            return false;
        });
        const headersInit = headersFlat.map((headerFlat)=>headerFlat.split(/:\s(.+)/).slice(0, 2));
        const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {
            status,
            headers: headersInit,
            url: curlHandle.getInfo(Curl.info.REDIRECT_URL)?.toString() || fetchRequest.url,
            redirected: Number(curlHandle.getInfo(Curl.info.REDIRECT_COUNT)) > 0
        });
        deferredPromise.resolve(ponyfillResponse);
        streamResolved = outputStream;
    });
    setImmediate(()=>{
        curlHandle.perform();
    });
    return deferredPromise.promise;
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/URL.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillURL = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_buffer_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)"));
const node_crypto_1 = __turbopack_context__.r("[externals]/node:crypto [external] (node:crypto, cjs)");
const NativeURL = globalThis.URL;
class URL extends NativeURL {
    // This part is only needed to handle `PonyfillBlob` objects
    static blobRegistry = new Map();
    static createObjectURL(blob) {
        const blobUrl = `blob:whatwgnode:${(0, node_crypto_1.randomUUID)()}`;
        this.blobRegistry.set(blobUrl, blob);
        return blobUrl;
    }
    static revokeObjectURL(url) {
        if (!this.blobRegistry.has(url)) {
            NativeURL.revokeObjectURL(url);
        } else {
            this.blobRegistry.delete(url);
        }
    }
    static getBlobFromURL(url) {
        return this.blobRegistry.get(url) || node_buffer_1.default?.resolveObjectURL?.(url);
    }
}
exports.PonyfillURL = URL;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/Request.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillRequest = void 0;
const node_http_1 = __turbopack_context__.r("[externals]/node:http [external] (node:http, cjs)");
const node_https_1 = __turbopack_context__.r("[externals]/node:https [external] (node:https, cjs)");
const Body_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Body.js [app-route] (ecmascript)");
const Headers_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Headers.js [app-route] (ecmascript)");
const URL_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/URL.js [app-route] (ecmascript)");
function isRequest(input) {
    return input[Symbol.toStringTag] === 'Request';
}
function isURL(obj) {
    return obj?.href != null;
}
class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options){
        let _url;
        let _parsedUrl;
        let bodyInit = null;
        let requestInit;
        if (typeof input === 'string') {
            _url = input;
        } else if (isURL(input)) {
            _parsedUrl = input;
        } else if (isRequest(input)) {
            if (input._parsedUrl) {
                _parsedUrl = input._parsedUrl;
            } else if (input._url) {
                _url = input._url;
            } else {
                _url = input.url;
            }
            bodyInit = input.body;
            requestInit = input;
        }
        if (options != null) {
            bodyInit = options.body || null;
            requestInit = options;
        }
        super(bodyInit, requestInit);
        this._url = _url;
        this._parsedUrl = _parsedUrl;
        this.cache = requestInit?.cache || 'default';
        this.credentials = requestInit?.credentials || 'same-origin';
        this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
        this.integrity = requestInit?.integrity || '';
        this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
        this.method = requestInit?.method?.toUpperCase() || 'GET';
        this.mode = requestInit?.mode || 'cors';
        this.redirect = requestInit?.redirect || 'follow';
        this.referrer = requestInit?.referrer || 'about:client';
        this.referrerPolicy = requestInit?.referrerPolicy || 'no-referrer';
        this.headersSerializer = requestInit?.headersSerializer;
        this.duplex = requestInit?.duplex || 'half';
        this.destination = 'document';
        this.priority = 'auto';
        if (this.method !== 'GET' && this.method !== 'HEAD') {
            this.handleContentLengthHeader(true);
        }
        if (requestInit?.agent != null) {
            const protocol = _parsedUrl?.protocol || _url || this.url;
            if (requestInit.agent === false) {
                this.agent = false;
            } else if (protocol.startsWith('http:') && requestInit.agent instanceof node_http_1.Agent) {
                this.agent = requestInit.agent;
            } else if (protocol.startsWith('https:') && requestInit.agent instanceof node_https_1.Agent) {
                this.agent = requestInit.agent;
            }
        }
    }
    headersSerializer;
    cache;
    credentials;
    destination;
    headers;
    integrity;
    keepalive;
    method;
    mode;
    priority;
    redirect;
    referrer;
    referrerPolicy;
    _url;
    get signal() {
        this._signal ||= new AbortController().signal;
        return this._signal;
    }
    get url() {
        if (this._url == null) {
            if (this._parsedUrl) {
                this._url = this._parsedUrl.toString();
            } else {
                throw new TypeError('Invalid URL');
            }
        }
        return this._url;
    }
    _parsedUrl;
    get parsedUrl() {
        if (this._parsedUrl == null) {
            if (this._url != null) {
                this._parsedUrl = new URL_js_1.PonyfillURL(this._url, 'http://localhost');
            } else {
                throw new TypeError('Invalid URL');
            }
        }
        return this._parsedUrl;
    }
    duplex;
    agent;
    clone() {
        return this;
    }
    [Symbol.toStringTag] = 'Request';
}
exports.PonyfillRequest = PonyfillRequest;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchNodeHttp = fetchNodeHttp;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_http_1 = __turbopack_context__.r("[externals]/node:http [external] (node:http, cjs)");
const node_https_1 = __turbopack_context__.r("[externals]/node:https [external] (node:https, cjs)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const node_zlib_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:zlib [external] (node:zlib, cjs)"));
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
const Request_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Request.js [app-route] (ecmascript)");
const Response_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Response.js [app-route] (ecmascript)");
const URL_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/URL.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
function getRequestFnForProtocol(url) {
    if (url.startsWith('http:')) {
        return node_http_1.request;
    } else if (url.startsWith('https:')) {
        return node_https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(':')[0] || url}`);
}
function fetchNodeHttp(fetchRequest) {
    return new Promise((resolve, reject)=>{
        try {
            const requestFn = getRequestFnForProtocol(fetchRequest.parsedUrl?.protocol || fetchRequest.url);
            const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
            const nodeHeaders = headersSerializer(fetchRequest.headers);
            nodeHeaders['accept-encoding'] ||= utils_js_1.DEFAULT_ACCEPT_ENCODING;
            if (nodeHeaders['user-agent'] == null && nodeHeaders['User-Agent'] == null) {
                nodeHeaders['user-agent'] = 'node';
            }
            let signal;
            if (fetchRequest._signal == null) {
                signal = undefined;
            } else if (fetchRequest._signal) {
                signal = fetchRequest._signal;
            }
            let nodeRequest;
            // If it is our ponyfilled Request, it should have `parsedUrl` which is a `URL` object
            if (fetchRequest.parsedUrl) {
                nodeRequest = requestFn(fetchRequest.parsedUrl, {
                    method: fetchRequest.method,
                    headers: nodeHeaders,
                    signal,
                    agent: fetchRequest.agent
                });
            } else {
                nodeRequest = requestFn(fetchRequest.url, {
                    method: fetchRequest.method,
                    headers: nodeHeaders,
                    signal,
                    agent: fetchRequest.agent
                });
            }
            nodeRequest.once('error', reject);
            nodeRequest.once('response', (nodeResponse)=>{
                let outputStream;
                const contentEncoding = nodeResponse.headers['content-encoding'];
                switch(contentEncoding){
                    case 'x-gzip':
                    case 'gzip':
                        outputStream = node_zlib_1.default.createGunzip();
                        break;
                    case 'x-deflate':
                    case 'deflate':
                        outputStream = node_zlib_1.default.createInflate();
                        break;
                    case 'x-deflate-raw':
                    case 'deflate-raw':
                        outputStream = node_zlib_1.default.createInflateRaw();
                        break;
                    case 'br':
                        outputStream = node_zlib_1.default.createBrotliDecompress();
                        break;
                    case 'zstd':
                        if (node_zlib_1.default.createZstdDecompress != null) {
                            outputStream = node_zlib_1.default.createZstdDecompress();
                        }
                        break;
                }
                if (nodeResponse.headers.location && (0, utils_js_1.shouldRedirect)(nodeResponse.statusCode)) {
                    if (fetchRequest.redirect === 'error') {
                        const redirectError = new Error('Redirects are not allowed');
                        reject(redirectError);
                        nodeResponse.resume();
                        return;
                    }
                    if (fetchRequest.redirect === 'follow') {
                        const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.parsedUrl || fetchRequest.url);
                        const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
                        resolve(redirectResponse$.then((redirectResponse)=>{
                            redirectResponse.redirected = true;
                            return redirectResponse;
                        }));
                        nodeResponse.resume();
                        return;
                    }
                }
                outputStream ||= new node_stream_1.PassThrough();
                (0, utils_js_1.pipeThrough)({
                    src: nodeResponse,
                    dest: outputStream,
                    signal,
                    onError: (e)=>{
                        if (!nodeResponse.destroyed) {
                            nodeResponse.destroy(e);
                        }
                        if (!outputStream.destroyed) {
                            outputStream.destroy(e);
                        }
                        reject(e);
                    }
                });
                const statusCode = nodeResponse.statusCode || 200;
                let statusText = nodeResponse.statusMessage || node_http_1.STATUS_CODES[statusCode];
                if (statusText == null) {
                    statusText = '';
                }
                const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream || nodeResponse, {
                    status: statusCode,
                    statusText,
                    headers: nodeResponse.headers,
                    url: fetchRequest.url,
                    signal
                });
                resolve(ponyfillResponse);
            });
            if (fetchRequest['_buffer'] != null) {
                (0, promise_helpers_1.handleMaybePromise)(()=>(0, utils_js_1.safeWrite)(fetchRequest['_buffer'], nodeRequest), ()=>(0, utils_js_1.endStream)(nodeRequest), reject);
            } else {
                const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;
                if (nodeReadable) {
                    nodeReadable.pipe(nodeRequest);
                } else {
                    (0, utils_js_1.endStream)(nodeRequest);
                }
            }
        } catch (e) {
            reject(e);
        }
    });
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/fetch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchPonyfill = fetchPonyfill;
const node_buffer_1 = __turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)");
const node_fs_1 = __turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)");
const node_url_1 = __turbopack_context__.r("[externals]/node:url [external] (node:url, cjs)");
const fetchCurl_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js [app-route] (ecmascript)");
const fetchNodeHttp_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js [app-route] (ecmascript)");
const Request_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Request.js [app-route] (ecmascript)");
const Response_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Response.js [app-route] (ecmascript)");
const URL_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/URL.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
const BASE64_SUFFIX = ';base64';
async function getResponseForFile(url) {
    const path = (0, node_url_1.fileURLToPath)(url);
    try {
        await node_fs_1.promises.access(path, node_fs_1.promises.constants.R_OK);
        const stats = await node_fs_1.promises.stat(path, {
            bigint: true
        });
        const readable = (0, node_fs_1.createReadStream)(path);
        return new Response_js_1.PonyfillResponse(readable, {
            status: 200,
            statusText: 'OK',
            headers: {
                'content-type': 'application/octet-stream',
                'last-modified': stats.mtime.toUTCString()
            }
        });
    } catch (err) {
        if (err.code === 'ENOENT') {
            return new Response_js_1.PonyfillResponse(null, {
                status: 404,
                statusText: 'Not Found'
            });
        } else if (err.code === 'EACCES') {
            return new Response_js_1.PonyfillResponse(null, {
                status: 403,
                statusText: 'Forbidden'
            });
        }
        throw err;
    }
}
function getResponseForDataUri(url) {
    const [mimeType = 'text/plain', ...datas] = url.substring(5).split(',');
    const data = decodeURIComponent(datas.join(','));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
        const buffer = node_buffer_1.Buffer.from(data, 'base64url');
        const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
        return new Response_js_1.PonyfillResponse(buffer, {
            status: 200,
            statusText: 'OK',
            headers: {
                'content-type': realMimeType
            }
        });
    }
    return new Response_js_1.PonyfillResponse(data, {
        status: 200,
        statusText: 'OK',
        headers: {
            'content-type': mimeType
        }
    });
}
function getResponseForBlob(url) {
    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);
    if (!blob) {
        throw new TypeError('Invalid Blob URL');
    }
    return new Response_js_1.PonyfillResponse(blob, {
        status: 200,
        headers: {
            'content-type': blob.type,
            'content-length': blob.size.toString()
        }
    });
}
function isURL(obj) {
    return obj != null && obj.href != null;
}
function fetchPonyfill(info, init) {
    if (typeof info === 'string' || isURL(info)) {
        const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
        return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith('data:')) {
        const response = getResponseForDataUri(fetchRequest.url);
        return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith('file:')) {
        const response = getResponseForFile(fetchRequest.url);
        return response;
    }
    if (fetchRequest.url.startsWith('blob:')) {
        const response = getResponseForBlob(fetchRequest.url);
        return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl && !fetchRequest.agent) {
        return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = void 0;
exports.PonyfillBtoa = PonyfillBtoa;
const node_buffer_1 = __turbopack_context__.r("[externals]/node:buffer [external] (node:buffer, cjs)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
class PonyfillTextEncoder {
    encoding;
    constructor(encoding = 'utf-8'){
        this.encoding = encoding;
    }
    encode(input) {
        return node_buffer_1.Buffer.from(input, this.encoding);
    }
    encodeInto(source, destination) {
        const buffer = this.encode(source);
        const copied = buffer.copy(destination);
        return {
            read: copied,
            written: copied
        };
    }
}
exports.PonyfillTextEncoder = PonyfillTextEncoder;
class PonyfillTextDecoder {
    encoding;
    fatal = false;
    ignoreBOM = false;
    constructor(encoding = 'utf-8', options){
        this.encoding = encoding;
        if (options) {
            this.fatal = options.fatal || false;
            this.ignoreBOM = options.ignoreBOM || false;
        }
    }
    decode(input) {
        if (node_buffer_1.Buffer.isBuffer(input)) {
            return input.toString(this.encoding);
        }
        if ((0, utils_js_1.isArrayBufferView)(input)) {
            return node_buffer_1.Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
        }
        return node_buffer_1.Buffer.from(input).toString(this.encoding);
    }
}
exports.PonyfillTextDecoder = PonyfillTextDecoder;
function PonyfillBtoa(input) {
    return node_buffer_1.Buffer.from(input, 'binary').toString('base64');
}
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillURLSearchParams = void 0;
exports.PonyfillURLSearchParams = globalThis.URLSearchParams;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillWritableStream = void 0;
const node_events_1 = __turbopack_context__.r("[externals]/node:events [external] (node:events, cjs)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
class PonyfillWritableStream {
    writable;
    constructor(underlyingSink){
        if (underlyingSink instanceof node_stream_1.Writable) {
            this.writable = underlyingSink;
        } else if (underlyingSink) {
            const writable = new node_stream_1.Writable({
                write (chunk, _encoding, callback) {
                    try {
                        const result = underlyingSink.write?.(chunk, controller);
                        if (result instanceof Promise) {
                            result.then(()=>{
                                callback();
                            }, (err)=>{
                                callback(err);
                            });
                        } else {
                            callback();
                        }
                    } catch (err) {
                        callback(err);
                    }
                },
                final (callback) {
                    const result = underlyingSink.close?.();
                    if (result instanceof Promise) {
                        result.then(()=>{
                            callback();
                        }, (err)=>{
                            callback(err);
                        });
                    } else {
                        callback();
                    }
                }
            });
            this.writable = writable;
            const abortCtrl = new AbortController();
            const controller = {
                signal: abortCtrl.signal,
                error (e) {
                    writable.destroy(e);
                }
            };
            writable.once('error', (err)=>abortCtrl.abort(err));
            writable.once('close', ()=>abortCtrl.abort());
        } else {
            this.writable = new node_stream_1.Writable();
        }
    }
    getWriter() {
        const writable = this.writable;
        return {
            get closed () {
                return (0, node_events_1.once)(writable, 'close');
            },
            get desiredSize () {
                return writable.writableLength;
            },
            get ready () {
                return (0, node_events_1.once)(writable, 'drain');
            },
            releaseLock () {
            // no-op
            },
            write (chunk) {
                const promise = (0, utils_js_1.fakePromise)();
                if (chunk == null) {
                    return promise;
                }
                return promise.then(()=>(0, utils_js_1.safeWrite)(chunk, writable));
            },
            close () {
                if (!writable.errored && writable.closed) {
                    return (0, utils_js_1.fakePromise)();
                }
                if (writable.errored) {
                    return (0, promise_helpers_1.fakeRejectPromise)(writable.errored);
                }
                return (0, utils_js_1.fakePromise)().then(()=>(0, utils_js_1.endStream)(writable));
            },
            abort (reason) {
                writable.destroy(reason);
                return (0, node_events_1.once)(writable, 'close');
            }
        };
    }
    close() {
        if (!this.writable.errored && this.writable.closed) {
            return (0, utils_js_1.fakePromise)();
        }
        if (this.writable.errored) {
            return (0, promise_helpers_1.fakeRejectPromise)(this.writable.errored);
        }
        return (0, utils_js_1.fakePromise)().then(()=>(0, utils_js_1.endStream)(this.writable));
    }
    abort(reason) {
        this.writable.destroy(reason);
        return (0, node_events_1.once)(this.writable, 'close');
    }
    locked = false;
}
exports.PonyfillWritableStream = PonyfillWritableStream;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillTransformStream = void 0;
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const ReadableStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
const WritableStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js [app-route] (ecmascript)");
class PonyfillTransformStream {
    transform;
    writable;
    readable;
    constructor(transformer){
        if (transformer instanceof node_stream_1.Transform) {
            this.transform = transformer;
        } else if (transformer) {
            const controller = {
                enqueue (chunk) {
                    transform.push(chunk);
                },
                error (reason) {
                    transform.destroy(reason);
                },
                terminate () {
                    (0, utils_js_1.endStream)(transform);
                },
                get desiredSize () {
                    return transform.writableLength;
                }
            };
            const transform = new node_stream_1.Transform({
                read () {},
                write (chunk, _encoding, callback) {
                    try {
                        const result = transformer.transform?.(chunk, controller);
                        if (result instanceof Promise) {
                            result.then(()=>{
                                callback();
                            }, (err)=>{
                                callback(err);
                            });
                        } else {
                            callback();
                        }
                    } catch (err) {
                        callback(err);
                    }
                },
                final (callback) {
                    try {
                        const result = transformer.flush?.(controller);
                        if (result instanceof Promise) {
                            result.then(()=>{
                                callback();
                            }, (err)=>{
                                callback(err);
                            });
                        } else {
                            callback();
                        }
                    } catch (err) {
                        callback(err);
                    }
                }
            });
            this.transform = transform;
        } else {
            this.transform = new node_stream_1.Transform();
        }
        this.writable = new WritableStream_js_1.PonyfillWritableStream(this.transform);
        this.readable = new ReadableStream_js_1.PonyfillReadableStream(this.transform);
    }
}
exports.PonyfillTransformStream = PonyfillTransformStream;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/CompressionStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillCompressionStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_zlib_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:zlib [external] (node:zlib, cjs)"));
const TransformStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
class PonyfillCompressionStream extends TransformStream_js_1.PonyfillTransformStream {
    static supportedFormats = (0, utils_js_1.getSupportedFormats)();
    constructor(compressionFormat){
        switch(compressionFormat){
            case 'x-gzip':
            case 'gzip':
                super(node_zlib_1.default.createGzip());
                break;
            case 'x-deflate':
            case 'deflate':
                super(node_zlib_1.default.createDeflate());
                break;
            case 'deflate-raw':
                super(node_zlib_1.default.createDeflateRaw());
                break;
            case 'br':
                super(node_zlib_1.default.createBrotliCompress());
                break;
            case 'zstd':
                super(node_zlib_1.default.createZstdCompress());
                break;
            default:
                throw new Error(`Unsupported compression format: ${compressionFormat}`);
        }
    }
}
exports.PonyfillCompressionStream = PonyfillCompressionStream;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/DecompressionStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillDecompressionStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const node_zlib_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/node:zlib [external] (node:zlib, cjs)"));
const TransformStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/utils.js [app-route] (ecmascript)");
class PonyfillDecompressionStream extends TransformStream_js_1.PonyfillTransformStream {
    static supportedFormats = (0, utils_js_1.getSupportedFormats)();
    constructor(compressionFormat){
        switch(compressionFormat){
            case 'x-gzip':
            case 'gzip':
                super(node_zlib_1.default.createGunzip());
                break;
            case 'x-deflate':
            case 'deflate':
                super(node_zlib_1.default.createInflate());
                break;
            case 'deflate-raw':
                super(node_zlib_1.default.createInflateRaw());
                break;
            case 'br':
                super(node_zlib_1.default.createBrotliDecompress());
                break;
            case 'zstd':
                super(node_zlib_1.default.createZstdDecompress());
                break;
            default:
                throw new TypeError(`Unsupported compression format: '${compressionFormat}'`);
        }
    }
}
exports.PonyfillDecompressionStream = PonyfillDecompressionStream;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoderStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PonyfillTextEncoderStream = exports.PonyfillTextDecoderStream = void 0;
const TextEncoderDecoder_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js [app-route] (ecmascript)");
const TransformStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js [app-route] (ecmascript)");
class PonyfillTextDecoderStream extends TransformStream_js_1.PonyfillTransformStream {
    textDecoder;
    constructor(encoding, options){
        super({
            transform: (chunk, controller)=>controller.enqueue(this.textDecoder.decode(chunk, {
                    stream: true
                }))
        });
        this.textDecoder = new TextEncoderDecoder_js_1.PonyfillTextDecoder(encoding, options);
    }
    get encoding() {
        return this.textDecoder.encoding;
    }
    get fatal() {
        return this.textDecoder.fatal;
    }
    get ignoreBOM() {
        return this.textDecoder.ignoreBOM;
    }
}
exports.PonyfillTextDecoderStream = PonyfillTextDecoderStream;
class PonyfillTextEncoderStream extends TransformStream_js_1.PonyfillTransformStream {
    textEncoder;
    constructor(encoding){
        super({
            transform: (chunk, controller)=>controller.enqueue(this.textEncoder.encode(chunk))
        });
        this.textEncoder = new TextEncoderDecoder_js_1.PonyfillTextEncoder(encoding);
    }
    get encoding() {
        return this.textEncoder.encoding;
    }
    encode(input) {
        return this.textEncoder.encode(input);
    }
}
exports.PonyfillTextEncoderStream = PonyfillTextEncoderStream;
}),
"[project]/node_modules/@whatwg-node/node-fetch/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextEncoderStream = exports.TextDecoderStream = exports.IteratorObject = exports.DecompressionStream = exports.CompressionStream = exports.TransformStream = exports.WritableStream = exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = void 0;
var fetch_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/fetch.js [app-route] (ecmascript)");
Object.defineProperty(exports, "fetch", {
    enumerable: true,
    get: function() {
        return fetch_js_1.fetchPonyfill;
    }
});
var Headers_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Headers.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Headers", {
    enumerable: true,
    get: function() {
        return Headers_js_1.PonyfillHeaders;
    }
});
var Body_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Body.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Body", {
    enumerable: true,
    get: function() {
        return Body_js_1.PonyfillBody;
    }
});
var Request_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Request.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Request", {
    enumerable: true,
    get: function() {
        return Request_js_1.PonyfillRequest;
    }
});
var Response_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Response.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Response", {
    enumerable: true,
    get: function() {
        return Response_js_1.PonyfillResponse;
    }
});
var ReadableStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ReadableStream", {
    enumerable: true,
    get: function() {
        return ReadableStream_js_1.PonyfillReadableStream;
    }
});
var File_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/File.js [app-route] (ecmascript)");
Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
        return File_js_1.PonyfillFile;
    }
});
var FormData_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/FormData.js [app-route] (ecmascript)");
Object.defineProperty(exports, "FormData", {
    enumerable: true,
    get: function() {
        return FormData_js_1.PonyfillFormData;
    }
});
var Blob_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/Blob.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Blob", {
    enumerable: true,
    get: function() {
        return Blob_js_1.PonyfillBlob;
    }
});
var TextEncoderDecoder_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "TextEncoder", {
    enumerable: true,
    get: function() {
        return TextEncoderDecoder_js_1.PonyfillTextEncoder;
    }
});
Object.defineProperty(exports, "TextDecoder", {
    enumerable: true,
    get: function() {
        return TextEncoderDecoder_js_1.PonyfillTextDecoder;
    }
});
Object.defineProperty(exports, "btoa", {
    enumerable: true,
    get: function() {
        return TextEncoderDecoder_js_1.PonyfillBtoa;
    }
});
var URL_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/URL.js [app-route] (ecmascript)");
Object.defineProperty(exports, "URL", {
    enumerable: true,
    get: function() {
        return URL_js_1.PonyfillURL;
    }
});
var URLSearchParams_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js [app-route] (ecmascript)");
Object.defineProperty(exports, "URLSearchParams", {
    enumerable: true,
    get: function() {
        return URLSearchParams_js_1.PonyfillURLSearchParams;
    }
});
var WritableStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "WritableStream", {
    enumerable: true,
    get: function() {
        return WritableStream_js_1.PonyfillWritableStream;
    }
});
var TransformStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "TransformStream", {
    enumerable: true,
    get: function() {
        return TransformStream_js_1.PonyfillTransformStream;
    }
});
var CompressionStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/CompressionStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "CompressionStream", {
    enumerable: true,
    get: function() {
        return CompressionStream_js_1.PonyfillCompressionStream;
    }
});
var DecompressionStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/DecompressionStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DecompressionStream", {
    enumerable: true,
    get: function() {
        return DecompressionStream_js_1.PonyfillDecompressionStream;
    }
});
var IteratorObject_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/IteratorObject.js [app-route] (ecmascript)");
Object.defineProperty(exports, "IteratorObject", {
    enumerable: true,
    get: function() {
        return IteratorObject_js_1.PonyfillIteratorObject;
    }
});
var TextEncoderDecoderStream_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoderStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "TextDecoderStream", {
    enumerable: true,
    get: function() {
        return TextEncoderDecoderStream_js_1.PonyfillTextDecoderStream;
    }
});
Object.defineProperty(exports, "TextEncoderStream", {
    enumerable: true,
    get: function() {
        return TextEncoderDecoderStream_js_1.PonyfillTextEncoderStream;
    }
});
}),
"[project]/node_modules/@whatwg-node/server/cjs/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decompressedResponseMap = exports.iterateAsyncVoid = exports.createDeferredPromise = exports.isPromise = void 0;
exports.isAsyncIterable = isAsyncIterable;
exports.normalizeNodeRequest = normalizeNodeRequest;
exports.isReadable = isReadable;
exports.isNodeRequest = isNodeRequest;
exports.isServerResponse = isServerResponse;
exports.isReadableStream = isReadableStream;
exports.isFetchEvent = isFetchEvent;
exports.sendNodeResponse = sendNodeResponse;
exports.isRequestInit = isRequestInit;
exports.completeAssign = completeAssign;
exports.handleErrorFromRequestHandler = handleErrorFromRequestHandler;
exports.isolateObject = isolateObject;
exports.handleAbortSignalAndPromiseResponse = handleAbortSignalAndPromiseResponse;
exports.getSupportedEncodings = getSupportedEncodings;
exports.handleResponseDecompression = handleResponseDecompression;
exports.ensureDisposableStackRegisteredForTerminateEvents = ensureDisposableStackRegisteredForTerminateEvents;
exports.createCustomAbortControllerSignal = createCustomAbortControllerSignal;
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createDeferredPromise", {
    enumerable: true,
    get: function() {
        return promise_helpers_1.createDeferredPromise;
    }
});
Object.defineProperty(exports, "isPromise", {
    enumerable: true,
    get: function() {
        return promise_helpers_1.isPromise;
    }
});
function isAsyncIterable(body) {
    return body != null && typeof body === 'object' && typeof body[Symbol.asyncIterator] === 'function';
}
function getPort(nodeRequest) {
    if (nodeRequest.socket?.localPort) {
        return nodeRequest.socket?.localPort;
    }
    const hostInHeader = nodeRequest.headers?.[':authority'] || nodeRequest.headers?.host;
    const portInHeader = hostInHeader?.split(':')?.[1];
    if (portInHeader) {
        return portInHeader;
    }
    return 80;
}
function getHostnameWithPort(nodeRequest) {
    if (nodeRequest.headers?.[':authority']) {
        return nodeRequest.headers?.[':authority'];
    }
    if (nodeRequest.headers?.host) {
        return nodeRequest.headers?.host;
    }
    const port = getPort(nodeRequest);
    if (nodeRequest.hostname) {
        return nodeRequest.hostname + ':' + port;
    }
    const localIp = nodeRequest.socket?.localAddress;
    if (localIp && !localIp?.includes('::') && !localIp?.includes('ffff')) {
        return `${localIp}:${port}`;
    }
    return 'localhost';
}
function buildFullUrl(nodeRequest) {
    const hostnameWithPort = getHostnameWithPort(nodeRequest);
    const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? 'https' : 'http');
    const endpoint = nodeRequest.originalUrl || nodeRequest.url || '/graphql';
    return `${protocol}://${hostnameWithPort}${endpoint}`;
}
function isRequestBody(body) {
    const stringTag = body[Symbol.toStringTag];
    if (typeof body === 'string' || stringTag === 'Uint8Array' || stringTag === 'Blob' || stringTag === 'FormData' || stringTag === 'URLSearchParams' || isAsyncIterable(body)) {
        return true;
    }
    return false;
}
function normalizeNodeRequest(nodeRequest, fetchAPI, nodeResponse, __useCustomAbortCtrl) {
    const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
    let fullUrl = buildFullUrl(rawRequest);
    if (nodeRequest.query) {
        const url = new fetchAPI.URL(fullUrl);
        for(const key in nodeRequest.query){
            url.searchParams.set(key, nodeRequest.query[key]);
        }
        fullUrl = url.toString();
    }
    let normalizedHeaders = nodeRequest.headers;
    if (nodeRequest.headers?.[':method']) {
        normalizedHeaders = {};
        for(const key in nodeRequest.headers){
            if (!key.startsWith(':')) {
                normalizedHeaders[key] = nodeRequest.headers[key];
            }
        }
    }
    const controller = __useCustomAbortCtrl ? createCustomAbortControllerSignal() : new AbortController();
    if (nodeResponse?.once) {
        const closeEventListener = ()=>{
            if (!controller.signal.aborted) {
                Object.defineProperty(rawRequest, 'aborted', {
                    value: true
                });
                controller.abort(nodeResponse.errored ?? undefined);
            }
        };
        nodeResponse.once('error', closeEventListener);
        nodeResponse.once('close', closeEventListener);
        nodeResponse.once('finish', ()=>{
            nodeResponse.removeListener('close', closeEventListener);
        });
    }
    if (nodeRequest.method === 'GET' || nodeRequest.method === 'HEAD') {
        return new fetchAPI.Request(fullUrl, {
            method: nodeRequest.method,
            headers: normalizedHeaders,
            signal: controller.signal
        });
    }
    /**
     * Some Node server frameworks like Serverless Express sends a dummy object with body but as a Buffer not string
     * so we do those checks to see is there something we can use directly as BodyInit
     * because the presence of body means the request stream is already consumed and,
     * rawRequest cannot be used as BodyInit/ReadableStream by Fetch API in this case.
     */ const maybeParsedBody = nodeRequest.body;
    if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
        if (isRequestBody(maybeParsedBody)) {
            return new fetchAPI.Request(fullUrl, {
                method: nodeRequest.method || 'GET',
                headers: normalizedHeaders,
                body: maybeParsedBody,
                signal: controller.signal
            });
        }
        const request = new fetchAPI.Request(fullUrl, {
            method: nodeRequest.method || 'GET',
            headers: normalizedHeaders,
            signal: controller.signal
        });
        if (!request.headers.get('content-type')?.includes('json')) {
            request.headers.set('content-type', 'application/json; charset=utf-8');
        }
        return new Proxy(request, {
            get: (target, prop, receiver)=>{
                switch(prop){
                    case 'json':
                        return ()=>(0, promise_helpers_1.fakePromise)(maybeParsedBody);
                    case 'text':
                        return ()=>(0, promise_helpers_1.fakePromise)(JSON.stringify(maybeParsedBody));
                    default:
                        if (globalThis.Bun) {
                            // workaround for https://github.com/oven-sh/bun/issues/12368
                            // Proxy.get doesn't seem to get `receiver` correctly
                            return Reflect.get(target, prop);
                        }
                        return Reflect.get(target, prop, receiver);
                }
            }
        });
    }
    // perf: instead of spreading the object, we can just pass it as is and it performs better
    return new fetchAPI.Request(fullUrl, {
        method: nodeRequest.method,
        headers: normalizedHeaders,
        signal: controller.signal,
        // @ts-expect-error - AsyncIterable is supported as body
        body: rawRequest,
        duplex: 'half'
    });
}
function isReadable(stream) {
    return stream.read != null;
}
function isNodeRequest(request) {
    return isReadable(request);
}
function isServerResponse(stream) {
    // Check all used functions are defined
    return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isReadableStream(stream) {
    return stream != null && stream.getReader != null;
}
function isFetchEvent(event) {
    return event != null && event.request != null && event.respondWith != null;
}
function configureSocket(rawRequest) {
    rawRequest?.socket?.setTimeout?.(0);
    rawRequest?.socket?.setNoDelay?.(true);
    rawRequest?.socket?.setKeepAlive?.(true);
}
function endResponse(serverResponse) {
    // @ts-expect-error Avoid arguments adaptor trampoline https://v8.dev/blog/adaptor-frame
    serverResponse.end(null, null, null);
}
function sendAsyncIterable(serverResponse, asyncIterable) {
    let closed = false;
    const closeEventListener = ()=>{
        closed = true;
    };
    serverResponse.once('error', closeEventListener);
    serverResponse.once('close', closeEventListener);
    serverResponse.once('finish', ()=>{
        serverResponse.removeListener('close', closeEventListener);
        serverResponse.removeListener('error', closeEventListener);
    });
    const iterator = asyncIterable[Symbol.asyncIterator]();
    const pump = ()=>iterator.next().then(({ done, value })=>{
            if (closed || done) {
                return;
            }
            return (0, promise_helpers_1.handleMaybePromise)(()=>safeWrite(value, serverResponse), ()=>closed ? endResponse(serverResponse) : pump());
        });
    return pump();
}
function safeWrite(chunk, serverResponse) {
    // @ts-expect-error http and http2 writes are actually compatible
    const result = serverResponse.write(chunk);
    if (!result) {
        return new Promise((resolve)=>serverResponse.once('drain', resolve));
    }
}
const isNode1x = globalThis.process?.versions?.node?.startsWith('1');
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest, __useSingleWriteHead) {
    if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {
        return;
    }
    if (!fetchResponse) {
        serverResponse.statusCode = 404;
        endResponse(serverResponse);
        return;
    }
    if (__useSingleWriteHead && // @ts-expect-error - headersInit is a private property
    fetchResponse.headers?.headersInit && // @ts-expect-error - headersInit is a private property
    !Array.isArray(fetchResponse.headers.headersInit) && // @ts-expect-error - headersInit is a private property
    !fetchResponse.headers.headersInit.get && // @ts-expect-error - map is a private property
    !fetchResponse.headers._map && // @ts-expect-error - _setCookies is a private property
    !fetchResponse.headers._setCookies?.length) {
        // @ts-expect-error - writeHead accepts headers object
        serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText, // @ts-expect-error - headersInit is a private property
        fetchResponse.headers.headersInit);
    } else {
        // Avoid using `setHeaders` on Node.js 18 as it is broken with multiple headers with the same name
        // @ts-expect-error - setHeaders exist
        if (serverResponse.setHeaders && !isNode1x) {
            // @ts-expect-error - writeHead bad typings
            serverResponse.setHeaders(fetchResponse.headers);
        } else {
            let setCookiesSet = false;
            fetchResponse.headers.forEach((value, key)=>{
                if (key === 'set-cookie') {
                    if (setCookiesSet) {
                        return;
                    }
                    setCookiesSet = true;
                    const setCookies = fetchResponse.headers.getSetCookie?.();
                    if (setCookies) {
                        serverResponse.setHeader('set-cookie', setCookies);
                        return;
                    }
                }
                serverResponse.setHeader(key, value);
            });
        }
        // @ts-expect-error - writeHead bad typings
        serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText);
    }
    // @ts-expect-error - Handle the case where the response is a string
    if (fetchResponse['bodyType'] === 'String') {
        return (0, promise_helpers_1.handleMaybePromise)(// @ts-expect-error - bodyInit is a private property
        ()=>safeWrite(fetchResponse.bodyInit, serverResponse), ()=>endResponse(serverResponse));
    }
    // Optimizations for node-fetch
    const bufOfRes = // @ts-expect-error - _buffer is a private property
    fetchResponse._buffer;
    if (bufOfRes) {
        return (0, promise_helpers_1.handleMaybePromise)(()=>safeWrite(bufOfRes, serverResponse), ()=>endResponse(serverResponse));
    }
    // Other fetch implementations
    const fetchBody = fetchResponse.body;
    if (fetchBody == null) {
        endResponse(serverResponse);
        return;
    }
    if (// @ts-expect-error - Uint8Array is a valid body type
    fetchBody[Symbol.toStringTag] === 'Uint8Array') {
        return (0, promise_helpers_1.handleMaybePromise)(()=>safeWrite(fetchBody, serverResponse), ()=>endResponse(serverResponse));
    }
    configureSocket(nodeRequest);
    if (isReadable(fetchBody)) {
        serverResponse.once('close', ()=>{
            fetchBody.destroy();
        });
        fetchBody.pipe(serverResponse, {
            end: true
        });
        return;
    }
    if (isReadableStream(fetchBody)) {
        return sendReadableStream(nodeRequest, serverResponse, fetchBody);
    }
    if (isAsyncIterable(fetchBody)) {
        return sendAsyncIterable(serverResponse, fetchBody);
    }
}
function sendReadableStream(nodeRequest, serverResponse, readableStream) {
    const reader = readableStream.getReader();
    nodeRequest?.once?.('error', (err)=>{
        reader.cancel(err);
    });
    function pump() {
        return reader.read().then(({ done, value })=>done ? endResponse(serverResponse) : (0, promise_helpers_1.handleMaybePromise)(()=>safeWrite(value, serverResponse), pump));
    }
    return pump();
}
function isRequestInit(val) {
    return val != null && typeof val === 'object' && ('body' in val || 'cache' in val || 'credentials' in val || 'headers' in val || 'integrity' in val || 'keepalive' in val || 'method' in val || 'mode' in val || 'redirect' in val || 'referrer' in val || 'referrerPolicy' in val || 'signal' in val || 'window' in val);
}
// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#copying_accessors
function completeAssign(...args) {
    const [target, ...sources] = args.filter((arg)=>arg != null && typeof arg === 'object');
    sources.forEach((source)=>{
        // modified Object.keys to Object.getOwnPropertyNames
        // because Object.keys only returns enumerable properties
        const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors, key)=>{
            const descriptor = Object.getOwnPropertyDescriptor(source, key);
            if (descriptor) {
                descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
            }
            return descriptors;
        }, {});
        // By default, Object.assign copies enumerable Symbols, too
        Object.getOwnPropertySymbols(source).forEach((sym)=>{
            const descriptor = Object.getOwnPropertyDescriptor(source, sym);
            if (descriptor?.enumerable) {
                descriptors[sym] = descriptor;
            }
        });
        Object.defineProperties(target, descriptors);
    });
    return target;
}
var promise_helpers_2 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "iterateAsyncVoid", {
    enumerable: true,
    get: function() {
        return promise_helpers_2.iterateAsyncVoid;
    }
});
function handleErrorFromRequestHandler(error, ResponseCtor) {
    return new ResponseCtor(error.stack || error.message || error.toString(), {
        status: error.status || 500
    });
}
function isolateObject(originalCtx, waitUntilFn) {
    if (originalCtx == null) {
        if (waitUntilFn == null) {
            return {};
        }
        return {
            waitUntil: waitUntilFn
        };
    }
    return completeAssign(Object.create(originalCtx), {
        waitUntil: waitUntilFn
    }, originalCtx);
}
function handleAbortSignalAndPromiseResponse(response$, abortSignal) {
    if (abortSignal?.aborted) {
        throw abortSignal.reason;
    }
    if ((0, promise_helpers_1.isPromise)(response$) && abortSignal) {
        const deferred$ = (0, promise_helpers_1.createDeferredPromise)();
        function abortSignalFetchErrorHandler() {
            deferred$.reject(abortSignal.reason);
        }
        abortSignal.addEventListener('abort', abortSignalFetchErrorHandler, {
            once: true
        });
        response$.then(function fetchSuccessHandler(res) {
            deferred$.resolve(res);
        }).catch(function fetchErrorHandler(err) {
            deferred$.reject(err);
        }).finally(()=>{
            abortSignal.removeEventListener('abort', abortSignalFetchErrorHandler);
        });
        return deferred$.promise;
    }
    return response$;
}
exports.decompressedResponseMap = new WeakMap();
const supportedEncodingsByFetchAPI = new WeakMap();
function getSupportedEncodings(fetchAPI) {
    let supportedEncodings = supportedEncodingsByFetchAPI.get(fetchAPI);
    if (!supportedEncodings) {
        const possibleEncodings = [
            'deflate',
            'gzip',
            'deflate-raw',
            'br',
            'zstd'
        ];
        if (fetchAPI.DecompressionStream?.['supportedFormats']) {
            supportedEncodings = fetchAPI.DecompressionStream['supportedFormats'];
        } else {
            supportedEncodings = possibleEncodings.filter((encoding)=>{
                // deflate-raw is not supported in Node.js >v20
                if (globalThis.process?.version?.startsWith('v2') && fetchAPI.DecompressionStream === globalThis.DecompressionStream && encoding === 'deflate-raw') {
                    return false;
                }
                try {
                    // eslint-disable-next-line no-new
                    new fetchAPI.DecompressionStream(encoding);
                    return true;
                } catch  {
                    return false;
                }
            });
        }
        supportedEncodingsByFetchAPI.set(fetchAPI, supportedEncodings);
    }
    return supportedEncodings;
}
function handleResponseDecompression(response, fetchAPI) {
    const contentEncodingHeader = response?.headers.get('content-encoding');
    if (!contentEncodingHeader || contentEncodingHeader === 'none') {
        return response;
    }
    if (!response?.body) {
        return response;
    }
    let decompressedResponse = exports.decompressedResponseMap.get(response);
    if (!decompressedResponse || decompressedResponse.bodyUsed) {
        let decompressedBody = response.body;
        const contentEncodings = contentEncodingHeader.split(',');
        if (!contentEncodings.every((encoding)=>getSupportedEncodings(fetchAPI).includes(encoding))) {
            return new fetchAPI.Response(`Unsupported 'Content-Encoding': ${contentEncodingHeader}`, {
                status: 415,
                statusText: 'Unsupported Media Type'
            });
        }
        for (const contentEncoding of contentEncodings){
            decompressedBody = decompressedBody.pipeThrough(new fetchAPI.DecompressionStream(contentEncoding));
        }
        decompressedResponse = new fetchAPI.Response(decompressedBody, response);
        exports.decompressedResponseMap.set(response, decompressedResponse);
    }
    return decompressedResponse;
}
const terminateEvents = [
    'SIGINT',
    'exit',
    'SIGTERM'
];
const disposableStacks = new Set();
let eventListenerRegistered = false;
function ensureEventListenerForDisposableStacks() {
    if (eventListenerRegistered) {
        return;
    }
    eventListenerRegistered = true;
    for (const event of terminateEvents){
        globalThis.process.once(event, function terminateHandler() {
            return Promise.allSettled([
                ...disposableStacks
            ].map((stack)=>!stack.disposed && stack.disposeAsync()));
        });
    }
}
function ensureDisposableStackRegisteredForTerminateEvents(disposableStack) {
    if (globalThis.process) {
        ensureEventListenerForDisposableStacks();
        if (!disposableStacks.has(disposableStack)) {
            disposableStacks.add(disposableStack);
            disposableStack.defer(()=>{
                disposableStacks.delete(disposableStack);
            });
        }
    }
}
class CustomAbortControllerSignal extends EventTarget {
    aborted = false;
    _onabort = null;
    _reason;
    constructor(){
        super();
        const nodeEvents = globalThis.process?.getBuiltinModule?.('node:events');
        // @ts-expect-error - We know kMaxEventTargetListeners is available in node:events
        if (nodeEvents?.kMaxEventTargetListeners) {
            // @ts-expect-error - See https://github.com/nodejs/node/pull/55816/files#diff-03bd4f07a1006cb0daaddced702858751b20f5ab7681cb0719c1b1d80d6ca05cR31
            this[nodeEvents.kMaxEventTargetListeners] = 0;
        }
    }
    throwIfAborted() {
        if (this._nativeCtrl?.signal?.throwIfAborted) {
            return this._nativeCtrl.signal.throwIfAborted();
        }
        if (this.aborted) {
            throw this._reason;
        }
    }
    _nativeCtrl;
    ensureNativeCtrl() {
        if (!this._nativeCtrl) {
            const isAborted = this.aborted;
            this._nativeCtrl = new AbortController();
            if (isAborted) {
                this._nativeCtrl.abort(this._reason);
            }
        }
        return this._nativeCtrl;
    }
    abort(reason) {
        if (this._nativeCtrl?.abort) {
            return this._nativeCtrl?.abort(reason);
        }
        this._reason = reason || new DOMException('This operation was aborted', 'AbortError');
        this.aborted = true;
        this.dispatchEvent(new Event('abort'));
    }
    get signal() {
        if (this._nativeCtrl?.signal) {
            return this._nativeCtrl.signal;
        }
        return this;
    }
    get reason() {
        if (this._nativeCtrl?.signal) {
            return this._nativeCtrl.signal.reason;
        }
        return this._reason;
    }
    get onabort() {
        if (this._onabort) {
            return this._onabort;
        }
        return this._onabort;
    }
    set onabort(value) {
        if (this._nativeCtrl?.signal) {
            this._nativeCtrl.signal.onabort = value;
            return;
        }
        if (this._onabort) {
            this.removeEventListener('abort', this._onabort);
        }
        this._onabort = value;
        if (value) {
            this.addEventListener('abort', value);
        }
    }
}
function createCustomAbortControllerSignal() {
    if (globalThis.Bun || globalThis.Deno) {
        return new AbortController();
    }
    return new Proxy(new CustomAbortControllerSignal(), {
        get (target, prop, receiver) {
            if (prop.toString().includes('kDependantSignals')) {
                const nativeCtrl = target.ensureNativeCtrl();
                return Reflect.get(nativeCtrl.signal, prop, nativeCtrl.signal);
            }
            return Reflect.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (prop.toString().includes('kDependantSignals')) {
                const nativeCtrl = target.ensureNativeCtrl();
                return Reflect.set(nativeCtrl.signal, prop, value, nativeCtrl.signal);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        getPrototypeOf () {
            return AbortSignal.prototype;
        }
    });
}
}),
"[project]/node_modules/@whatwg-node/server/cjs/uwebsockets.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fakePromise = void 0;
exports.isUWSResponse = isUWSResponse;
exports.getRequestFromUWSRequest = getRequestFromUWSRequest;
exports.createWritableFromUWS = createWritableFromUWS;
exports.sendResponseToUwsOpts = sendResponseToUwsOpts;
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "fakePromise", {
    enumerable: true,
    get: function() {
        return promise_helpers_1.fakePromise;
    }
});
function isUWSResponse(res) {
    return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI, controller }) {
    const method = req.getMethod();
    let duplex;
    const chunks = [];
    const pushFns = [
        (chunk)=>{
            chunks.push(chunk);
        }
    ];
    const push = (chunk)=>{
        for (const pushFn of pushFns){
            pushFn(chunk);
        }
    };
    let stopped = false;
    const stopFns = [
        ()=>{
            stopped = true;
        }
    ];
    const stop = ()=>{
        for (const stopFn of stopFns){
            stopFn();
        }
    };
    res.onData(function(ab, isLast) {
        push(Buffer.from(Buffer.from(ab, 0, ab.byteLength)));
        if (isLast) {
            stop();
        }
    });
    let getReadableStream;
    if (method !== 'get' && method !== 'head') {
        duplex = 'half';
        controller.signal.addEventListener('abort', ()=>{
            stop();
        }, {
            once: true
        });
        let readableStream;
        getReadableStream = ()=>{
            if (!readableStream) {
                readableStream = new fetchAPI.ReadableStream({
                    start (streamCtrl) {
                        for (const chunk of chunks){
                            streamCtrl.enqueue(chunk);
                        }
                        if (stopped) {
                            streamCtrl.close();
                            return;
                        }
                        pushFns.push((chunk)=>{
                            streamCtrl.enqueue(chunk);
                        });
                        stopFns.push(()=>{
                            if (controller.signal.reason) {
                                streamCtrl.error(controller.signal.reason);
                                return;
                            }
                            if (streamCtrl.desiredSize) {
                                streamCtrl.close();
                            }
                        });
                    }
                });
            }
            return readableStream;
        };
    }
    const headers = new fetchAPI.Headers();
    req.forEach((key, value)=>{
        headers.append(key, value);
    });
    let url = `http://localhost${req.getUrl()}`;
    const query = req.getQuery();
    if (query) {
        url += `?${query}`;
    }
    let buffer;
    function getBody() {
        if (!getReadableStream) {
            return null;
        }
        if (stopped) {
            return getBufferFromChunks();
        }
        return getReadableStream();
    }
    const request = new fetchAPI.Request(url, {
        method,
        headers,
        get body () {
            return getBody();
        },
        signal: controller.signal,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore - not in the TS types yet
        duplex
    });
    function getBufferFromChunks() {
        if (!buffer) {
            buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks);
        }
        return buffer;
    }
    function collectBuffer() {
        if (stopped) {
            return (0, promise_helpers_1.fakePromise)(getBufferFromChunks());
        }
        return new Promise((resolve, reject)=>{
            try {
                stopFns.push(()=>{
                    resolve(getBufferFromChunks());
                });
            } catch (e) {
                reject(e);
            }
        });
    }
    Object.defineProperties(request, {
        body: {
            get () {
                return getBody();
            },
            configurable: true,
            enumerable: true
        },
        json: {
            value () {
                return collectBuffer().then((b)=>b.toString('utf8')).then((t)=>JSON.parse(t));
            },
            configurable: true,
            enumerable: true
        },
        text: {
            value () {
                return collectBuffer().then((b)=>b.toString('utf8'));
            },
            configurable: true,
            enumerable: true
        },
        arrayBuffer: {
            value () {
                return collectBuffer();
            },
            configurable: true,
            enumerable: true
        }
    });
    return request;
}
function createWritableFromUWS(uwsResponse, fetchAPI) {
    return new fetchAPI.WritableStream({
        write (chunk) {
            uwsResponse.cork(()=>{
                uwsResponse.write(chunk);
            });
        },
        close () {
            uwsResponse.cork(()=>{
                uwsResponse.end();
            });
        }
    });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse, controller, fetchAPI) {
    if (!fetchResponse) {
        uwsResponse.writeStatus('404 Not Found');
        uwsResponse.end();
        return;
    }
    const bufferOfRes = fetchResponse._buffer;
    // @ts-expect-error - Handle the case where the response is a string
    const strBody = fetchResponse['bodyType'] === 'String' ? fetchResponse.bodyInit : undefined;
    if (controller.signal.aborted) {
        return;
    }
    uwsResponse.cork(()=>{
        uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
        let isSetCookieHandled = false;
        for (const [key, value] of fetchResponse.headers){
            // content-length causes an error with Node.js's fetch
            if (key !== 'content-length') {
                if (key === 'set-cookie') {
                    if (isSetCookieHandled) {
                        continue;
                    }
                    isSetCookieHandled = true;
                    const setCookies = fetchResponse.headers.getSetCookie?.();
                    if (setCookies) {
                        for (const setCookie of setCookies){
                            uwsResponse.writeHeader(key, setCookie);
                        }
                        continue;
                    }
                }
                uwsResponse.writeHeader(key, value);
            }
        }
        if (strBody) {
            uwsResponse.end(strBody);
        } else if (bufferOfRes) {
            uwsResponse.end(bufferOfRes);
        } else if (!fetchResponse.body) {
            uwsResponse.end();
        }
    });
    if (strBody || bufferOfRes || !fetchResponse.body) {
        return;
    }
    controller.signal.addEventListener('abort', ()=>{
        if (!fetchResponse.body?.locked) {
            fetchResponse.body?.cancel(controller.signal.reason);
        }
    }, {
        once: true
    });
    return fetchResponse.body.pipeTo(createWritableFromUWS(uwsResponse, fetchAPI), {
        signal: controller.signal
    }).catch((err)=>{
        if (controller.signal.aborted) {
            return;
        }
        throw err;
    });
}
}),
"[project]/node_modules/@whatwg-node/server/cjs/createServerAdapter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createServerAdapter = createServerAdapter;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const instrumentation_1 = __turbopack_context__.r("[project]/node_modules/@envelop/instrumentation/cjs/index.js [app-route] (ecmascript)");
const disposablestack_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/index.js [app-route] (ecmascript)");
const DefaultFetchAPI = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js [app-route] (ecmascript)"));
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/utils.js [app-route] (ecmascript)");
const uwebsockets_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/uwebsockets.js [app-route] (ecmascript)");
// Required for envs like nextjs edge runtime
function isRequestAccessible(serverContext) {
    try {
        return !!serverContext?.request;
    } catch  {
        return false;
    }
}
const EMPTY_OBJECT = {};
function createServerAdapter(serverAdapterBaseObject, options) {
    const useSingleWriteHead = options?.__useSingleWriteHead == null ? true : options.__useSingleWriteHead;
    const fetchAPI = {
        ...DefaultFetchAPI,
        ...options?.fetchAPI
    };
    const useCustomAbortCtrl = options?.__useCustomAbortCtrl == null ? fetchAPI.Request !== globalThis.Request : options.__useCustomAbortCtrl;
    const givenHandleRequest = typeof serverAdapterBaseObject === 'function' ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
    const onRequestHooks = [];
    const onResponseHooks = [];
    let instrumentation;
    const waitUntilPromises = new Set();
    let _disposableStack;
    function ensureDisposableStack() {
        if (!_disposableStack) {
            _disposableStack = new disposablestack_1.AsyncDisposableStack();
            if (options?.disposeOnProcessTerminate) {
                (0, utils_js_1.ensureDisposableStackRegisteredForTerminateEvents)(_disposableStack);
            }
            _disposableStack.defer(()=>{
                if (waitUntilPromises.size > 0) {
                    return Promise.allSettled(waitUntilPromises).then(()=>{
                        waitUntilPromises.clear();
                    }, ()=>{
                        waitUntilPromises.clear();
                    });
                }
            });
        }
        return _disposableStack;
    }
    function waitUntil(maybePromise) {
        // Ensure that the disposable stack is created
        if ((0, utils_js_1.isPromise)(maybePromise)) {
            ensureDisposableStack();
            waitUntilPromises.add(maybePromise);
            maybePromise.then(()=>{
                waitUntilPromises.delete(maybePromise);
            }, (err)=>{
                console.error(`Unexpected error while waiting: ${err.message || err}`);
                waitUntilPromises.delete(maybePromise);
            });
        }
    }
    if (options?.plugins != null) {
        for (const plugin of options.plugins){
            if (plugin.instrumentation) {
                instrumentation = instrumentation ? (0, instrumentation_1.chain)(instrumentation, plugin.instrumentation) : plugin.instrumentation;
            }
            if (plugin.onRequest) {
                onRequestHooks.push(plugin.onRequest);
            }
            if (plugin.onResponse) {
                onResponseHooks.push(plugin.onResponse);
            }
            const disposeFn = plugin[disposablestack_1.DisposableSymbols.dispose];
            if (disposeFn) {
                ensureDisposableStack().defer(disposeFn);
            }
            const asyncDisposeFn = plugin[disposablestack_1.DisposableSymbols.asyncDispose];
            if (asyncDisposeFn) {
                ensureDisposableStack().defer(asyncDisposeFn);
            }
            if (plugin.onDispose) {
                ensureDisposableStack().defer(plugin.onDispose);
            }
        }
    }
    let handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {
        let requestHandler = givenHandleRequest;
        let response;
        if (onRequestHooks.length === 0) {
            return handleEarlyResponse();
        }
        let url = request['parsedUrl'] || new Proxy(EMPTY_OBJECT, {
            get (_target, prop, _receiver) {
                url = new fetchAPI.URL(request.url, 'http://localhost');
                return Reflect.get(url, prop, url);
            }
        });
        function handleResponse(response) {
            if (onResponseHooks.length === 0) {
                return response;
            }
            return (0, promise_helpers_1.handleMaybePromise)(()=>(0, utils_js_1.iterateAsyncVoid)(onResponseHooks, (onResponseHook)=>onResponseHook({
                        request,
                        response,
                        serverContext,
                        setResponse (newResponse) {
                            response = newResponse;
                        },
                        fetchAPI
                    })), ()=>response);
        }
        function handleEarlyResponse() {
            if (!response) {
                return (0, promise_helpers_1.handleMaybePromise)(()=>requestHandler(request, serverContext), handleResponse);
            }
            return handleResponse(response);
        }
        return (0, promise_helpers_1.handleMaybePromise)(()=>(0, utils_js_1.iterateAsyncVoid)(onRequestHooks, (onRequestHook, stopEarly)=>onRequestHook({
                    request,
                    setRequest (newRequest) {
                        request = newRequest;
                    },
                    serverContext,
                    fetchAPI,
                    url,
                    requestHandler,
                    setRequestHandler (newRequestHandler) {
                        requestHandler = newRequestHandler;
                    },
                    endResponse (newResponse) {
                        response = newResponse;
                        if (newResponse) {
                            stopEarly();
                        }
                    }
                })), handleEarlyResponse);
    } : givenHandleRequest;
    if (instrumentation?.request) {
        const originalRequestHandler = handleRequest;
        handleRequest = (request, initialContext)=>{
            return (0, instrumentation_1.getInstrumented)({
                request
            }).asyncFn(instrumentation.request, originalRequestHandler)(request, initialContext);
        };
    }
    // TODO: Remove this on the next major version
    function handleNodeRequest(nodeRequest, ...ctx) {
        const serverContext = ctx.length > 1 ? (0, utils_js_1.completeAssign)(...ctx) : ctx[0] || {};
        // Ensure `waitUntil` is available in the server context
        if (!serverContext.waitUntil) {
            serverContext.waitUntil = waitUntil;
        }
        const request = (0, utils_js_1.normalizeNodeRequest)(nodeRequest, fetchAPI, undefined, useCustomAbortCtrl);
        return handleRequest(request, serverContext);
    }
    function handleNodeRequestAndResponse(nodeRequest, nodeResponseOrContainer, ...ctx) {
        const nodeResponse = nodeResponseOrContainer.raw || nodeResponseOrContainer;
        const serverContext = ctx.length > 1 ? (0, utils_js_1.completeAssign)(...ctx) : ctx[0] || {};
        // Ensure `waitUntil` is available in the server context
        if (!serverContext.waitUntil) {
            serverContext.waitUntil = waitUntil;
        }
        const request = (0, utils_js_1.normalizeNodeRequest)(nodeRequest, fetchAPI, nodeResponse, useCustomAbortCtrl);
        return handleRequest(request, serverContext);
    }
    function requestListener(nodeRequest, nodeResponse, ...ctx) {
        const defaultServerContext = {
            req: nodeRequest,
            res: nodeResponse,
            waitUntil
        };
        return (0, promise_helpers_1.unfakePromise)((0, uwebsockets_js_1.fakePromise)().then(()=>handleNodeRequestAndResponse(nodeRequest, nodeResponse, defaultServerContext, ...ctx)).catch((err)=>(0, utils_js_1.handleErrorFromRequestHandler)(err, fetchAPI.Response)).then((response)=>(0, utils_js_1.sendNodeResponse)(response, nodeResponse, nodeRequest, useSingleWriteHead)).catch((err)=>console.error(`Unexpected error while handling request: ${err.message || err}`)));
    }
    function handleUWS(res, req, ...ctx) {
        const defaultServerContext = {
            res,
            req,
            waitUntil
        };
        const filteredCtxParts = ctx.filter((partCtx)=>partCtx != null);
        const serverContext = filteredCtxParts.length > 0 ? (0, utils_js_1.completeAssign)(defaultServerContext, ...ctx) : defaultServerContext;
        const controller = useCustomAbortCtrl ? (0, utils_js_1.createCustomAbortControllerSignal)() : new AbortController();
        const originalResEnd = res.end.bind(res);
        let resEnded = false;
        res.end = function(data) {
            resEnded = true;
            return originalResEnd(data);
        };
        const originalOnAborted = res.onAborted.bind(res);
        originalOnAborted(function() {
            controller.abort();
        });
        res.onAborted = function(cb) {
            controller.signal.addEventListener('abort', cb, {
                once: true
            });
        };
        const request = (0, uwebsockets_js_1.getRequestFromUWSRequest)({
            req,
            res,
            fetchAPI,
            controller
        });
        return (0, promise_helpers_1.handleMaybePromise)(()=>(0, promise_helpers_1.handleMaybePromise)(()=>handleRequest(request, serverContext), (response)=>response, (err)=>(0, utils_js_1.handleErrorFromRequestHandler)(err, fetchAPI.Response)), (response)=>{
            if (!controller.signal.aborted && !resEnded) {
                return (0, promise_helpers_1.handleMaybePromise)(()=>(0, uwebsockets_js_1.sendResponseToUwsOpts)(res, response, controller, fetchAPI), (r)=>r, (err)=>{
                    console.error(`Unexpected error while handling request: ${err.message || err}`);
                });
            }
        });
    }
    function handleEvent(event, ...ctx) {
        if (!event.respondWith || !event.request) {
            throw new TypeError(`Expected FetchEvent, got ${event}`);
        }
        const filteredCtxParts = ctx.filter((partCtx)=>partCtx != null);
        const serverContext = filteredCtxParts.length > 0 ? (0, utils_js_1.completeAssign)({}, event, ...filteredCtxParts) : (0, utils_js_1.isolateObject)(event);
        const response$ = handleRequest(event.request, serverContext);
        event.respondWith(response$);
    }
    function handleRequestWithWaitUntil(request, ...ctx) {
        const filteredCtxParts = ctx.filter((partCtx)=>partCtx != null);
        const serverContext = filteredCtxParts.length > 1 ? (0, utils_js_1.completeAssign)({}, ...filteredCtxParts) : (0, utils_js_1.isolateObject)(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null ? waitUntil : undefined);
        return handleRequest(request, serverContext);
    }
    const fetchFn = (input, ...maybeCtx)=>{
        if (typeof input === 'string' || 'href' in input) {
            const [initOrCtx, ...restOfCtx] = maybeCtx;
            if ((0, utils_js_1.isRequestInit)(initOrCtx)) {
                const request = new fetchAPI.Request(input, initOrCtx);
                const res$ = handleRequestWithWaitUntil(request, ...restOfCtx);
                const signal = initOrCtx.signal;
                if (signal) {
                    return (0, utils_js_1.handleAbortSignalAndPromiseResponse)(res$, signal);
                }
                return res$;
            }
            const request = new fetchAPI.Request(input);
            return handleRequestWithWaitUntil(request, ...maybeCtx);
        }
        const res$ = handleRequestWithWaitUntil(input, ...maybeCtx);
        return (0, utils_js_1.handleAbortSignalAndPromiseResponse)(res$, input.signal);
    };
    const genericRequestHandler = (input, ...maybeCtx)=>{
        // If it is a Node request
        const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
        if ((0, utils_js_1.isNodeRequest)(input)) {
            if (!(0, utils_js_1.isServerResponse)(initOrCtxOrRes)) {
                throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
            }
            return requestListener(input, initOrCtxOrRes, ...restOfCtx);
        }
        if ((0, uwebsockets_js_1.isUWSResponse)(input)) {
            return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
        }
        if ((0, utils_js_1.isServerResponse)(initOrCtxOrRes)) {
            throw new TypeError('Got Node response without Node request');
        }
        // Is input a container object over Request?
        if (isRequestAccessible(input)) {
            // Is it FetchEvent?
            if ((0, utils_js_1.isFetchEvent)(input)) {
                return handleEvent(input, ...maybeCtx);
            }
            // In this input is also the context
            return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
        }
        // Or is it Request itself?
        // Then ctx is present and it is the context
        return fetchFn(input, ...maybeCtx);
    };
    const adapterObj = {
        handleRequest: handleRequestWithWaitUntil,
        fetch: fetchFn,
        handleNodeRequest,
        handleNodeRequestAndResponse,
        requestListener,
        handleEvent,
        handleUWS,
        handle: genericRequestHandler,
        get disposableStack () {
            return ensureDisposableStack();
        },
        [disposablestack_1.DisposableSymbols.asyncDispose] () {
            if (_disposableStack && !_disposableStack.disposed) {
                return _disposableStack.disposeAsync();
            }
            return (0, uwebsockets_js_1.fakePromise)();
        },
        dispose () {
            if (_disposableStack && !_disposableStack.disposed) {
                return _disposableStack.disposeAsync();
            }
            return (0, uwebsockets_js_1.fakePromise)();
        },
        waitUntil
    };
    const serverAdapter = new Proxy(genericRequestHandler, {
        // It should have all the attributes of the handler function and the server instance
        has: (_, prop)=>{
            return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;
        },
        get: (_, prop)=>{
            // Somehow Deno and Node 24 don't like bound dispose functions
            if (globalThis.Deno || prop === Symbol.asyncDispose || prop === Symbol.dispose) {
                const adapterProp = Reflect.get(adapterObj, prop, adapterObj);
                if (adapterProp) {
                    return adapterProp;
                }
            }
            const adapterProp = adapterObj[prop];
            if (adapterProp) {
                if (adapterProp.bind) {
                    return adapterProp.bind(adapterObj);
                }
                return adapterProp;
            }
            const handleProp = genericRequestHandler[prop];
            if (handleProp) {
                if (handleProp.bind) {
                    return handleProp.bind(genericRequestHandler);
                }
                return handleProp;
            }
            if (serverAdapterBaseObject) {
                const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
                if (serverAdapterBaseObjectProp) {
                    if (serverAdapterBaseObjectProp.bind) {
                        return function(...args) {
                            const returnedVal = serverAdapterBaseObject[prop](...args);
                            if (returnedVal === serverAdapterBaseObject) {
                                return serverAdapter;
                            }
                            return returnedVal;
                        };
                    }
                    return serverAdapterBaseObjectProp;
                }
            }
        },
        apply (_, __, args) {
            return genericRequestHandler(...args);
        }
    });
    return serverAdapter;
}
}),
"[project]/node_modules/@whatwg-node/server/cjs/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[project]/node_modules/@whatwg-node/server/cjs/plugins/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[project]/node_modules/@whatwg-node/server/cjs/plugins/useCors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getCORSHeadersByRequestAndOptions = getCORSHeadersByRequestAndOptions;
exports.useCORS = useCORS;
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
    const currentOrigin = request.headers.get('origin');
    if (corsOptions === false || currentOrigin == null) {
        return null;
    }
    const headers = {};
    // If defined origins have '*' or undefined by any means, we should allow all origins
    if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes('*')) {
        headers['Access-Control-Allow-Origin'] = currentOrigin;
        // Vary by origin because there are multiple origins
        headers['Vary'] = 'Origin';
    } else if (typeof corsOptions.origin === 'string') {
        // If there is one specific origin is specified, use it directly
        headers['Access-Control-Allow-Origin'] = corsOptions.origin;
    } else if (Array.isArray(corsOptions.origin)) {
        // If there is only one origin defined in the array, consider it as a single one
        if (corsOptions.origin.length === 1) {
            headers['Access-Control-Allow-Origin'] = corsOptions.origin[0];
        } else if (corsOptions.origin.includes(currentOrigin)) {
            // If origin is available in the headers, use it
            headers['Access-Control-Allow-Origin'] = currentOrigin;
            // Vary by origin because there are multiple origins
            headers['Vary'] = 'Origin';
        } else {
            // There is no origin found in the headers, so we should return null
            headers['Access-Control-Allow-Origin'] = 'null';
        }
    }
    if (corsOptions.methods?.length) {
        headers['Access-Control-Allow-Methods'] = corsOptions.methods.join(', ');
    } else {
        const requestMethod = request.headers.get('access-control-request-method');
        if (requestMethod) {
            headers['Access-Control-Allow-Methods'] = requestMethod;
        }
    }
    if (corsOptions.allowedHeaders?.length) {
        headers['Access-Control-Allow-Headers'] = corsOptions.allowedHeaders.join(', ');
    } else {
        const requestHeaders = request.headers.get('access-control-request-headers');
        if (requestHeaders) {
            headers['Access-Control-Allow-Headers'] = requestHeaders;
            if (headers['Vary']) {
                headers['Vary'] += ', Access-Control-Request-Headers';
            } else {
                headers['Vary'] = 'Access-Control-Request-Headers';
            }
        }
    }
    if (corsOptions.credentials != null) {
        if (corsOptions.credentials === true) {
            headers['Access-Control-Allow-Credentials'] = 'true';
        }
    } else if (headers['Access-Control-Allow-Origin'] !== '*') {
        headers['Access-Control-Allow-Credentials'] = 'true';
    }
    if (corsOptions.exposedHeaders) {
        headers['Access-Control-Expose-Headers'] = corsOptions.exposedHeaders.join(', ');
    }
    if (corsOptions.maxAge) {
        headers['Access-Control-Max-Age'] = corsOptions.maxAge.toString();
    }
    return headers;
}
function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
    return (0, promise_helpers_1.handleMaybePromise)(()=>corsOptionsFactory(request, serverContext), (corsOptions)=>getCORSHeadersByRequestAndOptions(request, corsOptions));
}
function useCORS(options) {
    let corsOptionsFactory = ()=>({});
    if (options != null) {
        if (typeof options === 'function') {
            corsOptionsFactory = options;
        } else if (typeof options === 'object') {
            const corsOptions = {
                ...options
            };
            corsOptionsFactory = ()=>corsOptions;
        } else if (options === false) {
            corsOptionsFactory = ()=>false;
        }
    }
    return {
        onRequest ({ request, fetchAPI, endResponse }) {
            if (request.method.toUpperCase() === 'OPTIONS') {
                const response = new fetchAPI.Response(null, {
                    status: 204,
                    // Safari (and potentially other browsers) need content-length 0,
                    // for 204 or they just hang waiting for a body
                    // see: https://github.com/expressjs/cors/blob/master/lib/index.js#L176
                    headers: {
                        'Content-Length': '0'
                    }
                });
                endResponse(response);
            }
        },
        onResponse ({ request, serverContext, response }) {
            return (0, promise_helpers_1.handleMaybePromise)(()=>getCORSResponseHeaders(request, corsOptionsFactory, serverContext), (headers)=>{
                if (headers != null) {
                    for(const headerName in headers){
                        response.headers.set(headerName, headers[headerName]);
                    }
                }
            });
        }
    };
}
}),
"[project]/node_modules/@whatwg-node/server/cjs/plugins/useErrorHandling.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HTTPError = void 0;
exports.createDefaultErrorHandler = createDefaultErrorHandler;
exports.useErrorHandling = useErrorHandling;
const fetch_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js [app-route] (ecmascript)");
const promise_helpers_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/promise-helpers/cjs/index.js [app-route] (ecmascript)");
function createDefaultErrorHandler(ResponseCtor = fetch_1.Response) {
    return function defaultErrorHandler(e) {
        if (e.details || e.status || e.headers || e.name === 'HTTPError') {
            return new ResponseCtor(typeof e.details === 'object' ? JSON.stringify(e.details) : e.message, {
                status: e.status,
                headers: e.headers || {}
            });
        }
        console.error(e);
        return createDefaultErrorResponse(ResponseCtor);
    };
}
function createDefaultErrorResponse(ResponseCtor) {
    if (ResponseCtor.error) {
        return ResponseCtor.error();
    }
    return new ResponseCtor(null, {
        status: 500
    });
}
class HTTPError extends Error {
    status;
    message;
    headers;
    details;
    name = 'HTTPError';
    constructor(status = 500, message, headers = {}, details){
        super(message);
        this.status = status;
        this.message = message;
        this.headers = headers;
        this.details = details;
        Error.captureStackTrace(this, HTTPError);
    }
}
exports.HTTPError = HTTPError;
function useErrorHandling(onError) {
    return {
        onRequest ({ requestHandler, setRequestHandler, fetchAPI }) {
            const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
            setRequestHandler(function handlerWithErrorHandling(request, serverContext) {
                return (0, promise_helpers_1.handleMaybePromise)(()=>requestHandler(request, serverContext), (response)=>response, (e)=>errorHandler(e, request, serverContext) || createDefaultErrorResponse(fetchAPI.Response));
            });
        }
    };
}
}),
"[project]/node_modules/@whatwg-node/server/cjs/plugins/useContentEncoding.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useContentEncoding = useContentEncoding;
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/utils.js [app-route] (ecmascript)");
const emptyEncodings = [
    'none',
    'identity'
];
function useContentEncoding() {
    return {
        onRequest ({ request, setRequest, fetchAPI, endResponse }) {
            const contentEncodingHeader = request.headers.get('content-encoding');
            if (contentEncodingHeader && contentEncodingHeader !== 'none' && contentEncodingHeader !== 'identity' && request.body) {
                const contentEncodings = contentEncodingHeader.split(',').filter((encoding)=>!emptyEncodings.includes(encoding));
                if (contentEncodings.length) {
                    if (!contentEncodings.every((encoding)=>(0, utils_js_1.getSupportedEncodings)(fetchAPI).includes(encoding))) {
                        endResponse(new fetchAPI.Response(`Unsupported 'Content-Encoding': ${contentEncodingHeader}`, {
                            status: 415,
                            statusText: 'Unsupported Media Type'
                        }));
                        return;
                    }
                    let newBody = request.body;
                    for (const contentEncoding of contentEncodings){
                        newBody = request.body.pipeThrough(new fetchAPI.DecompressionStream(contentEncoding));
                    }
                    setRequest(new fetchAPI.Request(request.url, {
                        body: newBody,
                        cache: request.cache,
                        credentials: request.credentials,
                        headers: request.headers,
                        integrity: request.integrity,
                        keepalive: request.keepalive,
                        method: request.method,
                        mode: request.mode,
                        redirect: request.redirect,
                        referrer: request.referrer,
                        referrerPolicy: request.referrerPolicy,
                        signal: request.signal,
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore - not in the TS types yet
                        duplex: 'half'
                    }));
                }
            }
        },
        onResponse ({ request, response, setResponse, fetchAPI }) {
            const acceptEncoding = request.headers.get('accept-encoding');
            if (acceptEncoding) {
                const encodings = acceptEncoding.split(',');
                if (encodings.length && response.body) {
                    const supportedEncoding = encodings.find((encoding)=>(0, utils_js_1.getSupportedEncodings)(fetchAPI).includes(encoding));
                    if (supportedEncoding) {
                        const compressionStream = new fetchAPI.CompressionStream(supportedEncoding);
                        const newHeaders = new fetchAPI.Headers(response.headers);
                        newHeaders.set('content-encoding', supportedEncoding);
                        newHeaders.delete('content-length');
                        const compressedBody = response.body.pipeThrough(compressionStream);
                        const compressedResponse = new fetchAPI.Response(compressedBody, {
                            status: response.status,
                            statusText: response.statusText,
                            headers: newHeaders
                        });
                        utils_js_1.decompressedResponseMap.set(compressedResponse, response);
                        setResponse(compressedResponse);
                    }
                }
            }
        }
    };
}
}),
"[project]/node_modules/@whatwg-node/server/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DisposableSymbols = exports.Response = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/createServerAdapter.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/types.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/utils.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/plugins/types.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/plugins/useCors.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/plugins/useErrorHandling.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/plugins/useContentEncoding.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@whatwg-node/server/cjs/uwebsockets.js [app-route] (ecmascript)"), exports);
var fetch_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Response", {
    enumerable: true,
    get: function() {
        return fetch_1.Response;
    }
});
var disposablestack_1 = __turbopack_context__.r("[project]/node_modules/@whatwg-node/disposablestack/cjs/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DisposableSymbols", {
    enumerable: true,
    get: function() {
        return disposablestack_1.DisposableSymbols;
    }
});
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@envelop/instrumentation/cjs/index.js [app-route] (ecmascript)"), exports);
}),
];

//# sourceMappingURL=node_modules_%40whatwg-node_84374022._.js.map