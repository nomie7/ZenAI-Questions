{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/assertResolversPresent.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertResolversPresent = assertResolversPresent;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar !== 'ignore' && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {\n            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n    if (!field.resolve) {\n        const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n        if (behavior === 'error') {\n            throw new Error(message);\n        }\n        if (behavior === 'warn') {\n            console.warn(message);\n        }\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,sBAAsB,GAAG;AACjC,MAAM;AACN,MAAM;AACN,SAAS,uBAAuB,MAAM,EAAE,4BAA4B,CAAC,CAAC;IAClE,MAAM,EAAE,uBAAuB,EAAE,4BAA4B,EAAE,4BAA4B,EAAE,GAAG;IAChG,IAAI,gCAAgC,CAAC,2BAA2B,4BAA4B,GAAG;QAC3F,MAAM,IAAI,UAAU,sFAChB,uFACA;IACR;IACA,CAAC,GAAG,QAAQ,YAAY,EAAE,QAAQ,CAAC,OAAO,UAAU;QAChD,yCAAyC;QACzC,IAAI,8BAA8B;YAC9B,eAAe,gCAAgC,8BAA8B,OAAO,UAAU;QAClG;QACA,wDAAwD;QACxD,IAAI,2BAA2B,MAAM,IAAI,CAAC,MAAM,GAAG,GAAG;YAClD,eAAe,2BAA2B,yBAAyB,OAAO,UAAU;QACxF;QACA,oEAAoE;QACpE,IAAI,iCAAiC,YAAY,CAAC,CAAC,GAAG,UAAU,YAAY,EAAE,CAAC,GAAG,UAAU,YAAY,EAAE,MAAM,IAAI,IAAI;YACpH,eAAe,gCAAgC,8BAA8B,OAAO,UAAU;QAClG;IACJ;AACJ;AACA,SAAS,eAAe,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS;IACnE,IAAI,CAAC,MAAM,OAAO,EAAE;QAChB,MAAM,UAAU,CAAC,sBAAsB,EAAE,SAAS,CAAC,EAAE,UAAU;;;IAGnE,EAAE,UAAU;GACb,CAAC;QACI,IAAI,aAAa,SAAS;YACtB,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,aAAa,QAAQ;YACrB,QAAQ,IAAI,CAAC;QACjB;QACA;IACJ;IACA,IAAI,OAAO,MAAM,OAAO,KAAK,YAAY;QACrC,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE,SAAS,CAAC,EAAE,UAAU,oBAAoB,CAAC;IAC5E;AACJ","ignoreList":[0]}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/chainResolvers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chainResolvers = chainResolvers;\nconst graphql_1 = require(\"graphql\");\nfunction chainResolvers(resolvers) {\n    return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n        if (curResolver != null) {\n            return curResolver(prev, args, ctx, info);\n        }\n        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);\n    }, root);\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,cAAc,GAAG;AACzB,MAAM;AACN,SAAS,eAAe,SAAS;IAC7B,OAAO,CAAC,MAAM,MAAM,KAAK,OAAS,UAAU,MAAM,CAAC,CAAC,MAAM;YACtD,IAAI,eAAe,MAAM;gBACrB,OAAO,YAAY,MAAM,MAAM,KAAK;YACxC;YACA,OAAO,CAAC,GAAG,UAAU,oBAAoB,EAAE,MAAM,MAAM,KAAK;QAChE,GAAG;AACP","ignoreList":[0]}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/checkForResolveTypeResolver.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkForResolveTypeResolver = checkForResolveTypeResolver;\nconst utils_1 = require(\"@graphql-tools/utils\");\n// If we have any union or interface types throw if no there is no resolveType resolver\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    (0, utils_1.mapSchema)(schema, {\n        [utils_1.MapperKind.ABSTRACT_TYPE]: type => {\n            if (!type.resolveType) {\n                const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` +\n                    '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n                if (requireResolversForResolveType === 'error') {\n                    throw new Error(message);\n                }\n                if (requireResolversForResolveType === 'warn') {\n                    console.warn(message);\n                }\n            }\n            return undefined;\n        },\n    });\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,2BAA2B,GAAG;AACtC,MAAM;AACN,uFAAuF;AACvF,SAAS,4BAA4B,MAAM,EAAE,8BAA8B;IACvE,CAAC,GAAG,QAAQ,SAAS,EAAE,QAAQ;QAC3B,CAAC,QAAQ,UAAU,CAAC,aAAa,CAAC,EAAE,CAAA;YAChC,IAAI,CAAC,KAAK,WAAW,EAAE;gBACnB,MAAM,UAAU,CAAC,MAAM,EAAE,KAAK,IAAI,CAAC,4DAA4D,CAAC,GAC5F;gBACJ,IAAI,mCAAmC,SAAS;oBAC5C,MAAM,IAAI,MAAM;gBACpB;gBACA,IAAI,mCAAmC,QAAQ;oBAC3C,QAAQ,IAAI,CAAC;gBACjB;YACJ;YACA,OAAO;QACX;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/extendResolversFromInterfaces.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendResolversFromInterfaces = extendResolversFromInterfaces;\nfunction extendResolversFromInterfaces(schema, resolvers) {\n    const extendedResolvers = {};\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if ('getInterfaces' in type) {\n            extendedResolvers[typeName] = {};\n            for (const iFace of type.getInterfaces()) {\n                if (resolvers[iFace.name]) {\n                    for (const fieldName in resolvers[iFace.name]) {\n                        if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];\n                        }\n                    }\n                }\n            }\n            const typeResolvers = resolvers[typeName];\n            extendedResolvers[typeName] = {\n                ...extendedResolvers[typeName],\n                ...typeResolvers,\n            };\n        }\n        else {\n            const typeResolvers = resolvers[typeName];\n            if (typeResolvers != null) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    }\n    return extendedResolvers;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,6BAA6B,GAAG;AACxC,SAAS,8BAA8B,MAAM,EAAE,SAAS;IACpD,MAAM,oBAAoB,CAAC;IAC3B,MAAM,UAAU,OAAO,UAAU;IACjC,IAAK,MAAM,YAAY,QAAS;QAC5B,MAAM,OAAO,OAAO,CAAC,SAAS;QAC9B,IAAI,mBAAmB,MAAM;YACzB,iBAAiB,CAAC,SAAS,GAAG,CAAC;YAC/B,KAAK,MAAM,SAAS,KAAK,aAAa,GAAI;gBACtC,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,EAAE;oBACvB,IAAK,MAAM,aAAa,SAAS,CAAC,MAAM,IAAI,CAAC,CAAE;wBAC3C,IAAI,cAAc,gBAAgB,CAAC,UAAU,UAAU,CAAC,OAAO;4BAC3D,iBAAiB,CAAC,SAAS,CAAC,UAAU,GAAG,SAAS,CAAC,MAAM,IAAI,CAAC,CAAC,UAAU;wBAC7E;oBACJ;gBACJ;YACJ;YACA,MAAM,gBAAgB,SAAS,CAAC,SAAS;YACzC,iBAAiB,CAAC,SAAS,GAAG;gBAC1B,GAAG,iBAAiB,CAAC,SAAS;gBAC9B,GAAG,aAAa;YACpB;QACJ,OACK;YACD,MAAM,gBAAgB,SAAS,CAAC,SAAS;YACzC,IAAI,iBAAiB,MAAM;gBACvB,iBAAiB,CAAC,SAAS,GAAG;YAClC;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/addResolversToSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addResolversToSchema = addResolversToSchema;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst checkForResolveTypeResolver_js_1 = require(\"./checkForResolveTypeResolver.js\");\nconst extendResolversFromInterfaces_js_1 = require(\"./extendResolversFromInterfaces.js\");\nfunction addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, }) {\n    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers)\n        : inputResolvers;\n    for (const typeName in resolvers) {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (resolverType !== 'object') {\n            throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n        }\n        const type = schema.getType(typeName);\n        if (type == null) {\n            const msg = `\"${typeName}\" defined in resolvers, but not in schema`;\n            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'error') {\n                if (requireResolversToMatchSchema === 'warn') {\n                    console.warn(msg);\n                }\n                continue;\n            }\n            throw new Error(msg);\n        }\n        else if ((0, graphql_1.isSpecifiedScalarType)(type)) {\n            // allow -- without recommending -- overriding of specified scalar types\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if ((0, graphql_1.isEnumType)(type)) {\n            const values = type.getValues();\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    !values.some(value => value.name === fieldName) &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    const msg = `${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`;\n                    if (requireResolversToMatchSchema === 'error') {\n                        throw new Error(msg);\n                    }\n                    else {\n                        console.warn(msg);\n                    }\n                }\n            }\n        }\n        else if ((0, graphql_1.isUnionType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    const msg = `${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`;\n                    if (requireResolversToMatchSchema === 'error') {\n                        throw new Error(msg);\n                    }\n                    else {\n                        console.warn(msg);\n                    }\n                }\n            }\n        }\n        else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__')) {\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field == null) {\n                        // Field present in resolver but not in schema\n                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n                            const msg = `${typeName}.${fieldName} defined in resolvers, but not in schema`;\n                            if (requireResolversToMatchSchema === 'error') {\n                                throw new Error(msg);\n                            }\n                            else {\n                                console.error(msg);\n                            }\n                        }\n                    }\n                    else {\n                        // Field present in both the resolver and schema\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);\n    }\n    return schema;\n}\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in resolvers) {\n        const type = schema.getType(typeName);\n        const resolverValue = resolvers[typeName];\n        if ((0, graphql_1.isScalarType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && type.astNode != null) {\n                    type.astNode = {\n                        ...type.astNode,\n                        description: resolverValue?.astNode?.description ??\n                            type.astNode.description,\n                        directives: (type.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                    type.extensionASTNodes = type.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if ((0, graphql_1.isEnumType)(type)) {\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    config[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && config.astNode != null) {\n                    config.astNode = {\n                        ...config.astNode,\n                        description: resolverValue?.astNode?.description ??\n                            config.astNode.description,\n                        directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                    config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else if (enumValueConfigMap[fieldName]) {\n                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                }\n            }\n            typeMap[typeName] = new graphql_1.GraphQLEnumType(config);\n        }\n        else if ((0, graphql_1.isUnionType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    // this is for isTypeOf and resolveType and all the other stuff.\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                    continue;\n                }\n                const fields = type.getFields();\n                const field = fields[fieldName];\n                if (field != null) {\n                    const fieldResolve = resolverValue[fieldName];\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        field.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(field, fieldResolve);\n                    }\n                }\n            }\n        }\n    }\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    (0, utils_1.healSchema)(schema);\n    // reparse all default values with new parsing functions.\n    (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);\n    if (defaultFieldResolver != null) {\n        (0, utils_1.forEachField)(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = (0, utils_1.mapSchema)(schema, {\n        [utils_1.MapperKind.SCALAR_TYPE]: type => {\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: resolverValue?.astNode?.description ??\n                                config.astNode.description,\n                            directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                }\n                return new graphql_1.GraphQLScalarType(config);\n            }\n        },\n        [utils_1.MapperKind.ENUM_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: resolverValue?.astNode?.description ??\n                                config.astNode.description,\n                            directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                }\n                return new graphql_1.GraphQLEnumType(config);\n            }\n        },\n        [utils_1.MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql_1.GraphQLUnionType(config);\n            }\n        },\n        [utils_1.MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__isTypeOf']) {\n                    config.isTypeOf = resolverValue['__isTypeOf'];\n                }\n                return new graphql_1.GraphQLObjectType(config);\n            }\n        },\n        [utils_1.MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql_1.GraphQLInterfaceType(config);\n            }\n        },\n        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = (0, utils_1.mapSchema)(schema, {\n            [utils_1.MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    for (const propertyName in propertiesObj) {\n        field[propertyName] = propertiesObj[propertyName];\n    }\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,oBAAoB,GAAG;AAC/B,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,qBAAqB,EAAE,MAAM,EAAE,WAAW,cAAc,EAAE,oBAAoB,EAAE,4BAA4B,CAAC,CAAC,EAAE,iCAAiC,KAAK,EAAE,yBAAyB,KAAK,EAAG;IAC9L,MAAM,EAAE,gCAAgC,OAAO,EAAE,8BAA8B,EAAE,GAAG;IACpF,MAAM,YAAY,iCACZ,CAAC,GAAG,mCAAmC,6BAA6B,EAAE,QAAQ,kBAC9E;IACN,IAAK,MAAM,YAAY,UAAW;QAC9B,MAAM,gBAAgB,SAAS,CAAC,SAAS;QACzC,MAAM,eAAe,OAAO;QAC5B,IAAI,iBAAiB,UAAU;YAC3B,MAAM,IAAI,MAAM,CAAC,CAAC,EAAE,SAAS,+CAA+C,EAAE,cAAc,+CAA+C,CAAC;QAChJ;QACA,MAAM,OAAO,OAAO,OAAO,CAAC;QAC5B,IAAI,QAAQ,MAAM;YACd,MAAM,MAAM,CAAC,CAAC,EAAE,SAAS,yCAAyC,CAAC;YACnE,IAAI,iCAAiC,kCAAkC,SAAS;gBAC5E,IAAI,kCAAkC,QAAQ;oBAC1C,QAAQ,IAAI,CAAC;gBACjB;gBACA;YACJ;YACA,MAAM,IAAI,MAAM;QACpB,OACK,IAAI,CAAC,GAAG,UAAU,qBAAqB,EAAE,OAAO;YACjD,wEAAwE;YACxE,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,UAAU,UAAU,CAAC,OAAO;oBAC5B,IAAI,CAAC,UAAU,SAAS,CAAC,GAAG,GAAG,aAAa,CAAC,UAAU;gBAC3D,OACK;oBACD,IAAI,CAAC,UAAU,GAAG,aAAa,CAAC,UAAU;gBAC9C;YACJ;QACJ,OACK,IAAI,CAAC,GAAG,UAAU,UAAU,EAAE,OAAO;YACtC,MAAM,SAAS,KAAK,SAAS;YAC7B,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,CAAC,UAAU,UAAU,CAAC,SACtB,CAAC,OAAO,IAAI,CAAC,CAAA,QAAS,MAAM,IAAI,KAAK,cACrC,iCACA,kCAAkC,UAAU;oBAC5C,MAAM,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC,EAAE,UAAU,kDAAkD,EAAE,KAAK,IAAI,EAAE;oBACrG,IAAI,kCAAkC,SAAS;wBAC3C,MAAM,IAAI,MAAM;oBACpB,OACK;wBACD,QAAQ,IAAI,CAAC;oBACjB;gBACJ;YACJ;QACJ,OACK,IAAI,CAAC,GAAG,UAAU,WAAW,EAAE,OAAO;YACvC,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,CAAC,UAAU,UAAU,CAAC,SACtB,iCACA,kCAAkC,UAAU;oBAC5C,MAAM,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC,EAAE,UAAU,+BAA+B,EAAE,KAAK,IAAI,CAAC,mCAAmC,CAAC;oBACrH,IAAI,kCAAkC,SAAS;wBAC3C,MAAM,IAAI,MAAM;oBACpB,OACK;wBACD,QAAQ,IAAI,CAAC;oBACjB;gBACJ;YACJ;QACJ,OACK,IAAI,CAAC,GAAG,UAAU,YAAY,EAAE,SAAS,CAAC,GAAG,UAAU,eAAe,EAAE,OAAO;YAChF,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,CAAC,UAAU,UAAU,CAAC,OAAO;oBAC7B,MAAM,SAAS,KAAK,SAAS;oBAC7B,MAAM,QAAQ,MAAM,CAAC,UAAU;oBAC/B,IAAI,SAAS,MAAM;wBACf,8CAA8C;wBAC9C,IAAI,iCAAiC,kCAAkC,UAAU;4BAC7E,MAAM,MAAM,GAAG,SAAS,CAAC,EAAE,UAAU,wCAAwC,CAAC;4BAC9E,IAAI,kCAAkC,SAAS;gCAC3C,MAAM,IAAI,MAAM;4BACpB,OACK;gCACD,QAAQ,KAAK,CAAC;4BAClB;wBACJ;oBACJ,OACK;wBACD,gDAAgD;wBAChD,MAAM,eAAe,aAAa,CAAC,UAAU;wBAC7C,IAAI,OAAO,iBAAiB,cAAc,OAAO,iBAAiB,UAAU;4BACxE,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,UAAU,2BAA2B,CAAC;wBAClF;oBACJ;gBACJ;YACJ;QACJ;IACJ;IACA,SAAS,yBACH,6BAA6B,QAAQ,WAAW,wBAChD,6BAA6B,QAAQ,WAAW;IACtD,IAAI,kCAAkC,mCAAmC,UAAU;QAC/E,CAAC,GAAG,iCAAiC,2BAA2B,EAAE,QAAQ;IAC9E;IACA,OAAO;AACX;AACA,SAAS,6BAA6B,MAAM,EAAE,SAAS,EAAE,oBAAoB;IACzE,MAAM,UAAU,OAAO,UAAU;IACjC,IAAK,MAAM,YAAY,UAAW;QAC9B,MAAM,OAAO,OAAO,OAAO,CAAC;QAC5B,MAAM,gBAAgB,SAAS,CAAC,SAAS;QACzC,IAAI,CAAC,GAAG,UAAU,YAAY,EAAE,OAAO;YACnC,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,UAAU,UAAU,CAAC,OAAO;oBAC5B,IAAI,CAAC,UAAU,SAAS,CAAC,GAAG,GAAG,aAAa,CAAC,UAAU;gBAC3D,OACK,IAAI,cAAc,aAAa,KAAK,OAAO,IAAI,MAAM;oBACtD,KAAK,OAAO,GAAG;wBACX,GAAG,KAAK,OAAO;wBACf,aAAa,eAAe,SAAS,eACjC,KAAK,OAAO,CAAC,WAAW;wBAC5B,YAAY,CAAC,KAAK,OAAO,CAAC,UAAU,IAAI,EAAE,EAAE,MAAM,CAAC,eAAe,SAAS,cAAc,EAAE;oBAC/F;gBACJ,OACK,IAAI,cAAc,uBAAuB,KAAK,iBAAiB,IAAI,MAAM;oBAC1E,KAAK,iBAAiB,GAAG,KAAK,iBAAiB,CAAC,MAAM,CAAC,eAAe,qBAAqB,EAAE;gBACjG,OACK,IAAI,cAAc,gBACnB,KAAK,UAAU,IAAI,QACnB,cAAc,UAAU,IAAI,MAAM;oBAClC,KAAK,UAAU,GAAG,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO,KAAK,UAAU,EAAE,cAAc,UAAU;gBAClG,OACK;oBACD,IAAI,CAAC,UAAU,GAAG,aAAa,CAAC,UAAU;gBAC9C;YACJ;QACJ,OACK,IAAI,CAAC,GAAG,UAAU,UAAU,EAAE,OAAO;YACtC,MAAM,SAAS,KAAK,QAAQ;YAC5B,MAAM,qBAAqB,OAAO,MAAM;YACxC,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,UAAU,UAAU,CAAC,OAAO;oBAC5B,MAAM,CAAC,UAAU,SAAS,CAAC,GAAG,GAAG,aAAa,CAAC,UAAU;gBAC7D,OACK,IAAI,cAAc,aAAa,OAAO,OAAO,IAAI,MAAM;oBACxD,OAAO,OAAO,GAAG;wBACb,GAAG,OAAO,OAAO;wBACjB,aAAa,eAAe,SAAS,eACjC,OAAO,OAAO,CAAC,WAAW;wBAC9B,YAAY,CAAC,OAAO,OAAO,CAAC,UAAU,IAAI,EAAE,EAAE,MAAM,CAAC,eAAe,SAAS,cAAc,EAAE;oBACjG;gBACJ,OACK,IAAI,cAAc,uBAAuB,OAAO,iBAAiB,IAAI,MAAM;oBAC5E,OAAO,iBAAiB,GAAG,OAAO,iBAAiB,CAAC,MAAM,CAAC,eAAe,qBAAqB,EAAE;gBACrG,OACK,IAAI,cAAc,gBACnB,KAAK,UAAU,IAAI,QACnB,cAAc,UAAU,IAAI,MAAM;oBAClC,KAAK,UAAU,GAAG,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO,KAAK,UAAU,EAAE,cAAc,UAAU;gBAClG,OACK,IAAI,kBAAkB,CAAC,UAAU,EAAE;oBACpC,kBAAkB,CAAC,UAAU,CAAC,KAAK,GAAG,aAAa,CAAC,UAAU;gBAClE;YACJ;YACA,OAAO,CAAC,SAAS,GAAG,IAAI,UAAU,eAAe,CAAC;QACtD,OACK,IAAI,CAAC,GAAG,UAAU,WAAW,EAAE,OAAO;YACvC,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,UAAU,UAAU,CAAC,OAAO;oBAC5B,IAAI,CAAC,UAAU,SAAS,CAAC,GAAG,GAAG,aAAa,CAAC,UAAU;gBAC3D;YACJ;QACJ,OACK,IAAI,CAAC,GAAG,UAAU,YAAY,EAAE,SAAS,CAAC,GAAG,UAAU,eAAe,EAAE,OAAO;YAChF,IAAK,MAAM,aAAa,cAAe;gBACnC,IAAI,UAAU,UAAU,CAAC,OAAO;oBAC5B,gEAAgE;oBAChE,IAAI,CAAC,UAAU,SAAS,CAAC,GAAG,GAAG,aAAa,CAAC,UAAU;oBACvD;gBACJ;gBACA,MAAM,SAAS,KAAK,SAAS;gBAC7B,MAAM,QAAQ,MAAM,CAAC,UAAU;gBAC/B,IAAI,SAAS,MAAM;oBACf,MAAM,eAAe,aAAa,CAAC,UAAU;oBAC7C,IAAI,OAAO,iBAAiB,YAAY;wBACpC,qEAAqE;wBACrE,MAAM,OAAO,GAAG,aAAa,IAAI,CAAC;oBACtC,OACK;wBACD,mBAAmB,OAAO;oBAC9B;gBACJ;YACJ;QACJ;IACJ;IACA,mFAAmF;IACnF,CAAC,GAAG,QAAQ,mBAAmB,EAAE,QAAQ,QAAQ,mBAAmB;IACpE,6DAA6D;IAC7D,CAAC,GAAG,QAAQ,UAAU,EAAE;IACxB,yDAAyD;IACzD,CAAC,GAAG,QAAQ,mBAAmB,EAAE,QAAQ,QAAQ,eAAe;IAChE,IAAI,wBAAwB,MAAM;QAC9B,CAAC,GAAG,QAAQ,YAAY,EAAE,QAAQ,CAAA;YAC9B,IAAI,CAAC,MAAM,OAAO,EAAE;gBAChB,MAAM,OAAO,GAAG;YACpB;QACJ;IACJ;IACA,OAAO;AACX;AACA,SAAS,6BAA6B,MAAM,EAAE,SAAS,EAAE,oBAAoB;IACzE,SAAS,CAAC,GAAG,QAAQ,SAAS,EAAE,QAAQ;QACpC,CAAC,QAAQ,UAAU,CAAC,WAAW,CAAC,EAAE,CAAA;YAC9B,MAAM,SAAS,KAAK,QAAQ;YAC5B,MAAM,gBAAgB,SAAS,CAAC,KAAK,IAAI,CAAC;YAC1C,IAAI,CAAC,CAAC,GAAG,UAAU,qBAAqB,EAAE,SAAS,iBAAiB,MAAM;gBACtE,IAAK,MAAM,aAAa,cAAe;oBACnC,IAAI,UAAU,UAAU,CAAC,OAAO;wBAC5B,MAAM,CAAC,UAAU,SAAS,CAAC,GAAG,GAAG,aAAa,CAAC,UAAU;oBAC7D,OACK,IAAI,cAAc,aAAa,OAAO,OAAO,IAAI,MAAM;wBACxD,OAAO,OAAO,GAAG;4BACb,GAAG,OAAO,OAAO;4BACjB,aAAa,eAAe,SAAS,eACjC,OAAO,OAAO,CAAC,WAAW;4BAC9B,YAAY,CAAC,OAAO,OAAO,CAAC,UAAU,IAAI,EAAE,EAAE,MAAM,CAAC,eAAe,SAAS,cAAc,EAAE;wBACjG;oBACJ,OACK,IAAI,cAAc,uBAAuB,OAAO,iBAAiB,IAAI,MAAM;wBAC5E,OAAO,iBAAiB,GAAG,OAAO,iBAAiB,CAAC,MAAM,CAAC,eAAe,qBAAqB,EAAE;oBACrG,OACK,IAAI,cAAc,gBACnB,OAAO,UAAU,IAAI,QACrB,cAAc,UAAU,IAAI,MAAM;wBAClC,OAAO,UAAU,GAAG,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO,KAAK,UAAU,EAAE,cAAc,UAAU;oBACpG,OACK;wBACD,MAAM,CAAC,UAAU,GAAG,aAAa,CAAC,UAAU;oBAChD;gBACJ;gBACA,OAAO,IAAI,UAAU,iBAAiB,CAAC;YAC3C;QACJ;QACA,CAAC,QAAQ,UAAU,CAAC,SAAS,CAAC,EAAE,CAAA;YAC5B,MAAM,gBAAgB,SAAS,CAAC,KAAK,IAAI,CAAC;YAC1C,MAAM,SAAS,KAAK,QAAQ;YAC5B,MAAM,qBAAqB,OAAO,MAAM;YACxC,IAAI,iBAAiB,MAAM;gBACvB,IAAK,MAAM,aAAa,cAAe;oBACnC,IAAI,UAAU,UAAU,CAAC,OAAO;wBAC5B,MAAM,CAAC,UAAU,SAAS,CAAC,GAAG,GAAG,aAAa,CAAC,UAAU;oBAC7D,OACK,IAAI,cAAc,aAAa,OAAO,OAAO,IAAI,MAAM;wBACxD,OAAO,OAAO,GAAG;4BACb,GAAG,OAAO,OAAO;4BACjB,aAAa,eAAe,SAAS,eACjC,OAAO,OAAO,CAAC,WAAW;4BAC9B,YAAY,CAAC,OAAO,OAAO,CAAC,UAAU,IAAI,EAAE,EAAE,MAAM,CAAC,eAAe,SAAS,cAAc,EAAE;wBACjG;oBACJ,OACK,IAAI,cAAc,uBAAuB,OAAO,iBAAiB,IAAI,MAAM;wBAC5E,OAAO,iBAAiB,GAAG,OAAO,iBAAiB,CAAC,MAAM,CAAC,eAAe,qBAAqB,EAAE;oBACrG,OACK,IAAI,cAAc,gBACnB,OAAO,UAAU,IAAI,QACrB,cAAc,UAAU,IAAI,MAAM;wBAClC,OAAO,UAAU,GAAG,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,OAAO,KAAK,UAAU,EAAE,cAAc,UAAU;oBACpG,OACK,IAAI,kBAAkB,CAAC,UAAU,EAAE;wBACpC,kBAAkB,CAAC,UAAU,CAAC,KAAK,GAAG,aAAa,CAAC,UAAU;oBAClE;gBACJ;gBACA,OAAO,IAAI,UAAU,eAAe,CAAC;YACzC;QACJ;QACA,CAAC,QAAQ,UAAU,CAAC,UAAU,CAAC,EAAE,CAAA;YAC7B,MAAM,gBAAgB,SAAS,CAAC,KAAK,IAAI,CAAC;YAC1C,IAAI,iBAAiB,MAAM;gBACvB,MAAM,SAAS,KAAK,QAAQ;gBAC5B,IAAI,aAAa,CAAC,gBAAgB,EAAE;oBAChC,OAAO,WAAW,GAAG,aAAa,CAAC,gBAAgB;gBACvD;gBACA,OAAO,IAAI,UAAU,gBAAgB,CAAC;YAC1C;QACJ;QACA,CAAC,QAAQ,UAAU,CAAC,WAAW,CAAC,EAAE,CAAA;YAC9B,MAAM,gBAAgB,SAAS,CAAC,KAAK,IAAI,CAAC;YAC1C,IAAI,iBAAiB,MAAM;gBACvB,MAAM,SAAS,KAAK,QAAQ;gBAC5B,IAAI,aAAa,CAAC,aAAa,EAAE;oBAC7B,OAAO,QAAQ,GAAG,aAAa,CAAC,aAAa;gBACjD;gBACA,OAAO,IAAI,UAAU,iBAAiB,CAAC;YAC3C;QACJ;QACA,CAAC,QAAQ,UAAU,CAAC,cAAc,CAAC,EAAE,CAAA;YACjC,MAAM,gBAAgB,SAAS,CAAC,KAAK,IAAI,CAAC;YAC1C,IAAI,iBAAiB,MAAM;gBACvB,MAAM,SAAS,KAAK,QAAQ;gBAC5B,IAAI,aAAa,CAAC,gBAAgB,EAAE;oBAChC,OAAO,WAAW,GAAG,aAAa,CAAC,gBAAgB;gBACvD;gBACA,OAAO,IAAI,UAAU,oBAAoB,CAAC;YAC9C;QACJ;QACA,CAAC,QAAQ,UAAU,CAAC,eAAe,CAAC,EAAE,CAAC,aAAa,WAAW;YAC3D,MAAM,gBAAgB,SAAS,CAAC,SAAS;YACzC,IAAI,iBAAiB,MAAM;gBACvB,MAAM,eAAe,aAAa,CAAC,UAAU;gBAC7C,IAAI,gBAAgB,MAAM;oBACtB,MAAM,iBAAiB;wBAAE,GAAG,WAAW;oBAAC;oBACxC,IAAI,OAAO,iBAAiB,YAAY;wBACpC,qEAAqE;wBACrE,eAAe,OAAO,GAAG,aAAa,IAAI,CAAC;oBAC/C,OACK;wBACD,mBAAmB,gBAAgB;oBACvC;oBACA,OAAO;gBACX;YACJ;QACJ;IACJ;IACA,IAAI,wBAAwB,MAAM;QAC9B,SAAS,CAAC,GAAG,QAAQ,SAAS,EAAE,QAAQ;YACpC,CAAC,QAAQ,UAAU,CAAC,YAAY,CAAC,EAAE,CAAA,cAAe,CAAC;oBAC/C,GAAG,WAAW;oBACd,SAAS,YAAY,OAAO,IAAI,OAAO,YAAY,OAAO,GAAG;gBACjE,CAAC;QACL;IACJ;IACA,OAAO;AACX;AACA,SAAS,mBAAmB,KAAK,EAAE,aAAa;IAC5C,IAAK,MAAM,gBAAgB,cAAe;QACtC,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC,aAAa;IACrD;AACJ","ignoreList":[0]}},
    {"offset": {"line": 430, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/makeExecutableSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeExecutableSchema = makeExecutableSchema;\nconst graphql_1 = require(\"graphql\");\nconst merge_1 = require(\"@graphql-tools/merge\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst addResolversToSchema_js_1 = require(\"./addResolversToSchema.js\");\nconst assertResolversPresent_js_1 = require(\"./assertResolversPresent.js\");\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use GraphQL magic comment provide additional syntax\n * highlighting in your editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = /* GraphQL *\\/ `\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, defaultFieldResolver, ...otherOptions }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    let schema;\n    if ((0, graphql_1.isSchema)(typeDefs)) {\n        schema = typeDefs;\n    }\n    else if (otherOptions?.commentDescriptions) {\n        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {\n            ...otherOptions,\n            commentDescriptions: true,\n        });\n        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);\n    }\n    else {\n        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);\n        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    schema = (0, addResolversToSchema_js_1.addResolversToSchema)({\n        schema,\n        resolvers: (0, merge_1.mergeResolvers)(resolvers),\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n        defaultFieldResolver,\n    });\n    if (Object.keys(resolverValidationOptions).length > 0) {\n        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);\n    }\n    if (schemaExtensions) {\n        for (const schemaExtension of (0, utils_1.asArray)(schemaExtensions)) {\n            (0, merge_1.applyExtensions)(schema, schemaExtension);\n        }\n    }\n    return schema;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,oBAAoB,GAAG;AAC/B,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0CC,GACD,SAAS,qBAAqB,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC,EAAE,4BAA4B,CAAC,CAAC,EAAE,iCAAiC,KAAK,EAAE,yBAAyB,KAAK,EAAE,gBAAgB,EAAE,oBAAoB,EAAE,GAAG,cAAc;IACvN,kCAAkC;IAClC,IAAI,OAAO,8BAA8B,UAAU;QAC/C,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,UAAU;QACX,MAAM,IAAI,MAAM;IACpB;IACA,IAAI;IACJ,IAAI,CAAC,GAAG,UAAU,QAAQ,EAAE,WAAW;QACnC,SAAS;IACb,OACK,IAAI,cAAc,qBAAqB;QACxC,MAAM,iBAAiB,CAAC,GAAG,QAAQ,aAAa,EAAE,UAAU;YACxD,GAAG,YAAY;YACf,qBAAqB;QACzB;QACA,SAAS,CAAC,GAAG,UAAU,WAAW,EAAE,gBAAgB;IACxD,OACK;QACD,MAAM,iBAAiB,CAAC,GAAG,QAAQ,aAAa,EAAE,UAAU;QAC5D,SAAS,CAAC,GAAG,UAAU,cAAc,EAAE,gBAAgB;IAC3D;IACA,6EAA6E;IAC7E,SAAS,CAAC,GAAG,0BAA0B,oBAAoB,EAAE;QACzD;QACA,WAAW,CAAC,GAAG,QAAQ,cAAc,EAAE;QACvC;QACA;QACA;QACA;IACJ;IACA,IAAI,OAAO,IAAI,CAAC,2BAA2B,MAAM,GAAG,GAAG;QACnD,CAAC,GAAG,4BAA4B,sBAAsB,EAAE,QAAQ;IACpE;IACA,IAAI,kBAAkB;QAClB,KAAK,MAAM,mBAAmB,CAAC,GAAG,QAAQ,OAAO,EAAE,kBAAmB;YAClE,CAAC,GAAG,QAAQ,eAAe,EAAE,QAAQ;QACzC;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 524, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 528, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/merge-schemas.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeSchemas = mergeSchemas;\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst makeExecutableSchema_js_1 = require(\"./makeExecutableSchema.js\");\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nfunction mergeSchemas(config) {\n    const extractedTypeDefs = [];\n    const extractedResolvers = [];\n    const extractedSchemaExtensions = [];\n    if (config.schemas != null) {\n        for (const schema of config.schemas) {\n            extractedTypeDefs.push((0, utils_1.getDocumentNodeFromSchema)(schema));\n            extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema));\n            extractedSchemaExtensions.push((0, utils_1.extractExtensionsFromSchema)(schema));\n        }\n    }\n    if (config.typeDefs != null) {\n        extractedTypeDefs.push(config.typeDefs);\n    }\n    if (config.resolvers != null) {\n        const additionalResolvers = (0, utils_1.asArray)(config.resolvers);\n        extractedResolvers.push(...additionalResolvers);\n    }\n    if (config.schemaExtensions != null) {\n        const additionalSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions);\n        extractedSchemaExtensions.push(...additionalSchemaExtensions);\n    }\n    return (0, makeExecutableSchema_js_1.makeExecutableSchema)({\n        ...config,\n        typeDefs: extractedTypeDefs,\n        resolvers: extractedResolvers,\n        schemaExtensions: extractedSchemaExtensions,\n    });\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,YAAY,GAAG;AACvB,MAAM;AACN,MAAM;AACN;;;CAGC,GACD,SAAS,aAAa,MAAM;IACxB,MAAM,oBAAoB,EAAE;IAC5B,MAAM,qBAAqB,EAAE;IAC7B,MAAM,4BAA4B,EAAE;IACpC,IAAI,OAAO,OAAO,IAAI,MAAM;QACxB,KAAK,MAAM,UAAU,OAAO,OAAO,CAAE;YACjC,kBAAkB,IAAI,CAAC,CAAC,GAAG,QAAQ,yBAAyB,EAAE;YAC9D,mBAAmB,IAAI,CAAC,CAAC,GAAG,QAAQ,sBAAsB,EAAE;YAC5D,0BAA0B,IAAI,CAAC,CAAC,GAAG,QAAQ,2BAA2B,EAAE;QAC5E;IACJ;IACA,IAAI,OAAO,QAAQ,IAAI,MAAM;QACzB,kBAAkB,IAAI,CAAC,OAAO,QAAQ;IAC1C;IACA,IAAI,OAAO,SAAS,IAAI,MAAM;QAC1B,MAAM,sBAAsB,CAAC,GAAG,QAAQ,OAAO,EAAE,OAAO,SAAS;QACjE,mBAAmB,IAAI,IAAI;IAC/B;IACA,IAAI,OAAO,gBAAgB,IAAI,MAAM;QACjC,MAAM,6BAA6B,CAAC,GAAG,QAAQ,OAAO,EAAE,OAAO,gBAAgB;QAC/E,0BAA0B,IAAI,IAAI;IACtC;IACA,OAAO,CAAC,GAAG,0BAA0B,oBAAoB,EAAE;QACvD,GAAG,MAAM;QACT,UAAU;QACV,WAAW;QACX,kBAAkB;IACtB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 570, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/schema/cjs/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractExtensionsFromSchema = exports.extendResolversFromInterfaces = exports.checkForResolveTypeResolver = exports.addResolversToSchema = exports.chainResolvers = exports.assertResolversPresent = void 0;\nconst tslib_1 = require(\"tslib\");\nvar assertResolversPresent_js_1 = require(\"./assertResolversPresent.js\");\nObject.defineProperty(exports, \"assertResolversPresent\", { enumerable: true, get: function () { return assertResolversPresent_js_1.assertResolversPresent; } });\nvar chainResolvers_js_1 = require(\"./chainResolvers.js\");\nObject.defineProperty(exports, \"chainResolvers\", { enumerable: true, get: function () { return chainResolvers_js_1.chainResolvers; } });\nvar addResolversToSchema_js_1 = require(\"./addResolversToSchema.js\");\nObject.defineProperty(exports, \"addResolversToSchema\", { enumerable: true, get: function () { return addResolversToSchema_js_1.addResolversToSchema; } });\nvar checkForResolveTypeResolver_js_1 = require(\"./checkForResolveTypeResolver.js\");\nObject.defineProperty(exports, \"checkForResolveTypeResolver\", { enumerable: true, get: function () { return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver; } });\nvar extendResolversFromInterfaces_js_1 = require(\"./extendResolversFromInterfaces.js\");\nObject.defineProperty(exports, \"extendResolversFromInterfaces\", { enumerable: true, get: function () { return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces; } });\ntslib_1.__exportStar(require(\"./makeExecutableSchema.js\"), exports);\ntslib_1.__exportStar(require(\"./types.js\"), exports);\ntslib_1.__exportStar(require(\"./merge-schemas.js\"), exports);\nvar utils_1 = require(\"@graphql-tools/utils\");\nObject.defineProperty(exports, \"extractExtensionsFromSchema\", { enumerable: true, get: function () { return utils_1.extractExtensionsFromSchema; } });\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,2BAA2B,GAAG,QAAQ,6BAA6B,GAAG,QAAQ,2BAA2B,GAAG,QAAQ,oBAAoB,GAAG,QAAQ,cAAc,GAAG,QAAQ,sBAAsB,GAAG,KAAK;AAClN,MAAM;AACN,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,0BAA0B;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,4BAA4B,sBAAsB;IAAE;AAAE;AAC7J,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,kBAAkB;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,oBAAoB,cAAc;IAAE;AAAE;AACrI,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,wBAAwB;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,0BAA0B,oBAAoB;IAAE;AAAE;AACvJ,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,+BAA+B;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,iCAAiC,2BAA2B;IAAE;AAAE;AAC5K,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,iCAAiC;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,mCAAmC,6BAA6B;IAAE;AAAE;AAClL,QAAQ,YAAY,+HAAuC;AAC3D,QAAQ,YAAY,gHAAwB;AAC5C,QAAQ,YAAY,wHAAgC;AACpD,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,+BAA+B;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,QAAQ,2BAA2B;IAAE;AAAE","ignoreList":[0]}},
    {"offset": {"line": 624, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/merge-resolvers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeResolvers = mergeResolvers;\nconst utils_1 = require(\"@graphql-tools/utils\");\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\nfunction mergeResolvers(resolversDefinitions, options) {\n    if (!resolversDefinitions ||\n        (Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0)) {\n        return {};\n    }\n    if (!Array.isArray(resolversDefinitions)) {\n        return resolversDefinitions;\n    }\n    if (resolversDefinitions.length === 1) {\n        return resolversDefinitions[0] || {};\n    }\n    const resolvers = new Array();\n    for (let resolversDefinition of resolversDefinitions) {\n        if (Array.isArray(resolversDefinition)) {\n            resolversDefinition = mergeResolvers(resolversDefinition);\n        }\n        if (typeof resolversDefinition === 'object' && resolversDefinition) {\n            resolvers.push(resolversDefinition);\n        }\n    }\n    const result = (0, utils_1.mergeDeep)(resolvers, true);\n    if (options?.exclusions) {\n        for (const exclusion of options.exclusions) {\n            const [typeName, fieldName] = exclusion.split('.');\n            if (['__proto__', 'constructor', 'prototype'].includes(typeName) ||\n                ['__proto__', 'constructor', 'prototype'].includes(fieldName)) {\n                continue;\n            }\n            if (!fieldName || fieldName === '*') {\n                delete result[typeName];\n            }\n            else if (result[typeName]) {\n                delete result[typeName][fieldName];\n            }\n        }\n    }\n    return result;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,cAAc,GAAG;AACzB,MAAM;AACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC,GACD,SAAS,eAAe,oBAAoB,EAAE,OAAO;IACjD,IAAI,CAAC,wBACA,MAAM,OAAO,CAAC,yBAAyB,qBAAqB,MAAM,KAAK,GAAI;QAC5E,OAAO,CAAC;IACZ;IACA,IAAI,CAAC,MAAM,OAAO,CAAC,uBAAuB;QACtC,OAAO;IACX;IACA,IAAI,qBAAqB,MAAM,KAAK,GAAG;QACnC,OAAO,oBAAoB,CAAC,EAAE,IAAI,CAAC;IACvC;IACA,MAAM,YAAY,IAAI;IACtB,KAAK,IAAI,uBAAuB,qBAAsB;QAClD,IAAI,MAAM,OAAO,CAAC,sBAAsB;YACpC,sBAAsB,eAAe;QACzC;QACA,IAAI,OAAO,wBAAwB,YAAY,qBAAqB;YAChE,UAAU,IAAI,CAAC;QACnB;IACJ;IACA,MAAM,SAAS,CAAC,GAAG,QAAQ,SAAS,EAAE,WAAW;IACjD,IAAI,SAAS,YAAY;QACrB,KAAK,MAAM,aAAa,QAAQ,UAAU,CAAE;YACxC,MAAM,CAAC,UAAU,UAAU,GAAG,UAAU,KAAK,CAAC;YAC9C,IAAI;gBAAC;gBAAa;gBAAe;aAAY,CAAC,QAAQ,CAAC,aACnD;gBAAC;gBAAa;gBAAe;aAAY,CAAC,QAAQ,CAAC,YAAY;gBAC/D;YACJ;YACA,IAAI,CAAC,aAAa,cAAc,KAAK;gBACjC,OAAO,MAAM,CAAC,SAAS;YAC3B,OACK,IAAI,MAAM,CAAC,SAAS,EAAE;gBACvB,OAAO,MAAM,CAAC,SAAS,CAAC,UAAU;YACtC;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/arguments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeArguments = mergeArguments;\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction mergeArguments(args1, args2, config) {\n    const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome), config);\n    if (config && config.sort) {\n        result.sort(utils_1.compareNodes);\n    }\n    return result;\n}\nfunction deduplicateArguments(args, config) {\n    return args.reduce((acc, current) => {\n        const dupIndex = acc.findIndex(arg => arg.name.value === current.name.value);\n        if (dupIndex === -1) {\n            return acc.concat([current]);\n        }\n        else if (!config?.reverseArguments) {\n            acc[dupIndex] = current;\n        }\n        return acc;\n    }, []);\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,cAAc,GAAG;AACzB,MAAM;AACN,SAAS,eAAe,KAAK,EAAE,KAAK,EAAE,MAAM;IACxC,MAAM,SAAS,qBAAqB;WAAI;WAAU;KAAM,CAAC,MAAM,CAAC,QAAQ,MAAM,GAAG;IACjF,IAAI,UAAU,OAAO,IAAI,EAAE;QACvB,OAAO,IAAI,CAAC,QAAQ,YAAY;IACpC;IACA,OAAO;AACX;AACA,SAAS,qBAAqB,IAAI,EAAE,MAAM;IACtC,OAAO,KAAK,MAAM,CAAC,CAAC,KAAK;QACrB,MAAM,WAAW,IAAI,SAAS,CAAC,CAAA,MAAO,IAAI,IAAI,CAAC,KAAK,KAAK,QAAQ,IAAI,CAAC,KAAK;QAC3E,IAAI,aAAa,CAAC,GAAG;YACjB,OAAO,IAAI,MAAM,CAAC;gBAAC;aAAQ;QAC/B,OACK,IAAI,CAAC,QAAQ,kBAAkB;YAChC,GAAG,CAAC,SAAS,GAAG;QACpB;QACA,OAAO;IACX,GAAG,EAAE;AACT","ignoreList":[0]}},
    {"offset": {"line": 736, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/directives.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeDirectives = mergeDirectives;\nexports.mergeDirective = mergeDirective;\nconst graphql_1 = require(\"graphql\");\nfunction isRepeatableDirective(directive, directives, repeatableLinkImports) {\n    return !!(directives?.[directive.name.value]?.repeatable ??\n        repeatableLinkImports?.has(directive.name.value));\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments(a1, a2) {\n    const result = [];\n    for (const argument of [...a2, ...a1]) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex === -1) {\n            result.push(argument);\n        }\n        else {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value = {\n                    ...existingArg.value,\n                    values: deduplicateLists(source, target, (targetVal, source) => {\n                        const value = targetVal.value;\n                        return !value || !source.some((sourceVal) => sourceVal.value === value);\n                    }),\n                };\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n    }\n    return result;\n}\nconst matchValues = (a, b) => {\n    if (a.kind === b.kind) {\n        switch (a.kind) {\n            case graphql_1.Kind.LIST:\n                return (a.values.length === b.values.length &&\n                    a.values.every(aVal => b.values.find(bVal => matchValues(aVal, bVal))));\n            case graphql_1.Kind.VARIABLE:\n            case graphql_1.Kind.NULL:\n                return true;\n            case graphql_1.Kind.OBJECT:\n                return (a.fields.length === b.fields.length &&\n                    a.fields.every(aField => b.fields.find(bField => aField.name.value === bField.name.value && matchValues(aField.value, bField.value))));\n            default:\n                return a.value === b.value;\n        }\n    }\n    return false;\n};\nconst isLinkDirective = (directive) => directive.name.value === 'link';\nconst getLinkDirectiveURL = (directive) => {\n    const stringValue = isLinkDirective(directive)\n        ? directive.arguments?.find(arg => arg.name.value === 'url')?.value\n        : undefined;\n    return stringValue?.kind === 'StringValue' ? stringValue.value : undefined;\n};\nconst matchArguments = (a, b) => a.name.value === b.name.value && a.value.kind === b.value.kind && matchValues(a.value, b.value);\n/**\n * Check if a directive is an exact match of another directive based on their\n * arguments.\n */\nconst matchDirectives = (a, b) => {\n    const matched = a.name.value === b.name.value &&\n        (a.arguments === b.arguments ||\n            (a.arguments?.length === b.arguments?.length &&\n                a.arguments?.every(argA => b.arguments?.find(argB => matchArguments(argA, argB)))));\n    return !!matched;\n};\nfunction mergeDirectives(d1 = [], d2 = [], config, directives) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = [];\n    for (const directive of [...asNext, ...asFirst]) {\n        if (isRepeatableDirective(directive, directives, config?.repeatableLinkImports)) {\n            // look for repeated, identical directives that come before this instance\n            // if those exist, return null so that this directive gets removed.\n            const exactDuplicate = result.find(d => matchDirectives(directive, d));\n            if (!exactDuplicate) {\n                result.push(directive);\n            }\n        }\n        else {\n            const firstAt = result.findIndex(d => d.name.value === directive.name.value);\n            if (firstAt === -1) {\n                // if did not find a directive with this name on the result set already\n                result.push(directive);\n            }\n            else {\n                if (isLinkDirective(directive) && isLinkDirective(result[firstAt])) {\n                    const url1 = getLinkDirectiveURL(directive);\n                    const url2 = getLinkDirectiveURL(result[firstAt]);\n                    // if both are link directives but with different urls, do not merge them\n                    if (url1 && url2 && url1 !== url2) {\n                        result.push(directive);\n                        continue;\n                    }\n                }\n                // if not repeatable and found directive with the same name already in the result set,\n                // then merge the arguments of the existing directive and the new directive\n                const mergedArguments = mergeArguments(directive.arguments ?? [], result[firstAt].arguments ?? []);\n                result[firstAt] = {\n                    ...result[firstAt],\n                    arguments: mergedArguments.length === 0 ? undefined : mergedArguments,\n                };\n            }\n        }\n    }\n    return result;\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        return {\n            ...node,\n            arguments: deduplicateLists(existingNode.arguments || [], node.arguments || [], (arg, existingArgs) => !nameAlreadyExists(arg.name, existingArgs.map(a => a.name))),\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 869, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeEnumValues = mergeEnumValues;\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst directives_js_1 = require(\"./directives.js\");\nfunction mergeEnumValues(first, second, config, directives) {\n    if (config?.consistentEnumMerge) {\n        const reversed = [];\n        if (first) {\n            reversed.push(...first);\n        }\n        first = second;\n        second = reversed;\n    }\n    const enumValueMap = new Map();\n    if (first) {\n        for (const firstValue of first) {\n            enumValueMap.set(firstValue.name.value, firstValue);\n        }\n    }\n    if (second) {\n        for (const secondValue of second) {\n            const enumValue = secondValue.name.value;\n            if (enumValueMap.has(enumValue)) {\n                const firstValue = enumValueMap.get(enumValue);\n                firstValue.description = secondValue.description || firstValue.description;\n                firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives, directives);\n            }\n            else {\n                enumValueMap.set(enumValue, secondValue);\n            }\n        }\n    }\n    const result = [...enumValueMap.values()];\n    if (config && config.sort) {\n        result.sort(utils_1.compareNodes);\n    }\n    return result;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,eAAe,GAAG;AAC1B,MAAM;AACN,MAAM;AACN,SAAS,gBAAgB,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU;IACtD,IAAI,QAAQ,qBAAqB;QAC7B,MAAM,WAAW,EAAE;QACnB,IAAI,OAAO;YACP,SAAS,IAAI,IAAI;QACrB;QACA,QAAQ;QACR,SAAS;IACb;IACA,MAAM,eAAe,IAAI;IACzB,IAAI,OAAO;QACP,KAAK,MAAM,cAAc,MAAO;YAC5B,aAAa,GAAG,CAAC,WAAW,IAAI,CAAC,KAAK,EAAE;QAC5C;IACJ;IACA,IAAI,QAAQ;QACR,KAAK,MAAM,eAAe,OAAQ;YAC9B,MAAM,YAAY,YAAY,IAAI,CAAC,KAAK;YACxC,IAAI,aAAa,GAAG,CAAC,YAAY;gBAC7B,MAAM,aAAa,aAAa,GAAG,CAAC;gBACpC,WAAW,WAAW,GAAG,YAAY,WAAW,IAAI,WAAW,WAAW;gBAC1E,WAAW,UAAU,GAAG,CAAC,GAAG,gBAAgB,eAAe,EAAE,YAAY,UAAU,EAAE,WAAW,UAAU,EAAE;YAChH,OACK;gBACD,aAAa,GAAG,CAAC,WAAW;YAChC;QACJ;IACJ;IACA,MAAM,SAAS;WAAI,aAAa,MAAM;KAAG;IACzC,IAAI,UAAU,OAAO,IAAI,EAAE;QACvB,OAAO,IAAI,CAAC,QAAQ,YAAY;IACpC;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 914, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/enum.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeEnum = mergeEnum;\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nconst enum_values_js_1 = require(\"./enum-values.js\");\nfunction mergeEnum(e1, e2, config, directives) {\n    if (e2) {\n        return {\n            name: e1.name,\n            description: e1['description'] || e2['description'],\n            kind: config?.convertExtensions ||\n                e1.kind === 'EnumTypeDefinition' ||\n                e2.kind === 'EnumTypeDefinition'\n                ? 'EnumTypeDefinition'\n                : 'EnumTypeExtension',\n            loc: e1.loc,\n            directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config, directives),\n            values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config),\n        };\n    }\n    return config?.convertExtensions\n        ? {\n            ...e1,\n            kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,\n        }\n        : e1;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,SAAS,GAAG;AACpB,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,UAAU,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,UAAU;IACzC,IAAI,IAAI;QACJ,OAAO;YACH,MAAM,GAAG,IAAI;YACb,aAAa,EAAE,CAAC,cAAc,IAAI,EAAE,CAAC,cAAc;YACnD,MAAM,QAAQ,qBACV,GAAG,IAAI,KAAK,wBACZ,GAAG,IAAI,KAAK,uBACV,uBACA;YACN,KAAK,GAAG,GAAG;YACX,YAAY,CAAC,GAAG,gBAAgB,eAAe,EAAE,GAAG,UAAU,EAAE,GAAG,UAAU,EAAE,QAAQ;YACvF,QAAQ,CAAC,GAAG,iBAAiB,eAAe,EAAE,GAAG,MAAM,EAAE,GAAG,MAAM,EAAE;QACxE;IACJ;IACA,OAAO,QAAQ,oBACT;QACE,GAAG,EAAE;QACL,MAAM,UAAU,IAAI,CAAC,oBAAoB;IAC7C,IACE;AACV","ignoreList":[0]}},
    {"offset": {"line": 941, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompareVal = void 0;\nexports.isStringTypes = isStringTypes;\nexports.isSourceTypes = isSourceTypes;\nexports.extractType = extractType;\nexports.isWrappingTypeNode = isWrappingTypeNode;\nexports.isListTypeNode = isListTypeNode;\nexports.isNonNullTypeNode = isNonNullTypeNode;\nexports.printTypeNode = printTypeNode;\nexports.defaultStringComparator = defaultStringComparator;\nconst graphql_1 = require(\"graphql\");\nfunction isStringTypes(types) {\n    return typeof types === 'string';\n}\nfunction isSourceTypes(types) {\n    return types instanceof graphql_1.Source;\n}\nfunction extractType(type) {\n    let visitedType = type;\n    while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === 'NonNullType') {\n        visitedType = visitedType.type;\n    }\n    return visitedType;\n}\nfunction isWrappingTypeNode(type) {\n    return type.kind !== graphql_1.Kind.NAMED_TYPE;\n}\nfunction isListTypeNode(type) {\n    return type.kind === graphql_1.Kind.LIST_TYPE;\n}\nfunction isNonNullTypeNode(type) {\n    return type.kind === graphql_1.Kind.NON_NULL_TYPE;\n}\nfunction printTypeNode(type) {\n    if (isListTypeNode(type)) {\n        return `[${printTypeNode(type.type)}]`;\n    }\n    if (isNonNullTypeNode(type)) {\n        return `${printTypeNode(type.type)}!`;\n    }\n    return type.name.value;\n}\nvar CompareVal;\n(function (CompareVal) {\n    CompareVal[CompareVal[\"A_SMALLER_THAN_B\"] = -1] = \"A_SMALLER_THAN_B\";\n    CompareVal[CompareVal[\"A_EQUALS_B\"] = 0] = \"A_EQUALS_B\";\n    CompareVal[CompareVal[\"A_GREATER_THAN_B\"] = 1] = \"A_GREATER_THAN_B\";\n})(CompareVal || (exports.CompareVal = CompareVal = {}));\nfunction defaultStringComparator(a, b) {\n    if (a == null && b == null) {\n        return CompareVal.A_EQUALS_B;\n    }\n    if (a == null) {\n        return CompareVal.A_SMALLER_THAN_B;\n    }\n    if (b == null) {\n        return CompareVal.A_GREATER_THAN_B;\n    }\n    if (a < b)\n        return CompareVal.A_SMALLER_THAN_B;\n    if (a > b)\n        return CompareVal.A_GREATER_THAN_B;\n    return CompareVal.A_EQUALS_B;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,UAAU,GAAG,KAAK;AAC1B,QAAQ,aAAa,GAAG;AACxB,QAAQ,aAAa,GAAG;AACxB,QAAQ,WAAW,GAAG;AACtB,QAAQ,kBAAkB,GAAG;AAC7B,QAAQ,cAAc,GAAG;AACzB,QAAQ,iBAAiB,GAAG;AAC5B,QAAQ,aAAa,GAAG;AACxB,QAAQ,uBAAuB,GAAG;AAClC,MAAM;AACN,SAAS,cAAc,KAAK;IACxB,OAAO,OAAO,UAAU;AAC5B;AACA,SAAS,cAAc,KAAK;IACxB,OAAO,iBAAiB,UAAU,MAAM;AAC5C;AACA,SAAS,YAAY,IAAI;IACrB,IAAI,cAAc;IAClB,MAAO,YAAY,IAAI,KAAK,UAAU,IAAI,CAAC,SAAS,IAAI,YAAY,IAAI,KAAK,cAAe;QACxF,cAAc,YAAY,IAAI;IAClC;IACA,OAAO;AACX;AACA,SAAS,mBAAmB,IAAI;IAC5B,OAAO,KAAK,IAAI,KAAK,UAAU,IAAI,CAAC,UAAU;AAClD;AACA,SAAS,eAAe,IAAI;IACxB,OAAO,KAAK,IAAI,KAAK,UAAU,IAAI,CAAC,SAAS;AACjD;AACA,SAAS,kBAAkB,IAAI;IAC3B,OAAO,KAAK,IAAI,KAAK,UAAU,IAAI,CAAC,aAAa;AACrD;AACA,SAAS,cAAc,IAAI;IACvB,IAAI,eAAe,OAAO;QACtB,OAAO,CAAC,CAAC,EAAE,cAAc,KAAK,IAAI,EAAE,CAAC,CAAC;IAC1C;IACA,IAAI,kBAAkB,OAAO;QACzB,OAAO,GAAG,cAAc,KAAK,IAAI,EAAE,CAAC,CAAC;IACzC;IACA,OAAO,KAAK,IAAI,CAAC,KAAK;AAC1B;AACA,IAAI;AACJ,CAAC,SAAU,UAAU;IACjB,UAAU,CAAC,UAAU,CAAC,mBAAmB,GAAG,CAAC,EAAE,GAAG;IAClD,UAAU,CAAC,UAAU,CAAC,aAAa,GAAG,EAAE,GAAG;IAC3C,UAAU,CAAC,UAAU,CAAC,mBAAmB,GAAG,EAAE,GAAG;AACrD,CAAC,EAAE,cAAc,CAAC,QAAQ,UAAU,GAAG,aAAa,CAAC,CAAC;AACtD,SAAS,wBAAwB,CAAC,EAAE,CAAC;IACjC,IAAI,KAAK,QAAQ,KAAK,MAAM;QACxB,OAAO,WAAW,UAAU;IAChC;IACA,IAAI,KAAK,MAAM;QACX,OAAO,WAAW,gBAAgB;IACtC;IACA,IAAI,KAAK,MAAM;QACX,OAAO,WAAW,gBAAgB;IACtC;IACA,IAAI,IAAI,GACJ,OAAO,WAAW,gBAAgB;IACtC,IAAI,IAAI,GACJ,OAAO,WAAW,gBAAgB;IACtC,OAAO,WAAW,UAAU;AAChC","ignoreList":[0]}},
    {"offset": {"line": 1009, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/fields.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeFields = mergeFields;\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst arguments_js_1 = require(\"./arguments.js\");\nconst directives_js_1 = require(\"./directives.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction fieldAlreadyExists(fieldsArr, otherField) {\n    const resultIndex = fieldsArr.findIndex(field => field.name.value === otherField.name.value);\n    return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];\n}\nfunction mergeFields(type, f1, f2, config, directives) {\n    const result = [];\n    if (f2 != null) {\n        result.push(...f2);\n    }\n    if (f1 != null) {\n        for (const field of f1) {\n            const [existing, existingIndex] = fieldAlreadyExists(result, field);\n            if (existing && !config?.ignoreFieldConflicts) {\n                const newField = (config?.onFieldTypeConflict &&\n                    config.onFieldTypeConflict(existing, field, type, config?.throwOnConflict)) ||\n                    preventConflicts(type, existing, field, config?.throwOnConflict);\n                newField.arguments = (0, arguments_js_1.mergeArguments)(field['arguments'] || [], existing['arguments'] || [], config);\n                newField.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config, directives);\n                newField.description = field.description || existing.description;\n                result[existingIndex] = newField;\n            }\n            else {\n                result.push(field);\n            }\n        }\n    }\n    if (config && config.sort) {\n        result.sort(utils_1.compareNodes);\n    }\n    if (config && config.exclusions) {\n        const exclusions = config.exclusions;\n        return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = (0, utils_js_1.printTypeNode)(a.type);\n    const bType = (0, utils_js_1.printTypeNode)(b.type);\n    if (aType !== bType) {\n        const t1 = (0, utils_js_1.extractType)(a.type);\n        const t2 = (0, utils_js_1.extractType)(b.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${b.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n        if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {\n            throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n        }\n    }\n    if ((0, utils_js_1.isNonNullTypeNode)(b.type) && !(0, utils_js_1.isNonNullTypeNode)(a.type)) {\n        a.type = b.type;\n    }\n    return a;\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if ((0, utils_js_1.isNonNullTypeNode)(newType)) {\n        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if ((0, utils_js_1.isListTypeNode)(oldType)) {\n        return (((0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            ((0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1094, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/input-type.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeInputType = mergeInputType;\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nconst fields_js_1 = require(\"./fields.js\");\nfunction mergeInputType(node, existingNode, config, directives) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: config?.convertExtensions ||\n                    node.kind === 'InputObjectTypeDefinition' ||\n                    existingNode.kind === 'InputObjectTypeDefinition'\n                    ? 'InputObjectTypeDefinition'\n                    : 'InputObjectTypeExtension',\n                loc: node.loc,\n                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),\n                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,cAAc,GAAG;AACzB,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,eAAe,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,UAAU;IAC1D,IAAI,cAAc;QACd,IAAI;YACA,OAAO;gBACH,MAAM,KAAK,IAAI;gBACf,aAAa,IAAI,CAAC,cAAc,IAAI,YAAY,CAAC,cAAc;gBAC/D,MAAM,QAAQ,qBACV,KAAK,IAAI,KAAK,+BACd,aAAa,IAAI,KAAK,8BACpB,8BACA;gBACN,KAAK,KAAK,GAAG;gBACb,QAAQ,CAAC,GAAG,YAAY,WAAW,EAAE,MAAM,KAAK,MAAM,EAAE,aAAa,MAAM,EAAE;gBAC7E,YAAY,CAAC,GAAG,gBAAgB,eAAe,EAAE,KAAK,UAAU,EAAE,aAAa,UAAU,EAAE,QAAQ;YACvG;QACJ,EACA,OAAO,GAAG;YACN,MAAM,IAAI,MAAM,CAAC,oCAAoC,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,OAAO,EAAE;QAC3F;IACJ;IACA,OAAO,QAAQ,oBACT;QACE,GAAG,IAAI;QACP,MAAM,UAAU,IAAI,CAAC,4BAA4B;IACrD,IACE;AACV","ignoreList":[0]}},
    {"offset": {"line": 1125, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeNamedTypeArray = mergeNamedTypeArray;\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction alreadyExists(arr, other) {\n    return !!arr.find(i => i.name.value === other.name.value);\n}\nfunction mergeNamedTypeArray(first = [], second = [], config = {}) {\n    const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n    if (config && config.sort) {\n        result.sort(utils_1.compareNodes);\n    }\n    return result;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,mBAAmB,GAAG;AAC9B,MAAM;AACN,SAAS,cAAc,GAAG,EAAE,KAAK;IAC7B,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,CAAC,KAAK,KAAK,MAAM,IAAI,CAAC,KAAK;AAC5D;AACA,SAAS,oBAAoB,QAAQ,EAAE,EAAE,SAAS,EAAE,EAAE,SAAS,CAAC,CAAC;IAC7D,MAAM,SAAS;WAAI;WAAW,MAAM,MAAM,CAAC,CAAA,IAAK,CAAC,cAAc,QAAQ;KAAI;IAC3E,IAAI,UAAU,OAAO,IAAI,EAAE;QACvB,OAAO,IAAI,CAAC,QAAQ,YAAY;IACpC;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1147, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/interface.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeInterface = mergeInterface;\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nconst fields_js_1 = require(\"./fields.js\");\nconst merge_named_type_array_js_1 = require(\"./merge-named-type-array.js\");\nfunction mergeInterface(node, existingNode, config, directives) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: config?.convertExtensions ||\n                    node.kind === 'InterfaceTypeDefinition' ||\n                    existingNode.kind === 'InterfaceTypeDefinition'\n                    ? 'InterfaceTypeDefinition'\n                    : 'InterfaceTypeExtension',\n                loc: node.loc,\n                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config, directives),\n                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),\n                interfaces: node['interfaces']\n                    ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node['interfaces'], existingNode['interfaces'], config)\n                    : undefined,\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n        }\n        : node;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,cAAc,GAAG;AACzB,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,eAAe,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,UAAU;IAC1D,IAAI,cAAc;QACd,IAAI;YACA,OAAO;gBACH,MAAM,KAAK,IAAI;gBACf,aAAa,IAAI,CAAC,cAAc,IAAI,YAAY,CAAC,cAAc;gBAC/D,MAAM,QAAQ,qBACV,KAAK,IAAI,KAAK,6BACd,aAAa,IAAI,KAAK,4BACpB,4BACA;gBACN,KAAK,KAAK,GAAG;gBACb,QAAQ,CAAC,GAAG,YAAY,WAAW,EAAE,MAAM,KAAK,MAAM,EAAE,aAAa,MAAM,EAAE,QAAQ;gBACrF,YAAY,CAAC,GAAG,gBAAgB,eAAe,EAAE,KAAK,UAAU,EAAE,aAAa,UAAU,EAAE,QAAQ;gBACnG,YAAY,IAAI,CAAC,aAAa,GACxB,CAAC,GAAG,4BAA4B,mBAAmB,EAAE,IAAI,CAAC,aAAa,EAAE,YAAY,CAAC,aAAa,EAAE,UACrG;YACV;QACJ,EACA,OAAO,GAAG;YACN,MAAM,IAAI,MAAM,CAAC,mCAAmC,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,OAAO,EAAE;QAC1F;IACJ;IACA,OAAO,QAAQ,oBACT;QACE,GAAG,IAAI;QACP,MAAM,UAAU,IAAI,CAAC,yBAAyB;IAClD,IACE;AACV","ignoreList":[0]}},
    {"offset": {"line": 1180, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/scalar.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeScalar = mergeScalar;\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nfunction mergeScalar(node, existingNode, config, directives) {\n    if (existingNode) {\n        return {\n            name: node.name,\n            description: node['description'] || existingNode['description'],\n            kind: config?.convertExtensions ||\n                node.kind === 'ScalarTypeDefinition' ||\n                existingNode.kind === 'ScalarTypeDefinition'\n                ? 'ScalarTypeDefinition'\n                : 'ScalarTypeExtension',\n            loc: node.loc,\n            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),\n        };\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,\n        }\n        : node;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,WAAW,GAAG;AACtB,MAAM;AACN,MAAM;AACN,SAAS,YAAY,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,UAAU;IACvD,IAAI,cAAc;QACd,OAAO;YACH,MAAM,KAAK,IAAI;YACf,aAAa,IAAI,CAAC,cAAc,IAAI,YAAY,CAAC,cAAc;YAC/D,MAAM,QAAQ,qBACV,KAAK,IAAI,KAAK,0BACd,aAAa,IAAI,KAAK,yBACpB,yBACA;YACN,KAAK,KAAK,GAAG;YACb,YAAY,CAAC,GAAG,gBAAgB,eAAe,EAAE,KAAK,UAAU,EAAE,aAAa,UAAU,EAAE,QAAQ;QACvG;IACJ;IACA,OAAO,QAAQ,oBACT;QACE,GAAG,IAAI;QACP,MAAM,UAAU,IAAI,CAAC,sBAAsB;IAC/C,IACE;AACV","ignoreList":[0]}},
    {"offset": {"line": 1205, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;\nexports.mergeSchemaDefs = mergeSchemaDefs;\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nexports.DEFAULT_OPERATION_TYPE_NAME_MAP = {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription',\n};\nfunction mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {\n    const finalOpNodeList = [];\n    for (const opNodeType in exports.DEFAULT_OPERATION_TYPE_NAME_MAP) {\n        const opNode = opNodeList.find(n => n.operation === opNodeType) ||\n            existingOpNodeList.find(n => n.operation === opNodeType);\n        if (opNode) {\n            finalOpNodeList.push(opNode);\n        }\n    }\n    return finalOpNodeList;\n}\nfunction mergeSchemaDefs(node, existingNode, config, directives) {\n    if (existingNode) {\n        return {\n            kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION\n                ? graphql_1.Kind.SCHEMA_DEFINITION\n                : graphql_1.Kind.SCHEMA_EXTENSION,\n            description: node['description'] || existingNode['description'],\n            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),\n            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes),\n        };\n    }\n    return (config?.convertExtensions\n        ? {\n            ...node,\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n        }\n        : node);\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,+BAA+B,GAAG,KAAK;AAC/C,QAAQ,eAAe,GAAG;AAC1B,MAAM;AACN,MAAM;AACN,QAAQ,+BAA+B,GAAG;IACtC,OAAO;IACP,UAAU;IACV,cAAc;AAClB;AACA,SAAS,oBAAoB,aAAa,EAAE,EAAE,qBAAqB,EAAE;IACjE,MAAM,kBAAkB,EAAE;IAC1B,IAAK,MAAM,cAAc,QAAQ,+BAA+B,CAAE;QAC9D,MAAM,SAAS,WAAW,IAAI,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK,eAChD,mBAAmB,IAAI,CAAC,CAAA,IAAK,EAAE,SAAS,KAAK;QACjD,IAAI,QAAQ;YACR,gBAAgB,IAAI,CAAC;QACzB;IACJ;IACA,OAAO;AACX;AACA,SAAS,gBAAgB,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,UAAU;IAC3D,IAAI,cAAc;QACd,OAAO;YACH,MAAM,KAAK,IAAI,KAAK,UAAU,IAAI,CAAC,iBAAiB,IAAI,aAAa,IAAI,KAAK,UAAU,IAAI,CAAC,iBAAiB,GACxG,UAAU,IAAI,CAAC,iBAAiB,GAChC,UAAU,IAAI,CAAC,gBAAgB;YACrC,aAAa,IAAI,CAAC,cAAc,IAAI,YAAY,CAAC,cAAc;YAC/D,YAAY,CAAC,GAAG,gBAAgB,eAAe,EAAE,KAAK,UAAU,EAAE,aAAa,UAAU,EAAE,QAAQ;YACnG,gBAAgB,oBAAoB,KAAK,cAAc,EAAE,aAAa,cAAc;QACxF;IACJ;IACA,OAAQ,QAAQ,oBACV;QACE,GAAG,IAAI;QACP,MAAM,UAAU,IAAI,CAAC,iBAAiB;IAC1C,IACE;AACV","ignoreList":[0]}},
    {"offset": {"line": 1245, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/type.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeType = mergeType;\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nconst fields_js_1 = require(\"./fields.js\");\nconst merge_named_type_array_js_1 = require(\"./merge-named-type-array.js\");\nfunction mergeType(node, existingNode, config, directives) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: config?.convertExtensions ||\n                    node.kind === 'ObjectTypeDefinition' ||\n                    existingNode.kind === 'ObjectTypeDefinition'\n                    ? 'ObjectTypeDefinition'\n                    : 'ObjectTypeExtension',\n                loc: node.loc,\n                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config, directives),\n                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),\n                interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config?.convertExtensions\n        ? {\n            ...node,\n            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n        }\n        : node;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,SAAS,GAAG;AACpB,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,UAAU,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,UAAU;IACrD,IAAI,cAAc;QACd,IAAI;YACA,OAAO;gBACH,MAAM,KAAK,IAAI;gBACf,aAAa,IAAI,CAAC,cAAc,IAAI,YAAY,CAAC,cAAc;gBAC/D,MAAM,QAAQ,qBACV,KAAK,IAAI,KAAK,0BACd,aAAa,IAAI,KAAK,yBACpB,yBACA;gBACN,KAAK,KAAK,GAAG;gBACb,QAAQ,CAAC,GAAG,YAAY,WAAW,EAAE,MAAM,KAAK,MAAM,EAAE,aAAa,MAAM,EAAE,QAAQ;gBACrF,YAAY,CAAC,GAAG,gBAAgB,eAAe,EAAE,KAAK,UAAU,EAAE,aAAa,UAAU,EAAE,QAAQ;gBACnG,YAAY,CAAC,GAAG,4BAA4B,mBAAmB,EAAE,KAAK,UAAU,EAAE,aAAa,UAAU,EAAE;YAC/G;QACJ,EACA,OAAO,GAAG;YACN,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,OAAO,EAAE;QACrF;IACJ;IACA,OAAO,QAAQ,oBACT;QACE,GAAG,IAAI;QACP,MAAM,UAAU,IAAI,CAAC,sBAAsB;IAC/C,IACE;AACV","ignoreList":[0]}},
    {"offset": {"line": 1278, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/union.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeUnion = mergeUnion;\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nconst merge_named_type_array_js_1 = require(\"./merge-named-type-array.js\");\nfunction mergeUnion(first, second, config, directives) {\n    if (second) {\n        return {\n            name: first.name,\n            description: first['description'] || second['description'],\n            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n            directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config, directives),\n            kind: config?.convertExtensions ||\n                first.kind === 'UnionTypeDefinition' ||\n                second.kind === 'UnionTypeDefinition'\n                ? graphql_1.Kind.UNION_TYPE_DEFINITION\n                : graphql_1.Kind.UNION_TYPE_EXTENSION,\n            loc: first.loc,\n            types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config),\n        };\n    }\n    return config?.convertExtensions\n        ? {\n            ...first,\n            kind: graphql_1.Kind.UNION_TYPE_DEFINITION,\n        }\n        : first;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,UAAU,GAAG;AACrB,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,WAAW,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU;IACjD,IAAI,QAAQ;QACR,OAAO;YACH,MAAM,MAAM,IAAI;YAChB,aAAa,KAAK,CAAC,cAAc,IAAI,MAAM,CAAC,cAAc;YAC1D,0HAA0H;YAC1H,YAAY,CAAC,GAAG,gBAAgB,eAAe,EAAE,MAAM,UAAU,EAAE,OAAO,UAAU,EAAE,QAAQ;YAC9F,MAAM,QAAQ,qBACV,MAAM,IAAI,KAAK,yBACf,OAAO,IAAI,KAAK,wBACd,UAAU,IAAI,CAAC,qBAAqB,GACpC,UAAU,IAAI,CAAC,oBAAoB;YACzC,KAAK,MAAM,GAAG;YACd,OAAO,CAAC,GAAG,4BAA4B,mBAAmB,EAAE,MAAM,KAAK,EAAE,OAAO,KAAK,EAAE;QAC3F;IACJ;IACA,OAAO,QAAQ,oBACT;QACE,GAAG,KAAK;QACR,MAAM,UAAU,IAAI,CAAC,qBAAqB;IAC9C,IACE;AACV","ignoreList":[0]}},
    {"offset": {"line": 1306, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.schemaDefSymbol = void 0;\nexports.isNamedDefinitionNode = isNamedDefinitionNode;\nexports.mergeGraphQLNodes = mergeGraphQLNodes;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst directives_js_1 = require(\"./directives.js\");\nconst enum_js_1 = require(\"./enum.js\");\nconst input_type_js_1 = require(\"./input-type.js\");\nconst interface_js_1 = require(\"./interface.js\");\nconst scalar_js_1 = require(\"./scalar.js\");\nconst schema_def_js_1 = require(\"./schema-def.js\");\nconst type_js_1 = require(\"./type.js\");\nconst union_js_1 = require(\"./union.js\");\nexports.schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';\nfunction isNamedDefinitionNode(definitionNode) {\n    return 'name' in definitionNode;\n}\nfunction mergeGraphQLNodes(nodes, config, directives = {}) {\n    const mergedResultMap = directives;\n    for (const nodeDefinition of nodes) {\n        if (isNamedDefinitionNode(nodeDefinition)) {\n            const name = nodeDefinition.name?.value;\n            if (config?.commentDescriptions) {\n                (0, utils_1.collectComment)(nodeDefinition);\n            }\n            if (name == null) {\n                continue;\n            }\n            if (config?.exclusions?.includes(name + '.*') || config?.exclusions?.includes(name)) {\n                delete mergedResultMap[name];\n            }\n            else {\n                switch (nodeDefinition.kind) {\n                    case graphql_1.Kind.OBJECT_TYPE_DEFINITION:\n                    case graphql_1.Kind.OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case graphql_1.Kind.ENUM_TYPE_DEFINITION:\n                    case graphql_1.Kind.ENUM_TYPE_EXTENSION:\n                        mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case graphql_1.Kind.UNION_TYPE_DEFINITION:\n                    case graphql_1.Kind.UNION_TYPE_EXTENSION:\n                        mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case graphql_1.Kind.SCALAR_TYPE_DEFINITION:\n                    case graphql_1.Kind.SCALAR_TYPE_EXTENSION:\n                        mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n                    case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n                        mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:\n                    case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:\n                        mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config, directives);\n                        break;\n                    case graphql_1.Kind.DIRECTIVE_DEFINITION:\n                        if (mergedResultMap[name]) {\n                            const isInheritedFromPrototype = name in {}; // i.e. toString\n                            if (isInheritedFromPrototype) {\n                                if (!isASTNode(mergedResultMap[name])) {\n                                    mergedResultMap[name] = undefined;\n                                }\n                            }\n                        }\n                        mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);\n                        break;\n                }\n            }\n        }\n        else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION ||\n            nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n            mergedResultMap[exports.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports.schemaDefSymbol], config);\n        }\n    }\n    return mergedResultMap;\n}\nfunction isASTNode(node) {\n    return (node != null && typeof node === 'object' && 'kind' in node && typeof node.kind === 'string');\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1391, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/links.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveImportName = resolveImportName;\nexports.extractLinks = extractLinks;\n/**\n * A simplified, GraphQL v15 compatible version of\n * https://github.com/graphql-hive/federation-composition/blob/main/src/utils/link/index.ts\n * that does not provide the same safeguards or functionality, but still can determine the\n * correct name of an linked resource.\n */\nconst graphql_1 = require(\"graphql\");\nfunction namespace(link) {\n    return link.as ?? link.url.name;\n}\nfunction defaultImport(link) {\n    const name = namespace(link);\n    return name && `@${name}`;\n}\nfunction resolveImportName(link, elementName) {\n    if (link.url.name && elementName === `@${link.url.name}`) {\n        // @note: default is a directive... So remove the `@`\n        return defaultImport(link).substring(1);\n    }\n    const imported = link.imports.find(i => i.name === elementName);\n    const resolvedName = imported?.as ?? imported?.name ?? namespaced(namespace(link), elementName);\n    // Strip the `@` prefix for directives because in all implementations of mapping or visiting a schema,\n    // directive names are not prefixed with `@`. The `@` is only for SDL.\n    return resolvedName.startsWith('@') ? resolvedName.substring(1) : resolvedName;\n}\nfunction namespaced(namespace, name) {\n    if (namespace?.length) {\n        if (name.startsWith('@')) {\n            return `@${namespace}__${name.substring(1)}`;\n        }\n        return `${namespace}__${name}`;\n    }\n    return name;\n}\nfunction extractLinks(typeDefs) {\n    let links = [];\n    for (const definition of typeDefs.definitions) {\n        if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION || definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n            const defLinks = definition.directives?.filter(directive => directive.name.value === 'link');\n            const parsedLinks = defLinks?.map(l => linkFromArgs(l.arguments ?? [])).filter(l => l !== undefined) ?? [];\n            links = links.concat(parsedLinks);\n            // Federation 1 support... Federation 1 uses \"@core\" instead of \"@link\", but behavior is similar enough that\n            //  it can be translated.\n            const defCores = definition.directives?.filter(({ name }) => name.value === 'core');\n            const coreLinks = defCores\n                ?.map(c => linkFromCoreArgs(c.arguments ?? []))\n                .filter(l => l !== undefined);\n            if (coreLinks) {\n                links = links.concat(...coreLinks);\n            }\n        }\n    }\n    return links;\n}\nfunction linkFromArgs(args) {\n    let url;\n    let imports = [];\n    let as;\n    for (const arg of args) {\n        switch (arg.name.value) {\n            case 'url': {\n                if (arg.value.kind === graphql_1.Kind.STRING) {\n                    url = parseFederationLinkUrl(arg.value.value);\n                }\n                break;\n            }\n            case 'import': {\n                imports = parseImportNode(arg.value);\n                break;\n            }\n            case 'as': {\n                if (arg.value.kind === graphql_1.Kind.STRING) {\n                    as = arg.value.value ?? undefined;\n                }\n                break;\n            }\n            default: {\n                // ignore. It's not the job of this package to validate. Federation should validate links.\n            }\n        }\n    }\n    if (url !== undefined) {\n        return {\n            url,\n            as,\n            imports,\n        };\n    }\n}\n/**\n * Supports federation 1\n */\nfunction linkFromCoreArgs(args) {\n    const feature = args.find(({ name, value }) => name.value === 'feature' && value.kind === graphql_1.Kind.STRING);\n    if (feature) {\n        const url = parseFederationLinkUrl(feature.value.value);\n        return {\n            url,\n            imports: [],\n        };\n    }\n}\nfunction parseImportNode(node) {\n    if (node.kind === graphql_1.Kind.LIST) {\n        const imports = node.values.map((v) => {\n            let namedImport;\n            if (v.kind === graphql_1.Kind.STRING) {\n                namedImport = { name: v.value };\n            }\n            else if (v.kind === graphql_1.Kind.OBJECT) {\n                let name = '';\n                let as;\n                for (const f of v.fields) {\n                    if (f.name.value === 'name') {\n                        if (f.value.kind === graphql_1.Kind.STRING) {\n                            name = f.value.value;\n                        }\n                    }\n                    else if (f.name.value === 'as') {\n                        if (f.value.kind === graphql_1.Kind.STRING) {\n                            as = f.value.value;\n                        }\n                    }\n                }\n                namedImport = { name, as };\n            }\n            return namedImport;\n        });\n        return imports.filter(i => i !== undefined);\n    }\n    return [];\n}\nconst VERSION_MATCH = /v(\\d{1,3})\\.(\\d{1,4})/i;\nfunction parseFederationLinkUrl(urlSource) {\n    const url = new URL(urlSource);\n    const parts = url.pathname.split('/').filter(Boolean);\n    const versionOrName = parts[parts.length - 1];\n    if (versionOrName) {\n        if (VERSION_MATCH.test(versionOrName)) {\n            const maybeName = parts[parts.length - 2];\n            return {\n                identity: url.origin + (maybeName ? `/${parts.slice(0, parts.length - 1).join('/')}` : ''),\n                name: maybeName ?? null,\n                version: versionOrName,\n            };\n        }\n        return {\n            identity: `${url.origin}/${parts.join('/')}`,\n            name: versionOrName,\n            version: null,\n        };\n    }\n    return {\n        identity: url.origin,\n        name: null,\n        version: null,\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1561, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeTypeDefs = mergeTypeDefs;\nexports.mergeGraphQLTypes = mergeGraphQLTypes;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst links_js_1 = require(\"../links.js\");\nconst merge_nodes_js_1 = require(\"./merge-nodes.js\");\nconst schema_def_js_1 = require(\"./schema-def.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction mergeTypeDefs(typeSource, config) {\n    (0, utils_1.resetComments)();\n    const doc = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(typeSource, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config?.commentDescriptions) {\n        result = (0, utils_1.printWithComments)(doc);\n    }\n    else {\n        result = doc;\n    }\n    (0, utils_1.resetComments)();\n    return result;\n}\nfunction visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = new Set(), repeatableLinkImports = new Set()) {\n    const addRepeatable = (name) => {\n        repeatableLinkImports.add(name);\n    };\n    if (typeSource && !visitedTypeSources.has(typeSource)) {\n        visitedTypeSources.add(typeSource);\n        if (typeof typeSource === 'function') {\n            visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);\n        }\n        else if (Array.isArray(typeSource)) {\n            for (const type of typeSource) {\n                visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);\n            }\n        }\n        else if ((0, graphql_1.isSchema)(typeSource)) {\n            const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);\n        }\n        else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {\n            const documentNode = (0, graphql_1.parse)(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);\n        }\n        else if (typeof typeSource === 'object' && (0, graphql_1.isDefinitionNode)(typeSource)) {\n            const links = (0, links_js_1.extractLinks)({\n                definitions: [typeSource],\n                kind: graphql_1.Kind.DOCUMENT,\n            });\n            const federationUrl = 'https://specs.apollo.dev/federation';\n            const linkUrl = 'https://specs.apollo.dev/link';\n            /**\n             * Official Federated imports are special because they can be referenced without specifyin the import.\n             * To handle this case, we must prepare a list of all the possible valid usages to check against.\n             * Note that this versioning is not technically correct, since some definitions are after v2.0.\n             * But this is enough information to be comfortable not blocking the imports at this phase. It's\n             * the job of the composer to validate the versions.\n             * */\n            const federationLink = links.find(l => l.url.identity === federationUrl);\n            if (federationLink) {\n                addRepeatable((0, links_js_1.resolveImportName)(federationLink, '@composeDirective'));\n                addRepeatable((0, links_js_1.resolveImportName)(federationLink, '@key'));\n            }\n            const linkLink = links.find(l => l.url.identity === linkUrl);\n            if (linkLink) {\n                addRepeatable((0, links_js_1.resolveImportName)(linkLink, '@link'));\n            }\n            if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n                allDirectives.push(typeSource);\n            }\n            else {\n                allNodes.push(typeSource);\n            }\n        }\n        else if ((0, utils_1.isDocumentNode)(typeSource)) {\n            visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);\n        }\n        else {\n            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n        }\n    }\n    return { allDirectives, allNodes, repeatableLinkImports };\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n    (0, utils_1.resetComments)();\n    const { allDirectives, allNodes, repeatableLinkImports } = visitTypeSources(typeSource, config);\n    const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config);\n    config.repeatableLinkImports = repeatableLinkImports;\n    const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config, mergedDirectives);\n    if (config?.useSchemaDefinition) {\n        // XXX: right now we don't handle multiple schema definitions\n        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            operationTypes: [],\n        };\n        const operationTypes = schemaDef.operationTypes;\n        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {\n            const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n            if (!opTypeDefNode) {\n                const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n                const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n                    operationTypes.push({\n                        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n                        type: {\n                            kind: graphql_1.Kind.NAMED_TYPE,\n                            name: existingPossibleRootType.name,\n                        },\n                        operation: opTypeDefNodeType,\n                    });\n                }\n            }\n        }\n        if (schemaDef?.operationTypes?.length != null && schemaDef.operationTypes.length > 0) {\n            mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;\n        }\n    }\n    if (config?.forceSchemaDefinition && !mergedNodes[merge_nodes_js_1.schemaDefSymbol]?.operationTypes?.length) {\n        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            operationTypes: [\n                {\n                    kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n                    operation: 'query',\n                    type: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: 'Query',\n                        },\n                    },\n                },\n            ],\n        };\n    }\n    const mergedNodeDefinitions = Object.values(mergedNodes);\n    if (config?.sort) {\n        const sortFn = typeof config.sort === 'function' ? config.sort : utils_js_1.defaultStringComparator;\n        mergedNodeDefinitions.sort((a, b) => sortFn(a.name?.value, b.name?.value));\n    }\n    return mergedNodeDefinitions;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1715, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/typedefs-mergers/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./arguments.js\"), exports);\ntslib_1.__exportStar(require(\"./directives.js\"), exports);\ntslib_1.__exportStar(require(\"./enum-values.js\"), exports);\ntslib_1.__exportStar(require(\"./enum.js\"), exports);\ntslib_1.__exportStar(require(\"./fields.js\"), exports);\ntslib_1.__exportStar(require(\"./input-type.js\"), exports);\ntslib_1.__exportStar(require(\"./interface.js\"), exports);\ntslib_1.__exportStar(require(\"./merge-named-type-array.js\"), exports);\ntslib_1.__exportStar(require(\"./merge-nodes.js\"), exports);\ntslib_1.__exportStar(require(\"./merge-typedefs.js\"), exports);\ntslib_1.__exportStar(require(\"./scalar.js\"), exports);\ntslib_1.__exportStar(require(\"./type.js\"), exports);\ntslib_1.__exportStar(require(\"./union.js\"), exports);\ntslib_1.__exportStar(require(\"./utils.js\"), exports);\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,QAAQ,YAAY,oIAA4B;AAChD,QAAQ,YAAY,qIAA6B;AACjD,QAAQ,YAAY,sIAA8B;AAClD,QAAQ,YAAY,+HAAuB;AAC3C,QAAQ,YAAY,iIAAyB;AAC7C,QAAQ,YAAY,qIAA6B;AACjD,QAAQ,YAAY,oIAA4B;AAChD,QAAQ,YAAY,iJAAyC;AAC7D,QAAQ,YAAY,sIAA8B;AAClD,QAAQ,YAAY,yIAAiC;AACrD,QAAQ,YAAY,iIAAyB;AAC7C,QAAQ,YAAY,+HAAuB;AAC3C,QAAQ,YAAY,gIAAwB;AAC5C,QAAQ,YAAY,gIAAwB","ignoreList":[0]}},
    {"offset": {"line": 1737, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/extensions.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractExtensionsFromSchema = void 0;\nexports.mergeExtensions = mergeExtensions;\nexports.applyExtensions = applyExtensions;\nconst utils_1 = require(\"@graphql-tools/utils\");\nvar utils_2 = require(\"@graphql-tools/utils\");\nObject.defineProperty(exports, \"extractExtensionsFromSchema\", { enumerable: true, get: function () { return utils_2.extractExtensionsFromSchema; } });\nfunction mergeExtensions(extensions) {\n    return (0, utils_1.mergeDeep)(extensions, false, true);\n}\nfunction applyExtensionObject(obj, extensions) {\n    if (!obj || !extensions || extensions === obj.extensions) {\n        return;\n    }\n    if (!obj.extensions) {\n        obj.extensions = extensions;\n        return;\n    }\n    obj.extensions = (0, utils_1.mergeDeep)([obj.extensions, extensions], false, true);\n}\nfunction applyExtensions(schema, extensions) {\n    applyExtensionObject(schema, extensions.schemaExtensions);\n    for (const [typeName, data] of Object.entries(extensions.types || {})) {\n        const type = schema.getType(typeName);\n        if (type) {\n            applyExtensionObject(type, data.extensions);\n            if (data.type === 'object' || data.type === 'interface') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    if (field) {\n                        applyExtensionObject(field, fieldData.extensions);\n                        for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n                            applyExtensionObject(field.args.find(a => a.name === arg), argData);\n                        }\n                    }\n                }\n            }\n            else if (data.type === 'input') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    applyExtensionObject(field, fieldData.extensions);\n                }\n            }\n            else if (data.type === 'enum') {\n                for (const [valueName, valueData] of Object.entries(data.values)) {\n                    const value = type.getValue(valueName);\n                    applyExtensionObject(value, valueData);\n                }\n            }\n        }\n    }\n    return schema;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,2BAA2B,GAAG,KAAK;AAC3C,QAAQ,eAAe,GAAG;AAC1B,QAAQ,eAAe,GAAG;AAC1B,MAAM;AACN,IAAI;AACJ,OAAO,cAAc,CAAC,SAAS,+BAA+B;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,QAAQ,2BAA2B;IAAE;AAAE;AACnJ,SAAS,gBAAgB,UAAU;IAC/B,OAAO,CAAC,GAAG,QAAQ,SAAS,EAAE,YAAY,OAAO;AACrD;AACA,SAAS,qBAAqB,GAAG,EAAE,UAAU;IACzC,IAAI,CAAC,OAAO,CAAC,cAAc,eAAe,IAAI,UAAU,EAAE;QACtD;IACJ;IACA,IAAI,CAAC,IAAI,UAAU,EAAE;QACjB,IAAI,UAAU,GAAG;QACjB;IACJ;IACA,IAAI,UAAU,GAAG,CAAC,GAAG,QAAQ,SAAS,EAAE;QAAC,IAAI,UAAU;QAAE;KAAW,EAAE,OAAO;AACjF;AACA,SAAS,gBAAgB,MAAM,EAAE,UAAU;IACvC,qBAAqB,QAAQ,WAAW,gBAAgB;IACxD,KAAK,MAAM,CAAC,UAAU,KAAK,IAAI,OAAO,OAAO,CAAC,WAAW,KAAK,IAAI,CAAC,GAAI;QACnE,MAAM,OAAO,OAAO,OAAO,CAAC;QAC5B,IAAI,MAAM;YACN,qBAAqB,MAAM,KAAK,UAAU;YAC1C,IAAI,KAAK,IAAI,KAAK,YAAY,KAAK,IAAI,KAAK,aAAa;gBACrD,KAAK,MAAM,CAAC,WAAW,UAAU,IAAI,OAAO,OAAO,CAAC,KAAK,MAAM,EAAG;oBAC9D,MAAM,QAAQ,KAAK,SAAS,EAAE,CAAC,UAAU;oBACzC,IAAI,OAAO;wBACP,qBAAqB,OAAO,UAAU,UAAU;wBAChD,KAAK,MAAM,CAAC,KAAK,QAAQ,IAAI,OAAO,OAAO,CAAC,UAAU,SAAS,EAAG;4BAC9D,qBAAqB,MAAM,IAAI,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,MAAM;wBAC/D;oBACJ;gBACJ;YACJ,OACK,IAAI,KAAK,IAAI,KAAK,SAAS;gBAC5B,KAAK,MAAM,CAAC,WAAW,UAAU,IAAI,OAAO,OAAO,CAAC,KAAK,MAAM,EAAG;oBAC9D,MAAM,QAAQ,KAAK,SAAS,EAAE,CAAC,UAAU;oBACzC,qBAAqB,OAAO,UAAU,UAAU;gBACpD;YACJ,OACK,IAAI,KAAK,IAAI,KAAK,QAAQ;gBAC3B,KAAK,MAAM,CAAC,WAAW,UAAU,IAAI,OAAO,OAAO,CAAC,KAAK,MAAM,EAAG;oBAC9D,MAAM,QAAQ,KAAK,QAAQ,CAAC;oBAC5B,qBAAqB,OAAO;gBAChC;YACJ;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1802, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/merge/cjs/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./merge-resolvers.js\"), exports);\ntslib_1.__exportStar(require(\"./typedefs-mergers/index.js\"), exports);\ntslib_1.__exportStar(require(\"./extensions.js\"), exports);\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,QAAQ,YAAY,yHAAkC;AACtD,QAAQ,YAAY,gIAAyC;AAC7D,QAAQ,YAAY,oHAA6B","ignoreList":[0]}},
    {"offset": {"line": 1813, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/coerceError.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.coerceError = coerceError;\nfunction coerceError(error) {\n    if (error instanceof Error) {\n        return error;\n    }\n    if (typeof error === 'object' && error != null) {\n        if ('message' in error && typeof error.message === 'string') {\n            let errorOptions;\n            if ('cause' in error) {\n                errorOptions = { cause: error.cause };\n            }\n            const coercedError = new Error(error.message, errorOptions);\n            if ('stack' in error && typeof error.stack === 'string') {\n                coercedError.stack = error.stack;\n            }\n            if ('name' in error && typeof error.name === 'string') {\n                coercedError.name = error.name;\n            }\n            return coercedError;\n        }\n    }\n    return new Error(String(error));\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,WAAW,GAAG;AACtB,SAAS,YAAY,KAAK;IACtB,IAAI,iBAAiB,OAAO;QACxB,OAAO;IACX;IACA,IAAI,OAAO,UAAU,YAAY,SAAS,MAAM;QAC5C,IAAI,aAAa,SAAS,OAAO,MAAM,OAAO,KAAK,UAAU;YACzD,IAAI;YACJ,IAAI,WAAW,OAAO;gBAClB,eAAe;oBAAE,OAAO,MAAM,KAAK;gBAAC;YACxC;YACA,MAAM,eAAe,IAAI,MAAM,MAAM,OAAO,EAAE;YAC9C,IAAI,WAAW,SAAS,OAAO,MAAM,KAAK,KAAK,UAAU;gBACrD,aAAa,KAAK,GAAG,MAAM,KAAK;YACpC;YACA,IAAI,UAAU,SAAS,OAAO,MAAM,IAAI,KAAK,UAAU;gBACnD,aAAa,IAAI,GAAG,MAAM,IAAI;YAClC;YACA,OAAO;QACX;IACJ;IACA,OAAO,IAAI,MAAM,OAAO;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 1845, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/flattenAsyncIterable.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.flattenAsyncIterable = flattenAsyncIterable;\nconst disposablestack_1 = require(\"@whatwg-node/disposablestack\");\n/**\n * Given an AsyncIterable of AsyncIterables, flatten all yielded results into a\n * single AsyncIterable.\n */\nfunction flattenAsyncIterable(iterable) {\n    // You might think this whole function could be replaced with\n    //\n    //    async function* flattenAsyncIterable(iterable) {\n    //      for await (const subIterator of iterable) {\n    //        yield* subIterator;\n    //      }\n    //    }\n    //\n    // but calling `.return()` on the iterator it returns won't interrupt the `for await`.\n    const topIterator = iterable[Symbol.asyncIterator]();\n    let currentNestedIterator;\n    let waitForCurrentNestedIterator;\n    let done = false;\n    async function next() {\n        if (done) {\n            return { value: undefined, done: true };\n        }\n        try {\n            if (!currentNestedIterator) {\n                // Somebody else is getting it already.\n                if (waitForCurrentNestedIterator) {\n                    await waitForCurrentNestedIterator;\n                    return await next();\n                }\n                // Nobody else is getting it. We should!\n                let resolve;\n                waitForCurrentNestedIterator = new Promise(r => {\n                    resolve = r;\n                });\n                const topIteratorResult = await topIterator.next();\n                if (topIteratorResult.done) {\n                    // Given that done only ever transitions from false to true,\n                    // require-atomic-updates is being unnecessarily cautious.\n                    done = true;\n                    return await next();\n                }\n                // eslint is making a reasonable point here, but we've explicitly protected\n                // ourself from the race condition by ensuring that only the single call\n                // that assigns to waitForCurrentNestedIterator is allowed to assign to\n                // currentNestedIterator or waitForCurrentNestedIterator.\n                currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();\n                waitForCurrentNestedIterator = undefined;\n                resolve();\n                return await next();\n            }\n            const rememberCurrentNestedIterator = currentNestedIterator;\n            const nestedIteratorResult = await currentNestedIterator.next();\n            if (!nestedIteratorResult.done) {\n                return nestedIteratorResult;\n            }\n            // The nested iterator is done. If it's still the current one, make it not\n            // current. (If it's not the current one, somebody else has made us move on.)\n            if (currentNestedIterator === rememberCurrentNestedIterator) {\n                currentNestedIterator = undefined;\n            }\n            return await next();\n        }\n        catch (err) {\n            done = true;\n            throw err;\n        }\n    }\n    return {\n        next,\n        async return() {\n            done = true;\n            await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);\n            return { value: undefined, done: true };\n        },\n        async throw(error) {\n            done = true;\n            await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);\n            /* c8 ignore next */\n            throw error;\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        async [disposablestack_1.DisposableSymbols.asyncDispose]() {\n            done = true;\n            await Promise.all([\n                currentNestedIterator?.[disposablestack_1.DisposableSymbols.asyncDispose]?.(),\n                topIterator?.[disposablestack_1.DisposableSymbols.asyncDispose]?.(),\n            ]);\n        },\n    };\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,oBAAoB,GAAG;AAC/B,MAAM;AACN;;;CAGC,GACD,SAAS,qBAAqB,QAAQ;IAClC,6DAA6D;IAC7D,EAAE;IACF,sDAAsD;IACtD,mDAAmD;IACnD,6BAA6B;IAC7B,SAAS;IACT,OAAO;IACP,EAAE;IACF,sFAAsF;IACtF,MAAM,cAAc,QAAQ,CAAC,OAAO,aAAa,CAAC;IAClD,IAAI;IACJ,IAAI;IACJ,IAAI,OAAO;IACX,eAAe;QACX,IAAI,MAAM;YACN,OAAO;gBAAE,OAAO;gBAAW,MAAM;YAAK;QAC1C;QACA,IAAI;YACA,IAAI,CAAC,uBAAuB;gBACxB,uCAAuC;gBACvC,IAAI,8BAA8B;oBAC9B,MAAM;oBACN,OAAO,MAAM;gBACjB;gBACA,wCAAwC;gBACxC,IAAI;gBACJ,+BAA+B,IAAI,QAAQ,CAAA;oBACvC,UAAU;gBACd;gBACA,MAAM,oBAAoB,MAAM,YAAY,IAAI;gBAChD,IAAI,kBAAkB,IAAI,EAAE;oBACxB,4DAA4D;oBAC5D,0DAA0D;oBAC1D,OAAO;oBACP,OAAO,MAAM;gBACjB;gBACA,2EAA2E;gBAC3E,wEAAwE;gBACxE,uEAAuE;gBACvE,yDAAyD;gBACzD,wBAAwB,kBAAkB,KAAK,CAAC,OAAO,aAAa,CAAC;gBACrE,+BAA+B;gBAC/B;gBACA,OAAO,MAAM;YACjB;YACA,MAAM,gCAAgC;YACtC,MAAM,uBAAuB,MAAM,sBAAsB,IAAI;YAC7D,IAAI,CAAC,qBAAqB,IAAI,EAAE;gBAC5B,OAAO;YACX;YACA,0EAA0E;YAC1E,6EAA6E;YAC7E,IAAI,0BAA0B,+BAA+B;gBACzD,wBAAwB;YAC5B;YACA,OAAO,MAAM;QACjB,EACA,OAAO,KAAK;YACR,OAAO;YACP,MAAM;QACV;IACJ;IACA,OAAO;QACH;QACA,MAAM;YACF,OAAO;YACP,MAAM,QAAQ,GAAG,CAAC;gBAAC,uBAAuB;gBAAY,YAAY,MAAM;aAAK;YAC7E,OAAO;gBAAE,OAAO;gBAAW,MAAM;YAAK;QAC1C;QACA,MAAM,OAAM,KAAK;YACb,OAAO;YACP,MAAM,QAAQ,GAAG,CAAC;gBAAC,uBAAuB,QAAQ;gBAAQ,YAAY,KAAK,GAAG;aAAO;YACrF,kBAAkB,GAClB,MAAM;QACV;QACA,CAAC,OAAO,aAAa,CAAC;YAClB,OAAO,IAAI;QACf;QACA,MAAM,CAAC,kBAAkB,iBAAiB,CAAC,YAAY,CAAC;YACpD,OAAO;YACP,MAAM,QAAQ,GAAG,CAAC;gBACd,uBAAuB,CAAC,kBAAkB,iBAAiB,CAAC,YAAY,CAAC;gBACzE,aAAa,CAAC,kBAAkB,iBAAiB,CAAC,YAAY,CAAC;aAClE;QACL;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1955, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/invariant.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.invariant = invariant;\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(message != null ? message : 'Unexpected invariant triggered.');\n    }\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,SAAS,GAAG;AACpB,SAAS,UAAU,SAAS,EAAE,OAAO;IACjC,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM,WAAW,OAAO,UAAU;IAChD;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1968, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/promiseForObject.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.promiseForObject = promiseForObject;\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\n/**\n * This function transforms a JS object `Record<string, Promise<T>>` into\n * a `Promise<Record<string, T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nfunction promiseForObject(object, signal, signalPromise) {\n    signal?.throwIfAborted();\n    const resolvedObject = Object.create(null);\n    const promises = [];\n    for (const key in object) {\n        const valueSet$ = (0, promise_helpers_1.handleMaybePromise)(() => object[key], resolvedValue => {\n            resolvedObject[key] = resolvedValue;\n        });\n        if ((0, promise_helpers_1.isPromise)(valueSet$)) {\n            promises.push(valueSet$);\n        }\n    }\n    if (!promises.length) {\n        return resolvedObject;\n    }\n    const promiseAll = promises.length === 1 ? promises[0] : Promise.all(promises);\n    if (signalPromise) {\n        return Promise.race([signalPromise, promiseAll]).then(() => resolvedObject);\n    }\n    return promiseAll.then(() => resolvedObject);\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,gBAAgB,GAAG;AAC3B,MAAM;AACN;;;;;;CAMC,GACD,SAAS,iBAAiB,MAAM,EAAE,MAAM,EAAE,aAAa;IACnD,QAAQ;IACR,MAAM,iBAAiB,OAAO,MAAM,CAAC;IACrC,MAAM,WAAW,EAAE;IACnB,IAAK,MAAM,OAAO,OAAQ;QACtB,MAAM,YAAY,CAAC,GAAG,kBAAkB,kBAAkB,EAAE,IAAM,MAAM,CAAC,IAAI,EAAE,CAAA;YAC3E,cAAc,CAAC,IAAI,GAAG;QAC1B;QACA,IAAI,CAAC,GAAG,kBAAkB,SAAS,EAAE,YAAY;YAC7C,SAAS,IAAI,CAAC;QAClB;IACJ;IACA,IAAI,CAAC,SAAS,MAAM,EAAE;QAClB,OAAO;IACX;IACA,MAAM,aAAa,SAAS,MAAM,KAAK,IAAI,QAAQ,CAAC,EAAE,GAAG,QAAQ,GAAG,CAAC;IACrE,IAAI,eAAe;QACf,OAAO,QAAQ,IAAI,CAAC;YAAC;YAAe;SAAW,EAAE,IAAI,CAAC,IAAM;IAChE;IACA,OAAO,WAAW,IAAI,CAAC,IAAM;AACjC","ignoreList":[0]}},
    {"offset": {"line": 2007, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/values.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getVariableValues = getVariableValues;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getVariableValues(schema, varDefNodes, inputs, options) {\n    const errors = [];\n    const maxErrors = options?.maxErrors;\n    try {\n        const coerced = coerceVariableValues(schema, varDefNodes, inputs, error => {\n            if (maxErrors != null && errors.length >= maxErrors) {\n                throw (0, utils_1.createGraphQLError)('Too many errors processing variables, error limit reached. Execution aborted.');\n            }\n            errors.push(error);\n        });\n        if (errors.length === 0) {\n            return { coerced };\n        }\n    }\n    catch (error) {\n        errors.push(error);\n    }\n    return { errors };\n}\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n    const coercedValues = {};\n    for (const varDefNode of varDefNodes) {\n        const varName = varDefNode.variable.name.value;\n        const varType = (0, graphql_1.typeFromAST)(schema, varDefNode.type);\n        if (!(0, graphql_1.isInputType)(varType)) {\n            // Must use input types for variables. This should be caught during\n            // validation, however is checked again here for safety.\n            const varTypeStr = (0, graphql_1.print)(varDefNode.type);\n            onError((0, utils_1.createGraphQLError)(`Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`, { nodes: varDefNode.type }));\n            continue;\n        }\n        if (!(0, utils_1.hasOwnProperty)(inputs, varName)) {\n            if (varDefNode.defaultValue) {\n                coercedValues[varName] = (0, graphql_1.valueFromAST)(varDefNode.defaultValue, varType);\n            }\n            else if ((0, graphql_1.isNonNullType)(varType)) {\n                const varTypeStr = (0, utils_1.inspect)(varType);\n                onError((0, utils_1.createGraphQLError)(`Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`, {\n                    nodes: varDefNode,\n                }));\n            }\n            continue;\n        }\n        const value = inputs[varName];\n        if (value === null && (0, graphql_1.isNonNullType)(varType)) {\n            const varTypeStr = (0, utils_1.inspect)(varType);\n            onError((0, utils_1.createGraphQLError)(`Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`, {\n                nodes: varDefNode,\n            }));\n            continue;\n        }\n        coercedValues[varName] = (0, graphql_1.coerceInputValue)(value, varType, (path, invalidValue, error) => {\n            let prefix = `Variable \"$${varName}\" got invalid value ` + (0, utils_1.inspect)(invalidValue);\n            if (path.length > 0) {\n                prefix += ` at \"${varName}${(0, utils_1.printPathArray)(path)}\"`;\n            }\n            onError((0, utils_1.createGraphQLError)(prefix + '; ' + error.message, {\n                nodes: varDefNode,\n                originalError: error,\n            }));\n        });\n    }\n    return coercedValues;\n}\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,iBAAiB,GAAG;AAC5B,MAAM;AACN,MAAM;AACN;;;;;;;;CAQC,GACD,SAAS,kBAAkB,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO;IAC3D,MAAM,SAAS,EAAE;IACjB,MAAM,YAAY,SAAS;IAC3B,IAAI;QACA,MAAM,UAAU,qBAAqB,QAAQ,aAAa,QAAQ,CAAA;YAC9D,IAAI,aAAa,QAAQ,OAAO,MAAM,IAAI,WAAW;gBACjD,MAAM,CAAC,GAAG,QAAQ,kBAAkB,EAAE;YAC1C;YACA,OAAO,IAAI,CAAC;QAChB;QACA,IAAI,OAAO,MAAM,KAAK,GAAG;YACrB,OAAO;gBAAE;YAAQ;QACrB;IACJ,EACA,OAAO,OAAO;QACV,OAAO,IAAI,CAAC;IAChB;IACA,OAAO;QAAE;IAAO;AACpB;AACA,SAAS,qBAAqB,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO;IAC9D,MAAM,gBAAgB,CAAC;IACvB,KAAK,MAAM,cAAc,YAAa;QAClC,MAAM,UAAU,WAAW,QAAQ,CAAC,IAAI,CAAC,KAAK;QAC9C,MAAM,UAAU,CAAC,GAAG,UAAU,WAAW,EAAE,QAAQ,WAAW,IAAI;QAClE,IAAI,CAAC,CAAC,GAAG,UAAU,WAAW,EAAE,UAAU;YACtC,mEAAmE;YACnE,wDAAwD;YACxD,MAAM,aAAa,CAAC,GAAG,UAAU,KAAK,EAAE,WAAW,IAAI;YACvD,QAAQ,CAAC,GAAG,QAAQ,kBAAkB,EAAE,CAAC,WAAW,EAAE,QAAQ,0BAA0B,EAAE,WAAW,wCAAwC,CAAC,EAAE;gBAAE,OAAO,WAAW,IAAI;YAAC;YACzK;QACJ;QACA,IAAI,CAAC,CAAC,GAAG,QAAQ,cAAc,EAAE,QAAQ,UAAU;YAC/C,IAAI,WAAW,YAAY,EAAE;gBACzB,aAAa,CAAC,QAAQ,GAAG,CAAC,GAAG,UAAU,YAAY,EAAE,WAAW,YAAY,EAAE;YAClF,OACK,IAAI,CAAC,GAAG,UAAU,aAAa,EAAE,UAAU;gBAC5C,MAAM,aAAa,CAAC,GAAG,QAAQ,OAAO,EAAE;gBACxC,QAAQ,CAAC,GAAG,QAAQ,kBAAkB,EAAE,CAAC,WAAW,EAAE,QAAQ,oBAAoB,EAAE,WAAW,mBAAmB,CAAC,EAAE;oBACjH,OAAO;gBACX;YACJ;YACA;QACJ;QACA,MAAM,QAAQ,MAAM,CAAC,QAAQ;QAC7B,IAAI,UAAU,QAAQ,CAAC,GAAG,UAAU,aAAa,EAAE,UAAU;YACzD,MAAM,aAAa,CAAC,GAAG,QAAQ,OAAO,EAAE;YACxC,QAAQ,CAAC,GAAG,QAAQ,kBAAkB,EAAE,CAAC,WAAW,EAAE,QAAQ,oBAAoB,EAAE,WAAW,mBAAmB,CAAC,EAAE;gBACjH,OAAO;YACX;YACA;QACJ;QACA,aAAa,CAAC,QAAQ,GAAG,CAAC,GAAG,UAAU,gBAAgB,EAAE,OAAO,SAAS,CAAC,MAAM,cAAc;YAC1F,IAAI,SAAS,CAAC,WAAW,EAAE,QAAQ,oBAAoB,CAAC,GAAG,CAAC,GAAG,QAAQ,OAAO,EAAE;YAChF,IAAI,KAAK,MAAM,GAAG,GAAG;gBACjB,UAAU,CAAC,KAAK,EAAE,UAAU,CAAC,GAAG,QAAQ,cAAc,EAAE,MAAM,CAAC,CAAC;YACpE;YACA,QAAQ,CAAC,GAAG,QAAQ,kBAAkB,EAAE,SAAS,OAAO,MAAM,OAAO,EAAE;gBACnE,OAAO;gBACP,eAAe;YACnB;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 2093, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/execute.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultFieldResolver = exports.defaultTypeResolver = exports.CRITICAL_ERROR = exports.getFragmentsFromDocument = void 0;\nexports.execute = execute;\nexports.executeSync = executeSync;\nexports.assertValidExecutionArguments = assertValidExecutionArguments;\nexports.buildExecutionContext = buildExecutionContext;\nexports.buildResolveInfo = buildResolveInfo;\nexports.subscribe = subscribe;\nexports.isIncrementalResults = isIncrementalResults;\nexports.flattenIncrementalResults = flattenIncrementalResults;\nexports.getFieldDef = getFieldDef;\nexports.isIncrementalResult = isIncrementalResult;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst disposablestack_1 = require(\"@whatwg-node/disposablestack\");\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst coerceError_js_1 = require(\"./coerceError.js\");\nconst flattenAsyncIterable_js_1 = require(\"./flattenAsyncIterable.js\");\nconst invariant_js_1 = require(\"./invariant.js\");\nconst promiseForObject_js_1 = require(\"./promiseForObject.js\");\nconst values_js_1 = require(\"./values.js\");\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\nconst collectSubfields = (0, utils_1.memoize3)((exeContext, returnType, fieldNodes) => (0, utils_1.collectSubFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification,\n * including `@defer` and `@stream` as proposed in\n * https://github.com/graphql/graphql-spec/pull/742\n *\n * This function returns a Promise of an IncrementalExecutionResults\n * object. This object either consists of a single ExecutionResult, or an\n * object containing an `initialResult` and a stream of `subsequentResults`.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nfunction execute(args) {\n    // If a valid execution context cannot be created due to incorrect arguments,\n    // a \"Response\" with only errors is returned.\n    const exeContext = buildExecutionContext(args);\n    // Return early errors if execution context failed.\n    if (!('schema' in exeContext)) {\n        return {\n            errors: exeContext.map(e => {\n                Object.defineProperty(e, 'extensions', {\n                    value: {\n                        ...e.extensions,\n                        http: {\n                            ...(e.extensions?.['http'] || {}),\n                            status: 400,\n                        },\n                    },\n                });\n                return e;\n            }),\n        };\n    }\n    return executeImpl(exeContext);\n}\nfunction executeImpl(exeContext) {\n    exeContext.signal?.throwIfAborted();\n    // Return a Promise that will eventually resolve to the data described by\n    // The \"Response\" section of the GraphQL specification.\n    //\n    // If errors are encountered while executing a GraphQL field, only that\n    // field and its descendants will be omitted, and sibling fields will still\n    // be executed. An execution which encounters errors will still result in a\n    // resolved Promise.\n    //\n    // Errors from sub-fields of a NonNull type may propagate to the top level,\n    // at which point we still log the error and null the parent field, which\n    // in this case is the entire response.\n    return (0, promise_helpers_1.handleMaybePromise)(() => executeOperation(exeContext), data => {\n        const initialResult = buildResponse(data, exeContext.errors);\n        if (exeContext.subsequentPayloads.size > 0) {\n            return {\n                initialResult: {\n                    ...initialResult,\n                    hasNext: true,\n                },\n                subsequentResults: yieldSubsequentPayloads(exeContext),\n            };\n        }\n        return initialResult;\n    }, (error) => {\n        exeContext.signal?.throwIfAborted();\n        if (error.errors) {\n            exeContext.errors.push(...error.errors);\n        }\n        else {\n            exeContext.errors.push(error);\n        }\n        return buildResponse(null, exeContext.errors);\n    });\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\nfunction executeSync(args) {\n    const result = execute(args);\n    // Assert that the execution was synchronous.\n    if ((0, utils_1.isPromise)(result) || 'initialResult' in result) {\n        throw new Error('GraphQL execution failed to complete synchronously.');\n    }\n    return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\nfunction buildResponse(data, errors) {\n    return errors.length === 0 ? { data } : { errors, data };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\nfunction assertValidExecutionArguments(schema, document, rawVariableValues) {\n    console.assert(!!document, 'Must provide document.');\n    // If the schema used for execution is invalid, throw an error.\n    (0, graphql_1.assertValidSchema)(schema);\n    // Variables, if provided, must be an object.\n    console.assert(rawVariableValues == null || (0, utils_1.isObjectLike)(rawVariableValues), 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\nexports.getFragmentsFromDocument = (0, utils_1.memoize1)(function getFragmentsFromDocument(document) {\n    const fragments = Object.create(null);\n    for (const definition of document.definitions) {\n        if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n            fragments[definition.name.value] = definition;\n        }\n    }\n    return fragments;\n});\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * TODO: consider no longer exporting this function\n * @internal\n */\nfunction buildExecutionContext(args) {\n    const { schema, document, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal, schemaCoordinateInErrors, } = args;\n    signal?.throwIfAborted();\n    // If the schema used for execution is invalid, throw an error.\n    (0, graphql_1.assertValidSchema)(schema);\n    const fragments = (0, exports.getFragmentsFromDocument)(document);\n    let operation;\n    for (const definition of document.definitions) {\n        switch (definition.kind) {\n            case graphql_1.Kind.OPERATION_DEFINITION:\n                if (operationName == null) {\n                    if (operation !== undefined) {\n                        return [\n                            (0, utils_1.createGraphQLError)('Must provide operation name if query contains multiple operations.', {\n                                extensions: {\n                                    code: 'OPERATION_RESOLUTION_FAILURE',\n                                },\n                            }),\n                        ];\n                    }\n                    operation = definition;\n                }\n                else if (definition.name?.value === operationName) {\n                    operation = definition;\n                }\n                break;\n            default:\n            // ignore non-executable definitions\n        }\n    }\n    if (operation == null) {\n        if (operationName != null) {\n            return [\n                (0, utils_1.createGraphQLError)(`Unknown operation named \"${operationName}\".`, {\n                    extensions: {\n                        code: 'OPERATION_RESOLUTION_FAILURE',\n                    },\n                }),\n            ];\n        }\n        return [\n            (0, utils_1.createGraphQLError)('Must provide an operation.', {\n                extensions: {\n                    code: 'OPERATION_RESOLUTION_FAILURE',\n                },\n            }),\n        ];\n    }\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    /* c8 ignore next */\n    const variableDefinitions = operation.variableDefinitions ?? [];\n    const coercedVariableValues = (0, values_js_1.getVariableValues)(schema, variableDefinitions, rawVariableValues ?? {}, {\n        maxErrors: 50,\n    });\n    if (coercedVariableValues.errors) {\n        return coercedVariableValues.errors;\n    }\n    signal?.throwIfAborted();\n    let onSignalAbort;\n    let signalPromise;\n    if (signal) {\n        const listeners = new Set();\n        const signalDeferred = (0, promise_helpers_1.createDeferredPromise)();\n        signalPromise = signalDeferred.promise;\n        const sharedListener = () => {\n            signalDeferred.reject(signal.reason);\n            signal.removeEventListener('abort', sharedListener);\n        };\n        signal.addEventListener('abort', sharedListener, { once: true });\n        signalPromise.catch(() => {\n            for (const listener of listeners) {\n                listener();\n            }\n            listeners.clear();\n        });\n        onSignalAbort = handler => {\n            listeners.add(handler);\n        };\n    }\n    return {\n        schema,\n        fragments,\n        rootValue,\n        contextValue,\n        operation,\n        variableValues: coercedVariableValues.coerced,\n        fieldResolver: fieldResolver ?? exports.defaultFieldResolver,\n        typeResolver: typeResolver ?? exports.defaultTypeResolver,\n        subscribeFieldResolver: subscribeFieldResolver ?? exports.defaultFieldResolver,\n        subsequentPayloads: new Set(),\n        errors: [],\n        signal,\n        onSignalAbort,\n        signalPromise,\n        schemaCoordinateInErrors,\n    };\n}\nfunction buildPerEventExecutionContext(exeContext, payload) {\n    return {\n        ...exeContext,\n        rootValue: payload,\n        subsequentPayloads: new Set(),\n        errors: [],\n    };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\nfunction executeOperation(exeContext) {\n    const { operation, schema, fragments, variableValues, rootValue } = exeContext;\n    const rootType = (0, utils_1.getDefinedRootType)(schema, operation.operation, [operation]);\n    if (rootType == null) {\n        (0, utils_1.createGraphQLError)(`Schema is not configured to execute ${operation.operation} operation.`, {\n            nodes: operation,\n        });\n    }\n    const { fields: rootFields, patches } = (0, utils_1.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);\n    const path = undefined;\n    let result;\n    if (operation.operation === 'mutation') {\n        result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n    }\n    else {\n        result = executeFields(exeContext, rootType, rootValue, path, rootFields);\n    }\n    for (const patch of patches) {\n        const { label, fields: patchFields } = patch;\n        executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);\n    }\n    return result;\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n    return (0, utils_1.promiseReduce)(fields, (results, [responseName, fieldNodes]) => {\n        const fieldPath = (0, utils_1.addPath)(path, responseName, parentType.name);\n        exeContext.signal?.throwIfAborted();\n        return (0, promise_helpers_1.handleMaybePromise)(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath), result => {\n            if (result === undefined) {\n                return results;\n            }\n            results[responseName] = result;\n            return results;\n        });\n    }, Object.create(null));\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\nfunction executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {\n    const results = Object.create(null);\n    let containsPromise = false;\n    try {\n        for (const [responseName, fieldNodes] of fields) {\n            exeContext.signal?.throwIfAborted();\n            const fieldPath = (0, utils_1.addPath)(path, responseName, parentType.name);\n            const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);\n            if (result !== undefined) {\n                results[responseName] = result;\n                if ((0, utils_1.isPromise)(result)) {\n                    containsPromise = true;\n                }\n            }\n        }\n    }\n    catch (error) {\n        if (error !== exeContext.signal?.reason && containsPromise) {\n            // Ensure that any promises returned by other fields are handled, as they may also reject.\n            return (0, promise_helpers_1.handleMaybePromise)(() => (0, promiseForObject_js_1.promiseForObject)(results, exeContext.signal), () => {\n                throw error;\n            }, () => {\n                throw error;\n            });\n        }\n        throw error;\n    }\n    // If there are no promises, we can just return the object\n    if (!containsPromise) {\n        return results;\n    }\n    // Otherwise, results is a map from field name to the result of resolving that\n    // field, which is possibly a promise. Return a promise that will return this\n    // same map, but with any promises replaced with the values they resolved to.\n    return (0, promiseForObject_js_1.promiseForObject)(results, exeContext.signal, exeContext.signalPromise);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\nfunction executeField(exeContext, parentType, source, fieldNodes, path, asyncPayloadRecord) {\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n    if (!fieldDef) {\n        return;\n    }\n    const returnType = fieldDef.type;\n    const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;\n    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);\n    // Get the resolve function, regardless of if its result is normal or abrupt (error).\n    try {\n        exeContext.signal?.throwIfAborted();\n        // Build a JS object of arguments from the field.arguments AST, using the\n        // variables scope to fulfill any variable references.\n        // TODO: find a way to memoize, in case this field is within a List type.\n        const args = (0, utils_1.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);\n        // The resolve function's optional third argument is a context value that\n        // is provided to every resolve function within an execution. It is commonly\n        // used to represent an authenticated user, or request-specific caches.\n        const contextValue = exeContext.contextValue;\n        const result = resolveFn(source, args, contextValue, info);\n        let completed;\n        if ((0, utils_1.isPromise)(result)) {\n            completed = result.then(resolved => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));\n        }\n        else {\n            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n        }\n        if ((0, utils_1.isPromise)(completed)) {\n            // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n            // to take a second callback for the error case.\n            return completed.then(undefined, rawError => {\n                if (rawError instanceof AggregateError) {\n                    let result;\n                    for (let rawErrorItem of rawError.errors) {\n                        rawErrorItem = (0, coerceError_js_1.coerceError)(rawErrorItem);\n                        const error = (0, utils_1.locatedError)(rawErrorItem, fieldNodes, (0, utils_1.pathToArray)(path), exeContext.schemaCoordinateInErrors && info);\n                        result = handleFieldError(error, returnType, errors);\n                        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                    }\n                    return result;\n                }\n                rawError = (0, coerceError_js_1.coerceError)(rawError);\n                const error = (0, utils_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(path), exeContext.schemaCoordinateInErrors && info);\n                const handledError = handleFieldError(error, returnType, errors);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                return handledError;\n            });\n        }\n        return completed;\n    }\n    catch (rawError) {\n        if (rawError instanceof AggregateError) {\n            let result;\n            for (let rawErrorItem of rawError.errors) {\n                rawErrorItem = (0, coerceError_js_1.coerceError)(rawErrorItem);\n                const error = (0, utils_1.locatedError)(rawErrorItem, fieldNodes, (0, utils_1.pathToArray)(path), exeContext.schemaCoordinateInErrors && info);\n                result = handleFieldError(error, returnType, errors);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            }\n            return result;\n        }\n        const coercedError = (0, coerceError_js_1.coerceError)(rawError);\n        const error = (0, utils_1.locatedError)(coercedError, fieldNodes, (0, utils_1.pathToArray)(path), exeContext.schemaCoordinateInErrors && info);\n        const handledError = handleFieldError(error, returnType, errors);\n        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n        return handledError;\n    }\n}\n/**\n * TODO: consider no longer exporting this function\n * @internal\n */\nfunction buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n    // The resolve function's optional fourth argument is a collection of\n    // information about the current execution state.\n    return {\n        fieldName: fieldDef.name,\n        fieldNodes,\n        returnType: fieldDef.type,\n        parentType,\n        path,\n        schema: exeContext.schema,\n        fragments: exeContext.fragments,\n        rootValue: exeContext.rootValue,\n        operation: exeContext.operation,\n        variableValues: exeContext.variableValues,\n        signal: exeContext.signal,\n    };\n}\nexports.CRITICAL_ERROR = 'CRITICAL_ERROR';\nfunction handleFieldError(error, returnType, errors) {\n    // If the field type is non-nullable, then it is resolved without any\n    // protection from errors, however it still properly locates the error.\n    if ((0, graphql_1.isNonNullType)(returnType)) {\n        throw error;\n    }\n    if (error.extensions?.[exports.CRITICAL_ERROR]) {\n        throw error;\n    }\n    // Otherwise, error protection is applied, logging the error and resolving\n    // a null value for this field if one is encountered.\n    errors.push(error);\n    return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    // If result is an Error, throw a located error.\n    if (result instanceof Error) {\n        throw result;\n    }\n    // If field type is NonNull, complete for inner type, and throw field error\n    // if result is null.\n    if ((0, graphql_1.isNonNullType)(returnType)) {\n        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);\n        if (completed === null) {\n            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);\n        }\n        return completed;\n    }\n    // If result value is null or undefined then return null.\n    if (result == null) {\n        return null;\n    }\n    // If field type is List, complete each item in the list with the inner type\n    if ((0, graphql_1.isListType)(returnType)) {\n        return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n    // returning null if serialization is not possible.\n    if ((0, graphql_1.isLeafType)(returnType)) {\n        return completeLeafValue(returnType, result);\n    }\n    // If field type is an abstract type, Interface or Union, determine the\n    // runtime Object type and complete for that type.\n    if ((0, graphql_1.isAbstractType)(returnType)) {\n        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    // If field type is Object, execute and complete all sub-selections.\n    if ((0, graphql_1.isObjectType)(returnType)) {\n        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);\n    }\n    /* c8 ignore next 6 */\n    // Not reachable, all possible output types have been considered.\n    console.assert(false, 'Cannot complete value of unexpected output type: ' + (0, utils_1.inspect)(returnType));\n}\n/**\n * Returns an object containing the `@stream` arguments if a field should be\n * streamed based on the experimental flag, stream directive present and\n * not disabled by the \"if\" argument.\n */\nfunction getStreamValues(exeContext, fieldNodes, path) {\n    // do not stream inner lists of multi-dimensional lists\n    if (typeof path.key === 'number') {\n        return;\n    }\n    // validation only allows equivalent streams on multiple fields, so it is\n    // safe to only check the first fieldNode for the stream directive\n    const stream = (0, graphql_1.getDirectiveValues)(utils_1.GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);\n    if (!stream) {\n        return;\n    }\n    if (stream.if === false) {\n        return;\n    }\n    (0, invariant_js_1.invariant)(typeof stream['initialCount'] === 'number', 'initialCount must be a number');\n    (0, invariant_js_1.invariant)(stream['initialCount'] >= 0, 'initialCount must be a positive integer');\n    return {\n        initialCount: stream['initialCount'],\n        label: typeof stream['label'] === 'string' ? stream['label'] : undefined,\n    };\n}\n/**\n * Complete a async iterator value by completing the result and calling\n * recursively until all the results are completed.\n */\nasync function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {\n    exeContext.signal?.throwIfAborted();\n    if (iterator.return) {\n        exeContext.onSignalAbort?.(() => {\n            iterator.return?.();\n        });\n    }\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    const stream = getStreamValues(exeContext, fieldNodes, path);\n    let containsPromise = false;\n    const completedResults = [];\n    let index = 0;\n    while (true) {\n        if (stream && typeof stream.initialCount === 'number' && index >= stream.initialCount) {\n            executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);\n            break;\n        }\n        const itemPath = (0, utils_1.addPath)(path, index, undefined);\n        let iteration;\n        try {\n            iteration = await iterator.next();\n            if (iteration.done) {\n                break;\n            }\n        }\n        catch (rawError) {\n            const coercedError = (0, coerceError_js_1.coerceError)(rawError);\n            const error = (0, utils_1.locatedError)(coercedError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n            completedResults.push(handleFieldError(error, itemType, errors));\n            break;\n        }\n        if (completeListItemValue(iteration.value, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {\n            containsPromise = true;\n        }\n        index += 1;\n    }\n    return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    const itemType = returnType.ofType;\n    const errors = asyncPayloadRecord?.errors ?? exeContext.errors;\n    if ((0, utils_1.isAsyncIterable)(result)) {\n        const iterator = result[Symbol.asyncIterator]();\n        return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);\n    }\n    if (!(0, utils_1.isIterableObject)(result)) {\n        throw (0, utils_1.createGraphQLError)(`Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`);\n    }\n    const stream = getStreamValues(exeContext, fieldNodes, path);\n    // This is specified as a simple map, however we're optimizing the path\n    // where the list contains no Promises by avoiding creating another Promise.\n    let containsPromise = false;\n    let previousAsyncPayloadRecord = asyncPayloadRecord;\n    const completedResults = [];\n    let index = 0;\n    for (const item of result) {\n        // No need to modify the info object containing the path,\n        // since from here on it is not ever accessed by resolver functions.\n        const itemPath = (0, utils_1.addPath)(path, index, undefined);\n        if (stream && typeof stream.initialCount === 'number' && index >= stream.initialCount) {\n            previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);\n            index++;\n            continue;\n        }\n        if (completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {\n            containsPromise = true;\n        }\n        index++;\n    }\n    return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a list item value by adding it to the completed results.\n *\n * Returns true if the value is a Promise.\n */\nfunction completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {\n    try {\n        let completedItem;\n        if ((0, utils_1.isPromise)(item)) {\n            completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));\n        }\n        else {\n            completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n        }\n        if ((0, utils_1.isPromise)(completedItem)) {\n            // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n            // to take a second callback for the error case.\n            completedResults.push(completedItem.then(undefined, rawError => {\n                rawError = (0, coerceError_js_1.coerceError)(rawError);\n                const error = (0, utils_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n                const handledError = handleFieldError(error, itemType, errors);\n                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                return handledError;\n            }));\n            return true;\n        }\n        completedResults.push(completedItem);\n    }\n    catch (rawError) {\n        const coercedError = (0, coerceError_js_1.coerceError)(rawError);\n        const error = (0, utils_1.locatedError)(coercedError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n        const handledError = handleFieldError(error, itemType, errors);\n        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        completedResults.push(handledError);\n    }\n    return false;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\nfunction completeLeafValue(returnType, result) {\n    let serializedResult;\n    // Note: We transform GraphQLError to Error in order to be consistent with\n    // how non-null checks work later on.\n    // See https://github.com/kamilkisiela/graphql-hive/pull/2299\n    // See https://github.com/n1ru4l/envelop/issues/1808\n    try {\n        serializedResult = returnType.serialize(result);\n    }\n    catch (err) {\n        if (err instanceof graphql_1.GraphQLError) {\n            throw new Error(err.message);\n        }\n        throw err;\n    }\n    if (serializedResult == null) {\n        throw new Error(`Expected \\`${(0, utils_1.inspect)(returnType)}.serialize(${(0, utils_1.inspect)(result)})\\` to ` +\n            `return non-nullable value, returned: ${(0, utils_1.inspect)(serializedResult)}`);\n    }\n    return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;\n    const contextValue = exeContext.contextValue;\n    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n    if ((0, utils_1.isPromise)(runtimeType)) {\n        return runtimeType.then(resolvedRuntimeType => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));\n    }\n    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);\n}\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {\n    if (runtimeTypeName == null) {\n        throw (0, utils_1.createGraphQLError)(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`, { nodes: fieldNodes });\n    }\n    // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n    // TODO: remove in 17.0.0 release\n    if ((0, graphql_1.isObjectType)(runtimeTypeName)) {\n        if (graphql_1.versionInfo.major >= 16) {\n            throw (0, utils_1.createGraphQLError)('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');\n        }\n        runtimeTypeName = runtimeTypeName.name;\n    }\n    if (typeof runtimeTypeName !== 'string') {\n        throw (0, utils_1.createGraphQLError)(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n            `value ${(0, utils_1.inspect)(result)}, received \"${(0, utils_1.inspect)(runtimeTypeName)}\".`);\n    }\n    const runtimeType = exeContext.schema.getType(runtimeTypeName);\n    if (runtimeType == null) {\n        throw (0, utils_1.createGraphQLError)(`Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`, { nodes: fieldNodes });\n    }\n    if (!(0, graphql_1.isObjectType)(runtimeType)) {\n        throw (0, utils_1.createGraphQLError)(`Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`, { nodes: fieldNodes });\n    }\n    if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n        throw (0, utils_1.createGraphQLError)(`Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`, { nodes: fieldNodes });\n    }\n    return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {\n    // If there is an isTypeOf predicate function, call it with the\n    // current result. If isTypeOf returns false, then raise an error rather\n    // than continuing execution.\n    if (returnType.isTypeOf) {\n        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n        if ((0, utils_1.isPromise)(isTypeOf)) {\n            return isTypeOf.then(resolvedIsTypeOf => {\n                if (!resolvedIsTypeOf) {\n                    throw invalidReturnTypeError(returnType, result, fieldNodes);\n                }\n                return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);\n            });\n        }\n        if (!isTypeOf) {\n            throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n    }\n    return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);\n}\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n    return (0, utils_1.createGraphQLError)(`Expected value of type \"${returnType.name}\" but got: ${(0, utils_1.inspect)(result)}.`, {\n        nodes: fieldNodes,\n    });\n}\nfunction collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {\n    // Collect sub-fields to execute to complete this value.\n    const { fields: subFieldNodes, patches: subPatches } = collectSubfields(exeContext, returnType, fieldNodes);\n    const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);\n    for (const subPatch of subPatches) {\n        const { label, fields: subPatchFieldNodes } = subPatch;\n        executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);\n    }\n    return subFields;\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\nconst defaultTypeResolver = function (value, contextValue, info, abstractType) {\n    // First, look for `__typename`.\n    if ((0, utils_1.isObjectLike)(value) && typeof value['__typename'] === 'string') {\n        return value['__typename'];\n    }\n    // Otherwise, test each possible type.\n    const possibleTypes = info.schema.getPossibleTypes(abstractType);\n    const promisedIsTypeOfResults = [];\n    for (let i = 0; i < possibleTypes.length; i++) {\n        const type = possibleTypes[i];\n        if (type.isTypeOf) {\n            const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n            if ((0, utils_1.isPromise)(isTypeOfResult)) {\n                promisedIsTypeOfResults[i] = isTypeOfResult;\n            }\n            else if (isTypeOfResult) {\n                return type.name;\n            }\n        }\n    }\n    if (promisedIsTypeOfResults.length) {\n        return Promise.all(promisedIsTypeOfResults).then(isTypeOfResults => {\n            for (let i = 0; i < isTypeOfResults.length; i++) {\n                if (isTypeOfResults[i]) {\n                    return possibleTypes[i].name;\n                }\n            }\n        });\n    }\n};\nexports.defaultTypeResolver = defaultTypeResolver;\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\nconst defaultFieldResolver = function (source, args, contextValue, info) {\n    // ensure source is a value for which property access is acceptable.\n    if ((0, utils_1.isObjectLike)(source) || typeof source === 'function') {\n        const property = source[info.fieldName];\n        if (typeof property === 'function') {\n            return source[info.fieldName](args, contextValue, info);\n        }\n        return property;\n    }\n};\nexports.defaultFieldResolver = defaultFieldResolver;\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification,\n * including `@defer` and `@stream` as proposed in\n * https://github.com/graphql/graphql-spec/pull/742\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with descriptive\n * errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription resolver\n * logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of result representing the response stream.\n *\n * Each result may be an ExecutionResult with no `hasNext` (if executing the\n * event did not use `@defer` or `@stream`), or an\n * `InitialIncrementalExecutionResult` or `SubsequentIncrementalExecutionResult`\n * (if executing the event used `@defer` or `@stream`). In the case of\n * incremental execution results, each event produces a single\n * `InitialIncrementalExecutionResult` followed by one or more\n * `SubsequentIncrementalExecutionResult`s; all but the last have `hasNext: true`,\n * and the last has `hasNext: false`. There is no interleaving between results\n * generated from the same original event.\n *\n * Accepts an object with named arguments.\n */\nfunction subscribe(args) {\n    // If a valid execution context cannot be created due to incorrect arguments,\n    // a \"Response\" with only errors is returned.\n    const exeContext = buildExecutionContext(args);\n    // Return early errors if execution context failed.\n    if (!('schema' in exeContext)) {\n        for (const error of exeContext) {\n            // @ts-expect-error - We are intentionally modifying the errors\n            const extensions = (error.extensions ||= {});\n            const httpExtensions = (extensions['http'] ||= {});\n            httpExtensions.status = 400;\n            error.extensions['code'] = 'BAD_USER_INPUT';\n        }\n        return {\n            errors: exeContext,\n        };\n    }\n    const resultOrStream = createSourceEventStreamImpl(exeContext);\n    if ((0, utils_1.isPromise)(resultOrStream)) {\n        return resultOrStream.then(resolvedResultOrStream => mapSourceToResponse(exeContext, resolvedResultOrStream));\n    }\n    return mapSourceToResponse(exeContext, resultOrStream);\n}\nfunction isIncrementalResults(results) {\n    return results?.initialResult;\n}\nfunction flattenIncrementalResults(incrementalResults) {\n    const subsequentIterator = incrementalResults.subsequentResults;\n    let initialResultSent = false;\n    let done = false;\n    return {\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        next() {\n            if (done) {\n                return (0, utils_1.fakePromise)({ value: undefined, done });\n            }\n            if (initialResultSent) {\n                return subsequentIterator.next();\n            }\n            initialResultSent = true;\n            return (0, utils_1.fakePromise)({\n                value: incrementalResults.initialResult,\n                done,\n            });\n        },\n        return() {\n            done = true;\n            return subsequentIterator.return();\n        },\n        throw(error) {\n            done = true;\n            return subsequentIterator.throw(error);\n        },\n        [disposablestack_1.DisposableSymbols.asyncDispose]() {\n            done = true;\n            return subsequentIterator?.[disposablestack_1.DisposableSymbols.asyncDispose]?.();\n        },\n    };\n}\nasync function* ensureAsyncIterable(someExecutionResult) {\n    if ('initialResult' in someExecutionResult) {\n        yield* flattenIncrementalResults(someExecutionResult);\n    }\n    else {\n        yield someExecutionResult;\n    }\n}\nfunction mapSourceToResponse(exeContext, resultOrStream) {\n    if (!(0, utils_1.isAsyncIterable)(resultOrStream)) {\n        return resultOrStream;\n    }\n    // For each payload yielded from a subscription, map it over the normal\n    // GraphQL `execute` function, with `payload` as the rootValue.\n    // This implements the \"MapSourceToResponseEvent\" algorithm described in\n    // the GraphQL specification. The `execute` function provides the\n    // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n    // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n    return (0, flattenAsyncIterable_js_1.flattenAsyncIterable)((0, utils_1.mapAsyncIterator)(resultOrStream, (payload) => (0, promise_helpers_1.handleMaybePromise)(() => executeImpl(buildPerEventExecutionContext(exeContext, payload)), ensureAsyncIterable), (error) => {\n        if (error instanceof AggregateError) {\n            throw new AggregateError(error.errors.map(e => wrapError(e, exeContext.operation)), error.message);\n        }\n        throw wrapError(error, exeContext.operation);\n    }));\n}\nfunction wrapError(error, operation) {\n    return (0, utils_1.createGraphQLError)(error.message, {\n        originalError: error,\n        nodes: [operation],\n    });\n}\nfunction createSourceEventStreamImpl(exeContext) {\n    try {\n        const eventStream = executeSubscription(exeContext);\n        if ((0, utils_1.isPromise)(eventStream)) {\n            return eventStream.then(undefined, error => ({ errors: [error] }));\n        }\n        return eventStream;\n    }\n    catch (error) {\n        return { errors: [error] };\n    }\n}\nfunction executeSubscription(exeContext) {\n    const { schema, fragments, operation, variableValues, rootValue } = exeContext;\n    const rootType = schema.getSubscriptionType();\n    if (rootType == null) {\n        throw (0, utils_1.createGraphQLError)('Schema is not configured to execute subscription operation.', {\n            nodes: operation,\n        });\n    }\n    const { fields: rootFields } = (0, utils_1.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);\n    const [responseName, fieldNodes] = [...rootFields.entries()][0];\n    const fieldName = fieldNodes[0].name.value;\n    const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n    if (!fieldDef) {\n        throw (0, utils_1.createGraphQLError)(`The subscription field \"${fieldName}\" is not defined.`, {\n            nodes: fieldNodes,\n        });\n    }\n    const path = (0, utils_1.addPath)(undefined, responseName, rootType.name);\n    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);\n    try {\n        // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n        // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n        // Build a JS object of arguments from the field.arguments AST, using the\n        // variables scope to fulfill any variable references.\n        const args = (0, utils_1.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);\n        // The resolve function's optional third argument is a context value that\n        // is provided to every resolve function within an execution. It is commonly\n        // used to represent an authenticated user, or request-specific caches.\n        const contextValue = exeContext.contextValue;\n        // Call the `subscribe()` resolver or the default resolver to produce an\n        // AsyncIterable yielding raw payloads.\n        const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;\n        const result = resolveFn(rootValue, args, contextValue, info);\n        if ((0, utils_1.isPromise)(result)) {\n            return result\n                .then(result => assertEventStream(result, exeContext.signal, exeContext.onSignalAbort))\n                .then(undefined, error => {\n                throw (0, utils_1.locatedError)(error, fieldNodes, (0, utils_1.pathToArray)(path), exeContext.schemaCoordinateInErrors && info);\n            });\n        }\n        return assertEventStream(result, exeContext.signal, exeContext.onSignalAbort);\n    }\n    catch (error) {\n        throw (0, utils_1.locatedError)(error, fieldNodes, (0, utils_1.pathToArray)(path), exeContext.schemaCoordinateInErrors && info);\n    }\n}\nfunction assertEventStream(result, signal, onSignalAbort) {\n    signal?.throwIfAborted();\n    if (result instanceof Error) {\n        throw result;\n    }\n    // Assert field returned an event stream, otherwise yield an error.\n    if (!(0, utils_1.isAsyncIterable)(result)) {\n        throw (0, utils_1.createGraphQLError)('Subscription field must return Async Iterable. ' + `Received: ${(0, utils_1.inspect)(result)}.`);\n    }\n    if (onSignalAbort) {\n        return {\n            [Symbol.asyncIterator]() {\n                const asyncIterator = result[Symbol.asyncIterator]();\n                if (asyncIterator.return) {\n                    onSignalAbort?.(() => {\n                        asyncIterator.return?.();\n                    });\n                }\n                return asyncIterator;\n            },\n        };\n    }\n    return result;\n}\nfunction executeDeferredFragment(exeContext, parentType, sourceValue, fields, label, path, parentContext) {\n    const asyncPayloadRecord = new DeferredFragmentRecord({\n        label,\n        path,\n        parentContext,\n        exeContext,\n    });\n    let promiseOrData;\n    try {\n        promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);\n        if ((0, utils_1.isPromise)(promiseOrData)) {\n            promiseOrData = promiseOrData.then(null, e => {\n                asyncPayloadRecord.errors.push(e);\n                return null;\n            });\n        }\n    }\n    catch (e) {\n        asyncPayloadRecord.errors.push(e);\n        promiseOrData = null;\n    }\n    asyncPayloadRecord.addData(promiseOrData);\n}\nfunction executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {\n    const asyncPayloadRecord = new StreamRecord({\n        label,\n        path: itemPath,\n        parentContext,\n        exeContext,\n    });\n    let completedItem;\n    try {\n        try {\n            if ((0, utils_1.isPromise)(item)) {\n                completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));\n            }\n            else {\n                completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n            }\n            if ((0, utils_1.isPromise)(completedItem)) {\n                // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n                // to take a second callback for the error case.\n                completedItem = completedItem.then(undefined, rawError => {\n                    rawError = (0, coerceError_js_1.coerceError)(rawError);\n                    const error = (0, utils_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n                    const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n                    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                    return handledError;\n                });\n            }\n        }\n        catch (rawError) {\n            const coercedError = (0, coerceError_js_1.coerceError)(rawError);\n            const error = (0, utils_1.locatedError)(coercedError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n            completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n            filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        }\n    }\n    catch (error) {\n        asyncPayloadRecord.errors.push(error);\n        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n        asyncPayloadRecord.addItems(null);\n        return asyncPayloadRecord;\n    }\n    let completedItems;\n    if ((0, utils_1.isPromise)(completedItem)) {\n        completedItems = completedItem.then(value => [value], error => {\n            asyncPayloadRecord.errors.push(error);\n            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            return null;\n        });\n    }\n    else {\n        completedItems = [completedItem];\n    }\n    asyncPayloadRecord.addItems(completedItems);\n    return asyncPayloadRecord;\n}\nasync function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {\n    let item;\n    try {\n        const { value, done } = await iterator.next();\n        if (done) {\n            asyncPayloadRecord.setIsCompletedIterator();\n            return { done, value: undefined };\n        }\n        item = value;\n    }\n    catch (rawError) {\n        const coercedError = (0, coerceError_js_1.coerceError)(rawError);\n        const error = (0, utils_1.locatedError)(coercedError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n        // don't continue if iterator throws\n        return { done: true, value };\n    }\n    let completedItem;\n    try {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);\n        if ((0, utils_1.isPromise)(completedItem)) {\n            completedItem = completedItem.then(undefined, rawError => {\n                const error = (0, utils_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n                const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n                return handledError;\n            });\n        }\n        return { done: false, value: completedItem };\n    }\n    catch (rawError) {\n        const error = (0, utils_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath), exeContext.schemaCoordinateInErrors && info);\n        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);\n        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);\n        return { done: false, value };\n    }\n}\nasync function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {\n    let index = initialIndex;\n    let previousAsyncPayloadRecord = parentContext ?? undefined;\n    while (true) {\n        const itemPath = (0, utils_1.addPath)(path, index, undefined);\n        const asyncPayloadRecord = new StreamRecord({\n            label,\n            path: itemPath,\n            parentContext: previousAsyncPayloadRecord,\n            iterator,\n            exeContext,\n        });\n        let iteration;\n        try {\n            iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);\n        }\n        catch (error) {\n            asyncPayloadRecord.errors.push(error);\n            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n            asyncPayloadRecord.addItems(null);\n            // entire stream has errored and bubbled upwards\n            if (iterator?.return) {\n                iterator.return().catch(() => {\n                    // ignore errors\n                });\n            }\n            return;\n        }\n        const { done, value: completedItem } = iteration;\n        let completedItems;\n        if ((0, utils_1.isPromise)(completedItem)) {\n            completedItems = completedItem.then(value => [value], error => {\n                asyncPayloadRecord.errors.push(error);\n                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);\n                return null;\n            });\n        }\n        else {\n            completedItems = [completedItem];\n        }\n        asyncPayloadRecord.addItems(completedItems);\n        if (done) {\n            break;\n        }\n        previousAsyncPayloadRecord = asyncPayloadRecord;\n        index++;\n    }\n}\nfunction filterSubsequentPayloads(exeContext, nullPath, currentAsyncRecord) {\n    const nullPathArray = (0, utils_1.pathToArray)(nullPath);\n    exeContext.subsequentPayloads.forEach(asyncRecord => {\n        if (asyncRecord === currentAsyncRecord) {\n            // don't remove payload from where error originates\n            return;\n        }\n        for (let i = 0; i < nullPathArray.length; i++) {\n            if (asyncRecord.path[i] !== nullPathArray[i]) {\n                // asyncRecord points to a path unaffected by this payload\n                return;\n            }\n        }\n        // asyncRecord path points to nulled error field\n        if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {\n            asyncRecord.iterator.return().catch(() => {\n                // ignore error\n            });\n        }\n        exeContext.subsequentPayloads.delete(asyncRecord);\n    });\n}\nfunction getCompletedIncrementalResults(exeContext) {\n    const incrementalResults = [];\n    for (const asyncPayloadRecord of exeContext.subsequentPayloads) {\n        const incrementalResult = {};\n        if (!asyncPayloadRecord.isCompleted) {\n            continue;\n        }\n        exeContext.subsequentPayloads.delete(asyncPayloadRecord);\n        if (isStreamPayload(asyncPayloadRecord)) {\n            const items = asyncPayloadRecord.items;\n            if (asyncPayloadRecord.isCompletedIterator) {\n                // async iterable resolver just finished but there may be pending payloads\n                continue;\n            }\n            incrementalResult.items = items;\n        }\n        else {\n            const data = asyncPayloadRecord.data;\n            incrementalResult.data = data ?? null;\n        }\n        incrementalResult.path = asyncPayloadRecord.path;\n        if (asyncPayloadRecord.label) {\n            incrementalResult.label = asyncPayloadRecord.label;\n        }\n        if (asyncPayloadRecord.errors.length > 0) {\n            incrementalResult.errors = asyncPayloadRecord.errors;\n        }\n        incrementalResults.push(incrementalResult);\n    }\n    return incrementalResults;\n}\nfunction yieldSubsequentPayloads(exeContext) {\n    let isDone = false;\n    async function next() {\n        if (isDone) {\n            return { value: undefined, done: true };\n        }\n        const subSequentPayloadPromises = Array.from(exeContext.subsequentPayloads).map(record => record.promise);\n        if (exeContext.signalPromise) {\n            await Promise.race([exeContext.signalPromise, ...subSequentPayloadPromises]);\n        }\n        else {\n            await Promise.race(subSequentPayloadPromises);\n        }\n        if (isDone) {\n            // a different call to next has exhausted all payloads\n            return { value: undefined, done: true };\n        }\n        const incremental = getCompletedIncrementalResults(exeContext);\n        const hasNext = exeContext.subsequentPayloads.size > 0;\n        if (!incremental.length && hasNext) {\n            return next();\n        }\n        if (!hasNext) {\n            isDone = true;\n        }\n        return {\n            value: incremental.length ? { incremental, hasNext } : { hasNext },\n            done: false,\n        };\n    }\n    function returnStreamIterators() {\n        const promises = [];\n        exeContext.subsequentPayloads.forEach(asyncPayloadRecord => {\n            if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {\n                promises.push(asyncPayloadRecord.iterator.return());\n            }\n        });\n        return Promise.all(promises);\n    }\n    return {\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        next,\n        async return() {\n            await returnStreamIterators();\n            isDone = true;\n            return { value: undefined, done: true };\n        },\n        async throw(error) {\n            await returnStreamIterators();\n            isDone = true;\n            throw error;\n        },\n        async [disposablestack_1.DisposableSymbols.asyncDispose]() {\n            await returnStreamIterators();\n            isDone = true;\n        },\n    };\n}\nclass DeferredFragmentRecord {\n    type;\n    errors;\n    label;\n    path;\n    promise;\n    data;\n    parentContext;\n    isCompleted;\n    _exeContext;\n    _resolve;\n    constructor(opts) {\n        this.type = 'defer';\n        this.label = opts.label;\n        this.path = (0, utils_1.pathToArray)(opts.path);\n        this.parentContext = opts.parentContext;\n        this.errors = [];\n        this._exeContext = opts.exeContext;\n        this._exeContext.subsequentPayloads.add(this);\n        this.isCompleted = false;\n        this.data = null;\n        this.promise = new Promise(resolve => {\n            this._resolve = MaybePromise => {\n                resolve(MaybePromise);\n            };\n        }).then(data => {\n            this.data = data;\n            this.isCompleted = true;\n        });\n    }\n    addData(data) {\n        const parentData = this.parentContext?.promise;\n        if (parentData) {\n            this._resolve?.(parentData.then(() => data));\n            return;\n        }\n        this._resolve?.(data);\n    }\n}\nclass StreamRecord {\n    type;\n    errors;\n    label;\n    path;\n    items;\n    promise;\n    parentContext;\n    iterator;\n    isCompletedIterator;\n    isCompleted;\n    _exeContext;\n    _resolve;\n    constructor(opts) {\n        this.type = 'stream';\n        this.items = null;\n        this.label = opts.label;\n        this.path = (0, utils_1.pathToArray)(opts.path);\n        this.parentContext = opts.parentContext;\n        this.iterator = opts.iterator;\n        this.errors = [];\n        this._exeContext = opts.exeContext;\n        this._exeContext.subsequentPayloads.add(this);\n        this.isCompleted = false;\n        this.items = null;\n        this.promise = new Promise(resolve => {\n            this._resolve = MaybePromise => {\n                resolve(MaybePromise);\n            };\n        }).then(items => {\n            this.items = items;\n            this.isCompleted = true;\n        });\n    }\n    addItems(items) {\n        const parentData = this.parentContext?.promise;\n        if (parentData) {\n            this._resolve?.(parentData.then(() => items));\n            return;\n        }\n        this._resolve?.(items);\n    }\n    setIsCompletedIterator() {\n        this.isCompletedIterator = true;\n    }\n}\nfunction isStreamPayload(asyncPayload) {\n    return asyncPayload.type === 'stream';\n}\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n    const fieldName = fieldNode.name.value;\n    if (fieldName === graphql_1.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n        return graphql_1.SchemaMetaFieldDef;\n    }\n    else if (fieldName === graphql_1.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n        return graphql_1.TypeMetaFieldDef;\n    }\n    else if (fieldName === graphql_1.TypeNameMetaFieldDef.name) {\n        return graphql_1.TypeNameMetaFieldDef;\n    }\n    return parentType.getFields()[fieldName];\n}\nfunction isIncrementalResult(result) {\n    return 'incremental' in result;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3521, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/normalizedExecutor.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.executorFromSchema = void 0;\nexports.normalizedExecutor = normalizedExecutor;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst promise_helpers_1 = require(\"@whatwg-node/promise-helpers\");\nconst execute_js_1 = require(\"./execute.js\");\nfunction normalizedExecutor(args) {\n    const operationAST = (0, graphql_1.getOperationAST)(args.document, args.operationName);\n    if (operationAST == null) {\n        throw new Error('Must provide an operation.');\n    }\n    if (operationAST.operation === 'subscription') {\n        return (0, execute_js_1.subscribe)(args);\n    }\n    return (0, promise_helpers_1.handleMaybePromise)(() => (0, execute_js_1.execute)(args), result => {\n        if ((0, execute_js_1.isIncrementalResults)(result)) {\n            return (0, execute_js_1.flattenIncrementalResults)(result);\n        }\n        return result;\n    });\n}\nexports.executorFromSchema = (0, utils_1.memoize1)(function executorFromSchema(schema) {\n    return function schemaExecutor(request) {\n        return normalizedExecutor({\n            schema,\n            document: request.document,\n            variableValues: request.variables,\n            operationName: request.operationName,\n            rootValue: request.rootValue,\n            contextValue: request.context,\n            signal: request.signal || request.info?.signal,\n            schemaCoordinateInErrors: request.schemaCoordinateInErrors,\n        });\n    };\n});\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,kBAAkB,GAAG,KAAK;AAClC,QAAQ,kBAAkB,GAAG;AAC7B,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,mBAAmB,IAAI;IAC5B,MAAM,eAAe,CAAC,GAAG,UAAU,eAAe,EAAE,KAAK,QAAQ,EAAE,KAAK,aAAa;IACrF,IAAI,gBAAgB,MAAM;QACtB,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,aAAa,SAAS,KAAK,gBAAgB;QAC3C,OAAO,CAAC,GAAG,aAAa,SAAS,EAAE;IACvC;IACA,OAAO,CAAC,GAAG,kBAAkB,kBAAkB,EAAE,IAAM,CAAC,GAAG,aAAa,OAAO,EAAE,OAAO,CAAA;QACpF,IAAI,CAAC,GAAG,aAAa,oBAAoB,EAAE,SAAS;YAChD,OAAO,CAAC,GAAG,aAAa,yBAAyB,EAAE;QACvD;QACA,OAAO;IACX;AACJ;AACA,QAAQ,kBAAkB,GAAG,CAAC,GAAG,QAAQ,QAAQ,EAAE,SAAS,mBAAmB,MAAM;IACjF,OAAO,SAAS,eAAe,OAAO;QAClC,OAAO,mBAAmB;YACtB;YACA,UAAU,QAAQ,QAAQ;YAC1B,gBAAgB,QAAQ,SAAS;YACjC,eAAe,QAAQ,aAAa;YACpC,WAAW,QAAQ,SAAS;YAC5B,cAAc,QAAQ,OAAO;YAC7B,QAAQ,QAAQ,MAAM,IAAI,QAAQ,IAAI,EAAE;YACxC,0BAA0B,QAAQ,wBAAwB;QAC9D;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3563, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/execution/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./execute.js\"), exports);\ntslib_1.__exportStar(require(\"./values.js\"), exports);\ntslib_1.__exportStar(require(\"./normalizedExecutor.js\"), exports);\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,QAAQ,YAAY,8HAA0B;AAC9C,QAAQ,YAAY,6HAAyB;AAC7C,QAAQ,YAAY,yIAAqC","ignoreList":[0]}},
    {"offset": {"line": 3574, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40graphql-tools/executor/cjs/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./execution/index.js\"), exports);\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,MAAM;AACN,QAAQ,YAAY,4HAAkC","ignoreList":[0]}}]
}