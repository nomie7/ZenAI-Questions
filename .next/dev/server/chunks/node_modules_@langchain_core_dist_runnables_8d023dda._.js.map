{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/config.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/config.ts"],"sourcesContent":["import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { RunnableConfig } from \"./types.js\";\n\nexport const DEFAULT_RECURSION_LIMIT = 25;\n\nexport { type RunnableConfig };\n\nexport async function getCallbackManagerForConfig(config?: RunnableConfig) {\n  return CallbackManager._configureSync(\n    config?.callbacks,\n    undefined,\n    config?.tags,\n    undefined,\n    config?.metadata\n  );\n}\n\nexport function mergeConfigs<CallOptions extends RunnableConfig>(\n  ...configs: (CallOptions | RunnableConfig | undefined | null)[]\n): Partial<CallOptions> {\n  // We do not want to call ensureConfig on the empty state here as this may cause\n  // double loading of callbacks if async local storage is being used.\n  const copy: Partial<CallOptions> = {};\n  for (const options of configs.filter((c): c is CallOptions => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"tags\") {\n        const baseKeys: string[] = copy[key] ?? [];\n        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n      } else if (key === \"configurable\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"timeout\") {\n        if (copy.timeout === undefined) {\n          copy.timeout = options.timeout;\n        } else if (options.timeout !== undefined) {\n          copy.timeout = Math.min(copy.timeout, options.timeout);\n        }\n      } else if (key === \"signal\") {\n        if (copy.signal === undefined) {\n          copy.signal = options.signal;\n        } else if (options.signal !== undefined) {\n          if (\"any\" in AbortSignal) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            copy.signal = (AbortSignal as any).any([\n              copy.signal,\n              options.signal,\n            ]);\n          } else {\n            copy.signal = options.signal;\n          }\n        }\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(\n              providedCallbacks._parentRunId,\n              {\n                handlers: baseCallbacks.handlers.concat(\n                  providedCallbacks.handlers\n                ),\n                inheritableHandlers: baseCallbacks.inheritableHandlers.concat(\n                  providedCallbacks.inheritableHandlers\n                ),\n                tags: Array.from(\n                  new Set(baseCallbacks.tags.concat(providedCallbacks.tags))\n                ),\n                inheritableTags: Array.from(\n                  new Set(\n                    baseCallbacks.inheritableTags.concat(\n                      providedCallbacks.inheritableTags\n                    )\n                  )\n                ),\n                metadata: {\n                  ...baseCallbacks.metadata,\n                  ...providedCallbacks.metadata,\n                },\n              }\n            );\n          }\n        }\n      } else {\n        const typedKey = key as keyof CallOptions;\n        copy[typedKey] = options[typedKey] ?? copy[typedKey];\n      }\n    }\n  }\n  return copy as Partial<CallOptions>;\n}\n\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig<CallOptions extends RunnableConfig>(\n  config?: CallOptions\n): CallOptions {\n  const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  let empty: RunnableConfig = {\n    tags: [],\n    metadata: {},\n    recursionLimit: 25,\n    runId: undefined,\n  };\n  if (implicitConfig) {\n    // Don't allow runId and runName to be loaded implicitly, as this can cause\n    // child runs to improperly inherit their parents' run ids.\n    const { runId, runName, ...rest } = implicitConfig;\n    empty = Object.entries(rest).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (config) {\n    empty = Object.entries(config).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (empty?.configurable) {\n    for (const key of Object.keys(empty.configurable)) {\n      if (\n        PRIMITIVES.has(typeof empty.configurable[key]) &&\n        !empty.metadata?.[key]\n      ) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = empty.configurable[key];\n      }\n    }\n  }\n  if (empty.timeout !== undefined) {\n    if (empty.timeout <= 0) {\n      throw new Error(\"Timeout must be a positive number\");\n    }\n    const timeoutSignal = AbortSignal.timeout(empty.timeout);\n    if (empty.signal !== undefined) {\n      if (\"any\" in AbortSignal) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        empty.signal = (AbortSignal as any).any([empty.signal, timeoutSignal]);\n      }\n    } else {\n      empty.signal = timeoutSignal;\n    }\n    delete empty.timeout;\n  }\n  return empty as CallOptions;\n}\n\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig<CallOptions extends RunnableConfig>(\n  config: Partial<CallOptions> = {},\n  {\n    callbacks,\n    maxConcurrency,\n    recursionLimit,\n    runName,\n    configurable,\n    runId,\n  }: RunnableConfig = {}\n): Partial<CallOptions> {\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = { ...newConfig.configurable, ...configurable };\n  }\n  if (runId !== undefined) {\n    delete newConfig.runId;\n  }\n  return newConfig;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function pickRunnableConfigKeys<CallOptions extends Record<string, any>>(\n  config?: CallOptions\n): Partial<RunnableConfig> | undefined {\n  if (!config) return undefined;\n\n  return {\n    configurable: config.configurable,\n    recursionLimit: config.recursionLimit,\n    callbacks: config.callbacks,\n    tags: config.tags,\n    metadata: config.metadata,\n    maxConcurrency: config.maxConcurrency,\n    timeout: config.timeout,\n    signal: config.signal,\n    // @ts-expect-error - Store is a LangGraph-specific property\n    // which wewant to pass through to all runnables.\n    // (eg. tools should have access to writing to the store)\n    store: config.store,\n  };\n}\n"],"names":["config?: RunnableConfig","CallbackManager","copy: Partial<CallOptions>","baseKeys: string[]","ensureHandler","config?: CallOptions","AsyncLocalStorageProviderSingleton","empty: RunnableConfig","currentConfig: Record<string, any>","config: Partial<CallOptions>"],"mappings":"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"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/utils.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/utils.ts"],"sourcesContent":["import { StreamEvent } from \"../tracers/event_stream.js\";\nimport type { RunnableInterface } from \"./types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isRunnableInterface(thing: any): thing is RunnableInterface {\n  return thing ? thing.lc_runnable : false;\n}\n\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nexport class _RootEventFilter {\n  includeNames?: string[];\n\n  includeTypes?: string[];\n\n  includeTags?: string[];\n\n  excludeNames?: string[];\n\n  excludeTypes?: string[];\n\n  excludeTags?: string[];\n\n  constructor(fields: {\n    includeNames?: string[];\n    includeTypes?: string[];\n    includeTags?: string[];\n    excludeNames?: string[];\n    excludeTypes?: string[];\n    excludeTags?: string[];\n  }) {\n    this.includeNames = fields.includeNames;\n    this.includeTypes = fields.includeTypes;\n    this.includeTags = fields.includeTags;\n    this.excludeNames = fields.excludeNames;\n    this.excludeTypes = fields.excludeTypes;\n    this.excludeTags = fields.excludeTags;\n  }\n\n  includeEvent(event: StreamEvent, rootType: string): boolean {\n    let include =\n      this.includeNames === undefined &&\n      this.includeTypes === undefined &&\n      this.includeTags === undefined;\n    const eventTags = event.tags ?? [];\n\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(event.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(rootType);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include || eventTags.some((tag) => this.includeTags?.includes(tag));\n    }\n\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(event.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(rootType);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n\n    return include;\n  }\n}\n"],"names":["thing: any","fields: {\n    includeNames?: string[];\n    includeTypes?: string[];\n    includeTags?: string[];\n    excludeNames?: string[];\n    excludeTypes?: string[];\n    excludeTags?: string[];\n  }","event: StreamEvent","rootType: string"],"mappings":";AAIA,SAAgB,oBAAoBA,KAAAA,EAAwC;IAC1E,OAAO,QAAQ,MAAM,WAAA,GAAc;AACpC;;;;;;;GASD,IAAa,mBAAb,MAA8B;IAC5B,aAAA;IAEA,aAAA;IAEA,YAAA;IAEA,aAAA;IAEA,aAAA;IAEA,YAAA;IAEA,YAAYC,MAAAA,CAOT;QACD,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,WAAA,GAAc,OAAO,WAAA;QAC1B,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,WAAA,GAAc,OAAO,WAAA;IAC3B;IAED,aAAaC,KAAAA,EAAoBC,QAAAA,EAA2B;QAC1D,IAAI,UACF,IAAA,CAAK,YAAA,KAAiB,KAAA,KACtB,IAAA,CAAK,YAAA,KAAiB,KAAA,KACtB,IAAA,CAAK,WAAA,KAAgB,KAAA;QACvB,MAAM,YAAY,MAAM,IAAA,IAAQ,CAAE,CAAA;QAElC,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,MAAM,IAAA,CAAK;QAE7D,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,SAAS;QAE3D,IAAI,IAAA,CAAK,WAAA,KAAgB,KAAA,GACvB,UACE,WAAW,UAAU,IAAA,CAAK,CAAC,MAAQ,IAAA,CAAK,WAAA,EAAa,SAAS,IAAI,CAAC;QAGvE,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,CAAC,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,MAAM,IAAA,CAAK;QAE9D,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,CAAC,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,SAAS;QAE5D,IAAI,IAAA,CAAK,WAAA,KAAgB,KAAA,GACvB,UACE,WAAW,UAAU,KAAA,CAAM,CAAC,MAAQ,CAAC,IAAA,CAAK,WAAA,EAAa,SAAS,IAAI,CAAC;QAGzE,OAAO;IACR;AACF"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/graph_mermaid.ts"],"sourcesContent":["import { Edge, Node } from \"./types.js\";\n\nfunction _escapeNodeLabel(nodeLabel: string): string {\n  // Escapes the node label for Mermaid syntax.\n  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\n\nconst MARKDOWN_SPECIAL_CHARS = [\"*\", \"_\", \"`\"];\n\nfunction _generateMermaidGraphStyles(\n  nodeColors: Record<string, string>\n): string {\n  let styles = \"\";\n  for (const [className, color] of Object.entries(nodeColors)) {\n    styles += `\\tclassDef ${className} ${color};\\n`;\n  }\n  return styles;\n}\n\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nexport function drawMermaid(\n  nodes: Record<string, Node>,\n  edges: Edge[],\n  config?: {\n    firstNode?: string;\n    lastNode?: string;\n    curveStyle?: string;\n    withStyles?: boolean;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }\n): string {\n  const {\n    firstNode,\n    lastNode,\n    nodeColors,\n    withStyles = true,\n    curveStyle = \"linear\",\n    wrapLabelNWords = 9,\n  } = config ?? {};\n  // Initialize Mermaid graph configuration\n  let mermaidGraph = withStyles\n    ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n    : \"graph TD;\\n\";\n  if (withStyles) {\n    // Node formatting templates\n    const defaultClassLabel = \"default\";\n    const formatDict: Record<string, string> = {\n      [defaultClassLabel]: \"{0}({1})\",\n    };\n    if (firstNode !== undefined) {\n      formatDict[firstNode] = \"{0}([{1}]):::first\";\n    }\n    if (lastNode !== undefined) {\n      formatDict[lastNode] = \"{0}([{1}]):::last\";\n    }\n\n    // Add nodes to the graph\n    for (const [key, node] of Object.entries(nodes)) {\n      const nodeName = node.name.split(\":\").pop() ?? \"\";\n      const label = MARKDOWN_SPECIAL_CHARS.some(\n        (char) => nodeName.startsWith(char) && nodeName.endsWith(char)\n      )\n        ? `<p>${nodeName}</p>`\n        : nodeName;\n\n      let finalLabel = label;\n      if (Object.keys(node.metadata ?? {}).length) {\n        finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {})\n          .map(([k, v]) => `${k} = ${v}`)\n          .join(\"\\n\")}</em></small>`;\n      }\n\n      const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel])\n        .replace(\"{0}\", _escapeNodeLabel(key))\n        .replace(\"{1}\", finalLabel);\n\n      mermaidGraph += `\\t${nodeLabel}\\n`;\n    }\n  }\n\n  // Group edges by their common prefixes\n  const edgeGroups: Record<string, Edge[]> = {};\n  for (const edge of edges) {\n    const srcParts = edge.source.split(\":\");\n    const tgtParts = edge.target.split(\":\");\n    const commonPrefix = srcParts\n      .filter((src, i) => src === tgtParts[i])\n      .join(\":\");\n    if (!edgeGroups[commonPrefix]) {\n      edgeGroups[commonPrefix] = [];\n    }\n    edgeGroups[commonPrefix].push(edge);\n  }\n\n  const seenSubgraphs = new Set<string>();\n\n  function addSubgraph(edges: Edge[], prefix: string): void {\n    const selfLoop = edges.length === 1 && edges[0].source === edges[0].target;\n    if (prefix && !selfLoop) {\n      const subgraph = prefix.split(\":\").pop()!;\n      if (seenSubgraphs.has(subgraph)) {\n        throw new Error(\n          `Found duplicate subgraph '${subgraph}' -- this likely means that ` +\n            \"you're reusing a subgraph node with the same name. \" +\n            \"Please adjust your graph to have subgraph nodes with unique names.\"\n        );\n      }\n\n      seenSubgraphs.add(subgraph);\n      mermaidGraph += `\\tsubgraph ${subgraph}\\n`;\n    }\n\n    for (const edge of edges) {\n      const { source, target, data, conditional } = edge;\n\n      let edgeLabel = \"\";\n      if (data !== undefined) {\n        let edgeData = data;\n        const words = edgeData.split(\" \");\n        if (words.length > wrapLabelNWords) {\n          edgeData = Array.from(\n            { length: Math.ceil(words.length / wrapLabelNWords) },\n            (_, i) =>\n              words\n                .slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords)\n                .join(\" \")\n          ).join(\"&nbsp;<br>&nbsp;\");\n        }\n        edgeLabel = conditional\n          ? ` -. &nbsp;${edgeData}&nbsp; .-> `\n          : ` -- &nbsp;${edgeData}&nbsp; --> `;\n      } else {\n        edgeLabel = conditional ? \" -.-> \" : \" --> \";\n      }\n\n      mermaidGraph += `\\t${_escapeNodeLabel(\n        source\n      )}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n    }\n\n    // Recursively add nested subgraphs\n    for (const nestedPrefix in edgeGroups) {\n      if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {\n        addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);\n      }\n    }\n\n    if (prefix && !selfLoop) {\n      mermaidGraph += \"\\tend\\n\";\n    }\n  }\n\n  // Start with the top-level edges (no common prefix)\n  addSubgraph(edgeGroups[\"\"] ?? [], \"\");\n\n  // Add remaining subgraphs\n  for (const prefix in edgeGroups) {\n    if (!prefix.includes(\":\") && prefix !== \"\") {\n      addSubgraph(edgeGroups[prefix], prefix);\n    }\n  }\n\n  // Add custom styles for nodes\n  if (withStyles) {\n    mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});\n  }\n\n  return mermaidGraph;\n}\n\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n *\n * @example\n * ```javascript\n * const image = await drawMermaidImage(mermaidSyntax, {\n *   backgroundColor: \"white\",\n *   imageType: \"png\",\n * });\n * fs.writeFileSync(\"image.png\", image);\n * ```\n *\n * @param mermaidSyntax - The Mermaid syntax to render.\n * @param config - The configuration for the image.\n * @returns The image as a Blob.\n */\nexport async function drawMermaidImage(\n  mermaidSyntax: string,\n  config?: {\n    /**\n     * The type of image to render.\n     * @default \"png\"\n     */\n    imageType?: \"png\" | \"jpeg\" | \"webp\";\n    backgroundColor?: string;\n  }\n) {\n  let backgroundColor = config?.backgroundColor ?? \"white\";\n  const imageType = config?.imageType ?? \"png\";\n\n  // Use btoa for compatibility, assume ASCII\n  const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n  // Check if the background color is a hexadecimal color code using regex\n  if (backgroundColor !== undefined) {\n    const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n    if (!hexColorPattern.test(backgroundColor)) {\n      backgroundColor = `!${backgroundColor}`;\n    }\n  }\n  const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;\n  const res = await fetch(imageUrl);\n  if (!res.ok) {\n    throw new Error(\n      [\n        `Failed to render the graph using the Mermaid.INK API.`,\n        `Status code: ${res.status}`,\n        `Status text: ${res.statusText}`,\n      ].join(\"\\n\")\n    );\n  }\n  const content = await res.blob();\n  return content;\n}\n"],"names":["nodeLabel: string","nodeColors: Record<string, string>","nodes: Record<string, Node>","edges: Edge[]","config?: {\n    firstNode?: string;\n    lastNode?: string;\n    curveStyle?: string;\n    withStyles?: boolean;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }","formatDict: Record<string, string>","edgeGroups: Record<string, Edge[]>","prefix: string","edges","mermaidSyntax: string","config?: {\n    /**\n     * The type of image to render.\n     * @default \"png\"\n     */\n    imageType?: \"png\" | \"jpeg\" | \"webp\";\n    backgroundColor?: string;\n  }"],"mappings":"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"}},
    {"offset": {"line": 312, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/graph.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/graph.ts"],"sourcesContent":["import { v4 as uuidv4, validate as isUuid } from \"uuid\";\nimport type {\n  RunnableInterface,\n  RunnableIOSchema,\n  Node,\n  Edge,\n} from \"./types.js\";\nimport { isRunnableInterface } from \"./utils.js\";\nimport { drawMermaid, drawMermaidImage } from \"./graph_mermaid.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\n\nexport { Node, Edge };\n\nfunction nodeDataStr(\n  id: string | undefined,\n  data: RunnableInterface | RunnableIOSchema\n): string {\n  if (id !== undefined && !isUuid(id)) {\n    return id;\n  } else if (isRunnableInterface(data)) {\n    try {\n      let dataStr = data.getName();\n      dataStr = dataStr.startsWith(\"Runnable\")\n        ? dataStr.slice(\"Runnable\".length)\n        : dataStr;\n      return dataStr;\n    } catch {\n      return data.getName();\n    }\n  } else {\n    return data.name ?? \"UnknownSchema\";\n  }\n}\n\nfunction nodeDataJson(node: Node) {\n  // if node.data implements Runnable\n  if (isRunnableInterface(node.data)) {\n    return {\n      type: \"runnable\",\n      data: {\n        id: node.data.lc_id,\n        name: node.data.getName(),\n      },\n    };\n  } else {\n    return {\n      type: \"schema\",\n      data: { ...toJsonSchema(node.data.schema), title: node.data.name },\n    };\n  }\n}\n\nexport class Graph {\n  nodes: Record<string, Node> = {};\n\n  edges: Edge[] = [];\n\n  constructor(params?: { nodes: Record<string, Node>; edges: Edge[] }) {\n    this.nodes = params?.nodes ?? this.nodes;\n    this.edges = params?.edges ?? this.edges;\n  }\n\n  // Convert the graph to a JSON-serializable format.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): Record<string, any> {\n    const stableNodeIds: Record<string, string | number> = {};\n    Object.values(this.nodes).forEach((node, i) => {\n      stableNodeIds[node.id] = isUuid(node.id) ? i : node.id;\n    });\n\n    return {\n      nodes: Object.values(this.nodes).map((node) => ({\n        id: stableNodeIds[node.id],\n        ...nodeDataJson(node),\n      })),\n      edges: this.edges.map((edge) => {\n        const item: Record<string, unknown> = {\n          source: stableNodeIds[edge.source],\n          target: stableNodeIds[edge.target],\n        };\n\n        if (typeof edge.data !== \"undefined\") {\n          item.data = edge.data;\n        }\n\n        if (typeof edge.conditional !== \"undefined\") {\n          item.conditional = edge.conditional;\n        }\n        return item;\n      }),\n    };\n  }\n\n  addNode(\n    data: RunnableInterface | RunnableIOSchema,\n    id?: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>\n  ): Node {\n    if (id !== undefined && this.nodes[id] !== undefined) {\n      throw new Error(`Node with id ${id} already exists`);\n    }\n    const nodeId = id ?? uuidv4();\n    const node: Node = {\n      id: nodeId,\n      data,\n      name: nodeDataStr(id, data),\n      metadata,\n    };\n    this.nodes[nodeId] = node;\n    return node;\n  }\n\n  removeNode(node: Node): void {\n    // Remove the node from the nodes map\n    delete this.nodes[node.id];\n\n    // Filter out edges connected to the node\n    this.edges = this.edges.filter(\n      (edge) => edge.source !== node.id && edge.target !== node.id\n    );\n  }\n\n  addEdge(\n    source: Node,\n    target: Node,\n    data?: string,\n    conditional?: boolean\n  ): Edge {\n    if (this.nodes[source.id] === undefined) {\n      throw new Error(`Source node ${source.id} not in graph`);\n    }\n    if (this.nodes[target.id] === undefined) {\n      throw new Error(`Target node ${target.id} not in graph`);\n    }\n    const edge: Edge = {\n      source: source.id,\n      target: target.id,\n      data,\n      conditional,\n    };\n    this.edges.push(edge);\n    return edge;\n  }\n\n  firstNode(): Node | undefined {\n    return _firstNode(this);\n  }\n\n  lastNode(): Node | undefined {\n    return _lastNode(this);\n  }\n\n  /**\n   * Add all nodes and edges from another graph.\n   * Note this doesn't check for duplicates, nor does it connect the graphs.\n   */\n  extend(graph: Graph, prefix = \"\") {\n    let finalPrefix = prefix;\n    const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n    if (nodeIds.every(isUuid)) {\n      finalPrefix = \"\";\n    }\n\n    const prefixed = (id: string) => {\n      return finalPrefix ? `${finalPrefix}:${id}` : id;\n    };\n\n    Object.entries(graph.nodes).forEach(([key, value]) => {\n      this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n    });\n\n    const newEdges = graph.edges.map((edge) => {\n      return {\n        ...edge,\n        source: prefixed(edge.source),\n        target: prefixed(edge.target),\n      };\n    });\n    // Add all edges from the other graph\n    this.edges = [...this.edges, ...newEdges];\n    const first = graph.firstNode();\n    const last = graph.lastNode();\n    return [\n      first ? { id: prefixed(first.id), data: first.data } : undefined,\n      last ? { id: prefixed(last.id), data: last.data } : undefined,\n    ];\n  }\n\n  trimFirstNode(): void {\n    const firstNode = this.firstNode();\n    if (firstNode && _firstNode(this, [firstNode.id])) {\n      this.removeNode(firstNode);\n    }\n  }\n\n  trimLastNode(): void {\n    const lastNode = this.lastNode();\n    if (lastNode && _lastNode(this, [lastNode.id])) {\n      this.removeNode(lastNode);\n    }\n  }\n\n  /**\n   * Return a new graph with all nodes re-identified,\n   * using their unique, readable names where possible.\n   */\n  reid(): Graph {\n    const nodeLabels: Record<string, string> = Object.fromEntries(\n      Object.values(this.nodes).map((node) => [node.id, node.name])\n    );\n    const nodeLabelCounts = new Map<string, number>();\n    Object.values(nodeLabels).forEach((label) => {\n      nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n    });\n\n    const getNodeId = (nodeId: string): string => {\n      const label = nodeLabels[nodeId];\n      if (isUuid(nodeId) && nodeLabelCounts.get(label) === 1) {\n        return label;\n      } else {\n        return nodeId;\n      }\n    };\n\n    return new Graph({\n      nodes: Object.fromEntries(\n        Object.entries(this.nodes).map(([id, node]) => [\n          getNodeId(id),\n          { ...node, id: getNodeId(id) },\n        ])\n      ),\n      edges: this.edges.map((edge) => ({\n        ...edge,\n        source: getNodeId(edge.source),\n        target: getNodeId(edge.target),\n      })),\n    });\n  }\n\n  drawMermaid(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }): string {\n    const {\n      withStyles,\n      curveStyle,\n      nodeColors = {\n        default: \"fill:#f2f0ff,line-height:1.2\",\n        first: \"fill-opacity:0\",\n        last: \"fill:#bfb6fc\",\n      },\n      wrapLabelNWords,\n    } = params ?? {};\n    const graph = this.reid();\n    const firstNode = graph.firstNode();\n\n    const lastNode = graph.lastNode();\n\n    return drawMermaid(graph.nodes, graph.edges, {\n      firstNode: firstNode?.id,\n      lastNode: lastNode?.id,\n      withStyles,\n      curveStyle,\n      nodeColors,\n      wrapLabelNWords,\n    });\n  }\n\n  async drawMermaidPng(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }): Promise<Blob> {\n    const mermaidSyntax = this.drawMermaid(params);\n    return drawMermaidImage(mermaidSyntax, {\n      backgroundColor: params?.backgroundColor,\n    });\n  }\n}\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph: Graph, exclude: string[] = []): Node | undefined {\n  const targets = new Set(\n    graph.edges\n      .filter((edge) => !exclude.includes(edge.source))\n      .map((edge) => edge.target)\n  );\n\n  const found: Node[] = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !targets.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}\n\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph: Graph, exclude: string[] = []): Node | undefined {\n  const sources = new Set(\n    graph.edges\n      .filter((edge) => !exclude.includes(edge.target))\n      .map((edge) => edge.source)\n  );\n\n  const found: Node[] = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !sources.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}\n"],"names":["id: string | undefined","data: RunnableInterface | RunnableIOSchema","isRunnableInterface","node: Node","toJsonSchema","params?: { nodes: Record<string, Node>; edges: Edge[] }","stableNodeIds: Record<string, string | number>","item: Record<string, unknown>","id?: string","metadata?: Record<string, any>","source: Node","target: Node","data?: string","conditional?: boolean","edge: Edge","graph: Graph","isUuid","id: string","nodeLabels: Record<string, string>","nodeId: string","params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }","drawMermaid","params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }","drawMermaidImage","exclude: string[]","found: Node[]"],"mappings":";;;;;;;;;;AAaA,SAAS,YACPA,EAAAA,EACAC,IAAAA,EACQ;IACR,IAAI,OAAO,KAAA,KAAa,CAAA,CAAA,GAAA,KAAA,QAAA,EAAQ,GAAG,CACjC,CAAA,OAAO;aACEC,cAAAA,mBAAAA,CAAoB,KAAK,CAClC,CAAA,IAAI;QACF,IAAI,UAAU,KAAK,OAAA,EAAS;QAC5B,UAAU,QAAQ,UAAA,CAAW,WAAW,GACpC,QAAQ,KAAA,CAAM,EAAkB,GAChC;QACJ,OAAO;IACR,EAAA,OAAO;QACN,OAAO,KAAK,OAAA,EAAS;IACtB;SAED,OAAO,KAAK,IAAA,IAAQ;AAEvB;AAED,SAAS,aAAaC,IAAAA,EAAY;IAEhC,IAAID,cAAAA,mBAAAA,CAAoB,KAAK,IAAA,CAAK,CAChC,CAAA,OAAO;QACL,MAAM;QACN,MAAM;YACJ,IAAI,KAAK,IAAA,CAAK,KAAA;YACd,MAAM,KAAK,IAAA,CAAK,OAAA,EAAS;QAC1B;IACF;SAED,OAAO;QACL,MAAM;QACN,MAAM;YAAE,GAAGE,0BAAAA,YAAAA,CAAa,KAAK,IAAA,CAAK,MAAA,CAAO;YAAE,OAAO,KAAK,IAAA,CAAK,IAAA;QAAM;IACnE;AAEJ;AAED,IAAa,QAAb,MAAa,MAAM;IACjB,QAA8B,CAAE,EAAA;IAEhC,QAAgB,CAAE,CAAA,CAAA;IAElB,YAAYC,MAAAA,CAAyD;QACnE,IAAA,CAAK,KAAA,GAAQ,QAAQ,SAAS,IAAA,CAAK,KAAA;QACnC,IAAA,CAAK,KAAA,GAAQ,QAAQ,SAAS,IAAA,CAAK,KAAA;IACpC;IAID,SAA8B;QAC5B,MAAMC,gBAAiD,CAAE;QACzD,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,CAAC,OAAA,CAAQ,CAAC,MAAM,MAAM;YAC7C,aAAA,CAAc,KAAK,EAAA,CAAA,GAAA,CAAA,GAAA,KAAA,QAAA,EAAa,KAAK,EAAA,CAAG,GAAG,IAAI,KAAK,EAAA;QACrD,EAAC;QAEF,OAAO;YACL,OAAO,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,OAAA,CAAU;oBAC9C,IAAI,aAAA,CAAc,KAAK,EAAA,CAAA;oBACvB,GAAG,aAAa,KAAK;gBACtB,CAAA,EAAE;YACH,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,CAAC,SAAS;gBAC9B,MAAMC,OAAgC;oBACpC,QAAQ,aAAA,CAAc,KAAK,MAAA,CAAA;oBAC3B,QAAQ,aAAA,CAAc,KAAK,MAAA,CAAA;gBAC5B;gBAED,IAAI,OAAO,KAAK,IAAA,KAAS,aACvB,KAAK,IAAA,GAAO,KAAK,IAAA;gBAGnB,IAAI,OAAO,KAAK,WAAA,KAAgB,aAC9B,KAAK,WAAA,GAAc,KAAK,WAAA;gBAE1B,OAAO;YACR,EAAC;QACH;IACF;IAED,QACEN,IAAAA,EACAO,EAAAA,EAEAC,QAAAA,EACM;QACN,IAAI,OAAO,KAAA,KAAa,IAAA,CAAK,KAAA,CAAM,GAAA,KAAQ,KAAA,EACzC,CAAA,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,GAAG,eAAe,CAAC;QAErD,MAAM,SAAS,MAAA,CAAA,GAAA,KAAA,EAAA,GAAc;QAC7B,MAAMN,OAAa;YACjB,IAAI;YACJ;YACA,MAAM,YAAY,IAAI,KAAK;YAC3B;QACD;QACD,IAAA,CAAK,KAAA,CAAM,OAAA,GAAU;QACrB,OAAO;IACR;IAED,WAAWA,IAAAA,EAAkB;QAE3B,OAAO,IAAA,CAAK,KAAA,CAAM,KAAK,EAAA,CAAA;QAGvB,IAAA,CAAK,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,MAAA,CACtB,CAAC,OAAS,KAAK,MAAA,KAAW,KAAK,EAAA,IAAM,KAAK,MAAA,KAAW,KAAK,EAAA,CAC3D;IACF;IAED,QACEO,MAAAA,EACAC,MAAAA,EACAC,IAAAA,EACAC,WAAAA,EACM;QACN,IAAI,IAAA,CAAK,KAAA,CAAM,OAAO,EAAA,CAAA,KAAQ,KAAA,EAC5B,CAAA,MAAM,IAAI,MAAM,CAAC,YAAY,EAAE,OAAO,EAAA,CAAG,aAAa,CAAC;QAEzD,IAAI,IAAA,CAAK,KAAA,CAAM,OAAO,EAAA,CAAA,KAAQ,KAAA,EAC5B,CAAA,MAAM,IAAI,MAAM,CAAC,YAAY,EAAE,OAAO,EAAA,CAAG,aAAa,CAAC;QAEzD,MAAMC,OAAa;YACjB,QAAQ,OAAO,EAAA;YACf,QAAQ,OAAO,EAAA;YACf;YACA;QACD;QACD,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,KAAK;QACrB,OAAO;IACR;IAED,YAA8B;QAC5B,OAAO,WAAW,IAAA,CAAK;IACxB;IAED,WAA6B;QAC3B,OAAO,UAAU,IAAA,CAAK;IACvB;;;;IAMD,OAAOC,KAAAA,EAAc,SAAS,EAAA,EAAI;QAChC,IAAI,cAAc;QAClB,MAAM,UAAU,OAAO,MAAA,CAAO,MAAM,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,OAAS,KAAK,EAAA,CAAG;QACjE,IAAI,QAAQ,KAAA,CAAMC,KAAAA,QAAAA,CAAO,EACvB,cAAc;QAGhB,MAAM,WAAW,CAACC,OAAe;YAC/B,OAAO,cAAc,GAAG,YAAY,CAAC,EAAE,IAAI,GAAG;QAC/C;QAED,OAAO,OAAA,CAAQ,MAAM,KAAA,CAAM,CAAC,OAAA,CAAQ,CAAC,CAAC,KAAK,MAAM,KAAK;YACpD,IAAA,CAAK,KAAA,CAAM,SAAS,IAAI,CAAA,GAAI;gBAAE,GAAG,KAAA;gBAAO,IAAI,SAAS,IAAI;YAAE;QAC5D,EAAC;QAEF,MAAM,WAAW,MAAM,KAAA,CAAM,GAAA,CAAI,CAAC,SAAS;YACzC,OAAO;gBACL,GAAG,IAAA;gBACH,QAAQ,SAAS,KAAK,MAAA,CAAO;gBAC7B,QAAQ,SAAS,KAAK,MAAA,CAAO;YAC9B;QACF,EAAC;QAEF,IAAA,CAAK,KAAA,GAAQ,CAAC;eAAG,IAAA,CAAK,KAAA,EAAO;eAAG,QAAS;SAAA;QACzC,MAAM,QAAQ,MAAM,SAAA,EAAW;QAC/B,MAAM,OAAO,MAAM,QAAA,EAAU;QAC7B,OAAO;YACL,QAAQ;gBAAE,IAAI,SAAS,MAAM,EAAA,CAAG;gBAAE,MAAM,MAAM,IAAA;YAAM,IAAG,KAAA;YACvD,OAAO;gBAAE,IAAI,SAAS,KAAK,EAAA,CAAG;gBAAE,MAAM,KAAK,IAAA;YAAM,IAAG,KAAA,CACrD;SAAA;IACF;IAED,gBAAsB;QACpB,MAAM,YAAY,IAAA,CAAK,SAAA,EAAW;QAClC,IAAI,aAAa,WAAW,IAAA,EAAM;YAAC,UAAU,EAAG;SAAA,CAAC,EAC/C,IAAA,CAAK,UAAA,CAAW,UAAU;IAE7B;IAED,eAAqB;QACnB,MAAM,WAAW,IAAA,CAAK,QAAA,EAAU;QAChC,IAAI,YAAY,UAAU,IAAA,EAAM;YAAC,SAAS,EAAG;SAAA,CAAC,EAC5C,IAAA,CAAK,UAAA,CAAW,SAAS;IAE5B;;;;IAMD,OAAc;QACZ,MAAMC,aAAqC,OAAO,WAAA,CAChD,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,OAAS;gBAAC,KAAK,EAAA;gBAAI,KAAK,IAAK;aAAA,CAAC,CAC9D;QACD,MAAM,kBAAA,aAAA,GAAkB,IAAI;QAC5B,OAAO,MAAA,CAAO,WAAW,CAAC,OAAA,CAAQ,CAAC,UAAU;YAC3C,gBAAgB,GAAA,CAAI,OAAA,CAAQ,gBAAgB,GAAA,CAAI,MAAM,IAAI,CAAA,IAAK,EAAE;QAClE,EAAC;QAEF,MAAM,YAAY,CAACC,WAA2B;YAC5C,MAAM,QAAQ,UAAA,CAAW,OAAA;YACzB,IAAA,CAAA,GAAA,KAAA,QAAA,EAAW,OAAO,IAAI,gBAAgB,GAAA,CAAI,MAAM,KAAK,EACnD,CAAA,OAAO;iBAEP,OAAO;QAEV;QAED,OAAO,IAAI,MAAM;YACf,OAAO,OAAO,WAAA,CACZ,OAAO,OAAA,CAAQ,IAAA,CAAK,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,CAAC,IAAI,KAAK,GAAK;oBAC7C,UAAU,GAAG;oBACb;wBAAE,GAAG,IAAA;wBAAM,IAAI,UAAU,GAAG;oBAAE,CAC/B;iBAAA,CAAC,CACH;YACD,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,CAAC,OAAA,CAAU;oBAC/B,GAAG,IAAA;oBACH,QAAQ,UAAU,KAAK,MAAA,CAAO;oBAC9B,QAAQ,UAAU,KAAK,MAAA,CAAO;gBAC/B,CAAA,EAAE;QACJ;IACF;IAED,YAAYC,MAAAA,EAKD;QACT,MAAM,EACJ,UAAA,EACA,UAAA,EACA,aAAa;YACX,SAAS;YACT,OAAO;YACP,MAAM;QACP,CAAA,EACD,eAAA,EACD,GAAG,UAAU,CAAE;QAChB,MAAM,QAAQ,IAAA,CAAK,IAAA,EAAM;QACzB,MAAM,YAAY,MAAM,SAAA,EAAW;QAEnC,MAAM,WAAW,MAAM,QAAA,EAAU;QAEjC,OAAOC,sBAAAA,WAAAA,CAAY,MAAM,KAAA,EAAO,MAAM,KAAA,EAAO;YAC3C,WAAW,WAAW;YACtB,UAAU,UAAU;YACpB;YACA;YACA;YACA;QACD,EAAC;IACH;IAED,MAAM,eAAeC,MAAAA,EAMH;QAChB,MAAM,gBAAgB,IAAA,CAAK,WAAA,CAAY,OAAO;QAC9C,OAAOC,sBAAAA,gBAAAA,CAAiB,eAAe;YACrC,iBAAiB,QAAQ;QAC1B,EAAC;IACH;AACF;;;;;;GAOD,SAAS,WAAWR,KAAAA,EAAcS,UAAoB,CAAE,CAAA,EAAoB;IAC1E,MAAM,UAAU,IAAI,IAClB,MAAM,KAAA,CACH,MAAA,CAAO,CAAC,OAAS,CAAC,QAAQ,QAAA,CAAS,KAAK,MAAA,CAAO,CAAC,CAChD,GAAA,CAAI,CAAC,OAAS,KAAK,MAAA,CAAO;IAG/B,MAAMC,QAAgB,CAAE,CAAA;IACxB,KAAK,MAAM,QAAQ,OAAO,MAAA,CAAO,MAAM,KAAA,CAAM,CAC3C,IAAI,CAAC,QAAQ,QAAA,CAAS,KAAK,EAAA,CAAG,IAAI,CAAC,QAAQ,GAAA,CAAI,KAAK,EAAA,CAAG,EACrD,MAAM,IAAA,CAAK,KAAK;IAGpB,OAAO,MAAM,MAAA,KAAW,IAAI,KAAA,CAAM,EAAA,GAAK,KAAA;AACxC;;;;;;GAQD,SAAS,UAAUV,KAAAA,EAAcS,UAAoB,CAAE,CAAA,EAAoB;IACzE,MAAM,UAAU,IAAI,IAClB,MAAM,KAAA,CACH,MAAA,CAAO,CAAC,OAAS,CAAC,QAAQ,QAAA,CAAS,KAAK,MAAA,CAAO,CAAC,CAChD,GAAA,CAAI,CAAC,OAAS,KAAK,MAAA,CAAO;IAG/B,MAAMC,QAAgB,CAAE,CAAA;IACxB,KAAK,MAAM,QAAQ,OAAO,MAAA,CAAO,MAAM,KAAA,CAAM,CAC3C,IAAI,CAAC,QAAQ,QAAA,CAAS,KAAK,EAAA,CAAG,IAAI,CAAC,QAAQ,GAAA,CAAI,KAAK,EAAA,CAAG,EACrD,MAAM,IAAA,CAAK,KAAK;IAGpB,OAAO,MAAM,MAAA,KAAW,IAAI,KAAA,CAAM,EAAA,GAAK,KAAA;AACxC"}},
    {"offset": {"line": 553, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/wrappers.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/wrappers.ts"],"sourcesContent":["import { IterableReadableStream } from \"../utils/stream.js\";\n\nexport function convertToHttpEventStream(stream: AsyncGenerator) {\n  const encoder = new TextEncoder();\n  const finalStream = new ReadableStream<Uint8Array>({\n    async start(controller) {\n      for await (const chunk of stream) {\n        controller.enqueue(\n          encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`)\n        );\n      }\n      controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n      controller.close();\n    },\n  });\n  return IterableReadableStream.fromReadableStream(finalStream);\n}\n"],"names":["stream: AsyncGenerator","IterableReadableStream"],"mappings":";;AAEA,SAAgB,yBAAyBA,MAAAA,EAAwB;IAC/D,MAAM,UAAU,IAAI;IACpB,MAAM,cAAc,IAAI,eAA2B;QACjD,MAAM,OAAM,UAAA,EAAY;YACtB,WAAW,MAAM,SAAS,OACxB,WAAW,OAAA,CACT,QAAQ,MAAA,CAAO,CAAC,mBAAmB,EAAE,KAAK,SAAA,CAAU,MAAM,CAAC,IAAI,CAAC,CAAC,CAClE;YAEH,WAAW,OAAA,CAAQ,QAAQ,MAAA,CAAO,iBAAiB,CAAC;YACpD,WAAW,KAAA,EAAO;QACnB;IACF;IACD,OAAOC,qBAAAA,sBAAAA,CAAuB,kBAAA,CAAmB,YAAY;AAC9D"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/iter.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/iter.ts"],"sourcesContent":["import type { RunnableConfig } from \"../runnables/types.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { pickRunnableConfigKeys } from \"./config.js\";\n\nexport function isIterableIterator(\n  thing: unknown\n): thing is IterableIterator<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as Generator)[Symbol.iterator] === \"function\" &&\n    // avoid detecting array/set as iterator\n    typeof (thing as Generator).next === \"function\"\n  );\n}\n\nexport const isIterator = (x: unknown): x is Iterator<unknown> =>\n  x != null &&\n  typeof x === \"object\" &&\n  \"next\" in x &&\n  typeof x.next === \"function\";\n\nexport function isAsyncIterable(\n  thing: unknown\n): thing is AsyncIterable<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as AsyncIterable<unknown>)[Symbol.asyncIterator] ===\n      \"function\"\n  );\n}\n\nexport function* consumeIteratorInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: IterableIterator<T>\n): IterableIterator<T> {\n  while (true) {\n    const { value, done } = AsyncLocalStorageProviderSingleton.runWithConfig(\n      pickRunnableConfigKeys(context),\n      iter.next.bind(iter),\n      true\n    );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n\nexport async function* consumeAsyncIterableInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: AsyncIterable<T>\n): AsyncIterableIterator<T> {\n  const iterator = iter[Symbol.asyncIterator]();\n  while (true) {\n    const { value, done } =\n      await AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(context),\n        iterator.next.bind(iter),\n        true\n      );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n"],"names":["thing: unknown","x: unknown","context: Partial<RunnableConfig> | undefined","iter: IterableIterator<T>","AsyncLocalStorageProviderSingleton","pickRunnableConfigKeys","iter: AsyncIterable<T>"],"mappings":";;;;AAIA,SAAgB,mBACdA,KAAAA,EACoC;IACpC,OACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAQ,KAAA,CAAoB,OAAO,QAAA,CAAA,KAAc,cAEjD,OAAQ,MAAoB,IAAA,KAAS;AAExC;AAED,MAAa,aAAa,CAACC,IACzB,KAAK,QACL,OAAO,MAAM,YACb,UAAU,KACV,OAAO,EAAE,IAAA,KAAS;AAEpB,SAAgB,gBACdD,KAAAA,EACiC;IACjC,OACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAQ,KAAA,CAAiC,OAAO,aAAA,CAAA,KAC9C;AAEL;AAED,UAAiB,yBACfE,OAAAA,EACAC,IAAAA,EACqB;IACrB,MAAO,KAAM;QACX,MAAM,EAAE,KAAA,EAAO,IAAA,EAAM,GAAGC,cAAAA,kCAAAA,CAAmC,aAAA,CACzDC,eAAAA,sBAAAA,CAAuB,QAAQ,EAC/B,KAAK,IAAA,CAAK,IAAA,CAAK,KAAK,EACpB,KACD;QACD,IAAI,KACF,CAAA;aAEA,MAAM;IAET;AACF;AAED,gBAAuB,8BACrBH,OAAAA,EACAI,IAAAA,EAC0B;IAC1B,MAAM,WAAW,IAAA,CAAK,OAAO,aAAA,CAAA,EAAgB;IAC7C,MAAO,KAAM;QACX,MAAM,EAAE,KAAA,EAAO,IAAA,EAAM,GACnB,MAAMF,cAAAA,kCAAAA,CAAmC,aAAA,CACvCC,eAAAA,sBAAAA,CAAuB,QAAQ,EAC/B,SAAS,IAAA,CAAK,IAAA,CAAK,KAAK,EACxB,KACD;QACH,IAAI,KACF,CAAA;aAEA,MAAM;IAET;AACF"}},
    {"offset": {"line": 606, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/base.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/base.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport {\n  type TraceableFunction,\n  isTraceableFunction,\n} from \"langsmith/singletons/traceable\";\nimport type {\n  RunnableInterface,\n  RunnableBatchOptions,\n  RunnableConfig,\n} from \"./types.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport {\n  LogStreamCallbackHandler,\n  LogStreamCallbackHandlerInput,\n  RunLog,\n  RunLogPatch,\n  isLogStreamHandler,\n} from \"../tracers/log_stream.js\";\nimport {\n  EventStreamCallbackHandler,\n  EventStreamCallbackHandlerInput,\n  StreamEvent,\n  StreamEventData,\n  isStreamEventsHandler,\n} from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport {\n  IterableReadableStream,\n  concat,\n  atee,\n  pipeGeneratorWithSetup,\n  AsyncGeneratorWithSetup,\n} from \"../utils/stream.js\";\nimport { raceWithSignal, getAbortSignalError } from \"../utils/signal.js\";\nimport {\n  DEFAULT_RECURSION_LIMIT,\n  ensureConfig,\n  getCallbackManagerForConfig,\n  mergeConfigs,\n  patchConfig,\n  pickRunnableConfigKeys,\n} from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { Run } from \"../tracers/base.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport {\n  consumeAsyncIterableInContext,\n  consumeIteratorInContext,\n  isAsyncIterable,\n  isIterableIterator,\n  isIterator,\n} from \"./iter.js\";\nimport { _isToolCall, ToolInputParsingException } from \"../tools/utils.js\";\nimport { ToolCall } from \"../messages/tool.js\";\nimport {\n  getSchemaDescription,\n  InferInteropZodOutput,\n  interopParseAsync,\n  InteropZodType,\n  isSimpleStringZodSchema,\n} from \"../utils/types/zod.js\";\n\nexport { type RunnableInterface, RunnableBatchOptions };\n\nexport type RunnableFunc<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> = (\n  input: RunInput,\n  options:\n    | CallOptions\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | Record<string, any>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | (Record<string, any> & CallOptions)\n) => RunOutput | Promise<RunOutput>;\n\nexport type RunnableMapLike<RunInput, RunOutput> = {\n  [K in keyof RunOutput]: RunnableLike<RunInput, RunOutput[K]>;\n};\n\nexport type RunnableLike<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends RunnableConfig = RunnableConfig\n> =\n  | RunnableInterface<RunInput, RunOutput, CallOptions>\n  | RunnableFunc<RunInput, RunOutput, CallOptions>\n  | RunnableMapLike<RunInput, RunOutput>;\n\nexport type RunnableRetryFailedAttemptHandler = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error: any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value: any, defaultKey: string) {\n  return value &&\n    !Array.isArray(value) &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    !(value instanceof Date) &&\n    typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport abstract class Runnable<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Serializable\n  implements RunnableInterface<RunInput, RunOutput, CallOptions>\n{\n  protected lc_runnable = true;\n\n  name?: string;\n\n  getName(suffix?: string): string {\n    const name =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.name ?? (this.constructor as any).lc_name() ?? this.constructor.name;\n    return suffix ? `${name}${suffix}` : name;\n  }\n\n  abstract invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput>;\n\n  /**\n   * Add retry logic to an existing runnable.\n   * @param fields.stopAfterAttempt The number of attempts to retry.\n   * @param fields.onFailedAttempt A function that is called when a retry fails.\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }): RunnableRetry<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields,\n    });\n  }\n\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(\n    config: Partial<CallOptions>\n  ): Runnable<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {},\n    });\n  }\n\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(\n    fields:\n      | {\n          fallbacks: Runnable<RunInput, RunOutput>[];\n        }\n      | Runnable<RunInput, RunOutput>[]\n  ): RunnableWithFallbacks<RunInput, RunOutput> {\n    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks<RunInput, RunOutput>({\n      runnable: this,\n      fallbacks,\n    });\n  }\n\n  protected _getOptionsList<O extends CallOptions & { runType?: string }>(\n    options: Partial<O> | Partial<O>[],\n    length = 0\n  ): Partial<O>[] {\n    if (Array.isArray(options) && options.length !== length) {\n      throw new Error(\n        `Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`\n      );\n    }\n\n    if (Array.isArray(options)) {\n      return options.map(ensureConfig);\n    }\n    if (length > 1 && !Array.isArray(options) && options.runId) {\n      console.warn(\n        \"Provided runId will be used only for the first element of the batch.\"\n      );\n      const subsequent = Object.fromEntries(\n        Object.entries(options).filter(([key]) => key !== \"runId\")\n      );\n\n      return Array.from({ length }, (_, i) =>\n        ensureConfig(i === 0 ? options : subsequent)\n      ) as Partial<O>[];\n    }\n    return Array.from({ length }, () => ensureConfig(options));\n  }\n\n  /**\n   * Default implementation of batch, which calls invoke N times.\n   * Subclasses should override this method if they can batch more efficiently.\n   * @param inputs Array of inputs to each batch call.\n   * @param options Either a single call options object to apply to each batch call or an array for each call.\n   * @param batchOptions.returnExceptions Whether to return errors rather than throwing on the first one\n   * @returns An array of RunOutputs, or mixed RunOutputs and errors if batchOptions.returnExceptions is set\n   */\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: (e) => {\n        throw e;\n      },\n    });\n    const batchCalls = inputs.map((input, i) =>\n      caller.call(async () => {\n        try {\n          const result = await this.invoke(input, configList[i]);\n          return result;\n        } catch (e) {\n          if (batchOptions?.returnExceptions) {\n            return e as Error;\n          }\n          throw e;\n        }\n      })\n    );\n    return Promise.all(batchCalls);\n  }\n\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    yield this.invoke(input, options);\n  }\n\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this._streamIterator(input, config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n\n  protected _separateRunnableConfigFromCallOptions(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, Omit<Partial<CallOptions>, keyof RunnableConfig>] {\n    let runnableConfig;\n    if (options === undefined) {\n      runnableConfig = ensureConfig(options);\n    } else {\n      runnableConfig = ensureConfig({\n        callbacks: options.callbacks,\n        tags: options.tags,\n        metadata: options.metadata,\n        runName: options.runName,\n        configurable: options.configurable,\n        recursionLimit: options.recursionLimit,\n        maxConcurrency: options.maxConcurrency,\n        runId: options.runId,\n        timeout: options.timeout,\n        signal: options.signal,\n      });\n    }\n    const callOptions = { ...(options as Partial<CallOptions>) };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    delete callOptions.runId;\n    delete callOptions.timeout;\n    delete callOptions.signal;\n    return [runnableConfig, callOptions];\n  }\n\n  protected async _callWithConfig<T extends RunInput>(\n    func:\n      | ((input: T) => Promise<RunOutput>)\n      | ((\n          input: T,\n          config?: Partial<CallOptions>,\n          runManager?: CallbackManagerForChainRun\n        ) => Promise<RunOutput>),\n    input: T,\n    options?: Partial<CallOptions> & { runType?: string }\n  ) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config.runId,\n      config?.runType,\n      undefined,\n      undefined,\n      config?.runName ?? this.getName()\n    );\n    delete config.runId;\n    let output;\n    try {\n      const promise = func.call(this, input, config, runManager);\n      output = await raceWithSignal(promise, options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig<T extends RunInput>(\n    func: (\n      inputs: T[],\n      options?: Partial<CallOptions>[],\n      runManagers?: (CallbackManagerForChainRun | undefined)[],\n      batchOptions?: RunnableBatchOptions\n    ) => Promise<(RunOutput | Error)[]>,\n    inputs: T[],\n    options?:\n      | Partial<CallOptions & { runType?: string }>\n      | Partial<CallOptions & { runType?: string }>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      optionsList.map(getCallbackManagerForConfig)\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          optionsList[i].runId,\n          optionsList[i].runType,\n          undefined,\n          undefined,\n          optionsList[i].runName ?? this.getName()\n        );\n        delete optionsList[i].runId;\n        return handleStartRes;\n      })\n    );\n    let outputs: (RunOutput | Error)[];\n    try {\n      const promise = func.call(\n        this,\n        inputs,\n        optionsList,\n        runManagers,\n        batchOptions\n      );\n      outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);\n    } catch (e) {\n      await Promise.all(\n        runManagers.map((runManager) => runManager?.handleChainError(e))\n      );\n      throw e;\n    }\n    await Promise.all(\n      runManagers.map((runManager) =>\n        runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))\n      )\n    );\n    return outputs;\n  }\n\n  /** @internal */\n  _concatOutputChunks<O>(first: O, second: O): O {\n    return concat(first, second);\n  }\n\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  protected async *_transformStreamWithConfig<\n    I extends RunInput,\n    O extends RunOutput\n  >(\n    inputGenerator: AsyncGenerator<I>,\n    transformer: (\n      generator: AsyncGenerator<I>,\n      runManager?: CallbackManagerForChainRun,\n      options?: Partial<CallOptions>\n    ) => AsyncGenerator<O>,\n    options?: Partial<CallOptions> & { runType?: string }\n  ): AsyncGenerator<O> {\n    let finalInput: I | undefined;\n    let finalInputSupported = true;\n    let finalOutput: O | undefined;\n    let finalOutputSupported = true;\n\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const outerThis = this;\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              finalInput = outerThis._concatOutputChunks(\n                finalInput,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                chunk as any\n              );\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n\n    let runManager: CallbackManagerForChainRun | undefined;\n    try {\n      const pipe = await pipeGeneratorWithSetup(\n        transformer.bind(this),\n        wrapInputForTracing(),\n        async () =>\n          callbackManager_?.handleChainStart(\n            this.toJSON(),\n            { input: \"\" },\n            config.runId,\n            config.runType,\n            undefined,\n            undefined,\n            config.runName ?? this.getName()\n          ),\n        options?.signal,\n        config\n      );\n      delete config.runId;\n      runManager = pipe.setup;\n\n      const streamEventsHandler = runManager?.handlers.find(\n        isStreamEventsHandler\n      );\n      let iterator = pipe.output;\n      if (streamEventsHandler !== undefined && runManager !== undefined) {\n        iterator = streamEventsHandler.tapOutputIterable(\n          runManager.runId,\n          iterator\n        );\n      }\n\n      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = streamLogHandler.tapOutputIterable(\n          runManager.runId,\n          iterator\n        );\n      }\n\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              finalOutput = this._concatOutputChunks(\n                finalOutput,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                chunk as any\n              );\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\"),\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(\n      finalOutput ?? {},\n      undefined,\n      undefined,\n      undefined,\n      { inputs: _coerceToDict(finalInput, \"input\") }\n    );\n  }\n\n  getGraph(_?: RunnableConfig): Graph {\n    const graph = new Graph();\n\n    // TODO: Add input schema for runnables\n    const inputNode = graph.addNode({\n      name: `${this.getName()}Input`,\n      schema: z.any(),\n    });\n\n    const runnableNode = graph.addNode(this);\n\n    // TODO: Add output schemas for runnables\n    const outputNode = graph.addNode({\n      name: `${this.getName()}Output`,\n      schema: z.any(),\n    });\n\n    graph.addEdge(inputNode, runnableNode);\n    graph.addEdge(runnableNode, outputNode);\n    return graph;\n  }\n\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<RunOutput, NewRunOutput>\n  ): Runnable<RunInput, Exclude<NewRunOutput, Error>> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable),\n    });\n  }\n\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys: string | string[]): Runnable {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys) as Runnable);\n  }\n\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(\n    mapping: RunnableMapLike<Record<string, unknown>, Record<string, unknown>>\n  ): Runnable {\n    return this.pipe(\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap<Record<string, unknown>>({ steps: mapping })\n      ) as Runnable\n    );\n  }\n\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = this._concatOutputChunks(finalChunk, chunk as any);\n      }\n    }\n    yield* this._streamIterator(finalChunk, ensureConfig(options));\n  }\n\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(\n    input: RunInput,\n    options?: Partial<CallOptions>,\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<RunLogPatch> {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\",\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n\n  protected async *_streamLog(\n    input: RunInput,\n    logStreamCallbackHandler: LogStreamCallbackHandler,\n    config: Partial<CallOptions>\n  ): AsyncGenerator<RunLogPatch> {\n    const { callbacks } = config;\n    if (callbacks === undefined) {\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [\n              {\n                op: \"add\",\n                path: \"/streamed_output/-\",\n                value: chunk,\n              },\n            ],\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n\n  /**\n   * Generate a stream of events emitted by the internal steps of the runnable.\n   *\n   * Use to create an iterator over StreamEvents that provide real-time information\n   * about the progress of the runnable, including StreamEvents from intermediate\n   * results.\n   *\n   * A StreamEvent is a dictionary with the following schema:\n   *\n   * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).\n   * - `name`: string - The name of the runnable that generated the event.\n   * - `run_id`: string - Randomly generated ID associated with the given execution of\n   *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a\n   *   parent runnable is assigned its own unique ID.\n   * - `tags`: string[] - The tags of the runnable that generated the event.\n   * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.\n   * - `data`: Record<string, any>\n   *\n   * Below is a table that illustrates some events that might be emitted by various\n   * chains. Metadata fields have been omitted from the table for brevity.\n   * Chain definitions have been included after the table.\n   *\n   * **ATTENTION** This reference table is for the V2 version of the schema.\n   *\n   * ```md\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | event                | input                       | output/chunk                             |\n   * +======================+=============================+==========================================+\n   * | on_chat_model_start  | {\"messages\": BaseMessage[]} |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chat_model_stream |                             | AIMessageChunk(\"hello\")                  |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chat_model_end    | {\"messages\": BaseMessage[]} | AIMessageChunk(\"hello world\")            |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_start         | {'input': 'hello'}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_stream        |                             | 'Hello'                                  |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_end           | 'Hello human!'              |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_start       |                             |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_stream      |                             | \"hello world!\"                           |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_end         | [Document(...)]             | \"hello world!, goodbye world!\"           |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_tool_start        | {\"x\": 1, \"y\": \"2\"}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_tool_end          |                             | {\"x\": 1, \"y\": \"2\"}                       |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_retriever_start   | {\"query\": \"hello\"}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_retriever_end     | {\"query\": \"hello\"}          | [Document(...), ..]                      |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_prompt_start      | {\"question\": \"hello\"}       |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_prompt_end        | {\"question\": \"hello\"}       | ChatPromptValue(messages: BaseMessage[]) |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * ```\n   *\n   * The \"on_chain_*\" events are the default for Runnables that don't fit one of the above categories.\n   *\n   * In addition to the standard events above, users can also dispatch custom events.\n   *\n   * Custom events will be only be surfaced with in the `v2` version of the API!\n   *\n   * A custom event has following format:\n   *\n   * ```md\n   * +-----------+------+------------------------------------------------------------+\n   * | Attribute | Type | Description                                                |\n   * +===========+======+============================================================+\n   * | name      | str  | A user defined name for the event.                         |\n   * +-----------+------+------------------------------------------------------------+\n   * | data      | Any  | The data associated with the event. This can be anything.  |\n   * +-----------+------+------------------------------------------------------------+\n   * ```\n   *\n   * Here's an example:\n   *\n   * ```ts\n   * import { RunnableLambda } from \"@langchain/core/runnables\";\n   * import { dispatchCustomEvent } from \"@langchain/core/callbacks/dispatch\";\n   * // Use this import for web environments that don't support \"async_hooks\"\n   * // and manually pass config to child runs.\n   * // import { dispatchCustomEvent } from \"@langchain/core/callbacks/dispatch/web\";\n   *\n   * const slowThing = RunnableLambda.from(async (someInput: string) => {\n   *   // Placeholder for some slow operation\n   *   await new Promise((resolve) => setTimeout(resolve, 100));\n   *   await dispatchCustomEvent(\"progress_event\", {\n   *    message: \"Finished step 1 of 2\",\n   *  });\n   *  await new Promise((resolve) => setTimeout(resolve, 100));\n   *  return \"Done\";\n   * });\n   *\n   * const eventStream = await slowThing.streamEvents(\"hello world\", {\n   *   version: \"v2\",\n   * });\n   *\n   * for await (const event of eventStream) {\n   *  if (event.event === \"on_custom_event\") {\n   *    console.log(event);\n   *  }\n   * }\n   * ```\n   */\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<Uint8Array>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    let stream;\n    if (options.version === \"v1\") {\n      stream = this._streamEventsV1(input, options, streamOptions);\n    } else if (options.version === \"v2\") {\n      stream = this._streamEventsV2(input, options, streamOptions);\n    } else {\n      throw new Error(\n        `Only versions \"v1\" and \"v2\" of the schema are currently supported.`\n      );\n    }\n    if (options.encoding === \"text/event-stream\") {\n      return convertToHttpEventStream(stream);\n    } else {\n      return IterableReadableStream.fromAsyncGenerator(stream);\n    }\n  }\n\n  private async *_streamEventsV2(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<StreamEvent> {\n    const eventStreamer = new EventStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n    });\n    const config = ensureConfig(options);\n    const runId = config.runId ?? uuidv4();\n    config.runId = runId;\n    const callbacks = config.callbacks;\n    if (callbacks === undefined) {\n      config.callbacks = [eventStreamer];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat(eventStreamer);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(eventStreamer, true);\n      config.callbacks = copiedCallbacks;\n    }\n    const abortController = new AbortController();\n    // Call the runnable in streaming mode,\n    // add each chunk to the output stream\n    const outerThis = this;\n    async function consumeRunnableStream() {\n      let signal;\n      let listener: (() => void) | null = null;\n\n      try {\n        if (options?.signal) {\n          if (\"any\" in AbortSignal) {\n            // Use native AbortSignal.any() if available (Node 19+)\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signal = (AbortSignal as any).any([\n              abortController.signal,\n              options.signal,\n            ]);\n          } else {\n            // Fallback for Node 18 and below - just use the provided signal\n            signal = options.signal;\n            // Ensure we still abort our controller when the parent signal aborts\n\n            listener = () => {\n              abortController.abort();\n            };\n\n            options.signal.addEventListener(\"abort\", listener, { once: true });\n          }\n        } else {\n          signal = abortController.signal;\n        }\n        const runnableStream = await outerThis.stream(input, {\n          ...config,\n          signal,\n        });\n        const tappedStream = eventStreamer.tapOutputIterable(\n          runId,\n          runnableStream\n        );\n        for await (const _ of tappedStream) {\n          // Just iterate so that the callback handler picks up events\n          if (abortController.signal.aborted) break;\n        }\n      } finally {\n        await eventStreamer.finish();\n\n        if (signal && listener) {\n          signal.removeEventListener(\"abort\", listener);\n        }\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    let firstEventSent = false;\n    let firstEventRunId;\n    try {\n      for await (const event of eventStreamer) {\n        // This is a work-around an issue where the inputs into the\n        // chain are not available until the entire input is consumed.\n        // As a temporary solution, we'll modify the input to be the input\n        // that was passed into the chain.\n        if (!firstEventSent) {\n          event.data.input = input;\n          firstEventSent = true;\n          firstEventRunId = event.run_id;\n          yield event;\n          continue;\n        }\n        if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n          // If it's the end event corresponding to the root runnable\n          // we dont include the input in the event since it's guaranteed\n          // to be included in the first event.\n          if (event.data?.input) {\n            delete event.data.input;\n          }\n        }\n        yield event;\n      }\n    } finally {\n      abortController.abort();\n      await runnableStreamConsumePromise;\n    }\n  }\n\n  private async *_streamEventsV1(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<StreamEvent> {\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = config.tags ?? [];\n    const rootMetadata = config.metadata ?? {};\n    const rootName = config.runName ?? this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\",\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions,\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(\n          `Internal error: \"streamEvents\" state is missing. Please open a bug report.`\n        );\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = { ...runLog.state };\n        const event: StreamEvent = {\n          run_id: state.id,\n          event: `on_${state.type}_start`,\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input,\n          },\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops\n        .filter((op) => op.path.startsWith(\"/logs/\"))\n        .map((op) => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data: StreamEventData = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(\n              `Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`\n            );\n          }\n          data = { chunk: logEntry.streamed_output[0] };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: `on_${logEntry.type}_${eventType}`,\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data,\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const { state } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(\n            `Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`\n          );\n        }\n        const data = { chunk: state.streamed_output[0] };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: `on_${state.type}_stream`,\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data,\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = runLog?.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: `on_${state.type}_end`,\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output,\n        },\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing: any): thing is Runnable {\n    return isRunnableInterface(thing);\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n  }): Runnable<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding<RunInput, RunOutput, CallOptions>({\n      bound: this,\n      config: {},\n      configFactories: [\n        (config) => ({\n          callbacks: [\n            new RootListenersTracer({\n              config,\n              onStart,\n              onEnd,\n              onError,\n            }),\n          ],\n        }),\n      ],\n    });\n  }\n\n  /**\n   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n   * which contains the runnable, name, description and schema.\n   *\n   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n   *\n   * @param fields\n   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n   */\n  asTool<T extends RunInput = RunInput>(fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<T>;\n  }): RunnableToolLike<InteropZodType<T | ToolCall>, RunOutput> {\n    return convertRunnableToTool<T, RunOutput>(this, fields);\n  }\n}\n\nexport type RunnableBindingArgs<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> = {\n  bound: Runnable<RunInput, RunOutput, CallOptions>;\n  /** @deprecated Use {@link config} instead. */\n  kwargs?: Partial<CallOptions>;\n  config: RunnableConfig;\n  configFactories?: Array<\n    (config: RunnableConfig) => RunnableConfig | Promise<RunnableConfig>\n  >;\n};\n\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.withConfig({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.withConfig({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nexport class RunnableBinding<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  bound: Runnable<RunInput, RunOutput, CallOptions>;\n\n  config: RunnableConfig;\n\n  kwargs?: Partial<CallOptions>;\n\n  configFactories?: Array<\n    (config: RunnableConfig) => RunnableConfig | Promise<RunnableConfig>\n  >;\n\n  constructor(fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>) {\n    super(fields);\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n\n  getName(suffix?: string | undefined): string {\n    return this.bound.getName(suffix);\n  }\n\n  async _mergeConfig(\n    ...options: (Partial<CallOptions> | RunnableConfig | undefined)[]\n  ): Promise<Partial<CallOptions>> {\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(\n      config,\n      ...(this.configFactories\n        ? await Promise.all(\n            this.configFactories.map(\n              async (configFactory) => await configFactory(config)\n            )\n          )\n        : [])\n    );\n  }\n\n  withConfig(\n    config: Partial<CallOptions>\n  ): Runnable<RunInput, RunOutput, CallOptions> {\n    return new (this.constructor as {\n      new (\n        fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>\n      ): RunnableBinding<RunInput, RunOutput, CallOptions>;\n    })({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: { ...this.config, ...config },\n    });\n  }\n\n  withRetry(fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }): RunnableRetry<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields,\n    });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this.bound.invoke(\n      input,\n      await this._mergeConfig(options, this.kwargs)\n    );\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const mergedOptions = Array.isArray(options)\n      ? await Promise.all(\n          options.map(async (individualOption) =>\n            this._mergeConfig(ensureConfig(individualOption), this.kwargs)\n          )\n        )\n      : await this._mergeConfig(ensureConfig(options), this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n\n  /** @internal */\n  override _concatOutputChunks<O>(first: O, second: O): O {\n    return this.bound._concatOutputChunks(first, second);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<CallOptions> | undefined\n  ) {\n    yield* this.bound._streamIterator(\n      input,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions> | undefined\n  ): Promise<IterableReadableStream<RunOutput>> {\n    return this.bound.stream(\n      input,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    yield* this.bound.transform(\n      generator,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<Uint8Array>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    const outerThis = this;\n    const generator = async function* () {\n      yield* outerThis.bound.streamEvents(\n        input,\n        {\n          ...(await outerThis._mergeConfig(\n            ensureConfig(options),\n            outerThis.kwargs\n          )),\n          version: options.version,\n        },\n        streamOptions\n      );\n    };\n    return IterableReadableStream.fromAsyncGenerator(generator());\n  }\n\n  static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing: any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): thing is RunnableBinding<any, any, any> {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n  }): Runnable<RunInput, RunOutput, CallOptions> {\n    return new RunnableBinding<RunInput, RunOutput, CallOptions>({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [\n        (config) => ({\n          callbacks: [\n            new RootListenersTracer({\n              config,\n              onStart,\n              onEnd,\n              onError,\n            }),\n          ],\n        }),\n      ],\n    });\n  }\n}\n\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n */\nexport class RunnableEach<\n  RunInputItem,\n  RunOutputItem,\n  CallOptions extends RunnableConfig\n> extends Runnable<RunInputItem[], RunOutputItem[], CallOptions> {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n\n  constructor(fields: {\n    bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n  }) {\n    super(fields);\n    this.bound = fields.bound;\n  }\n\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(\n    inputs: RunInputItem[],\n    config?: Partial<CallOptions>\n  ): Promise<RunOutputItem[]> {\n    return this._callWithConfig(this._invoke.bind(this), inputs, config);\n  }\n\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  protected async _invoke(\n    inputs: RunInputItem[],\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutputItem[]> {\n    return this.bound.batch(\n      inputs,\n      patchConfig(config, { callbacks: runManager?.getChild() })\n    );\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): Runnable<any, any, CallOptions> {\n    return new RunnableEach<RunInputItem, RunOutputItem, CallOptions>({\n      bound: this.bound.withListeners({ onStart, onEnd, onError }),\n    });\n  }\n}\n\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nexport class RunnableRetry<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends RunnableBinding<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected maxAttemptNumber = 3;\n\n  onFailedAttempt: RunnableRetryFailedAttemptHandler = () => {\n    // empty\n  };\n\n  constructor(\n    fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions> & {\n      maxAttemptNumber?: number;\n      onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n    }\n  ) {\n    super(fields);\n    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n  }\n\n  _patchConfigForRetry(\n    attempt: number,\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ): Partial<CallOptions> {\n    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n    return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n  }\n\n  protected async _invoke(\n    input: RunInput,\n    config?: CallOptions,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    return pRetry(\n      (attemptNumber: number) =>\n        super.invoke(\n          input,\n          this._patchConfigForRetry(attemptNumber, config, runManager)\n        ),\n      {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onFailedAttempt: ({ error }: { error: any }) =>\n          this.onFailedAttempt(error, input),\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true,\n      }\n    );\n  }\n\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input: RunInput, config?: CallOptions): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke.bind(this), input, config);\n  }\n\n  async _batch<ReturnExceptions extends boolean = false>(\n    inputs: RunInput[],\n    configs?: RunnableConfig[],\n    runManagers?: (CallbackManagerForChainRun | undefined)[],\n    batchOptions?: RunnableBatchOptions\n  ) {\n    const resultsMap: Record<string, RunOutput | Error> = {};\n    try {\n      await pRetry(\n        async (attemptNumber: number) => {\n          const remainingIndexes = inputs\n            .map((_, i) => i)\n            .filter(\n              (i) =>\n                resultsMap[i.toString()] === undefined ||\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                resultsMap[i.toString()] instanceof Error\n            );\n          const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n          const patchedConfigs = remainingIndexes.map((i) =>\n            this._patchConfigForRetry(\n              attemptNumber,\n              configs?.[i] as CallOptions,\n              runManagers?.[i]\n            )\n          );\n          const results = await super.batch(remainingInputs, patchedConfigs, {\n            ...batchOptions,\n            returnExceptions: true,\n          });\n          let firstException;\n          for (let i = 0; i < results.length; i += 1) {\n            const result = results[i];\n            const resultMapIndex = remainingIndexes[i];\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (result instanceof Error) {\n              if (firstException === undefined) {\n                firstException = result;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (firstException as any).input = remainingInputs[i];\n              }\n            }\n            resultsMap[resultMapIndex.toString()] = result;\n          }\n          if (firstException) {\n            throw firstException;\n          }\n          return results;\n        },\n        {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          onFailedAttempt: ({ error }: { error: any }) =>\n            this.onFailedAttempt(error, error.input),\n          retries: Math.max(this.maxAttemptNumber - 1, 0),\n          randomize: true,\n        }\n      );\n    } catch (e) {\n      if (batchOptions?.returnExceptions !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap)\n      .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n      .map(\n        (key) => resultsMap[parseInt(key, 10)]\n      ) as ReturnExceptions extends false ? RunOutput[] : (RunOutput | Error)[];\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    return this._batchWithConfig(\n      this._batch.bind(this),\n      inputs,\n      options,\n      batchOptions\n    );\n  }\n}\n\nexport type RunnableSequenceFields<RunInput, RunOutput> = {\n  first: Runnable<RunInput>;\n  middle?: Runnable[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  last: Runnable<any, RunOutput>;\n  name?: string;\n  omitSequenceTags?: boolean;\n};\n\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n\n  protected first: Runnable<RunInput>;\n\n  protected middle: Runnable[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected last: Runnable<any, RunOutput>;\n\n  omitSequenceTags = false;\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  constructor(fields: RunnableSequenceFields<RunInput, RunOutput>) {\n    super(fields);\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n    this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n  }\n\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n\n  async invoke(input: RunInput, options?: RunnableConfig): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    delete config.runId;\n    let nextStepInput = input;\n    let finalOutput: RunOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        const promise = step.invoke(\n          nextStepInput,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            ),\n          })\n        );\n        nextStepInput = await raceWithSignal(promise, options?.signal);\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      if (options?.signal?.aborted) {\n        throw getAbortSignalError(options.signal);\n      }\n      finalOutput = await this.last.invoke(\n        nextStepInput,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\n            this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`\n          ),\n        })\n      );\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      configList.map(getCallbackManagerForConfig)\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          configList[i].runId,\n          undefined,\n          undefined,\n          undefined,\n          configList[i].runName\n        );\n        delete configList[i].runId;\n        return handleStartRes;\n      })\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs: any = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        const promise = step.batch(\n          nextStepInputs,\n          runManagers.map((runManager, j) => {\n            const childRunManager = runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            );\n            return patchConfig(configList[j], { callbacks: childRunManager });\n          }),\n          batchOptions\n        );\n        nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);\n      }\n    } catch (e) {\n      await Promise.all(\n        runManagers.map((runManager) => runManager?.handleChainError(e))\n      );\n      throw e;\n    }\n    await Promise.all(\n      runManagers.map((runManager) =>\n        runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))\n      )\n    );\n    return nextStepInputs;\n  }\n\n  /** @internal */\n  override _concatOutputChunks<O>(first: O, second: O): O {\n    return this.last._concatOutputChunks(first, second);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: RunnableConfig\n  ): AsyncGenerator<RunOutput> {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const { runId, ...otherOptions } = options ?? {};\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherOptions?.runName\n    );\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(\n        inputGenerator(),\n        patchConfig(otherOptions, {\n          callbacks: runManager?.getChild(\n            this.omitSequenceTags ? undefined : `seq:step:1`\n          ),\n        })\n      );\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(\n          finalGenerator,\n          patchConfig(otherOptions, {\n            callbacks: runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            ),\n          })\n        );\n      }\n      for await (const chunk of finalGenerator) {\n        options?.signal?.throwIfAborted();\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = this._concatOutputChunks(finalOutput, chunk as any);\n            } catch {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n\n  getGraph(config?: RunnableConfig): Graph {\n    const graph = new Graph();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentLastNode: any = null;\n\n    this.steps.forEach((step, index) => {\n      const stepGraph = step.getGraph(config);\n\n      if (index !== 0) {\n        stepGraph.trimFirstNode();\n      }\n\n      if (index !== this.steps.length - 1) {\n        stepGraph.trimLastNode();\n      }\n\n      graph.extend(stepGraph);\n\n      const stepFirstNode = stepGraph.firstNode();\n      if (!stepFirstNode) {\n        throw new Error(`Runnable ${step} has no first node`);\n      }\n\n      if (currentLastNode) {\n        graph.addEdge(currentLastNode, stepFirstNode);\n      }\n\n      currentLastNode = stepGraph.lastNode();\n    });\n\n    return graph;\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<RunOutput, NewRunOutput>\n  ): RunnableSequence<RunInput, Exclude<NewRunOutput, Error>> {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([\n          this.last,\n          coerceable.first,\n          ...coerceable.middle,\n        ]),\n        last: coerceable.last,\n        name: this.name ?? coerceable.name,\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name,\n      });\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing: any): thing is RunnableSequence {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    [first, ...runnables]: [\n      RunnableLike<RunInput>,\n      ...RunnableLike[],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      RunnableLike<any, RunOutput>\n    ],\n    nameOrFields?:\n      | string\n      | Omit<\n          RunnableSequenceFields<RunInput, RunOutput>,\n          \"first\" | \"middle\" | \"last\"\n        >\n  ) {\n    let extra: Record<string, unknown> = {};\n    if (typeof nameOrFields === \"string\") {\n      extra.name = nameOrFields;\n    } else if (nameOrFields !== undefined) {\n      extra = nameOrFields;\n    }\n    return new RunnableSequence<RunInput, Exclude<RunOutput, Error>>({\n      ...extra,\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1]),\n    });\n  }\n}\n\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput extends Record<string, any> = Record<string, any>\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  protected steps: Record<string, Runnable<RunInput>>;\n\n  public getStepsKeys(): string[] {\n    return Object.keys(this.steps);\n  }\n\n  constructor(fields: { steps: RunnableMapLike<RunInput, RunOutput> }) {\n    super(fields);\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n\n  static from<\n    RunInput,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    steps: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableMap<RunInput, RunOutput> {\n    return new RunnableMap<RunInput, RunOutput>({ steps });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      {\n        input,\n      },\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    delete config.runId;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output: Record<string, any> = {};\n    try {\n      const promises = Object.entries(this.steps).map(\n        async ([key, runnable]) => {\n          output[key] = await runnable.invoke(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`map:key:${key}`),\n            })\n          );\n        }\n      );\n      await raceWithSignal(Promise.all(promises), options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output as RunOutput;\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    // shallow copy steps to ignore changes while iterating\n    const steps = { ...this.steps };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(\n      Object.entries(steps).map(([key, runnable], i) => {\n        const gen = runnable.transform(\n          inputCopies[i],\n          patchConfig(options, {\n            callbacks: runManager?.getChild(`map:key:${key}`),\n          })\n        );\n        return [key, gen.next().then((result) => ({ key, gen, result }))];\n      })\n    );\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const promise = Promise.race(tasks.values());\n      const { key, result, gen } = await raceWithSignal(\n        promise,\n        options?.signal\n      );\n      tasks.delete(key);\n      if (!result.done) {\n        yield { [key]: result.value } as unknown as RunOutput;\n        tasks.set(\n          key,\n          gen.next().then((result) => ({ key, gen, result }))\n        );\n      }\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyTraceableFunction = TraceableFunction<(...any: any[]) => any>;\n\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable<RunInput, RunOutput> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  lc_serializable = false;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected func: AnyTraceableFunction;\n\n  constructor(fields: { func: AnyTraceableFunction }) {\n    super(fields);\n\n    if (!isTraceableFunction(fields.func)) {\n      throw new Error(\n        \"RunnableTraceable requires a function that is wrapped in traceable higher-order function\"\n      );\n    }\n\n    this.func = fields.func;\n  }\n\n  async invoke(input: RunInput, options?: Partial<RunnableConfig>) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const callbacks = await getCallbackManagerForConfig(config);\n    const promise = this.func(\n      patchConfig(config, { callbacks }),\n      input\n    ) as Promise<RunOutput>;\n\n    return raceWithSignal(promise, config?.signal);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const result = await this.invoke(input, options);\n\n    if (isAsyncIterable(result)) {\n      for await (const item of result) {\n        config?.signal?.throwIfAborted();\n        yield item as RunOutput;\n      }\n      return;\n    }\n\n    if (isIterator(result)) {\n      while (true) {\n        config?.signal?.throwIfAborted();\n        const state: IteratorResult<unknown> = result.next();\n        if (state.done) break;\n        yield state.value as RunOutput;\n      }\n      return;\n    }\n\n    yield result;\n  }\n\n  static from(func: AnyTraceableFunction) {\n    return new RunnableTraceable({ func });\n  }\n}\n\nfunction assertNonTraceableFunction<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n>(\n  func:\n    | RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    | TraceableFunction<\n        RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      >\n): asserts func is RunnableFunc<\n  RunInput,\n  RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n  CallOptions\n> {\n  if (isTraceableFunction(func)) {\n    throw new Error(\n      \"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\"\n    );\n  }\n}\n\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nexport class RunnableLambda<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected func: RunnableFunc<\n    RunInput,\n    RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n    CallOptions\n  >;\n\n  constructor(fields: {\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >;\n  }) {\n    if (isTraceableFunction(fields.func)) {\n      // eslint-disable-next-line no-constructor-return\n      return RunnableTraceable.from(fields.func) as unknown as RunnableLambda<\n        RunInput,\n        RunOutput,\n        CallOptions\n      >;\n    }\n\n    super(fields);\n\n    assertNonTraceableFunction(fields.func);\n    this.func = fields.func;\n  }\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func: RunnableFunc<\n      RunInput,\n      RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n      CallOptions\n    >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions>;\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func: TraceableFunction<\n      RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions>;\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions> {\n    return new RunnableLambda({\n      func,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    return new Promise<RunOutput>((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n      });\n      // eslint-disable-next-line no-void\n      void AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(childConfig),\n        async () => {\n          try {\n            let output = await this.func(input, {\n              ...childConfig,\n            });\n            if (output && Runnable.isRunnable(output)) {\n              if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n              }\n              output = await output.invoke(input, {\n                ...childConfig,\n                recursionLimit:\n                  (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n              });\n            } else if (isAsyncIterable(output)) {\n              let finalOutput: RunOutput | undefined;\n              for await (const chunk of consumeAsyncIterableInContext(\n                childConfig,\n                output\n              )) {\n                config?.signal?.throwIfAborted();\n                if (finalOutput === undefined) {\n                  finalOutput = chunk as RunOutput;\n                } else {\n                  // Make a best effort to gather, for any type that supports concat.\n                  try {\n                    finalOutput = this._concatOutputChunks(\n                      finalOutput,\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      chunk as any\n                    );\n                  } catch {\n                    finalOutput = chunk as RunOutput;\n                  }\n                }\n              }\n              output = finalOutput as typeof output;\n            } else if (isIterableIterator(output)) {\n              let finalOutput: RunOutput | undefined;\n              for (const chunk of consumeIteratorInContext(\n                childConfig,\n                output\n              )) {\n                config?.signal?.throwIfAborted();\n                if (finalOutput === undefined) {\n                  finalOutput = chunk as RunOutput;\n                } else {\n                  // Make a best effort to gather, for any type that supports concat.\n                  try {\n                    finalOutput = this._concatOutputChunks(\n                      finalOutput,\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      chunk as any\n                    );\n                  } catch {\n                    finalOutput = chunk as RunOutput;\n                  }\n                }\n              }\n              output = finalOutput as typeof output;\n            }\n            resolve(output);\n          } catch (e) {\n            reject(e);\n          }\n        }\n      );\n    });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke.bind(this), input, options);\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    config?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    let finalChunk: RunInput | undefined;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = this._concatOutputChunks(finalChunk, chunk as any);\n        } catch {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const childConfig = patchConfig(config, {\n      callbacks: runManager?.getChild(),\n      recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n    });\n    const output = await new Promise<RunOutput | Runnable>(\n      (resolve, reject) => {\n        // eslint-disable-next-line no-void\n        void AsyncLocalStorageProviderSingleton.runWithConfig(\n          pickRunnableConfigKeys(childConfig),\n          async () => {\n            try {\n              const res = await this.func(finalChunk as RunInput, {\n                ...childConfig,\n                config: childConfig,\n              });\n              resolve(res);\n            } catch (e) {\n              reject(e);\n            }\n          }\n        );\n      }\n    );\n    if (output && Runnable.isRunnable(output)) {\n      if (config?.recursionLimit === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk as RunInput, childConfig);\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else if (isAsyncIterable(output)) {\n      for await (const chunk of consumeAsyncIterableInContext(\n        childConfig,\n        output\n      )) {\n        config?.signal?.throwIfAborted();\n        yield chunk as RunOutput;\n      }\n    } else if (isIterableIterator(output)) {\n      for (const chunk of consumeIteratorInContext(childConfig, output)) {\n        config?.signal?.throwIfAborted();\n        yield chunk as RunOutput;\n      }\n    } else {\n      yield output;\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nexport class RunnableParallel<RunInput> extends RunnableMap<RunInput> {}\n\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nexport class RunnableWithFallbacks<RunInput, RunOutput> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnable: Runnable<RunInput, RunOutput>;\n\n  fallbacks: Runnable<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    runnable: Runnable<RunInput, RunOutput>;\n    fallbacks: Runnable<RunInput, RunOutput>[];\n  }) {\n    super(fields);\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const { runId, ...otherConfigFields } = config;\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherConfigFields?.runName\n    );\n    const childConfig = patchConfig(otherConfigFields, {\n      callbacks: runManager?.getChild(),\n    });\n    const res = await AsyncLocalStorageProviderSingleton.runWithConfig(\n      childConfig,\n      async () => {\n        let firstError;\n        for (const runnable of this.runnables()) {\n          config?.signal?.throwIfAborted();\n          try {\n            const output = await runnable.invoke(input, childConfig);\n            await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n            return output;\n          } catch (e) {\n            if (firstError === undefined) {\n              firstError = e;\n            }\n          }\n        }\n        if (firstError === undefined) {\n          throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n      }\n    );\n    return res;\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<RunnableConfig> | undefined\n  ): AsyncGenerator<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const { runId, ...otherConfigFields } = config;\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherConfigFields?.runName\n    );\n    let firstError;\n    let stream;\n    for (const runnable of this.runnables()) {\n      config?.signal?.throwIfAborted();\n      const childConfig = patchConfig(otherConfigFields, {\n        callbacks: runManager?.getChild(),\n      });\n      try {\n        const originalStream = await runnable.stream(input, childConfig);\n        stream = consumeAsyncIterableInContext(childConfig, originalStream);\n        break;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (stream === undefined) {\n      const error =\n        firstError ?? new Error(\"No error stored at end of fallback.\");\n      await runManager?.handleChainError(error);\n      throw error;\n    }\n    let output;\n    try {\n      for await (const chunk of stream) {\n        yield chunk;\n        try {\n          output =\n            output === undefined\n              ? output\n              : this._concatOutputChunks(output, chunk);\n        } catch {\n          output = undefined;\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    if (batchOptions?.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      configList.map((config) => getCallbackManagerForConfig(config))\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          configList[i].runId,\n          undefined,\n          undefined,\n          undefined,\n          configList[i].runName\n        );\n        delete configList[i].runId;\n        return handleStartRes;\n      })\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError: any;\n    for (const runnable of this.runnables()) {\n      configList[0].signal?.throwIfAborted();\n      try {\n        const outputs = await runnable.batch(\n          inputs,\n          runManagers.map((runManager, j) =>\n            patchConfig(configList[j], {\n              callbacks: runManager?.getChild(),\n            })\n          ),\n          batchOptions\n        );\n        await Promise.all(\n          runManagers.map((runManager, i) =>\n            runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))\n          )\n        );\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(\n      runManagers.map((runManager) => runManager?.handleChainError(firstError))\n    );\n    throw firstError;\n  }\n}\n\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n>(\n  coerceable: RunnableLike<RunInput, RunOutput, CallOptions>\n): Runnable<RunInput, Exclude<RunOutput, Error>, CallOptions> {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({ func: coerceable }) as Runnable<\n      RunInput,\n      Exclude<RunOutput, Error>,\n      CallOptions\n    >;\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable as Runnable<\n      RunInput,\n      Exclude<RunOutput, Error>,\n      CallOptions\n    >;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables: Record<string, Runnable<RunInput>> = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value as RunnableLike);\n    }\n    return new RunnableMap({\n      steps: runnables,\n    }) as unknown as Runnable<RunInput, Exclude<RunOutput, Error>, CallOptions>;\n  } else {\n    throw new Error(\n      `Expected a Runnable, function or object.\\nInstead got an unsupported type.`\n    );\n  }\n}\n\nexport interface RunnableAssignFields<RunInput> {\n  mapper: RunnableMap<RunInput>;\n}\n\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nexport class RunnableAssign<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends Record<string, any> = Record<string, any>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements RunnableAssignFields<RunInput>\n{\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  mapper: RunnableMap<RunInput>;\n\n  constructor(fields: RunnableMap<RunInput> | RunnableAssignFields<RunInput>) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { mapper: fields };\n    }\n    super(fields);\n    this.mapper = fields.mapper;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    const mapperResult = await this.mapper.invoke(input, options);\n\n    return {\n      ...input,\n      ...mapperResult,\n    } as RunOutput;\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(\n      forMapper,\n      patchConfig(options, { callbacks: runManager?.getChild() })\n    );\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(\n          `RunnableAssign can only be used with objects as input, got ${typeof chunk}`\n        );\n      }\n      const filtered = Object.fromEntries(\n        Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key))\n      );\n      if (Object.keys(filtered).length > 0) {\n        yield filtered as unknown as RunOutput;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk as unknown as RunOutput;\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\nexport interface RunnablePickFields {\n  keys: string | string[];\n}\n\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nexport class RunnablePick<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends Record<string, any> = Record<string, any>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> | any = Record<string, any> | any,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements RunnablePickFields\n{\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  keys: string | string[];\n\n  constructor(fields: string | string[] | RunnablePickFields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { keys: fields };\n    }\n    super(fields);\n    this.keys = fields.keys;\n  }\n\n  async _pick(input: RunInput): Promise<RunOutput> {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys\n        .map((key) => [key, input[key]])\n        .filter((v) => v[1] !== undefined);\n      return picked.length === 0\n        ? (undefined as RunOutput)\n        : Object.fromEntries(picked);\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>\n  ): AsyncGenerator<RunOutput> {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\nexport interface RunnableToolLikeArgs<\n  RunInput extends InteropZodType = InteropZodType,\n  RunOutput = unknown\n> extends Omit<\n    RunnableBindingArgs<InferInteropZodOutput<RunInput>, RunOutput>,\n    \"config\"\n  > {\n  name: string;\n\n  description?: string;\n\n  schema: RunInput;\n\n  config?: RunnableConfig;\n}\n\nexport class RunnableToolLike<\n  RunInput extends InteropZodType = InteropZodType,\n  RunOutput = unknown\n> extends RunnableBinding<InferInteropZodOutput<RunInput>, RunOutput> {\n  name: string;\n\n  description?: string;\n\n  schema: RunInput;\n\n  constructor(fields: RunnableToolLikeArgs<RunInput, RunOutput>) {\n    const sequence = RunnableSequence.from([\n      RunnableLambda.from<\n        InferInteropZodOutput<RunInput> | ToolCall,\n        InferInteropZodOutput<RunInput>\n      >(async (input) => {\n        let toolInput: InferInteropZodOutput<RunInput>;\n\n        if (_isToolCall(input)) {\n          try {\n            toolInput = await interopParseAsync(this.schema, input.args);\n          } catch {\n            throw new ToolInputParsingException(\n              `Received tool input did not match expected schema`,\n              JSON.stringify(input.args)\n            );\n          }\n        } else {\n          toolInput = input;\n        }\n        return toolInput;\n      }).withConfig({ runName: `${fields.name}:parse_input` }),\n      fields.bound,\n    ]).withConfig({ runName: fields.name });\n\n    super({\n      bound: sequence,\n      config: fields.config ?? {},\n    });\n\n    this.name = fields.name;\n    this.description = fields.description;\n    this.schema = fields.schema;\n  }\n\n  static lc_name() {\n    return \"RunnableToolLike\";\n  }\n}\n\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nexport function convertRunnableToTool<RunInput, RunOutput>(\n  runnable: Runnable<RunInput, RunOutput>,\n  fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<RunInput>;\n  }\n): RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput> {\n  const name = fields.name ?? runnable.getName();\n  const description = fields.description ?? getSchemaDescription(fields.schema);\n\n  if (isSimpleStringZodSchema(fields.schema)) {\n    return new RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput>(\n      {\n        name,\n        description,\n        schema: z\n          .object({ input: z.string() })\n          .transform((input) => input.input) as InteropZodType,\n        bound: runnable,\n      }\n    );\n  }\n\n  return new RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput>({\n    name,\n    description,\n    schema: fields.schema,\n    bound: runnable,\n  });\n}\n"],"names":["value: any","defaultKey: string","Serializable","suffix?: string","fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }","config: Partial<CallOptions>","fields:\n      | {\n          fallbacks: Runnable<RunInput, RunOutput>[];\n        }\n      | Runnable<RunInput, RunOutput>[]","options: Partial<O> | Partial<O>[]","ensureConfig","inputs: RunInput[]","options?: Partial<CallOptions> | Partial<CallOptions>[]","batchOptions?: RunnableBatchOptions","AsyncCaller","input: RunInput","options?: Partial<CallOptions>","AsyncGeneratorWithSetup","IterableReadableStream","func:\n      | ((input: T) => Promise<RunOutput>)\n      | ((\n          input: T,\n          config?: Partial<CallOptions>,\n          runManager?: CallbackManagerForChainRun\n        ) => Promise<RunOutput>)","input: T","options?: Partial<CallOptions> & { runType?: string }","getCallbackManagerForConfig","raceWithSignal","func: (\n      inputs: T[],\n      options?: Partial<CallOptions>[],\n      runManagers?: (CallbackManagerForChainRun | undefined)[],\n      batchOptions?: RunnableBatchOptions\n    ) => Promise<(RunOutput | Error)[]>","inputs: T[]","options?:\n      | Partial<CallOptions & { runType?: string }>\n      | Partial<CallOptions & { runType?: string }>[]","outputs: (RunOutput | Error)[]","first: O","second: O","concat","inputGenerator: AsyncGenerator<I>","transformer: (\n      generator: AsyncGenerator<I>,\n      runManager?: CallbackManagerForChainRun,\n      options?: Partial<CallOptions>\n    ) => AsyncGenerator<O>","finalInput: I | undefined","finalOutput: O | undefined","runManager: CallbackManagerForChainRun | undefined","pipeGeneratorWithSetup","isStreamEventsHandler","isLogStreamHandler","_?: RunnableConfig","Graph","z","coerceable: RunnableLike<RunOutput, NewRunOutput>","keys: string | string[]","mapping: RunnableMapLike<Record<string, unknown>, Record<string, unknown>>","generator: AsyncGenerator<RunInput>","options: Partial<CallOptions>","streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">","LogStreamCallbackHandler","logStreamCallbackHandler: LogStreamCallbackHandler","RunLogPatch","options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    }","streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">","convertToHttpEventStream","options: Partial<CallOptions> & { version: \"v1\" | \"v2\" }","EventStreamCallbackHandler","listener: (() => void) | null","_RootEventFilter","RunLog","state","event: StreamEvent","data: StreamEventData","thing: any","isRunnableInterface","RootListenersTracer","fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<T>;\n  }","fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>","suffix?: string | undefined","mergeConfigs","options?: Partial<CallOptions> | undefined","fields: {\n    bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n  }","inputs: RunInputItem[]","config?: Partial<CallOptions>","runManager?: CallbackManagerForChainRun","patchConfig","fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions> & {\n      maxAttemptNumber?: number;\n      onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n    }","attempt: number","config?: CallOptions","attemptNumber: number","configs?: RunnableConfig[]","runManagers?: (CallbackManagerForChainRun | undefined)[]","resultsMap: Record<string, RunOutput | Error>","fields: RunnableSequenceFields<RunInput, RunOutput>","options?: RunnableConfig","finalOutput: RunOutput","getAbortSignalError","options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]","nextStepInputs: any","config?: RunnableConfig","currentLastNode: any","nameOrFields?:\n      | string\n      | Omit<\n          RunnableSequenceFields<RunInput, RunOutput>,\n          \"first\" | \"middle\" | \"last\"\n        >","extra: Record<string, unknown>","fields: { steps: RunnableMapLike<RunInput, RunOutput> }","steps: RunnableMapLike<RunInput, RunOutput>","options?: Partial<RunnableConfig>","output: Record<string, any>","atee","result","fields: { func: AnyTraceableFunction }","isAsyncIterable","isIterator","state: IteratorResult<unknown>","func: AnyTraceableFunction","func:\n    | RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    | TraceableFunction<\n        RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      >","fields: {\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >;\n  }","func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >","DEFAULT_RECURSION_LIMIT","AsyncLocalStorageProviderSingleton","pickRunnableConfigKeys","finalOutput: RunOutput | undefined","consumeAsyncIterableInContext","isIterableIterator","consumeIteratorInContext","finalChunk: RunInput | undefined","fields: {\n    runnable: Runnable<RunInput, RunOutput>;\n    fallbacks: Runnable<RunInput, RunOutput>[];\n  }","options?: Partial<RunnableConfig> | undefined","firstError: any","coerceable: RunnableLike<RunInput, RunOutput, CallOptions>","runnables: Record<string, Runnable<RunInput>>","fields: RunnableMap<RunInput> | RunnableAssignFields<RunInput>","fields: string | string[] | RunnablePickFields","fields: RunnableToolLikeArgs<RunInput, RunOutput>","toolInput: InferInteropZodOutput<RunInput>","_isToolCall","interopParseAsync","ToolInputParsingException","runnable: Runnable<RunInput, RunOutput>","fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<RunInput>;\n  }","getSchemaDescription","isSimpleStringZodSchema"],"mappings":"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"}},
    {"offset": {"line": 2525, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/passthrough.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/passthrough.ts"],"sourcesContent":["import { concat } from \"../utils/stream.js\";\nimport {\n  Runnable,\n  RunnableAssign,\n  RunnableMap,\n  RunnableMapLike,\n} from \"./base.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RunnablePassthroughFunc<RunInput = any> =\n  | ((input: RunInput) => void)\n  | ((input: RunInput, config?: RunnableConfig) => void)\n  | ((input: RunInput) => Promise<void>)\n  | ((input: RunInput, config?: RunnableConfig) => Promise<void>);\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough<RunInput = any> extends Runnable<\n  RunInput,\n  RunInput\n> {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  func?: RunnablePassthroughFunc<RunInput>;\n\n  constructor(fields?: { func?: RunnablePassthroughFunc<RunInput> }) {\n    super(fields);\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunInput> {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n\n    return this._callWithConfig(\n      (input: RunInput) => Promise.resolve(input),\n      input,\n      config\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<RunnableConfig>\n  ): AsyncGenerator<RunInput> {\n    const config = ensureConfig(options);\n    let finalOutput: RunInput | undefined;\n    let finalOutputSupported = true;\n\n    for await (const chunk of this._transformStreamWithConfig(\n      generator,\n      (input: AsyncGenerator<RunInput>) => input,\n      config\n    )) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk as any);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign<\n    RunInput extends Record<string, unknown> = Record<string, unknown>,\n    RunOutput extends Record<string, unknown> = Record<string, unknown>\n  >(\n    mapping: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableAssign<RunInput, RunInput & RunOutput> {\n    return new RunnableAssign(new RunnableMap({ steps: mapping }));\n  }\n}\n"],"names":["Runnable","fields?: { func?: RunnablePassthroughFunc<RunInput> }","input: RunInput","options?: Partial<RunnableConfig>","ensureConfig","input","generator: AsyncGenerator<RunInput>","options: Partial<RunnableConfig>","finalOutput: RunInput | undefined","input: AsyncGenerator<RunInput>","concat","mapping: RunnableMapLike<RunInput, RunOutput>","RunnableAssign","RunnableMap"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2CA,IAAa,sBAAb,cAAyDA,aAAAA,QAAAA,CAGvD;IACA,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,WAAY;KAAA,CAAA;IAE9C,kBAAkB,KAAA;IAElB,KAAA;IAEA,YAAYC,MAAAA,CAAuD;QACjE,KAAA,CAAM,OAAO;QACb,IAAI,QACF,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IAEtB;IAED,MAAM,OACJC,KAAAA,EACAC,OAAAA,EACmB;QACnB,MAAM,SAASC,eAAAA,YAAAA,CAAa,QAAQ;QACpC,IAAI,IAAA,CAAK,IAAA,EACP,MAAM,IAAA,CAAK,IAAA,CAAK,OAAO,OAAO;QAGhC,OAAO,IAAA,CAAK,eAAA,CACV,CAACF,UAAoB,QAAQ,OAAA,CAAQG,QAAM,EAC3C,OACA,OACD;IACF;IAED,OAAO,UACLC,SAAAA,EACAC,OAAAA,EAC0B;QAC1B,MAAM,SAASH,eAAAA,YAAAA,CAAa,QAAQ;QACpC,IAAII;QACJ,IAAI,uBAAuB;QAE3B,WAAW,MAAM,SAAS,IAAA,CAAK,0BAAA,CAC7B,WACA,CAACC,QAAoC,OACrC,OACD,CAAE;YACD,MAAM;YACN,IAAI,qBACF,CAAA,IAAI,gBAAgB,KAAA,GAClB,cAAc;iBAEd,IAAI;gBAEF,cAAcC,qBAAAA,MAAAA,CAAO,aAAa,MAAa;YAChD,EAAA,OAAO;gBACN,cAAc,KAAA;gBACd,uBAAuB;YACxB;QAGN;QAED,IAAI,IAAA,CAAK,IAAA,IAAQ,gBAAgB,KAAA,GAC/B,MAAM,IAAA,CAAK,IAAA,CAAK,aAAa,OAAO;IAEvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8BD,OAAO,OAILC,OAAAA,EACgD;QAChD,OAAO,IAAIC,aAAAA,cAAAA,CAAe,IAAIC,aAAAA,WAAAA,CAAY;YAAE,OAAO;QAAS;IAC7D;AACF"}},
    {"offset": {"line": 2627, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/router.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/router.ts"],"sourcesContent":["import { Runnable, type RunnableBatchOptions } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\nexport type RouterInput = {\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any;\n};\n\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nexport class RouterRunnable<\n  RunInput extends RouterInput,\n  RunnableInput,\n  RunOutput\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n\n  constructor(fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }) {\n    super(fields);\n    this.runnables = fields.runnables;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, ensureConfig(options));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const keys = inputs.map((input) => input.key);\n    const actualInputs = inputs.map((input) => input.input);\n    const missingKey = keys.find((key) => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map((key) => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const batchSize =\n      maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs\n        .slice(i, i + batchSize)\n        .map((actualInput, i) =>\n          runnables[i].invoke(actualInput, optionsList[i])\n        );\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n"],"names":["Runnable","fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }","input: RunInput","options?: Partial<RunnableConfig>","ensureConfig","inputs: RunInput[]","options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]","batchOptions?: RunnableBatchOptions","i"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCA,IAAa,iBAAb,cAIUA,aAAAA,QAAAA,CAA8B;IACtC,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,WAAY;KAAA,CAAA;IAE9C,kBAAkB,KAAA;IAElB,UAAA;IAEA,YAAYC,MAAAA,CAET;QACD,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,SAAA,GAAY,OAAO,SAAA;IACzB;IAED,MAAM,OACJC,KAAAA,EACAC,OAAAA,EACoB;QACpB,MAAM,EAAE,GAAA,EAAK,OAAO,WAAA,EAAa,GAAG;QACpC,MAAM,WAAW,IAAA,CAAK,SAAA,CAAU,IAAA;QAChC,IAAI,aAAa,KAAA,EACf,CAAA,MAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,IAAI,EAAE,CAAC;QAE7D,OAAO,SAAS,MAAA,CAAO,aAAaC,eAAAA,YAAAA,CAAa,QAAQ,CAAC;IAC3D;IAoBD,MAAM,MACJC,MAAAA,EACAC,OAAAA,EACAC,YAAAA,EACgC;QAChC,MAAM,OAAO,OAAO,GAAA,CAAI,CAAC,QAAU,MAAM,GAAA,CAAI;QAC7C,MAAM,eAAe,OAAO,GAAA,CAAI,CAAC,QAAU,MAAM,KAAA,CAAM;QACvD,MAAM,aAAa,KAAK,IAAA,CAAK,CAAC,MAAQ,IAAA,CAAK,SAAA,CAAU,IAAA,KAAS,KAAA,EAAU;QACxE,IAAI,eAAe,KAAA,EACjB,CAAA,MAAM,IAAI,MAAM,CAAC,sDAAsD,CAAC;QAE1E,MAAM,YAAY,KAAK,GAAA,CAAI,CAAC,MAAQ,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK;QACxD,MAAM,cAAc,IAAA,CAAK,eAAA,CAAgB,WAAW,CAAE,GAAE,OAAO,MAAA,CAAO;QACtE,MAAM,iBACJ,WAAA,CAAY,EAAA,EAAI,kBAAkB,cAAc;QAClD,MAAM,YACJ,kBAAkB,iBAAiB,IAAI,iBAAiB,OAAO,MAAA;QACjE,MAAM,eAAe,CAAE,CAAA;QACvB,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,MAAA,EAAQ,KAAK,UAAW;YACvD,MAAM,gBAAgB,aACnB,KAAA,CAAM,GAAG,IAAI,UAAU,CACvB,GAAA,CAAI,CAAC,aAAaC,MACjB,SAAA,CAAUA,IAAAA,CAAG,MAAA,CAAO,aAAa,WAAA,CAAYA,IAAAA,CAAG,CACjD;YACH,MAAM,cAAc,MAAM,QAAQ,GAAA,CAAI,cAAc;YACpD,aAAa,IAAA,CAAK,YAAY;QAC/B;QACD,OAAO,aAAa,IAAA,EAAM;IAC3B;IAED,MAAM,OACJN,KAAAA,EACAC,OAAAA,EAC4C;QAC5C,MAAM,EAAE,GAAA,EAAK,OAAO,WAAA,EAAa,GAAG;QACpC,MAAM,WAAW,IAAA,CAAK,SAAA,CAAU,IAAA;QAChC,IAAI,aAAa,KAAA,EACf,CAAA,MAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,IAAI,EAAE,CAAC;QAE7D,OAAO,SAAS,MAAA,CAAO,aAAa,QAAQ;IAC7C;AACF"}},
    {"offset": {"line": 2705, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/branch.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/branch.ts"],"sourcesContent":["import {\n  Runnable,\n  RunnableLike,\n  _coerceToDict,\n  _coerceToRunnable,\n} from \"./base.js\";\nimport {\n  RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n} from \"./config.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport { concat } from \"../utils/stream.js\";\n\n/**\n * Type for a branch in the RunnableBranch. It consists of a condition\n * runnable and a branch runnable. The condition runnable is used to\n * determine whether the branch should be executed, and the branch runnable\n * is executed if the condition is true.\n */\nexport type Branch<RunInput, RunOutput> = [\n  Runnable<RunInput, boolean>,\n  Runnable<RunInput, RunOutput>\n];\n\nexport type BranchLike<RunInput, RunOutput> = [\n  RunnableLike<RunInput, boolean>,\n  RunnableLike<RunInput, RunOutput>\n];\n\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch<RunInput = any, RunOutput = any> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  default: Runnable<RunInput, RunOutput>;\n\n  branches: Branch<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }) {\n    super(fields);\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>\n    ]\n  ) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1) as BranchLike<\n      RunInput,\n      RunOutput\n    >[];\n    const coercedBranches: Branch<RunInput, RunOutput>[] = branchLikes.map(\n      ([condition, runnable]) => [\n        _coerceToRunnable(condition),\n        _coerceToRunnable(runnable),\n      ]\n    );\n    const defaultBranch = _coerceToRunnable(\n      branches[branches.length - 1] as RunnableLike<RunInput, RunOutput>\n    );\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(`condition:${i + 1}`),\n        })\n      );\n      if (conditionValue) {\n        result = await branchRunnable.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`branch:${i + 1}`),\n          })\n        );\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\"branch:default\"),\n        })\n      );\n    }\n    return result;\n  }\n\n  async invoke(\n    input: RunInput,\n    config: RunnableConfig = {}\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n\n  async *_streamIterator(input: RunInput, config?: Partial<RunnableConfig>) {\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config?.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`condition:${i + 1}`),\n          })\n        );\n        if (conditionValue) {\n          stream = await branchRunnable.stream(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`branch:${i + 1}`),\n            })\n          );\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\"branch:default\"),\n          })\n        );\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk as RunOutput);\n              } catch {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {});\n  }\n}\n"],"names":["Runnable","fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }","branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>\n    ]","coercedBranches: Branch<RunInput, RunOutput>[]","_coerceToRunnable","input: RunInput","config?: Partial<RunnableConfig>","runManager?: CallbackManagerForChainRun","patchConfig","config: RunnableConfig","getCallbackManagerForConfig","_coerceToDict","concat"],"mappings":"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"}},
    {"offset": {"line": 2874, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/history.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/history.ts"],"sourcesContent":["import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../chat_history.js\";\nimport {\n  AIMessage,\n  BaseMessage,\n  HumanMessage,\n  isBaseMessage,\n} from \"../messages/index.js\";\nimport { Run } from \"../tracers/base.js\";\nimport {\n  Runnable,\n  RunnableBinding,\n  type RunnableBindingArgs,\n  RunnableLambda,\n} from \"./base.js\";\nimport { RunnableConfig } from \"./config.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n\ntype GetSessionHistoryCallable = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: Array<any>\n) =>\n  | Promise<BaseChatMessageHistory | BaseListChatMessageHistory>\n  | BaseChatMessageHistory\n  | BaseListChatMessageHistory;\n\nexport interface RunnableWithMessageHistoryInputs<RunInput, RunOutput>\n  extends Omit<RunnableBindingArgs<RunInput, RunOutput>, \"bound\" | \"config\"> {\n  runnable: Runnable<RunInput, RunOutput>;\n  getMessageHistory: GetSessionHistoryCallable;\n  inputMessagesKey?: string;\n  outputMessagesKey?: string;\n  historyMessagesKey?: string;\n  config?: RunnableConfig;\n}\n\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // pnpm install @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"@langchain/classic/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory<\n  RunInput,\n  RunOutput\n> extends RunnableBinding<RunInput, RunOutput> {\n  runnable: Runnable<RunInput, RunOutput>;\n\n  inputMessagesKey?: string;\n\n  outputMessagesKey?: string;\n\n  historyMessagesKey?: string;\n\n  getMessageHistory: GetSessionHistoryCallable;\n\n  constructor(fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>) {\n    let historyChain: Runnable = RunnableLambda.from((input, options) =>\n      this._enterHistory(input, options ?? {})\n    ).withConfig({ runName: \"loadHistory\" });\n\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain,\n      }).withConfig({ runName: \"insertHistory\" });\n    }\n\n    const bound = historyChain\n      .pipe(\n        fields.runnable.withListeners({\n          onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        })\n      )\n      .withConfig({ runName: \"RunnableWithMessageHistory\" });\n\n    const config = fields.config ?? {};\n\n    super({\n      ...fields,\n      config,\n      bound,\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n\n  _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedInputValue;\n    if (\n      typeof inputValue === \"object\" &&\n      !Array.isArray(inputValue) &&\n      !isBaseMessage(inputValue)\n    ) {\n      let key;\n      if (this.inputMessagesKey) {\n        key = this.inputMessagesKey;\n      } else if (Object.keys(inputValue).length === 1) {\n        key = Object.keys(inputValue)[0];\n      } else {\n        key = \"input\";\n      }\n      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n        parsedInputValue = inputValue[key][0];\n      } else {\n        parsedInputValue = inputValue[key];\n      }\n    } else {\n      parsedInputValue = inputValue;\n    }\n    if (typeof parsedInputValue === \"string\") {\n      return [new HumanMessage(parsedInputValue)];\n    } else if (Array.isArray(parsedInputValue)) {\n      return parsedInputValue;\n    } else if (isBaseMessage(parsedInputValue)) {\n      return [parsedInputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(\n          parsedInputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedOutputValue;\n    if (\n      !Array.isArray(outputValue) &&\n      !isBaseMessage(outputValue) &&\n      typeof outputValue !== \"string\"\n    ) {\n      let key;\n      if (this.outputMessagesKey !== undefined) {\n        key = this.outputMessagesKey;\n      } else if (Object.keys(outputValue).length === 1) {\n        key = Object.keys(outputValue)[0];\n      } else {\n        key = \"output\";\n      }\n      // If you are wrapping a chat model directly\n      // The output is actually this weird generations object\n      if (outputValue.generations !== undefined) {\n        parsedOutputValue = outputValue.generations[0][0].message;\n      } else {\n        parsedOutputValue = outputValue[key];\n      }\n    } else {\n      parsedOutputValue = outputValue;\n    }\n\n    if (typeof parsedOutputValue === \"string\") {\n      return [new AIMessage(parsedOutputValue)];\n    } else if (Array.isArray(parsedOutputValue)) {\n      return parsedOutputValue;\n    } else if (isBaseMessage(parsedOutputValue)) {\n      return [parsedOutputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(\n          parsedOutputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    kwargs?: RunnableConfig\n  ): Promise<BaseMessage[]> {\n    const history = kwargs?.configurable?.messageHistory;\n    const messages = await history.getMessages();\n    if (this.historyMessagesKey === undefined) {\n      return messages.concat(this._getInputMessages(input));\n    }\n    return messages;\n  }\n\n  async _exitHistory(run: Run, config: RunnableConfig): Promise<void> {\n    const history = config.configurable?.messageHistory;\n\n    // Get input messages\n    let inputs;\n    // Chat model inputs are nested arrays\n    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n      inputs = run.inputs[0];\n    } else {\n      inputs = run.inputs;\n    }\n    let inputMessages = this._getInputMessages(inputs);\n    // If historic messages were prepended to the input messages, remove them to\n    // avoid adding duplicate messages to history.\n    if (this.historyMessagesKey === undefined) {\n      const existingMessages = await history.getMessages();\n      inputMessages = inputMessages.slice(existingMessages.length);\n    }\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(\n        `Output values from 'Run' undefined. Run: ${JSON.stringify(\n          run,\n          null,\n          2\n        )}`\n      );\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    await history.addMessages([...inputMessages, ...outputMessages]);\n  }\n\n  async _mergeConfig(...configs: Array<RunnableConfig | undefined>) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\",\n      };\n      const exampleConfig = { configurable: { sessionId: \"123\" } };\n      throw new Error(\n        `sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n          `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(\n            exampleConfig\n          )})`\n      );\n    }\n    // attach messageHistory\n    const { sessionId } = config.configurable;\n    config.configurable.messageHistory = await this.getMessageHistory(\n      sessionId\n    );\n    return config;\n  }\n}\n"],"names":["RunnableBinding","fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>","historyChain: Runnable","RunnableLambda","RunnablePassthrough","config","inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>","isBaseMessage","HumanMessage","outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>","AIMessage","input: any","kwargs?: RunnableConfig","run: Run","config: RunnableConfig"],"mappings":"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"}},
    {"offset": {"line": 3062, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/index.cjs","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/index.ts"],"sourcesContent":["export {\n  type RunnableFunc,\n  type RunnableLike,\n  type RunnableRetryFailedAttemptHandler,\n  Runnable,\n  type RunnableBindingArgs,\n  RunnableBinding,\n  RunnableEach,\n  RunnableRetry,\n  RunnableSequence,\n  RunnableMap,\n  RunnableParallel,\n  RunnableLambda,\n  RunnableWithFallbacks,\n  RunnableAssign,\n  RunnablePick,\n  _coerceToRunnable,\n  RunnableToolLike,\n  type RunnableToolLikeArgs,\n} from \"./base.js\";\nexport {\n  type RunnableBatchOptions,\n  type RunnableInterface,\n  type RunnableIOSchema,\n} from \"./types.js\";\nexport {\n  type RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n  ensureConfig,\n  mergeConfigs,\n  pickRunnableConfigKeys,\n} from \"./config.js\";\nexport { RunnablePassthrough } from \"./passthrough.js\";\nexport { type RouterInput, RouterRunnable } from \"./router.js\";\nexport { RunnableBranch, type Branch, type BranchLike } from \"./branch.js\";\nexport {\n  type RunnableWithMessageHistoryInputs,\n  RunnableWithMessageHistory,\n} from \"./history.js\";\nexport { raceWithSignal } from \"../utils/signal.js\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 3131, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/config.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/config.ts"],"sourcesContent":["import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { RunnableConfig } from \"./types.js\";\n\nexport const DEFAULT_RECURSION_LIMIT = 25;\n\nexport { type RunnableConfig };\n\nexport async function getCallbackManagerForConfig(config?: RunnableConfig) {\n  return CallbackManager._configureSync(\n    config?.callbacks,\n    undefined,\n    config?.tags,\n    undefined,\n    config?.metadata\n  );\n}\n\nexport function mergeConfigs<CallOptions extends RunnableConfig>(\n  ...configs: (CallOptions | RunnableConfig | undefined | null)[]\n): Partial<CallOptions> {\n  // We do not want to call ensureConfig on the empty state here as this may cause\n  // double loading of callbacks if async local storage is being used.\n  const copy: Partial<CallOptions> = {};\n  for (const options of configs.filter((c): c is CallOptions => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"tags\") {\n        const baseKeys: string[] = copy[key] ?? [];\n        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n      } else if (key === \"configurable\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"timeout\") {\n        if (copy.timeout === undefined) {\n          copy.timeout = options.timeout;\n        } else if (options.timeout !== undefined) {\n          copy.timeout = Math.min(copy.timeout, options.timeout);\n        }\n      } else if (key === \"signal\") {\n        if (copy.signal === undefined) {\n          copy.signal = options.signal;\n        } else if (options.signal !== undefined) {\n          if (\"any\" in AbortSignal) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            copy.signal = (AbortSignal as any).any([\n              copy.signal,\n              options.signal,\n            ]);\n          } else {\n            copy.signal = options.signal;\n          }\n        }\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(\n              providedCallbacks._parentRunId,\n              {\n                handlers: baseCallbacks.handlers.concat(\n                  providedCallbacks.handlers\n                ),\n                inheritableHandlers: baseCallbacks.inheritableHandlers.concat(\n                  providedCallbacks.inheritableHandlers\n                ),\n                tags: Array.from(\n                  new Set(baseCallbacks.tags.concat(providedCallbacks.tags))\n                ),\n                inheritableTags: Array.from(\n                  new Set(\n                    baseCallbacks.inheritableTags.concat(\n                      providedCallbacks.inheritableTags\n                    )\n                  )\n                ),\n                metadata: {\n                  ...baseCallbacks.metadata,\n                  ...providedCallbacks.metadata,\n                },\n              }\n            );\n          }\n        }\n      } else {\n        const typedKey = key as keyof CallOptions;\n        copy[typedKey] = options[typedKey] ?? copy[typedKey];\n      }\n    }\n  }\n  return copy as Partial<CallOptions>;\n}\n\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig<CallOptions extends RunnableConfig>(\n  config?: CallOptions\n): CallOptions {\n  const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  let empty: RunnableConfig = {\n    tags: [],\n    metadata: {},\n    recursionLimit: 25,\n    runId: undefined,\n  };\n  if (implicitConfig) {\n    // Don't allow runId and runName to be loaded implicitly, as this can cause\n    // child runs to improperly inherit their parents' run ids.\n    const { runId, runName, ...rest } = implicitConfig;\n    empty = Object.entries(rest).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (config) {\n    empty = Object.entries(config).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (empty?.configurable) {\n    for (const key of Object.keys(empty.configurable)) {\n      if (\n        PRIMITIVES.has(typeof empty.configurable[key]) &&\n        !empty.metadata?.[key]\n      ) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = empty.configurable[key];\n      }\n    }\n  }\n  if (empty.timeout !== undefined) {\n    if (empty.timeout <= 0) {\n      throw new Error(\"Timeout must be a positive number\");\n    }\n    const timeoutSignal = AbortSignal.timeout(empty.timeout);\n    if (empty.signal !== undefined) {\n      if (\"any\" in AbortSignal) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        empty.signal = (AbortSignal as any).any([empty.signal, timeoutSignal]);\n      }\n    } else {\n      empty.signal = timeoutSignal;\n    }\n    delete empty.timeout;\n  }\n  return empty as CallOptions;\n}\n\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig<CallOptions extends RunnableConfig>(\n  config: Partial<CallOptions> = {},\n  {\n    callbacks,\n    maxConcurrency,\n    recursionLimit,\n    runName,\n    configurable,\n    runId,\n  }: RunnableConfig = {}\n): Partial<CallOptions> {\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = { ...newConfig.configurable, ...configurable };\n  }\n  if (runId !== undefined) {\n    delete newConfig.runId;\n  }\n  return newConfig;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function pickRunnableConfigKeys<CallOptions extends Record<string, any>>(\n  config?: CallOptions\n): Partial<RunnableConfig> | undefined {\n  if (!config) return undefined;\n\n  return {\n    configurable: config.configurable,\n    recursionLimit: config.recursionLimit,\n    callbacks: config.callbacks,\n    tags: config.tags,\n    metadata: config.metadata,\n    maxConcurrency: config.maxConcurrency,\n    timeout: config.timeout,\n    signal: config.signal,\n    // @ts-expect-error - Store is a LangGraph-specific property\n    // which wewant to pass through to all runnables.\n    // (eg. tools should have access to writing to the store)\n    store: config.store,\n  };\n}\n"],"names":["config?: RunnableConfig","copy: Partial<CallOptions>","baseKeys: string[]","config?: CallOptions","empty: RunnableConfig","currentConfig: Record<string, any>","config: Partial<CallOptions>"],"mappings":"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"}},
    {"offset": {"line": 3298, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/utils.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/utils.ts"],"sourcesContent":["import { StreamEvent } from \"../tracers/event_stream.js\";\nimport type { RunnableInterface } from \"./types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isRunnableInterface(thing: any): thing is RunnableInterface {\n  return thing ? thing.lc_runnable : false;\n}\n\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nexport class _RootEventFilter {\n  includeNames?: string[];\n\n  includeTypes?: string[];\n\n  includeTags?: string[];\n\n  excludeNames?: string[];\n\n  excludeTypes?: string[];\n\n  excludeTags?: string[];\n\n  constructor(fields: {\n    includeNames?: string[];\n    includeTypes?: string[];\n    includeTags?: string[];\n    excludeNames?: string[];\n    excludeTypes?: string[];\n    excludeTags?: string[];\n  }) {\n    this.includeNames = fields.includeNames;\n    this.includeTypes = fields.includeTypes;\n    this.includeTags = fields.includeTags;\n    this.excludeNames = fields.excludeNames;\n    this.excludeTypes = fields.excludeTypes;\n    this.excludeTags = fields.excludeTags;\n  }\n\n  includeEvent(event: StreamEvent, rootType: string): boolean {\n    let include =\n      this.includeNames === undefined &&\n      this.includeTypes === undefined &&\n      this.includeTags === undefined;\n    const eventTags = event.tags ?? [];\n\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(event.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(rootType);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include || eventTags.some((tag) => this.includeTags?.includes(tag));\n    }\n\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(event.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(rootType);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n\n    return include;\n  }\n}\n"],"names":["thing: any","fields: {\n    includeNames?: string[];\n    includeTypes?: string[];\n    includeTags?: string[];\n    excludeNames?: string[];\n    excludeTypes?: string[];\n    excludeTags?: string[];\n  }","event: StreamEvent","rootType: string"],"mappings":";;;;;;;AAIA,SAAgB,oBAAoBA,KAAAA,EAAwC;IAC1E,OAAO,QAAQ,MAAM,WAAA,GAAc;AACpC;;;;;;;GASD,IAAa,mBAAb,MAA8B;IAC5B,aAAA;IAEA,aAAA;IAEA,YAAA;IAEA,aAAA;IAEA,aAAA;IAEA,YAAA;IAEA,YAAYC,MAAAA,CAOT;QACD,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,WAAA,GAAc,OAAO,WAAA;QAC1B,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,YAAA,GAAe,OAAO,YAAA;QAC3B,IAAA,CAAK,WAAA,GAAc,OAAO,WAAA;IAC3B;IAED,aAAaC,KAAAA,EAAoBC,QAAAA,EAA2B;QAC1D,IAAI,UACF,IAAA,CAAK,YAAA,KAAiB,KAAA,KACtB,IAAA,CAAK,YAAA,KAAiB,KAAA,KACtB,IAAA,CAAK,WAAA,KAAgB,KAAA;QACvB,MAAM,YAAY,MAAM,IAAA,IAAQ,CAAE,CAAA;QAElC,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,MAAM,IAAA,CAAK;QAE7D,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,SAAS;QAE3D,IAAI,IAAA,CAAK,WAAA,KAAgB,KAAA,GACvB,UACE,WAAW,UAAU,IAAA,CAAK,CAAC,MAAQ,IAAA,CAAK,WAAA,EAAa,SAAS,IAAI,CAAC;QAGvE,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,CAAC,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,MAAM,IAAA,CAAK;QAE9D,IAAI,IAAA,CAAK,YAAA,KAAiB,KAAA,GACxB,UAAU,WAAW,CAAC,IAAA,CAAK,YAAA,CAAa,QAAA,CAAS,SAAS;QAE5D,IAAI,IAAA,CAAK,WAAA,KAAgB,KAAA,GACvB,UACE,WAAW,UAAU,KAAA,CAAM,CAAC,MAAQ,CAAC,IAAA,CAAK,WAAA,EAAa,SAAS,IAAI,CAAC;QAGzE,OAAO;IACR;AACF"}},
    {"offset": {"line": 3347, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/graph_mermaid.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/graph_mermaid.ts"],"sourcesContent":["import { Edge, Node } from \"./types.js\";\n\nfunction _escapeNodeLabel(nodeLabel: string): string {\n  // Escapes the node label for Mermaid syntax.\n  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\n\nconst MARKDOWN_SPECIAL_CHARS = [\"*\", \"_\", \"`\"];\n\nfunction _generateMermaidGraphStyles(\n  nodeColors: Record<string, string>\n): string {\n  let styles = \"\";\n  for (const [className, color] of Object.entries(nodeColors)) {\n    styles += `\\tclassDef ${className} ${color};\\n`;\n  }\n  return styles;\n}\n\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nexport function drawMermaid(\n  nodes: Record<string, Node>,\n  edges: Edge[],\n  config?: {\n    firstNode?: string;\n    lastNode?: string;\n    curveStyle?: string;\n    withStyles?: boolean;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }\n): string {\n  const {\n    firstNode,\n    lastNode,\n    nodeColors,\n    withStyles = true,\n    curveStyle = \"linear\",\n    wrapLabelNWords = 9,\n  } = config ?? {};\n  // Initialize Mermaid graph configuration\n  let mermaidGraph = withStyles\n    ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n    : \"graph TD;\\n\";\n  if (withStyles) {\n    // Node formatting templates\n    const defaultClassLabel = \"default\";\n    const formatDict: Record<string, string> = {\n      [defaultClassLabel]: \"{0}({1})\",\n    };\n    if (firstNode !== undefined) {\n      formatDict[firstNode] = \"{0}([{1}]):::first\";\n    }\n    if (lastNode !== undefined) {\n      formatDict[lastNode] = \"{0}([{1}]):::last\";\n    }\n\n    // Add nodes to the graph\n    for (const [key, node] of Object.entries(nodes)) {\n      const nodeName = node.name.split(\":\").pop() ?? \"\";\n      const label = MARKDOWN_SPECIAL_CHARS.some(\n        (char) => nodeName.startsWith(char) && nodeName.endsWith(char)\n      )\n        ? `<p>${nodeName}</p>`\n        : nodeName;\n\n      let finalLabel = label;\n      if (Object.keys(node.metadata ?? {}).length) {\n        finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {})\n          .map(([k, v]) => `${k} = ${v}`)\n          .join(\"\\n\")}</em></small>`;\n      }\n\n      const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel])\n        .replace(\"{0}\", _escapeNodeLabel(key))\n        .replace(\"{1}\", finalLabel);\n\n      mermaidGraph += `\\t${nodeLabel}\\n`;\n    }\n  }\n\n  // Group edges by their common prefixes\n  const edgeGroups: Record<string, Edge[]> = {};\n  for (const edge of edges) {\n    const srcParts = edge.source.split(\":\");\n    const tgtParts = edge.target.split(\":\");\n    const commonPrefix = srcParts\n      .filter((src, i) => src === tgtParts[i])\n      .join(\":\");\n    if (!edgeGroups[commonPrefix]) {\n      edgeGroups[commonPrefix] = [];\n    }\n    edgeGroups[commonPrefix].push(edge);\n  }\n\n  const seenSubgraphs = new Set<string>();\n\n  function addSubgraph(edges: Edge[], prefix: string): void {\n    const selfLoop = edges.length === 1 && edges[0].source === edges[0].target;\n    if (prefix && !selfLoop) {\n      const subgraph = prefix.split(\":\").pop()!;\n      if (seenSubgraphs.has(subgraph)) {\n        throw new Error(\n          `Found duplicate subgraph '${subgraph}' -- this likely means that ` +\n            \"you're reusing a subgraph node with the same name. \" +\n            \"Please adjust your graph to have subgraph nodes with unique names.\"\n        );\n      }\n\n      seenSubgraphs.add(subgraph);\n      mermaidGraph += `\\tsubgraph ${subgraph}\\n`;\n    }\n\n    for (const edge of edges) {\n      const { source, target, data, conditional } = edge;\n\n      let edgeLabel = \"\";\n      if (data !== undefined) {\n        let edgeData = data;\n        const words = edgeData.split(\" \");\n        if (words.length > wrapLabelNWords) {\n          edgeData = Array.from(\n            { length: Math.ceil(words.length / wrapLabelNWords) },\n            (_, i) =>\n              words\n                .slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords)\n                .join(\" \")\n          ).join(\"&nbsp;<br>&nbsp;\");\n        }\n        edgeLabel = conditional\n          ? ` -. &nbsp;${edgeData}&nbsp; .-> `\n          : ` -- &nbsp;${edgeData}&nbsp; --> `;\n      } else {\n        edgeLabel = conditional ? \" -.-> \" : \" --> \";\n      }\n\n      mermaidGraph += `\\t${_escapeNodeLabel(\n        source\n      )}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n    }\n\n    // Recursively add nested subgraphs\n    for (const nestedPrefix in edgeGroups) {\n      if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {\n        addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);\n      }\n    }\n\n    if (prefix && !selfLoop) {\n      mermaidGraph += \"\\tend\\n\";\n    }\n  }\n\n  // Start with the top-level edges (no common prefix)\n  addSubgraph(edgeGroups[\"\"] ?? [], \"\");\n\n  // Add remaining subgraphs\n  for (const prefix in edgeGroups) {\n    if (!prefix.includes(\":\") && prefix !== \"\") {\n      addSubgraph(edgeGroups[prefix], prefix);\n    }\n  }\n\n  // Add custom styles for nodes\n  if (withStyles) {\n    mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});\n  }\n\n  return mermaidGraph;\n}\n\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n *\n * @example\n * ```javascript\n * const image = await drawMermaidImage(mermaidSyntax, {\n *   backgroundColor: \"white\",\n *   imageType: \"png\",\n * });\n * fs.writeFileSync(\"image.png\", image);\n * ```\n *\n * @param mermaidSyntax - The Mermaid syntax to render.\n * @param config - The configuration for the image.\n * @returns The image as a Blob.\n */\nexport async function drawMermaidImage(\n  mermaidSyntax: string,\n  config?: {\n    /**\n     * The type of image to render.\n     * @default \"png\"\n     */\n    imageType?: \"png\" | \"jpeg\" | \"webp\";\n    backgroundColor?: string;\n  }\n) {\n  let backgroundColor = config?.backgroundColor ?? \"white\";\n  const imageType = config?.imageType ?? \"png\";\n\n  // Use btoa for compatibility, assume ASCII\n  const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n  // Check if the background color is a hexadecimal color code using regex\n  if (backgroundColor !== undefined) {\n    const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n    if (!hexColorPattern.test(backgroundColor)) {\n      backgroundColor = `!${backgroundColor}`;\n    }\n  }\n  const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;\n  const res = await fetch(imageUrl);\n  if (!res.ok) {\n    throw new Error(\n      [\n        `Failed to render the graph using the Mermaid.INK API.`,\n        `Status code: ${res.status}`,\n        `Status text: ${res.statusText}`,\n      ].join(\"\\n\")\n    );\n  }\n  const content = await res.blob();\n  return content;\n}\n"],"names":["nodeLabel: string","nodeColors: Record<string, string>","nodes: Record<string, Node>","edges: Edge[]","config?: {\n    firstNode?: string;\n    lastNode?: string;\n    curveStyle?: string;\n    withStyles?: boolean;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }","formatDict: Record<string, string>","edgeGroups: Record<string, Edge[]>","prefix: string","edges","mermaidSyntax: string","config?: {\n    /**\n     * The type of image to render.\n     * @default \"png\"\n     */\n    imageType?: \"png\" | \"jpeg\" | \"webp\";\n    backgroundColor?: string;\n  }"],"mappings":"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"}},
    {"offset": {"line": 3465, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/graph.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/graph.ts"],"sourcesContent":["import { v4 as uuidv4, validate as isUuid } from \"uuid\";\nimport type {\n  RunnableInterface,\n  RunnableIOSchema,\n  Node,\n  Edge,\n} from \"./types.js\";\nimport { isRunnableInterface } from \"./utils.js\";\nimport { drawMermaid, drawMermaidImage } from \"./graph_mermaid.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\n\nexport { Node, Edge };\n\nfunction nodeDataStr(\n  id: string | undefined,\n  data: RunnableInterface | RunnableIOSchema\n): string {\n  if (id !== undefined && !isUuid(id)) {\n    return id;\n  } else if (isRunnableInterface(data)) {\n    try {\n      let dataStr = data.getName();\n      dataStr = dataStr.startsWith(\"Runnable\")\n        ? dataStr.slice(\"Runnable\".length)\n        : dataStr;\n      return dataStr;\n    } catch {\n      return data.getName();\n    }\n  } else {\n    return data.name ?? \"UnknownSchema\";\n  }\n}\n\nfunction nodeDataJson(node: Node) {\n  // if node.data implements Runnable\n  if (isRunnableInterface(node.data)) {\n    return {\n      type: \"runnable\",\n      data: {\n        id: node.data.lc_id,\n        name: node.data.getName(),\n      },\n    };\n  } else {\n    return {\n      type: \"schema\",\n      data: { ...toJsonSchema(node.data.schema), title: node.data.name },\n    };\n  }\n}\n\nexport class Graph {\n  nodes: Record<string, Node> = {};\n\n  edges: Edge[] = [];\n\n  constructor(params?: { nodes: Record<string, Node>; edges: Edge[] }) {\n    this.nodes = params?.nodes ?? this.nodes;\n    this.edges = params?.edges ?? this.edges;\n  }\n\n  // Convert the graph to a JSON-serializable format.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): Record<string, any> {\n    const stableNodeIds: Record<string, string | number> = {};\n    Object.values(this.nodes).forEach((node, i) => {\n      stableNodeIds[node.id] = isUuid(node.id) ? i : node.id;\n    });\n\n    return {\n      nodes: Object.values(this.nodes).map((node) => ({\n        id: stableNodeIds[node.id],\n        ...nodeDataJson(node),\n      })),\n      edges: this.edges.map((edge) => {\n        const item: Record<string, unknown> = {\n          source: stableNodeIds[edge.source],\n          target: stableNodeIds[edge.target],\n        };\n\n        if (typeof edge.data !== \"undefined\") {\n          item.data = edge.data;\n        }\n\n        if (typeof edge.conditional !== \"undefined\") {\n          item.conditional = edge.conditional;\n        }\n        return item;\n      }),\n    };\n  }\n\n  addNode(\n    data: RunnableInterface | RunnableIOSchema,\n    id?: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>\n  ): Node {\n    if (id !== undefined && this.nodes[id] !== undefined) {\n      throw new Error(`Node with id ${id} already exists`);\n    }\n    const nodeId = id ?? uuidv4();\n    const node: Node = {\n      id: nodeId,\n      data,\n      name: nodeDataStr(id, data),\n      metadata,\n    };\n    this.nodes[nodeId] = node;\n    return node;\n  }\n\n  removeNode(node: Node): void {\n    // Remove the node from the nodes map\n    delete this.nodes[node.id];\n\n    // Filter out edges connected to the node\n    this.edges = this.edges.filter(\n      (edge) => edge.source !== node.id && edge.target !== node.id\n    );\n  }\n\n  addEdge(\n    source: Node,\n    target: Node,\n    data?: string,\n    conditional?: boolean\n  ): Edge {\n    if (this.nodes[source.id] === undefined) {\n      throw new Error(`Source node ${source.id} not in graph`);\n    }\n    if (this.nodes[target.id] === undefined) {\n      throw new Error(`Target node ${target.id} not in graph`);\n    }\n    const edge: Edge = {\n      source: source.id,\n      target: target.id,\n      data,\n      conditional,\n    };\n    this.edges.push(edge);\n    return edge;\n  }\n\n  firstNode(): Node | undefined {\n    return _firstNode(this);\n  }\n\n  lastNode(): Node | undefined {\n    return _lastNode(this);\n  }\n\n  /**\n   * Add all nodes and edges from another graph.\n   * Note this doesn't check for duplicates, nor does it connect the graphs.\n   */\n  extend(graph: Graph, prefix = \"\") {\n    let finalPrefix = prefix;\n    const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n    if (nodeIds.every(isUuid)) {\n      finalPrefix = \"\";\n    }\n\n    const prefixed = (id: string) => {\n      return finalPrefix ? `${finalPrefix}:${id}` : id;\n    };\n\n    Object.entries(graph.nodes).forEach(([key, value]) => {\n      this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n    });\n\n    const newEdges = graph.edges.map((edge) => {\n      return {\n        ...edge,\n        source: prefixed(edge.source),\n        target: prefixed(edge.target),\n      };\n    });\n    // Add all edges from the other graph\n    this.edges = [...this.edges, ...newEdges];\n    const first = graph.firstNode();\n    const last = graph.lastNode();\n    return [\n      first ? { id: prefixed(first.id), data: first.data } : undefined,\n      last ? { id: prefixed(last.id), data: last.data } : undefined,\n    ];\n  }\n\n  trimFirstNode(): void {\n    const firstNode = this.firstNode();\n    if (firstNode && _firstNode(this, [firstNode.id])) {\n      this.removeNode(firstNode);\n    }\n  }\n\n  trimLastNode(): void {\n    const lastNode = this.lastNode();\n    if (lastNode && _lastNode(this, [lastNode.id])) {\n      this.removeNode(lastNode);\n    }\n  }\n\n  /**\n   * Return a new graph with all nodes re-identified,\n   * using their unique, readable names where possible.\n   */\n  reid(): Graph {\n    const nodeLabels: Record<string, string> = Object.fromEntries(\n      Object.values(this.nodes).map((node) => [node.id, node.name])\n    );\n    const nodeLabelCounts = new Map<string, number>();\n    Object.values(nodeLabels).forEach((label) => {\n      nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n    });\n\n    const getNodeId = (nodeId: string): string => {\n      const label = nodeLabels[nodeId];\n      if (isUuid(nodeId) && nodeLabelCounts.get(label) === 1) {\n        return label;\n      } else {\n        return nodeId;\n      }\n    };\n\n    return new Graph({\n      nodes: Object.fromEntries(\n        Object.entries(this.nodes).map(([id, node]) => [\n          getNodeId(id),\n          { ...node, id: getNodeId(id) },\n        ])\n      ),\n      edges: this.edges.map((edge) => ({\n        ...edge,\n        source: getNodeId(edge.source),\n        target: getNodeId(edge.target),\n      })),\n    });\n  }\n\n  drawMermaid(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }): string {\n    const {\n      withStyles,\n      curveStyle,\n      nodeColors = {\n        default: \"fill:#f2f0ff,line-height:1.2\",\n        first: \"fill-opacity:0\",\n        last: \"fill:#bfb6fc\",\n      },\n      wrapLabelNWords,\n    } = params ?? {};\n    const graph = this.reid();\n    const firstNode = graph.firstNode();\n\n    const lastNode = graph.lastNode();\n\n    return drawMermaid(graph.nodes, graph.edges, {\n      firstNode: firstNode?.id,\n      lastNode: lastNode?.id,\n      withStyles,\n      curveStyle,\n      nodeColors,\n      wrapLabelNWords,\n    });\n  }\n\n  async drawMermaidPng(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }): Promise<Blob> {\n    const mermaidSyntax = this.drawMermaid(params);\n    return drawMermaidImage(mermaidSyntax, {\n      backgroundColor: params?.backgroundColor,\n    });\n  }\n}\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph: Graph, exclude: string[] = []): Node | undefined {\n  const targets = new Set(\n    graph.edges\n      .filter((edge) => !exclude.includes(edge.source))\n      .map((edge) => edge.target)\n  );\n\n  const found: Node[] = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !targets.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}\n\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph: Graph, exclude: string[] = []): Node | undefined {\n  const sources = new Set(\n    graph.edges\n      .filter((edge) => !exclude.includes(edge.target))\n      .map((edge) => edge.source)\n  );\n\n  const found: Node[] = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !sources.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}\n"],"names":["id: string | undefined","data: RunnableInterface | RunnableIOSchema","isUuid","node: Node","params?: { nodes: Record<string, Node>; edges: Edge[] }","stableNodeIds: Record<string, string | number>","item: Record<string, unknown>","id?: string","metadata?: Record<string, any>","uuidv4","source: Node","target: Node","data?: string","conditional?: boolean","edge: Edge","graph: Graph","id: string","nodeLabels: Record<string, string>","nodeId: string","params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }","params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }","exclude: string[]","found: Node[]"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAaA,SAAS,YACPA,EAAAA,EACAC,IAAAA,EACQ;IACR,IAAI,OAAO,KAAA,KAAa,KAACC,mPAAAA,EAAO,GAAG,CACjC,CAAA,OAAO;iBACE,0LAAA,EAAoB,KAAK,CAClC,CAAA,IAAI;QACF,IAAI,UAAU,KAAK,OAAA,EAAS;QAC5B,UAAU,QAAQ,UAAA,CAAW,WAAW,GACpC,QAAQ,KAAA,CAAM,EAAkB,GAChC;QACJ,OAAO;IACR,EAAA,OAAO;QACN,OAAO,KAAK,OAAA,EAAS;IACtB;SAED,OAAO,KAAK,IAAA,IAAQ;AAEvB;AAED,SAAS,aAAaC,IAAAA,EAAY;IAEhC,QAAI,0LAAA,EAAoB,KAAK,IAAA,CAAK,CAChC,CAAA,OAAO;QACL,MAAM;QACN,MAAM;YACJ,IAAI,KAAK,IAAA,CAAK,KAAA;YACd,MAAM,KAAK,IAAA,CAAK,OAAA,EAAS;QAC1B;IACF;SAED,OAAO;QACL,MAAM;QACN,MAAM;YAAE,OAAG,qMAAA,EAAa,KAAK,IAAA,CAAK,MAAA,CAAO;YAAE,OAAO,KAAK,IAAA,CAAK,IAAA;QAAM;IACnE;AAEJ;AAED,IAAa,QAAb,MAAa,MAAM;IACjB,QAA8B,CAAE,EAAA;IAEhC,QAAgB,CAAE,CAAA,CAAA;IAElB,YAAYC,MAAAA,CAAyD;QACnE,IAAA,CAAK,KAAA,GAAQ,QAAQ,SAAS,IAAA,CAAK,KAAA;QACnC,IAAA,CAAK,KAAA,GAAQ,QAAQ,SAAS,IAAA,CAAK,KAAA;IACpC;IAID,SAA8B;QAC5B,MAAMC,gBAAiD,CAAE;QACzD,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,CAAC,OAAA,CAAQ,CAAC,MAAM,MAAM;YAC7C,aAAA,CAAc,KAAK,EAAA,CAAA,OAAMH,mPAAAA,EAAO,KAAK,EAAA,CAAG,GAAG,IAAI,KAAK,EAAA;QACrD,EAAC;QAEF,OAAO;YACL,OAAO,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,OAAA,CAAU;oBAC9C,IAAI,aAAA,CAAc,KAAK,EAAA,CAAA;oBACvB,GAAG,aAAa,KAAK;gBACtB,CAAA,EAAE;YACH,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,CAAC,SAAS;gBAC9B,MAAMI,OAAgC;oBACpC,QAAQ,aAAA,CAAc,KAAK,MAAA,CAAA;oBAC3B,QAAQ,aAAA,CAAc,KAAK,MAAA,CAAA;gBAC5B;gBAED,IAAI,OAAO,KAAK,IAAA,KAAS,aACvB,KAAK,IAAA,GAAO,KAAK,IAAA;gBAGnB,IAAI,OAAO,KAAK,WAAA,KAAgB,aAC9B,KAAK,WAAA,GAAc,KAAK,WAAA;gBAE1B,OAAO;YACR,EAAC;QACH;IACF;IAED,QACEL,IAAAA,EACAM,EAAAA,EAEAC,QAAAA,EACM;QACN,IAAI,OAAO,KAAA,KAAa,IAAA,CAAK,KAAA,CAAM,GAAA,KAAQ,KAAA,EACzC,CAAA,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,GAAG,eAAe,CAAC;QAErD,MAAM,SAAS,UAAMC,iOAAAA,EAAQ;QAC7B,MAAMN,OAAa;YACjB,IAAI;YACJ;YACA,MAAM,YAAY,IAAI,KAAK;YAC3B;QACD;QACD,IAAA,CAAK,KAAA,CAAM,OAAA,GAAU;QACrB,OAAO;IACR;IAED,WAAWA,IAAAA,EAAkB;QAE3B,OAAO,IAAA,CAAK,KAAA,CAAM,KAAK,EAAA,CAAA;QAGvB,IAAA,CAAK,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,MAAA,CACtB,CAAC,OAAS,KAAK,MAAA,KAAW,KAAK,EAAA,IAAM,KAAK,MAAA,KAAW,KAAK,EAAA,CAC3D;IACF;IAED,QACEO,MAAAA,EACAC,MAAAA,EACAC,IAAAA,EACAC,WAAAA,EACM;QACN,IAAI,IAAA,CAAK,KAAA,CAAM,OAAO,EAAA,CAAA,KAAQ,KAAA,EAC5B,CAAA,MAAM,IAAI,MAAM,CAAC,YAAY,EAAE,OAAO,EAAA,CAAG,aAAa,CAAC;QAEzD,IAAI,IAAA,CAAK,KAAA,CAAM,OAAO,EAAA,CAAA,KAAQ,KAAA,EAC5B,CAAA,MAAM,IAAI,MAAM,CAAC,YAAY,EAAE,OAAO,EAAA,CAAG,aAAa,CAAC;QAEzD,MAAMC,OAAa;YACjB,QAAQ,OAAO,EAAA;YACf,QAAQ,OAAO,EAAA;YACf;YACA;QACD;QACD,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,KAAK;QACrB,OAAO;IACR;IAED,YAA8B;QAC5B,OAAO,WAAW,IAAA,CAAK;IACxB;IAED,WAA6B;QAC3B,OAAO,UAAU,IAAA,CAAK;IACvB;;;;IAMD,OAAOC,KAAAA,EAAc,SAAS,EAAA,EAAI;QAChC,IAAI,cAAc;QAClB,MAAM,UAAU,OAAO,MAAA,CAAO,MAAM,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,OAAS,KAAK,EAAA,CAAG;QACjE,IAAI,QAAQ,KAAA,CAAMb,mPAAAA,CAAO,EACvB,cAAc;QAGhB,MAAM,WAAW,CAACc,OAAe;YAC/B,OAAO,cAAc,GAAG,YAAY,CAAC,EAAE,IAAI,GAAG;QAC/C;QAED,OAAO,OAAA,CAAQ,MAAM,KAAA,CAAM,CAAC,OAAA,CAAQ,CAAC,CAAC,KAAK,MAAM,KAAK;YACpD,IAAA,CAAK,KAAA,CAAM,SAAS,IAAI,CAAA,GAAI;gBAAE,GAAG,KAAA;gBAAO,IAAI,SAAS,IAAI;YAAE;QAC5D,EAAC;QAEF,MAAM,WAAW,MAAM,KAAA,CAAM,GAAA,CAAI,CAAC,SAAS;YACzC,OAAO;gBACL,GAAG,IAAA;gBACH,QAAQ,SAAS,KAAK,MAAA,CAAO;gBAC7B,QAAQ,SAAS,KAAK,MAAA,CAAO;YAC9B;QACF,EAAC;QAEF,IAAA,CAAK,KAAA,GAAQ,CAAC;eAAG,IAAA,CAAK,KAAA,EAAO;eAAG,QAAS;SAAA;QACzC,MAAM,QAAQ,MAAM,SAAA,EAAW;QAC/B,MAAM,OAAO,MAAM,QAAA,EAAU;QAC7B,OAAO;YACL,QAAQ;gBAAE,IAAI,SAAS,MAAM,EAAA,CAAG;gBAAE,MAAM,MAAM,IAAA;YAAM,IAAG,KAAA;YACvD,OAAO;gBAAE,IAAI,SAAS,KAAK,EAAA,CAAG;gBAAE,MAAM,KAAK,IAAA;YAAM,IAAG,KAAA,CACrD;SAAA;IACF;IAED,gBAAsB;QACpB,MAAM,YAAY,IAAA,CAAK,SAAA,EAAW;QAClC,IAAI,aAAa,WAAW,IAAA,EAAM;YAAC,UAAU,EAAG;SAAA,CAAC,EAC/C,IAAA,CAAK,UAAA,CAAW,UAAU;IAE7B;IAED,eAAqB;QACnB,MAAM,WAAW,IAAA,CAAK,QAAA,EAAU;QAChC,IAAI,YAAY,UAAU,IAAA,EAAM;YAAC,SAAS,EAAG;SAAA,CAAC,EAC5C,IAAA,CAAK,UAAA,CAAW,SAAS;IAE5B;;;;IAMD,OAAc;QACZ,MAAMC,aAAqC,OAAO,WAAA,CAChD,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,OAAS;gBAAC,KAAK,EAAA;gBAAI,KAAK,IAAK;aAAA,CAAC,CAC9D;QACD,MAAM,kBAAA,aAAA,GAAkB,IAAI;QAC5B,OAAO,MAAA,CAAO,WAAW,CAAC,OAAA,CAAQ,CAAC,UAAU;YAC3C,gBAAgB,GAAA,CAAI,OAAA,CAAQ,gBAAgB,GAAA,CAAI,MAAM,IAAI,CAAA,IAAK,EAAE;QAClE,EAAC;QAEF,MAAM,YAAY,CAACC,WAA2B;YAC5C,MAAM,QAAQ,UAAA,CAAW,OAAA;YACzB,QAAIhB,mPAAAA,EAAO,OAAO,IAAI,gBAAgB,GAAA,CAAI,MAAM,KAAK,EACnD,CAAA,OAAO;iBAEP,OAAO;QAEV;QAED,OAAO,IAAI,MAAM;YACf,OAAO,OAAO,WAAA,CACZ,OAAO,OAAA,CAAQ,IAAA,CAAK,KAAA,CAAM,CAAC,GAAA,CAAI,CAAC,CAAC,IAAI,KAAK,GAAK;oBAC7C,UAAU,GAAG;oBACb;wBAAE,GAAG,IAAA;wBAAM,IAAI,UAAU,GAAG;oBAAE,CAC/B;iBAAA,CAAC,CACH;YACD,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,CAAC,OAAA,CAAU;oBAC/B,GAAG,IAAA;oBACH,QAAQ,UAAU,KAAK,MAAA,CAAO;oBAC9B,QAAQ,UAAU,KAAK,MAAA,CAAO;gBAC/B,CAAA,EAAE;QACJ;IACF;IAED,YAAYiB,MAAAA,EAKD;QACT,MAAM,EACJ,UAAA,EACA,UAAA,EACA,aAAa;YACX,SAAS;YACT,OAAO;YACP,MAAM;QACP,CAAA,EACD,eAAA,EACD,GAAG,UAAU,CAAE;QAChB,MAAM,QAAQ,IAAA,CAAK,IAAA,EAAM;QACzB,MAAM,YAAY,MAAM,SAAA,EAAW;QAEnC,MAAM,WAAW,MAAM,QAAA,EAAU;QAEjC,WAAO,0LAAA,EAAY,MAAM,KAAA,EAAO,MAAM,KAAA,EAAO;YAC3C,WAAW,WAAW;YACtB,UAAU,UAAU;YACpB;YACA;YACA;YACA;QACD,EAAC;IACH;IAED,MAAM,eAAeC,MAAAA,EAMH;QAChB,MAAM,gBAAgB,IAAA,CAAK,WAAA,CAAY,OAAO;QAC9C,WAAO,+LAAA,EAAiB,eAAe;YACrC,iBAAiB,QAAQ;QAC1B,EAAC;IACH;AACF;;;;;;GAOD,SAAS,WAAWL,KAAAA,EAAcM,UAAoB,CAAE,CAAA,EAAoB;IAC1E,MAAM,UAAU,IAAI,IAClB,MAAM,KAAA,CACH,MAAA,CAAO,CAAC,OAAS,CAAC,QAAQ,QAAA,CAAS,KAAK,MAAA,CAAO,CAAC,CAChD,GAAA,CAAI,CAAC,OAAS,KAAK,MAAA,CAAO;IAG/B,MAAMC,QAAgB,CAAE,CAAA;IACxB,KAAK,MAAM,QAAQ,OAAO,MAAA,CAAO,MAAM,KAAA,CAAM,CAC3C,IAAI,CAAC,QAAQ,QAAA,CAAS,KAAK,EAAA,CAAG,IAAI,CAAC,QAAQ,GAAA,CAAI,KAAK,EAAA,CAAG,EACrD,MAAM,IAAA,CAAK,KAAK;IAGpB,OAAO,MAAM,MAAA,KAAW,IAAI,KAAA,CAAM,EAAA,GAAK,KAAA;AACxC;;;;;;GAQD,SAAS,UAAUP,KAAAA,EAAcM,UAAoB,CAAE,CAAA,EAAoB;IACzE,MAAM,UAAU,IAAI,IAClB,MAAM,KAAA,CACH,MAAA,CAAO,CAAC,OAAS,CAAC,QAAQ,QAAA,CAAS,KAAK,MAAA,CAAO,CAAC,CAChD,GAAA,CAAI,CAAC,OAAS,KAAK,MAAA,CAAO;IAG/B,MAAMC,QAAgB,CAAE,CAAA;IACxB,KAAK,MAAM,QAAQ,OAAO,MAAA,CAAO,MAAM,KAAA,CAAM,CAC3C,IAAI,CAAC,QAAQ,QAAA,CAAS,KAAK,EAAA,CAAG,IAAI,CAAC,QAAQ,GAAA,CAAI,KAAK,EAAA,CAAG,EACrD,MAAM,IAAA,CAAK,KAAK;IAGpB,OAAO,MAAM,MAAA,KAAW,IAAI,KAAA,CAAM,EAAA,GAAK,KAAA;AACxC"}},
    {"offset": {"line": 3713, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/wrappers.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/wrappers.ts"],"sourcesContent":["import { IterableReadableStream } from \"../utils/stream.js\";\n\nexport function convertToHttpEventStream(stream: AsyncGenerator) {\n  const encoder = new TextEncoder();\n  const finalStream = new ReadableStream<Uint8Array>({\n    async start(controller) {\n      for await (const chunk of stream) {\n        controller.enqueue(\n          encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`)\n        );\n      }\n      controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n      controller.close();\n    },\n  });\n  return IterableReadableStream.fromReadableStream(finalStream);\n}\n"],"names":["stream: AsyncGenerator"],"mappings":";;;;;;;AAEA,SAAgB,yBAAyBA,MAAAA,EAAwB;IAC/D,MAAM,UAAU,IAAI;IACpB,MAAM,cAAc,IAAI,eAA2B;QACjD,MAAM,OAAM,UAAA,EAAY;YACtB,WAAW,MAAM,SAAS,OACxB,WAAW,OAAA,CACT,QAAQ,MAAA,CAAO,CAAC,mBAAmB,EAAE,KAAK,SAAA,CAAU,MAAM,CAAC,IAAI,CAAC,CAAC,CAClE;YAEH,WAAW,OAAA,CAAQ,QAAQ,MAAA,CAAO,iBAAiB,CAAC;YACpD,WAAW,KAAA,EAAO;QACnB;IACF;IACD,OAAO,0LAAA,CAAuB,kBAAA,CAAmB,YAAY;AAC9D"}},
    {"offset": {"line": 3737, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/iter.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/iter.ts"],"sourcesContent":["import type { RunnableConfig } from \"../runnables/types.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { pickRunnableConfigKeys } from \"./config.js\";\n\nexport function isIterableIterator(\n  thing: unknown\n): thing is IterableIterator<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as Generator)[Symbol.iterator] === \"function\" &&\n    // avoid detecting array/set as iterator\n    typeof (thing as Generator).next === \"function\"\n  );\n}\n\nexport const isIterator = (x: unknown): x is Iterator<unknown> =>\n  x != null &&\n  typeof x === \"object\" &&\n  \"next\" in x &&\n  typeof x.next === \"function\";\n\nexport function isAsyncIterable(\n  thing: unknown\n): thing is AsyncIterable<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as AsyncIterable<unknown>)[Symbol.asyncIterator] ===\n      \"function\"\n  );\n}\n\nexport function* consumeIteratorInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: IterableIterator<T>\n): IterableIterator<T> {\n  while (true) {\n    const { value, done } = AsyncLocalStorageProviderSingleton.runWithConfig(\n      pickRunnableConfigKeys(context),\n      iter.next.bind(iter),\n      true\n    );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n\nexport async function* consumeAsyncIterableInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: AsyncIterable<T>\n): AsyncIterableIterator<T> {\n  const iterator = iter[Symbol.asyncIterator]();\n  while (true) {\n    const { value, done } =\n      await AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(context),\n        iterator.next.bind(iter),\n        true\n      );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n"],"names":["thing: unknown","x: unknown","context: Partial<RunnableConfig> | undefined","iter: IterableIterator<T>","iter: AsyncIterable<T>"],"mappings":";;;;;;;;;;;;;;;;;;;AAIA,SAAgB,mBACdA,KAAAA,EACoC;IACpC,OACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAQ,KAAA,CAAoB,OAAO,QAAA,CAAA,KAAc,cAEjD,OAAQ,MAAoB,IAAA,KAAS;AAExC;AAED,MAAa,aAAa,CAACC,IACzB,KAAK,QACL,OAAO,MAAM,YACb,UAAU,KACV,OAAO,EAAE,IAAA,KAAS;AAEpB,SAAgB,gBACdD,KAAAA,EACiC;IACjC,OACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAQ,KAAA,CAAiC,OAAO,aAAA,CAAA,KAC9C;AAEL;AAED,UAAiB,yBACfE,OAAAA,EACAC,IAAAA,EACqB;IACrB,MAAO,KAAM;QACX,MAAM,EAAE,KAAA,EAAO,IAAA,EAAM,GAAG,iOAAA,CAAmC,aAAA,KACzD,8LAAA,EAAuB,QAAQ,EAC/B,KAAK,IAAA,CAAK,IAAA,CAAK,KAAK,EACpB,KACD;QACD,IAAI,KACF,CAAA;aAEA,MAAM;IAET;AACF;AAED,gBAAuB,8BACrBD,OAAAA,EACAE,IAAAA,EAC0B;IAC1B,MAAM,WAAW,IAAA,CAAK,OAAO,aAAA,CAAA,EAAgB;IAC7C,MAAO,KAAM;QACX,MAAM,EAAE,KAAA,EAAO,IAAA,EAAM,GACnB,MAAM,iOAAA,CAAmC,aAAA,KACvC,8LAAA,EAAuB,QAAQ,EAC/B,SAAS,IAAA,CAAK,IAAA,CAAK,KAAK,EACxB,KACD;QACH,IAAI,KACF,CAAA;aAEA,MAAM;IAET;AACF"}},
    {"offset": {"line": 3784, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/base.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/base.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport {\n  type TraceableFunction,\n  isTraceableFunction,\n} from \"langsmith/singletons/traceable\";\nimport type {\n  RunnableInterface,\n  RunnableBatchOptions,\n  RunnableConfig,\n} from \"./types.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport {\n  LogStreamCallbackHandler,\n  LogStreamCallbackHandlerInput,\n  RunLog,\n  RunLogPatch,\n  isLogStreamHandler,\n} from \"../tracers/log_stream.js\";\nimport {\n  EventStreamCallbackHandler,\n  EventStreamCallbackHandlerInput,\n  StreamEvent,\n  StreamEventData,\n  isStreamEventsHandler,\n} from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport {\n  IterableReadableStream,\n  concat,\n  atee,\n  pipeGeneratorWithSetup,\n  AsyncGeneratorWithSetup,\n} from \"../utils/stream.js\";\nimport { raceWithSignal, getAbortSignalError } from \"../utils/signal.js\";\nimport {\n  DEFAULT_RECURSION_LIMIT,\n  ensureConfig,\n  getCallbackManagerForConfig,\n  mergeConfigs,\n  patchConfig,\n  pickRunnableConfigKeys,\n} from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { Run } from \"../tracers/base.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport {\n  consumeAsyncIterableInContext,\n  consumeIteratorInContext,\n  isAsyncIterable,\n  isIterableIterator,\n  isIterator,\n} from \"./iter.js\";\nimport { _isToolCall, ToolInputParsingException } from \"../tools/utils.js\";\nimport { ToolCall } from \"../messages/tool.js\";\nimport {\n  getSchemaDescription,\n  InferInteropZodOutput,\n  interopParseAsync,\n  InteropZodType,\n  isSimpleStringZodSchema,\n} from \"../utils/types/zod.js\";\n\nexport { type RunnableInterface, RunnableBatchOptions };\n\nexport type RunnableFunc<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> = (\n  input: RunInput,\n  options:\n    | CallOptions\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | Record<string, any>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | (Record<string, any> & CallOptions)\n) => RunOutput | Promise<RunOutput>;\n\nexport type RunnableMapLike<RunInput, RunOutput> = {\n  [K in keyof RunOutput]: RunnableLike<RunInput, RunOutput[K]>;\n};\n\nexport type RunnableLike<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends RunnableConfig = RunnableConfig\n> =\n  | RunnableInterface<RunInput, RunOutput, CallOptions>\n  | RunnableFunc<RunInput, RunOutput, CallOptions>\n  | RunnableMapLike<RunInput, RunOutput>;\n\nexport type RunnableRetryFailedAttemptHandler = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error: any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value: any, defaultKey: string) {\n  return value &&\n    !Array.isArray(value) &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    !(value instanceof Date) &&\n    typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport abstract class Runnable<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Serializable\n  implements RunnableInterface<RunInput, RunOutput, CallOptions>\n{\n  protected lc_runnable = true;\n\n  name?: string;\n\n  getName(suffix?: string): string {\n    const name =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.name ?? (this.constructor as any).lc_name() ?? this.constructor.name;\n    return suffix ? `${name}${suffix}` : name;\n  }\n\n  abstract invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput>;\n\n  /**\n   * Add retry logic to an existing runnable.\n   * @param fields.stopAfterAttempt The number of attempts to retry.\n   * @param fields.onFailedAttempt A function that is called when a retry fails.\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }): RunnableRetry<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields,\n    });\n  }\n\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(\n    config: Partial<CallOptions>\n  ): Runnable<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {},\n    });\n  }\n\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(\n    fields:\n      | {\n          fallbacks: Runnable<RunInput, RunOutput>[];\n        }\n      | Runnable<RunInput, RunOutput>[]\n  ): RunnableWithFallbacks<RunInput, RunOutput> {\n    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks<RunInput, RunOutput>({\n      runnable: this,\n      fallbacks,\n    });\n  }\n\n  protected _getOptionsList<O extends CallOptions & { runType?: string }>(\n    options: Partial<O> | Partial<O>[],\n    length = 0\n  ): Partial<O>[] {\n    if (Array.isArray(options) && options.length !== length) {\n      throw new Error(\n        `Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`\n      );\n    }\n\n    if (Array.isArray(options)) {\n      return options.map(ensureConfig);\n    }\n    if (length > 1 && !Array.isArray(options) && options.runId) {\n      console.warn(\n        \"Provided runId will be used only for the first element of the batch.\"\n      );\n      const subsequent = Object.fromEntries(\n        Object.entries(options).filter(([key]) => key !== \"runId\")\n      );\n\n      return Array.from({ length }, (_, i) =>\n        ensureConfig(i === 0 ? options : subsequent)\n      ) as Partial<O>[];\n    }\n    return Array.from({ length }, () => ensureConfig(options));\n  }\n\n  /**\n   * Default implementation of batch, which calls invoke N times.\n   * Subclasses should override this method if they can batch more efficiently.\n   * @param inputs Array of inputs to each batch call.\n   * @param options Either a single call options object to apply to each batch call or an array for each call.\n   * @param batchOptions.returnExceptions Whether to return errors rather than throwing on the first one\n   * @returns An array of RunOutputs, or mixed RunOutputs and errors if batchOptions.returnExceptions is set\n   */\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: (e) => {\n        throw e;\n      },\n    });\n    const batchCalls = inputs.map((input, i) =>\n      caller.call(async () => {\n        try {\n          const result = await this.invoke(input, configList[i]);\n          return result;\n        } catch (e) {\n          if (batchOptions?.returnExceptions) {\n            return e as Error;\n          }\n          throw e;\n        }\n      })\n    );\n    return Promise.all(batchCalls);\n  }\n\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    yield this.invoke(input, options);\n  }\n\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this._streamIterator(input, config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n\n  protected _separateRunnableConfigFromCallOptions(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, Omit<Partial<CallOptions>, keyof RunnableConfig>] {\n    let runnableConfig;\n    if (options === undefined) {\n      runnableConfig = ensureConfig(options);\n    } else {\n      runnableConfig = ensureConfig({\n        callbacks: options.callbacks,\n        tags: options.tags,\n        metadata: options.metadata,\n        runName: options.runName,\n        configurable: options.configurable,\n        recursionLimit: options.recursionLimit,\n        maxConcurrency: options.maxConcurrency,\n        runId: options.runId,\n        timeout: options.timeout,\n        signal: options.signal,\n      });\n    }\n    const callOptions = { ...(options as Partial<CallOptions>) };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    delete callOptions.runId;\n    delete callOptions.timeout;\n    delete callOptions.signal;\n    return [runnableConfig, callOptions];\n  }\n\n  protected async _callWithConfig<T extends RunInput>(\n    func:\n      | ((input: T) => Promise<RunOutput>)\n      | ((\n          input: T,\n          config?: Partial<CallOptions>,\n          runManager?: CallbackManagerForChainRun\n        ) => Promise<RunOutput>),\n    input: T,\n    options?: Partial<CallOptions> & { runType?: string }\n  ) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config.runId,\n      config?.runType,\n      undefined,\n      undefined,\n      config?.runName ?? this.getName()\n    );\n    delete config.runId;\n    let output;\n    try {\n      const promise = func.call(this, input, config, runManager);\n      output = await raceWithSignal(promise, options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig<T extends RunInput>(\n    func: (\n      inputs: T[],\n      options?: Partial<CallOptions>[],\n      runManagers?: (CallbackManagerForChainRun | undefined)[],\n      batchOptions?: RunnableBatchOptions\n    ) => Promise<(RunOutput | Error)[]>,\n    inputs: T[],\n    options?:\n      | Partial<CallOptions & { runType?: string }>\n      | Partial<CallOptions & { runType?: string }>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      optionsList.map(getCallbackManagerForConfig)\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          optionsList[i].runId,\n          optionsList[i].runType,\n          undefined,\n          undefined,\n          optionsList[i].runName ?? this.getName()\n        );\n        delete optionsList[i].runId;\n        return handleStartRes;\n      })\n    );\n    let outputs: (RunOutput | Error)[];\n    try {\n      const promise = func.call(\n        this,\n        inputs,\n        optionsList,\n        runManagers,\n        batchOptions\n      );\n      outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);\n    } catch (e) {\n      await Promise.all(\n        runManagers.map((runManager) => runManager?.handleChainError(e))\n      );\n      throw e;\n    }\n    await Promise.all(\n      runManagers.map((runManager) =>\n        runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))\n      )\n    );\n    return outputs;\n  }\n\n  /** @internal */\n  _concatOutputChunks<O>(first: O, second: O): O {\n    return concat(first, second);\n  }\n\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  protected async *_transformStreamWithConfig<\n    I extends RunInput,\n    O extends RunOutput\n  >(\n    inputGenerator: AsyncGenerator<I>,\n    transformer: (\n      generator: AsyncGenerator<I>,\n      runManager?: CallbackManagerForChainRun,\n      options?: Partial<CallOptions>\n    ) => AsyncGenerator<O>,\n    options?: Partial<CallOptions> & { runType?: string }\n  ): AsyncGenerator<O> {\n    let finalInput: I | undefined;\n    let finalInputSupported = true;\n    let finalOutput: O | undefined;\n    let finalOutputSupported = true;\n\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const outerThis = this;\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              finalInput = outerThis._concatOutputChunks(\n                finalInput,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                chunk as any\n              );\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n\n    let runManager: CallbackManagerForChainRun | undefined;\n    try {\n      const pipe = await pipeGeneratorWithSetup(\n        transformer.bind(this),\n        wrapInputForTracing(),\n        async () =>\n          callbackManager_?.handleChainStart(\n            this.toJSON(),\n            { input: \"\" },\n            config.runId,\n            config.runType,\n            undefined,\n            undefined,\n            config.runName ?? this.getName()\n          ),\n        options?.signal,\n        config\n      );\n      delete config.runId;\n      runManager = pipe.setup;\n\n      const streamEventsHandler = runManager?.handlers.find(\n        isStreamEventsHandler\n      );\n      let iterator = pipe.output;\n      if (streamEventsHandler !== undefined && runManager !== undefined) {\n        iterator = streamEventsHandler.tapOutputIterable(\n          runManager.runId,\n          iterator\n        );\n      }\n\n      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = streamLogHandler.tapOutputIterable(\n          runManager.runId,\n          iterator\n        );\n      }\n\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              finalOutput = this._concatOutputChunks(\n                finalOutput,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                chunk as any\n              );\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\"),\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(\n      finalOutput ?? {},\n      undefined,\n      undefined,\n      undefined,\n      { inputs: _coerceToDict(finalInput, \"input\") }\n    );\n  }\n\n  getGraph(_?: RunnableConfig): Graph {\n    const graph = new Graph();\n\n    // TODO: Add input schema for runnables\n    const inputNode = graph.addNode({\n      name: `${this.getName()}Input`,\n      schema: z.any(),\n    });\n\n    const runnableNode = graph.addNode(this);\n\n    // TODO: Add output schemas for runnables\n    const outputNode = graph.addNode({\n      name: `${this.getName()}Output`,\n      schema: z.any(),\n    });\n\n    graph.addEdge(inputNode, runnableNode);\n    graph.addEdge(runnableNode, outputNode);\n    return graph;\n  }\n\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<RunOutput, NewRunOutput>\n  ): Runnable<RunInput, Exclude<NewRunOutput, Error>> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable),\n    });\n  }\n\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys: string | string[]): Runnable {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys) as Runnable);\n  }\n\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(\n    mapping: RunnableMapLike<Record<string, unknown>, Record<string, unknown>>\n  ): Runnable {\n    return this.pipe(\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap<Record<string, unknown>>({ steps: mapping })\n      ) as Runnable\n    );\n  }\n\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = this._concatOutputChunks(finalChunk, chunk as any);\n      }\n    }\n    yield* this._streamIterator(finalChunk, ensureConfig(options));\n  }\n\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(\n    input: RunInput,\n    options?: Partial<CallOptions>,\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<RunLogPatch> {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\",\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n\n  protected async *_streamLog(\n    input: RunInput,\n    logStreamCallbackHandler: LogStreamCallbackHandler,\n    config: Partial<CallOptions>\n  ): AsyncGenerator<RunLogPatch> {\n    const { callbacks } = config;\n    if (callbacks === undefined) {\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [\n              {\n                op: \"add\",\n                path: \"/streamed_output/-\",\n                value: chunk,\n              },\n            ],\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n\n  /**\n   * Generate a stream of events emitted by the internal steps of the runnable.\n   *\n   * Use to create an iterator over StreamEvents that provide real-time information\n   * about the progress of the runnable, including StreamEvents from intermediate\n   * results.\n   *\n   * A StreamEvent is a dictionary with the following schema:\n   *\n   * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).\n   * - `name`: string - The name of the runnable that generated the event.\n   * - `run_id`: string - Randomly generated ID associated with the given execution of\n   *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a\n   *   parent runnable is assigned its own unique ID.\n   * - `tags`: string[] - The tags of the runnable that generated the event.\n   * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.\n   * - `data`: Record<string, any>\n   *\n   * Below is a table that illustrates some events that might be emitted by various\n   * chains. Metadata fields have been omitted from the table for brevity.\n   * Chain definitions have been included after the table.\n   *\n   * **ATTENTION** This reference table is for the V2 version of the schema.\n   *\n   * ```md\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | event                | input                       | output/chunk                             |\n   * +======================+=============================+==========================================+\n   * | on_chat_model_start  | {\"messages\": BaseMessage[]} |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chat_model_stream |                             | AIMessageChunk(\"hello\")                  |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chat_model_end    | {\"messages\": BaseMessage[]} | AIMessageChunk(\"hello world\")            |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_start         | {'input': 'hello'}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_stream        |                             | 'Hello'                                  |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_end           | 'Hello human!'              |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_start       |                             |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_stream      |                             | \"hello world!\"                           |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_end         | [Document(...)]             | \"hello world!, goodbye world!\"           |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_tool_start        | {\"x\": 1, \"y\": \"2\"}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_tool_end          |                             | {\"x\": 1, \"y\": \"2\"}                       |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_retriever_start   | {\"query\": \"hello\"}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_retriever_end     | {\"query\": \"hello\"}          | [Document(...), ..]                      |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_prompt_start      | {\"question\": \"hello\"}       |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_prompt_end        | {\"question\": \"hello\"}       | ChatPromptValue(messages: BaseMessage[]) |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * ```\n   *\n   * The \"on_chain_*\" events are the default for Runnables that don't fit one of the above categories.\n   *\n   * In addition to the standard events above, users can also dispatch custom events.\n   *\n   * Custom events will be only be surfaced with in the `v2` version of the API!\n   *\n   * A custom event has following format:\n   *\n   * ```md\n   * +-----------+------+------------------------------------------------------------+\n   * | Attribute | Type | Description                                                |\n   * +===========+======+============================================================+\n   * | name      | str  | A user defined name for the event.                         |\n   * +-----------+------+------------------------------------------------------------+\n   * | data      | Any  | The data associated with the event. This can be anything.  |\n   * +-----------+------+------------------------------------------------------------+\n   * ```\n   *\n   * Here's an example:\n   *\n   * ```ts\n   * import { RunnableLambda } from \"@langchain/core/runnables\";\n   * import { dispatchCustomEvent } from \"@langchain/core/callbacks/dispatch\";\n   * // Use this import for web environments that don't support \"async_hooks\"\n   * // and manually pass config to child runs.\n   * // import { dispatchCustomEvent } from \"@langchain/core/callbacks/dispatch/web\";\n   *\n   * const slowThing = RunnableLambda.from(async (someInput: string) => {\n   *   // Placeholder for some slow operation\n   *   await new Promise((resolve) => setTimeout(resolve, 100));\n   *   await dispatchCustomEvent(\"progress_event\", {\n   *    message: \"Finished step 1 of 2\",\n   *  });\n   *  await new Promise((resolve) => setTimeout(resolve, 100));\n   *  return \"Done\";\n   * });\n   *\n   * const eventStream = await slowThing.streamEvents(\"hello world\", {\n   *   version: \"v2\",\n   * });\n   *\n   * for await (const event of eventStream) {\n   *  if (event.event === \"on_custom_event\") {\n   *    console.log(event);\n   *  }\n   * }\n   * ```\n   */\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<Uint8Array>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    let stream;\n    if (options.version === \"v1\") {\n      stream = this._streamEventsV1(input, options, streamOptions);\n    } else if (options.version === \"v2\") {\n      stream = this._streamEventsV2(input, options, streamOptions);\n    } else {\n      throw new Error(\n        `Only versions \"v1\" and \"v2\" of the schema are currently supported.`\n      );\n    }\n    if (options.encoding === \"text/event-stream\") {\n      return convertToHttpEventStream(stream);\n    } else {\n      return IterableReadableStream.fromAsyncGenerator(stream);\n    }\n  }\n\n  private async *_streamEventsV2(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<StreamEvent> {\n    const eventStreamer = new EventStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n    });\n    const config = ensureConfig(options);\n    const runId = config.runId ?? uuidv4();\n    config.runId = runId;\n    const callbacks = config.callbacks;\n    if (callbacks === undefined) {\n      config.callbacks = [eventStreamer];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat(eventStreamer);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(eventStreamer, true);\n      config.callbacks = copiedCallbacks;\n    }\n    const abortController = new AbortController();\n    // Call the runnable in streaming mode,\n    // add each chunk to the output stream\n    const outerThis = this;\n    async function consumeRunnableStream() {\n      let signal;\n      let listener: (() => void) | null = null;\n\n      try {\n        if (options?.signal) {\n          if (\"any\" in AbortSignal) {\n            // Use native AbortSignal.any() if available (Node 19+)\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signal = (AbortSignal as any).any([\n              abortController.signal,\n              options.signal,\n            ]);\n          } else {\n            // Fallback for Node 18 and below - just use the provided signal\n            signal = options.signal;\n            // Ensure we still abort our controller when the parent signal aborts\n\n            listener = () => {\n              abortController.abort();\n            };\n\n            options.signal.addEventListener(\"abort\", listener, { once: true });\n          }\n        } else {\n          signal = abortController.signal;\n        }\n        const runnableStream = await outerThis.stream(input, {\n          ...config,\n          signal,\n        });\n        const tappedStream = eventStreamer.tapOutputIterable(\n          runId,\n          runnableStream\n        );\n        for await (const _ of tappedStream) {\n          // Just iterate so that the callback handler picks up events\n          if (abortController.signal.aborted) break;\n        }\n      } finally {\n        await eventStreamer.finish();\n\n        if (signal && listener) {\n          signal.removeEventListener(\"abort\", listener);\n        }\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    let firstEventSent = false;\n    let firstEventRunId;\n    try {\n      for await (const event of eventStreamer) {\n        // This is a work-around an issue where the inputs into the\n        // chain are not available until the entire input is consumed.\n        // As a temporary solution, we'll modify the input to be the input\n        // that was passed into the chain.\n        if (!firstEventSent) {\n          event.data.input = input;\n          firstEventSent = true;\n          firstEventRunId = event.run_id;\n          yield event;\n          continue;\n        }\n        if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n          // If it's the end event corresponding to the root runnable\n          // we dont include the input in the event since it's guaranteed\n          // to be included in the first event.\n          if (event.data?.input) {\n            delete event.data.input;\n          }\n        }\n        yield event;\n      }\n    } finally {\n      abortController.abort();\n      await runnableStreamConsumePromise;\n    }\n  }\n\n  private async *_streamEventsV1(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<StreamEvent> {\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = config.tags ?? [];\n    const rootMetadata = config.metadata ?? {};\n    const rootName = config.runName ?? this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\",\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions,\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(\n          `Internal error: \"streamEvents\" state is missing. Please open a bug report.`\n        );\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = { ...runLog.state };\n        const event: StreamEvent = {\n          run_id: state.id,\n          event: `on_${state.type}_start`,\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input,\n          },\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops\n        .filter((op) => op.path.startsWith(\"/logs/\"))\n        .map((op) => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data: StreamEventData = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(\n              `Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`\n            );\n          }\n          data = { chunk: logEntry.streamed_output[0] };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: `on_${logEntry.type}_${eventType}`,\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data,\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const { state } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(\n            `Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`\n          );\n        }\n        const data = { chunk: state.streamed_output[0] };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: `on_${state.type}_stream`,\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data,\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = runLog?.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: `on_${state.type}_end`,\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output,\n        },\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing: any): thing is Runnable {\n    return isRunnableInterface(thing);\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n  }): Runnable<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding<RunInput, RunOutput, CallOptions>({\n      bound: this,\n      config: {},\n      configFactories: [\n        (config) => ({\n          callbacks: [\n            new RootListenersTracer({\n              config,\n              onStart,\n              onEnd,\n              onError,\n            }),\n          ],\n        }),\n      ],\n    });\n  }\n\n  /**\n   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n   * which contains the runnable, name, description and schema.\n   *\n   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n   *\n   * @param fields\n   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n   */\n  asTool<T extends RunInput = RunInput>(fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<T>;\n  }): RunnableToolLike<InteropZodType<T | ToolCall>, RunOutput> {\n    return convertRunnableToTool<T, RunOutput>(this, fields);\n  }\n}\n\nexport type RunnableBindingArgs<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> = {\n  bound: Runnable<RunInput, RunOutput, CallOptions>;\n  /** @deprecated Use {@link config} instead. */\n  kwargs?: Partial<CallOptions>;\n  config: RunnableConfig;\n  configFactories?: Array<\n    (config: RunnableConfig) => RunnableConfig | Promise<RunnableConfig>\n  >;\n};\n\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.withConfig({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.withConfig({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nexport class RunnableBinding<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  bound: Runnable<RunInput, RunOutput, CallOptions>;\n\n  config: RunnableConfig;\n\n  kwargs?: Partial<CallOptions>;\n\n  configFactories?: Array<\n    (config: RunnableConfig) => RunnableConfig | Promise<RunnableConfig>\n  >;\n\n  constructor(fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>) {\n    super(fields);\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n\n  getName(suffix?: string | undefined): string {\n    return this.bound.getName(suffix);\n  }\n\n  async _mergeConfig(\n    ...options: (Partial<CallOptions> | RunnableConfig | undefined)[]\n  ): Promise<Partial<CallOptions>> {\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(\n      config,\n      ...(this.configFactories\n        ? await Promise.all(\n            this.configFactories.map(\n              async (configFactory) => await configFactory(config)\n            )\n          )\n        : [])\n    );\n  }\n\n  withConfig(\n    config: Partial<CallOptions>\n  ): Runnable<RunInput, RunOutput, CallOptions> {\n    return new (this.constructor as {\n      new (\n        fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>\n      ): RunnableBinding<RunInput, RunOutput, CallOptions>;\n    })({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: { ...this.config, ...config },\n    });\n  }\n\n  withRetry(fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }): RunnableRetry<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields,\n    });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this.bound.invoke(\n      input,\n      await this._mergeConfig(options, this.kwargs)\n    );\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const mergedOptions = Array.isArray(options)\n      ? await Promise.all(\n          options.map(async (individualOption) =>\n            this._mergeConfig(ensureConfig(individualOption), this.kwargs)\n          )\n        )\n      : await this._mergeConfig(ensureConfig(options), this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n\n  /** @internal */\n  override _concatOutputChunks<O>(first: O, second: O): O {\n    return this.bound._concatOutputChunks(first, second);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<CallOptions> | undefined\n  ) {\n    yield* this.bound._streamIterator(\n      input,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions> | undefined\n  ): Promise<IterableReadableStream<RunOutput>> {\n    return this.bound.stream(\n      input,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    yield* this.bound.transform(\n      generator,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<Uint8Array>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    const outerThis = this;\n    const generator = async function* () {\n      yield* outerThis.bound.streamEvents(\n        input,\n        {\n          ...(await outerThis._mergeConfig(\n            ensureConfig(options),\n            outerThis.kwargs\n          )),\n          version: options.version,\n        },\n        streamOptions\n      );\n    };\n    return IterableReadableStream.fromAsyncGenerator(generator());\n  }\n\n  static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing: any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): thing is RunnableBinding<any, any, any> {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n  }): Runnable<RunInput, RunOutput, CallOptions> {\n    return new RunnableBinding<RunInput, RunOutput, CallOptions>({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [\n        (config) => ({\n          callbacks: [\n            new RootListenersTracer({\n              config,\n              onStart,\n              onEnd,\n              onError,\n            }),\n          ],\n        }),\n      ],\n    });\n  }\n}\n\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n */\nexport class RunnableEach<\n  RunInputItem,\n  RunOutputItem,\n  CallOptions extends RunnableConfig\n> extends Runnable<RunInputItem[], RunOutputItem[], CallOptions> {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n\n  constructor(fields: {\n    bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n  }) {\n    super(fields);\n    this.bound = fields.bound;\n  }\n\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(\n    inputs: RunInputItem[],\n    config?: Partial<CallOptions>\n  ): Promise<RunOutputItem[]> {\n    return this._callWithConfig(this._invoke.bind(this), inputs, config);\n  }\n\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  protected async _invoke(\n    inputs: RunInputItem[],\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutputItem[]> {\n    return this.bound.batch(\n      inputs,\n      patchConfig(config, { callbacks: runManager?.getChild() })\n    );\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): Runnable<any, any, CallOptions> {\n    return new RunnableEach<RunInputItem, RunOutputItem, CallOptions>({\n      bound: this.bound.withListeners({ onStart, onEnd, onError }),\n    });\n  }\n}\n\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nexport class RunnableRetry<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends RunnableBinding<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected maxAttemptNumber = 3;\n\n  onFailedAttempt: RunnableRetryFailedAttemptHandler = () => {\n    // empty\n  };\n\n  constructor(\n    fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions> & {\n      maxAttemptNumber?: number;\n      onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n    }\n  ) {\n    super(fields);\n    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n  }\n\n  _patchConfigForRetry(\n    attempt: number,\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ): Partial<CallOptions> {\n    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n    return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n  }\n\n  protected async _invoke(\n    input: RunInput,\n    config?: CallOptions,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    return pRetry(\n      (attemptNumber: number) =>\n        super.invoke(\n          input,\n          this._patchConfigForRetry(attemptNumber, config, runManager)\n        ),\n      {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onFailedAttempt: ({ error }: { error: any }) =>\n          this.onFailedAttempt(error, input),\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true,\n      }\n    );\n  }\n\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input: RunInput, config?: CallOptions): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke.bind(this), input, config);\n  }\n\n  async _batch<ReturnExceptions extends boolean = false>(\n    inputs: RunInput[],\n    configs?: RunnableConfig[],\n    runManagers?: (CallbackManagerForChainRun | undefined)[],\n    batchOptions?: RunnableBatchOptions\n  ) {\n    const resultsMap: Record<string, RunOutput | Error> = {};\n    try {\n      await pRetry(\n        async (attemptNumber: number) => {\n          const remainingIndexes = inputs\n            .map((_, i) => i)\n            .filter(\n              (i) =>\n                resultsMap[i.toString()] === undefined ||\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                resultsMap[i.toString()] instanceof Error\n            );\n          const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n          const patchedConfigs = remainingIndexes.map((i) =>\n            this._patchConfigForRetry(\n              attemptNumber,\n              configs?.[i] as CallOptions,\n              runManagers?.[i]\n            )\n          );\n          const results = await super.batch(remainingInputs, patchedConfigs, {\n            ...batchOptions,\n            returnExceptions: true,\n          });\n          let firstException;\n          for (let i = 0; i < results.length; i += 1) {\n            const result = results[i];\n            const resultMapIndex = remainingIndexes[i];\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (result instanceof Error) {\n              if (firstException === undefined) {\n                firstException = result;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (firstException as any).input = remainingInputs[i];\n              }\n            }\n            resultsMap[resultMapIndex.toString()] = result;\n          }\n          if (firstException) {\n            throw firstException;\n          }\n          return results;\n        },\n        {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          onFailedAttempt: ({ error }: { error: any }) =>\n            this.onFailedAttempt(error, error.input),\n          retries: Math.max(this.maxAttemptNumber - 1, 0),\n          randomize: true,\n        }\n      );\n    } catch (e) {\n      if (batchOptions?.returnExceptions !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap)\n      .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n      .map(\n        (key) => resultsMap[parseInt(key, 10)]\n      ) as ReturnExceptions extends false ? RunOutput[] : (RunOutput | Error)[];\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    return this._batchWithConfig(\n      this._batch.bind(this),\n      inputs,\n      options,\n      batchOptions\n    );\n  }\n}\n\nexport type RunnableSequenceFields<RunInput, RunOutput> = {\n  first: Runnable<RunInput>;\n  middle?: Runnable[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  last: Runnable<any, RunOutput>;\n  name?: string;\n  omitSequenceTags?: boolean;\n};\n\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n\n  protected first: Runnable<RunInput>;\n\n  protected middle: Runnable[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected last: Runnable<any, RunOutput>;\n\n  omitSequenceTags = false;\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  constructor(fields: RunnableSequenceFields<RunInput, RunOutput>) {\n    super(fields);\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n    this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n  }\n\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n\n  async invoke(input: RunInput, options?: RunnableConfig): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    delete config.runId;\n    let nextStepInput = input;\n    let finalOutput: RunOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        const promise = step.invoke(\n          nextStepInput,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            ),\n          })\n        );\n        nextStepInput = await raceWithSignal(promise, options?.signal);\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      if (options?.signal?.aborted) {\n        throw getAbortSignalError(options.signal);\n      }\n      finalOutput = await this.last.invoke(\n        nextStepInput,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\n            this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`\n          ),\n        })\n      );\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      configList.map(getCallbackManagerForConfig)\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          configList[i].runId,\n          undefined,\n          undefined,\n          undefined,\n          configList[i].runName\n        );\n        delete configList[i].runId;\n        return handleStartRes;\n      })\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs: any = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        const promise = step.batch(\n          nextStepInputs,\n          runManagers.map((runManager, j) => {\n            const childRunManager = runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            );\n            return patchConfig(configList[j], { callbacks: childRunManager });\n          }),\n          batchOptions\n        );\n        nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);\n      }\n    } catch (e) {\n      await Promise.all(\n        runManagers.map((runManager) => runManager?.handleChainError(e))\n      );\n      throw e;\n    }\n    await Promise.all(\n      runManagers.map((runManager) =>\n        runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))\n      )\n    );\n    return nextStepInputs;\n  }\n\n  /** @internal */\n  override _concatOutputChunks<O>(first: O, second: O): O {\n    return this.last._concatOutputChunks(first, second);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: RunnableConfig\n  ): AsyncGenerator<RunOutput> {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const { runId, ...otherOptions } = options ?? {};\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherOptions?.runName\n    );\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(\n        inputGenerator(),\n        patchConfig(otherOptions, {\n          callbacks: runManager?.getChild(\n            this.omitSequenceTags ? undefined : `seq:step:1`\n          ),\n        })\n      );\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(\n          finalGenerator,\n          patchConfig(otherOptions, {\n            callbacks: runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            ),\n          })\n        );\n      }\n      for await (const chunk of finalGenerator) {\n        options?.signal?.throwIfAborted();\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = this._concatOutputChunks(finalOutput, chunk as any);\n            } catch {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n\n  getGraph(config?: RunnableConfig): Graph {\n    const graph = new Graph();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentLastNode: any = null;\n\n    this.steps.forEach((step, index) => {\n      const stepGraph = step.getGraph(config);\n\n      if (index !== 0) {\n        stepGraph.trimFirstNode();\n      }\n\n      if (index !== this.steps.length - 1) {\n        stepGraph.trimLastNode();\n      }\n\n      graph.extend(stepGraph);\n\n      const stepFirstNode = stepGraph.firstNode();\n      if (!stepFirstNode) {\n        throw new Error(`Runnable ${step} has no first node`);\n      }\n\n      if (currentLastNode) {\n        graph.addEdge(currentLastNode, stepFirstNode);\n      }\n\n      currentLastNode = stepGraph.lastNode();\n    });\n\n    return graph;\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<RunOutput, NewRunOutput>\n  ): RunnableSequence<RunInput, Exclude<NewRunOutput, Error>> {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([\n          this.last,\n          coerceable.first,\n          ...coerceable.middle,\n        ]),\n        last: coerceable.last,\n        name: this.name ?? coerceable.name,\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name,\n      });\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing: any): thing is RunnableSequence {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    [first, ...runnables]: [\n      RunnableLike<RunInput>,\n      ...RunnableLike[],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      RunnableLike<any, RunOutput>\n    ],\n    nameOrFields?:\n      | string\n      | Omit<\n          RunnableSequenceFields<RunInput, RunOutput>,\n          \"first\" | \"middle\" | \"last\"\n        >\n  ) {\n    let extra: Record<string, unknown> = {};\n    if (typeof nameOrFields === \"string\") {\n      extra.name = nameOrFields;\n    } else if (nameOrFields !== undefined) {\n      extra = nameOrFields;\n    }\n    return new RunnableSequence<RunInput, Exclude<RunOutput, Error>>({\n      ...extra,\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1]),\n    });\n  }\n}\n\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput extends Record<string, any> = Record<string, any>\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  protected steps: Record<string, Runnable<RunInput>>;\n\n  public getStepsKeys(): string[] {\n    return Object.keys(this.steps);\n  }\n\n  constructor(fields: { steps: RunnableMapLike<RunInput, RunOutput> }) {\n    super(fields);\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n\n  static from<\n    RunInput,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    steps: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableMap<RunInput, RunOutput> {\n    return new RunnableMap<RunInput, RunOutput>({ steps });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      {\n        input,\n      },\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    delete config.runId;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output: Record<string, any> = {};\n    try {\n      const promises = Object.entries(this.steps).map(\n        async ([key, runnable]) => {\n          output[key] = await runnable.invoke(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`map:key:${key}`),\n            })\n          );\n        }\n      );\n      await raceWithSignal(Promise.all(promises), options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output as RunOutput;\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    // shallow copy steps to ignore changes while iterating\n    const steps = { ...this.steps };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(\n      Object.entries(steps).map(([key, runnable], i) => {\n        const gen = runnable.transform(\n          inputCopies[i],\n          patchConfig(options, {\n            callbacks: runManager?.getChild(`map:key:${key}`),\n          })\n        );\n        return [key, gen.next().then((result) => ({ key, gen, result }))];\n      })\n    );\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const promise = Promise.race(tasks.values());\n      const { key, result, gen } = await raceWithSignal(\n        promise,\n        options?.signal\n      );\n      tasks.delete(key);\n      if (!result.done) {\n        yield { [key]: result.value } as unknown as RunOutput;\n        tasks.set(\n          key,\n          gen.next().then((result) => ({ key, gen, result }))\n        );\n      }\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyTraceableFunction = TraceableFunction<(...any: any[]) => any>;\n\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable<RunInput, RunOutput> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  lc_serializable = false;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected func: AnyTraceableFunction;\n\n  constructor(fields: { func: AnyTraceableFunction }) {\n    super(fields);\n\n    if (!isTraceableFunction(fields.func)) {\n      throw new Error(\n        \"RunnableTraceable requires a function that is wrapped in traceable higher-order function\"\n      );\n    }\n\n    this.func = fields.func;\n  }\n\n  async invoke(input: RunInput, options?: Partial<RunnableConfig>) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const callbacks = await getCallbackManagerForConfig(config);\n    const promise = this.func(\n      patchConfig(config, { callbacks }),\n      input\n    ) as Promise<RunOutput>;\n\n    return raceWithSignal(promise, config?.signal);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const result = await this.invoke(input, options);\n\n    if (isAsyncIterable(result)) {\n      for await (const item of result) {\n        config?.signal?.throwIfAborted();\n        yield item as RunOutput;\n      }\n      return;\n    }\n\n    if (isIterator(result)) {\n      while (true) {\n        config?.signal?.throwIfAborted();\n        const state: IteratorResult<unknown> = result.next();\n        if (state.done) break;\n        yield state.value as RunOutput;\n      }\n      return;\n    }\n\n    yield result;\n  }\n\n  static from(func: AnyTraceableFunction) {\n    return new RunnableTraceable({ func });\n  }\n}\n\nfunction assertNonTraceableFunction<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n>(\n  func:\n    | RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    | TraceableFunction<\n        RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      >\n): asserts func is RunnableFunc<\n  RunInput,\n  RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n  CallOptions\n> {\n  if (isTraceableFunction(func)) {\n    throw new Error(\n      \"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\"\n    );\n  }\n}\n\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nexport class RunnableLambda<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected func: RunnableFunc<\n    RunInput,\n    RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n    CallOptions\n  >;\n\n  constructor(fields: {\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >;\n  }) {\n    if (isTraceableFunction(fields.func)) {\n      // eslint-disable-next-line no-constructor-return\n      return RunnableTraceable.from(fields.func) as unknown as RunnableLambda<\n        RunInput,\n        RunOutput,\n        CallOptions\n      >;\n    }\n\n    super(fields);\n\n    assertNonTraceableFunction(fields.func);\n    this.func = fields.func;\n  }\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func: RunnableFunc<\n      RunInput,\n      RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n      CallOptions\n    >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions>;\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func: TraceableFunction<\n      RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions>;\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions> {\n    return new RunnableLambda({\n      func,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    return new Promise<RunOutput>((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n      });\n      // eslint-disable-next-line no-void\n      void AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(childConfig),\n        async () => {\n          try {\n            let output = await this.func(input, {\n              ...childConfig,\n            });\n            if (output && Runnable.isRunnable(output)) {\n              if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n              }\n              output = await output.invoke(input, {\n                ...childConfig,\n                recursionLimit:\n                  (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n              });\n            } else if (isAsyncIterable(output)) {\n              let finalOutput: RunOutput | undefined;\n              for await (const chunk of consumeAsyncIterableInContext(\n                childConfig,\n                output\n              )) {\n                config?.signal?.throwIfAborted();\n                if (finalOutput === undefined) {\n                  finalOutput = chunk as RunOutput;\n                } else {\n                  // Make a best effort to gather, for any type that supports concat.\n                  try {\n                    finalOutput = this._concatOutputChunks(\n                      finalOutput,\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      chunk as any\n                    );\n                  } catch {\n                    finalOutput = chunk as RunOutput;\n                  }\n                }\n              }\n              output = finalOutput as typeof output;\n            } else if (isIterableIterator(output)) {\n              let finalOutput: RunOutput | undefined;\n              for (const chunk of consumeIteratorInContext(\n                childConfig,\n                output\n              )) {\n                config?.signal?.throwIfAborted();\n                if (finalOutput === undefined) {\n                  finalOutput = chunk as RunOutput;\n                } else {\n                  // Make a best effort to gather, for any type that supports concat.\n                  try {\n                    finalOutput = this._concatOutputChunks(\n                      finalOutput,\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      chunk as any\n                    );\n                  } catch {\n                    finalOutput = chunk as RunOutput;\n                  }\n                }\n              }\n              output = finalOutput as typeof output;\n            }\n            resolve(output);\n          } catch (e) {\n            reject(e);\n          }\n        }\n      );\n    });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke.bind(this), input, options);\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    config?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    let finalChunk: RunInput | undefined;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = this._concatOutputChunks(finalChunk, chunk as any);\n        } catch {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const childConfig = patchConfig(config, {\n      callbacks: runManager?.getChild(),\n      recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n    });\n    const output = await new Promise<RunOutput | Runnable>(\n      (resolve, reject) => {\n        // eslint-disable-next-line no-void\n        void AsyncLocalStorageProviderSingleton.runWithConfig(\n          pickRunnableConfigKeys(childConfig),\n          async () => {\n            try {\n              const res = await this.func(finalChunk as RunInput, {\n                ...childConfig,\n                config: childConfig,\n              });\n              resolve(res);\n            } catch (e) {\n              reject(e);\n            }\n          }\n        );\n      }\n    );\n    if (output && Runnable.isRunnable(output)) {\n      if (config?.recursionLimit === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk as RunInput, childConfig);\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else if (isAsyncIterable(output)) {\n      for await (const chunk of consumeAsyncIterableInContext(\n        childConfig,\n        output\n      )) {\n        config?.signal?.throwIfAborted();\n        yield chunk as RunOutput;\n      }\n    } else if (isIterableIterator(output)) {\n      for (const chunk of consumeIteratorInContext(childConfig, output)) {\n        config?.signal?.throwIfAborted();\n        yield chunk as RunOutput;\n      }\n    } else {\n      yield output;\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nexport class RunnableParallel<RunInput> extends RunnableMap<RunInput> {}\n\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nexport class RunnableWithFallbacks<RunInput, RunOutput> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnable: Runnable<RunInput, RunOutput>;\n\n  fallbacks: Runnable<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    runnable: Runnable<RunInput, RunOutput>;\n    fallbacks: Runnable<RunInput, RunOutput>[];\n  }) {\n    super(fields);\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const { runId, ...otherConfigFields } = config;\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherConfigFields?.runName\n    );\n    const childConfig = patchConfig(otherConfigFields, {\n      callbacks: runManager?.getChild(),\n    });\n    const res = await AsyncLocalStorageProviderSingleton.runWithConfig(\n      childConfig,\n      async () => {\n        let firstError;\n        for (const runnable of this.runnables()) {\n          config?.signal?.throwIfAborted();\n          try {\n            const output = await runnable.invoke(input, childConfig);\n            await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n            return output;\n          } catch (e) {\n            if (firstError === undefined) {\n              firstError = e;\n            }\n          }\n        }\n        if (firstError === undefined) {\n          throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n      }\n    );\n    return res;\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<RunnableConfig> | undefined\n  ): AsyncGenerator<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const { runId, ...otherConfigFields } = config;\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherConfigFields?.runName\n    );\n    let firstError;\n    let stream;\n    for (const runnable of this.runnables()) {\n      config?.signal?.throwIfAborted();\n      const childConfig = patchConfig(otherConfigFields, {\n        callbacks: runManager?.getChild(),\n      });\n      try {\n        const originalStream = await runnable.stream(input, childConfig);\n        stream = consumeAsyncIterableInContext(childConfig, originalStream);\n        break;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (stream === undefined) {\n      const error =\n        firstError ?? new Error(\"No error stored at end of fallback.\");\n      await runManager?.handleChainError(error);\n      throw error;\n    }\n    let output;\n    try {\n      for await (const chunk of stream) {\n        yield chunk;\n        try {\n          output =\n            output === undefined\n              ? output\n              : this._concatOutputChunks(output, chunk);\n        } catch {\n          output = undefined;\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    if (batchOptions?.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      configList.map((config) => getCallbackManagerForConfig(config))\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          configList[i].runId,\n          undefined,\n          undefined,\n          undefined,\n          configList[i].runName\n        );\n        delete configList[i].runId;\n        return handleStartRes;\n      })\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError: any;\n    for (const runnable of this.runnables()) {\n      configList[0].signal?.throwIfAborted();\n      try {\n        const outputs = await runnable.batch(\n          inputs,\n          runManagers.map((runManager, j) =>\n            patchConfig(configList[j], {\n              callbacks: runManager?.getChild(),\n            })\n          ),\n          batchOptions\n        );\n        await Promise.all(\n          runManagers.map((runManager, i) =>\n            runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))\n          )\n        );\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(\n      runManagers.map((runManager) => runManager?.handleChainError(firstError))\n    );\n    throw firstError;\n  }\n}\n\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n>(\n  coerceable: RunnableLike<RunInput, RunOutput, CallOptions>\n): Runnable<RunInput, Exclude<RunOutput, Error>, CallOptions> {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({ func: coerceable }) as Runnable<\n      RunInput,\n      Exclude<RunOutput, Error>,\n      CallOptions\n    >;\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable as Runnable<\n      RunInput,\n      Exclude<RunOutput, Error>,\n      CallOptions\n    >;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables: Record<string, Runnable<RunInput>> = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value as RunnableLike);\n    }\n    return new RunnableMap({\n      steps: runnables,\n    }) as unknown as Runnable<RunInput, Exclude<RunOutput, Error>, CallOptions>;\n  } else {\n    throw new Error(\n      `Expected a Runnable, function or object.\\nInstead got an unsupported type.`\n    );\n  }\n}\n\nexport interface RunnableAssignFields<RunInput> {\n  mapper: RunnableMap<RunInput>;\n}\n\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nexport class RunnableAssign<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends Record<string, any> = Record<string, any>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements RunnableAssignFields<RunInput>\n{\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  mapper: RunnableMap<RunInput>;\n\n  constructor(fields: RunnableMap<RunInput> | RunnableAssignFields<RunInput>) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { mapper: fields };\n    }\n    super(fields);\n    this.mapper = fields.mapper;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    const mapperResult = await this.mapper.invoke(input, options);\n\n    return {\n      ...input,\n      ...mapperResult,\n    } as RunOutput;\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(\n      forMapper,\n      patchConfig(options, { callbacks: runManager?.getChild() })\n    );\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(\n          `RunnableAssign can only be used with objects as input, got ${typeof chunk}`\n        );\n      }\n      const filtered = Object.fromEntries(\n        Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key))\n      );\n      if (Object.keys(filtered).length > 0) {\n        yield filtered as unknown as RunOutput;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk as unknown as RunOutput;\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\nexport interface RunnablePickFields {\n  keys: string | string[];\n}\n\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nexport class RunnablePick<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends Record<string, any> = Record<string, any>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> | any = Record<string, any> | any,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements RunnablePickFields\n{\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  keys: string | string[];\n\n  constructor(fields: string | string[] | RunnablePickFields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { keys: fields };\n    }\n    super(fields);\n    this.keys = fields.keys;\n  }\n\n  async _pick(input: RunInput): Promise<RunOutput> {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys\n        .map((key) => [key, input[key]])\n        .filter((v) => v[1] !== undefined);\n      return picked.length === 0\n        ? (undefined as RunOutput)\n        : Object.fromEntries(picked);\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>\n  ): AsyncGenerator<RunOutput> {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\nexport interface RunnableToolLikeArgs<\n  RunInput extends InteropZodType = InteropZodType,\n  RunOutput = unknown\n> extends Omit<\n    RunnableBindingArgs<InferInteropZodOutput<RunInput>, RunOutput>,\n    \"config\"\n  > {\n  name: string;\n\n  description?: string;\n\n  schema: RunInput;\n\n  config?: RunnableConfig;\n}\n\nexport class RunnableToolLike<\n  RunInput extends InteropZodType = InteropZodType,\n  RunOutput = unknown\n> extends RunnableBinding<InferInteropZodOutput<RunInput>, RunOutput> {\n  name: string;\n\n  description?: string;\n\n  schema: RunInput;\n\n  constructor(fields: RunnableToolLikeArgs<RunInput, RunOutput>) {\n    const sequence = RunnableSequence.from([\n      RunnableLambda.from<\n        InferInteropZodOutput<RunInput> | ToolCall,\n        InferInteropZodOutput<RunInput>\n      >(async (input) => {\n        let toolInput: InferInteropZodOutput<RunInput>;\n\n        if (_isToolCall(input)) {\n          try {\n            toolInput = await interopParseAsync(this.schema, input.args);\n          } catch {\n            throw new ToolInputParsingException(\n              `Received tool input did not match expected schema`,\n              JSON.stringify(input.args)\n            );\n          }\n        } else {\n          toolInput = input;\n        }\n        return toolInput;\n      }).withConfig({ runName: `${fields.name}:parse_input` }),\n      fields.bound,\n    ]).withConfig({ runName: fields.name });\n\n    super({\n      bound: sequence,\n      config: fields.config ?? {},\n    });\n\n    this.name = fields.name;\n    this.description = fields.description;\n    this.schema = fields.schema;\n  }\n\n  static lc_name() {\n    return \"RunnableToolLike\";\n  }\n}\n\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nexport function convertRunnableToTool<RunInput, RunOutput>(\n  runnable: Runnable<RunInput, RunOutput>,\n  fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<RunInput>;\n  }\n): RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput> {\n  const name = fields.name ?? runnable.getName();\n  const description = fields.description ?? getSchemaDescription(fields.schema);\n\n  if (isSimpleStringZodSchema(fields.schema)) {\n    return new RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput>(\n      {\n        name,\n        description,\n        schema: z\n          .object({ input: z.string() })\n          .transform((input) => input.input) as InteropZodType,\n        bound: runnable,\n      }\n    );\n  }\n\n  return new RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput>({\n    name,\n    description,\n    schema: fields.schema,\n    bound: runnable,\n  });\n}\n"],"names":["value: any","defaultKey: string","suffix?: string","fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }","config: Partial<CallOptions>","fields:\n      | {\n          fallbacks: Runnable<RunInput, RunOutput>[];\n        }\n      | Runnable<RunInput, RunOutput>[]","options: Partial<O> | Partial<O>[]","inputs: RunInput[]","options?: Partial<CallOptions> | Partial<CallOptions>[]","batchOptions?: RunnableBatchOptions","input: RunInput","options?: Partial<CallOptions>","func:\n      | ((input: T) => Promise<RunOutput>)\n      | ((\n          input: T,\n          config?: Partial<CallOptions>,\n          runManager?: CallbackManagerForChainRun\n        ) => Promise<RunOutput>)","input: T","options?: Partial<CallOptions> & { runType?: string }","func: (\n      inputs: T[],\n      options?: Partial<CallOptions>[],\n      runManagers?: (CallbackManagerForChainRun | undefined)[],\n      batchOptions?: RunnableBatchOptions\n    ) => Promise<(RunOutput | Error)[]>","inputs: T[]","options?:\n      | Partial<CallOptions & { runType?: string }>\n      | Partial<CallOptions & { runType?: string }>[]","outputs: (RunOutput | Error)[]","first: O","second: O","inputGenerator: AsyncGenerator<I>","transformer: (\n      generator: AsyncGenerator<I>,\n      runManager?: CallbackManagerForChainRun,\n      options?: Partial<CallOptions>\n    ) => AsyncGenerator<O>","finalInput: I | undefined","finalOutput: O | undefined","runManager: CallbackManagerForChainRun | undefined","_?: RunnableConfig","coerceable: RunnableLike<RunOutput, NewRunOutput>","keys: string | string[]","mapping: RunnableMapLike<Record<string, unknown>, Record<string, unknown>>","generator: AsyncGenerator<RunInput>","options: Partial<CallOptions>","streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">","logStreamCallbackHandler: LogStreamCallbackHandler","options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    }","streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">","options: Partial<CallOptions> & { version: \"v1\" | \"v2\" }","uuidv4","listener: (() => void) | null","state","event: StreamEvent","data: StreamEventData","thing: any","fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<T>;\n  }","fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>","suffix?: string | undefined","options?: Partial<CallOptions> | undefined","fields: {\n    bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n  }","inputs: RunInputItem[]","config?: Partial<CallOptions>","runManager?: CallbackManagerForChainRun","fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions> & {\n      maxAttemptNumber?: number;\n      onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n    }","attempt: number","config?: CallOptions","attemptNumber: number","configs?: RunnableConfig[]","runManagers?: (CallbackManagerForChainRun | undefined)[]","resultsMap: Record<string, RunOutput | Error>","fields: RunnableSequenceFields<RunInput, RunOutput>","options?: RunnableConfig","finalOutput: RunOutput","options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]","nextStepInputs: any","config?: RunnableConfig","currentLastNode: any","nameOrFields?:\n      | string\n      | Omit<\n          RunnableSequenceFields<RunInput, RunOutput>,\n          \"first\" | \"middle\" | \"last\"\n        >","extra: Record<string, unknown>","fields: { steps: RunnableMapLike<RunInput, RunOutput> }","steps: RunnableMapLike<RunInput, RunOutput>","options?: Partial<RunnableConfig>","output: Record<string, any>","result","fields: { func: AnyTraceableFunction }","state: IteratorResult<unknown>","func: AnyTraceableFunction","func:\n    | RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    | TraceableFunction<\n        RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      >","fields: {\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >;\n  }","func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >","finalOutput: RunOutput | undefined","finalChunk: RunInput | undefined","fields: {\n    runnable: Runnable<RunInput, RunOutput>;\n    fallbacks: Runnable<RunInput, RunOutput>[];\n  }","options?: Partial<RunnableConfig> | undefined","firstError: any","coerceable: RunnableLike<RunInput, RunOutput, CallOptions>","runnables: Record<string, Runnable<RunInput>>","fields: RunnableMap<RunInput> | RunnableAssignFields<RunInput>","fields: string | string[] | RunnablePickFields","fields: RunnableToolLikeArgs<RunInput, RunOutput>","toolInput: InferInteropZodOutput<RunInput>","runnable: Runnable<RunInput, RunOutput>","fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<RunInput>;\n  }"],"mappings":"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"}},
    {"offset": {"line": 5742, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/passthrough.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/passthrough.ts"],"sourcesContent":["import { concat } from \"../utils/stream.js\";\nimport {\n  Runnable,\n  RunnableAssign,\n  RunnableMap,\n  RunnableMapLike,\n} from \"./base.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RunnablePassthroughFunc<RunInput = any> =\n  | ((input: RunInput) => void)\n  | ((input: RunInput, config?: RunnableConfig) => void)\n  | ((input: RunInput) => Promise<void>)\n  | ((input: RunInput, config?: RunnableConfig) => Promise<void>);\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough<RunInput = any> extends Runnable<\n  RunInput,\n  RunInput\n> {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  func?: RunnablePassthroughFunc<RunInput>;\n\n  constructor(fields?: { func?: RunnablePassthroughFunc<RunInput> }) {\n    super(fields);\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunInput> {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n\n    return this._callWithConfig(\n      (input: RunInput) => Promise.resolve(input),\n      input,\n      config\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<RunnableConfig>\n  ): AsyncGenerator<RunInput> {\n    const config = ensureConfig(options);\n    let finalOutput: RunInput | undefined;\n    let finalOutputSupported = true;\n\n    for await (const chunk of this._transformStreamWithConfig(\n      generator,\n      (input: AsyncGenerator<RunInput>) => input,\n      config\n    )) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk as any);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign<\n    RunInput extends Record<string, unknown> = Record<string, unknown>,\n    RunOutput extends Record<string, unknown> = Record<string, unknown>\n  >(\n    mapping: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableAssign<RunInput, RunInput & RunOutput> {\n    return new RunnableAssign(new RunnableMap({ steps: mapping }));\n  }\n}\n"],"names":["fields?: { func?: RunnablePassthroughFunc<RunInput> }","input: RunInput","options?: Partial<RunnableConfig>","input","generator: AsyncGenerator<RunInput>","options: Partial<RunnableConfig>","finalOutput: RunInput | undefined","input: AsyncGenerator<RunInput>","mapping: RunnableMapLike<RunInput, RunOutput>"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2CA,IAAa,sBAAb,cAAyD,8KAAA,CAGvD;IACA,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,WAAY;KAAA,CAAA;IAE9C,kBAAkB,KAAA;IAElB,KAAA;IAEA,YAAYA,MAAAA,CAAuD;QACjE,KAAA,CAAM,OAAO;QACb,IAAI,QACF,IAAA,CAAK,IAAA,GAAO,OAAO,IAAA;IAEtB;IAED,MAAM,OACJC,KAAAA,EACAC,OAAAA,EACmB;QACnB,MAAM,aAAS,oLAAA,EAAa,QAAQ;QACpC,IAAI,IAAA,CAAK,IAAA,EACP,MAAM,IAAA,CAAK,IAAA,CAAK,OAAO,OAAO;QAGhC,OAAO,IAAA,CAAK,eAAA,CACV,CAACD,UAAoB,QAAQ,OAAA,CAAQE,QAAM,EAC3C,OACA,OACD;IACF;IAED,OAAO,UACLC,SAAAA,EACAC,OAAAA,EAC0B;QAC1B,MAAM,aAAS,oLAAA,EAAa,QAAQ;QACpC,IAAIC;QACJ,IAAI,uBAAuB;QAE3B,WAAW,MAAM,SAAS,IAAA,CAAK,0BAAA,CAC7B,WACA,CAACC,QAAoC,OACrC,OACD,CAAE;YACD,MAAM;YACN,IAAI,qBACF,CAAA,IAAI,gBAAgB,KAAA,GAClB,cAAc;iBAEd,IAAI;gBAEF,kBAAc,0KAAA,EAAO,aAAa,MAAa;YAChD,EAAA,OAAO;gBACN,cAAc,KAAA;gBACd,uBAAuB;YACxB;QAGN;QAED,IAAI,IAAA,CAAK,IAAA,IAAQ,gBAAgB,KAAA,GAC/B,MAAM,IAAA,CAAK,IAAA,CAAK,aAAa,OAAO;IAEvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8BD,OAAO,OAILC,OAAAA,EACgD;QAChD,OAAO,IAAI,oLAAA,CAAe,IAAI,iLAAA,CAAY;YAAE,OAAO;QAAS;IAC7D;AACF"}},
    {"offset": {"line": 5852, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/router.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/router.ts"],"sourcesContent":["import { Runnable, type RunnableBatchOptions } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\nexport type RouterInput = {\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any;\n};\n\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nexport class RouterRunnable<\n  RunInput extends RouterInput,\n  RunnableInput,\n  RunOutput\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n\n  constructor(fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }) {\n    super(fields);\n    this.runnables = fields.runnables;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, ensureConfig(options));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const keys = inputs.map((input) => input.key);\n    const actualInputs = inputs.map((input) => input.input);\n    const missingKey = keys.find((key) => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map((key) => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const batchSize =\n      maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs\n        .slice(i, i + batchSize)\n        .map((actualInput, i) =>\n          runnables[i].invoke(actualInput, optionsList[i])\n        );\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n"],"names":["fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }","input: RunInput","options?: Partial<RunnableConfig>","inputs: RunInput[]","options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]","batchOptions?: RunnableBatchOptions","i"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCA,IAAa,iBAAb,cAIU,8KAAA,CAA8B;IACtC,OAAO,UAAU;QACf,OAAO;IACR;IAED,eAAe;QAAC;QAAkB,WAAY;KAAA,CAAA;IAE9C,kBAAkB,KAAA;IAElB,UAAA;IAEA,YAAYA,MAAAA,CAET;QACD,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,SAAA,GAAY,OAAO,SAAA;IACzB;IAED,MAAM,OACJC,KAAAA,EACAC,OAAAA,EACoB;QACpB,MAAM,EAAE,GAAA,EAAK,OAAO,WAAA,EAAa,GAAG;QACpC,MAAM,WAAW,IAAA,CAAK,SAAA,CAAU,IAAA;QAChC,IAAI,aAAa,KAAA,EACf,CAAA,MAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,IAAI,EAAE,CAAC;QAE7D,OAAO,SAAS,MAAA,CAAO,iBAAa,oLAAA,EAAa,QAAQ,CAAC;IAC3D;IAoBD,MAAM,MACJC,MAAAA,EACAC,OAAAA,EACAC,YAAAA,EACgC;QAChC,MAAM,OAAO,OAAO,GAAA,CAAI,CAAC,QAAU,MAAM,GAAA,CAAI;QAC7C,MAAM,eAAe,OAAO,GAAA,CAAI,CAAC,QAAU,MAAM,KAAA,CAAM;QACvD,MAAM,aAAa,KAAK,IAAA,CAAK,CAAC,MAAQ,IAAA,CAAK,SAAA,CAAU,IAAA,KAAS,KAAA,EAAU;QACxE,IAAI,eAAe,KAAA,EACjB,CAAA,MAAM,IAAI,MAAM,CAAC,sDAAsD,CAAC;QAE1E,MAAM,YAAY,KAAK,GAAA,CAAI,CAAC,MAAQ,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK;QACxD,MAAM,cAAc,IAAA,CAAK,eAAA,CAAgB,WAAW,CAAE,GAAE,OAAO,MAAA,CAAO;QACtE,MAAM,iBACJ,WAAA,CAAY,EAAA,EAAI,kBAAkB,cAAc;QAClD,MAAM,YACJ,kBAAkB,iBAAiB,IAAI,iBAAiB,OAAO,MAAA;QACjE,MAAM,eAAe,CAAE,CAAA;QACvB,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,MAAA,EAAQ,KAAK,UAAW;YACvD,MAAM,gBAAgB,aACnB,KAAA,CAAM,GAAG,IAAI,UAAU,CACvB,GAAA,CAAI,CAAC,aAAaC,MACjB,SAAA,CAAUA,IAAAA,CAAG,MAAA,CAAO,aAAa,WAAA,CAAYA,IAAAA,CAAG,CACjD;YACH,MAAM,cAAc,MAAM,QAAQ,GAAA,CAAI,cAAc;YACpD,aAAa,IAAA,CAAK,YAAY;QAC/B;QACD,OAAO,aAAa,IAAA,EAAM;IAC3B;IAED,MAAM,OACJL,KAAAA,EACAC,OAAAA,EAC4C;QAC5C,MAAM,EAAE,GAAA,EAAK,OAAO,WAAA,EAAa,GAAG;QACpC,MAAM,WAAW,IAAA,CAAK,SAAA,CAAU,IAAA;QAChC,IAAI,aAAa,KAAA,EACf,CAAA,MAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,IAAI,EAAE,CAAC;QAE7D,OAAO,SAAS,MAAA,CAAO,aAAa,QAAQ;IAC7C;AACF"}},
    {"offset": {"line": 5937, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/branch.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/branch.ts"],"sourcesContent":["import {\n  Runnable,\n  RunnableLike,\n  _coerceToDict,\n  _coerceToRunnable,\n} from \"./base.js\";\nimport {\n  RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n} from \"./config.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport { concat } from \"../utils/stream.js\";\n\n/**\n * Type for a branch in the RunnableBranch. It consists of a condition\n * runnable and a branch runnable. The condition runnable is used to\n * determine whether the branch should be executed, and the branch runnable\n * is executed if the condition is true.\n */\nexport type Branch<RunInput, RunOutput> = [\n  Runnable<RunInput, boolean>,\n  Runnable<RunInput, RunOutput>\n];\n\nexport type BranchLike<RunInput, RunOutput> = [\n  RunnableLike<RunInput, boolean>,\n  RunnableLike<RunInput, RunOutput>\n];\n\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch<RunInput = any, RunOutput = any> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  default: Runnable<RunInput, RunOutput>;\n\n  branches: Branch<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }) {\n    super(fields);\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>\n    ]\n  ) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1) as BranchLike<\n      RunInput,\n      RunOutput\n    >[];\n    const coercedBranches: Branch<RunInput, RunOutput>[] = branchLikes.map(\n      ([condition, runnable]) => [\n        _coerceToRunnable(condition),\n        _coerceToRunnable(runnable),\n      ]\n    );\n    const defaultBranch = _coerceToRunnable(\n      branches[branches.length - 1] as RunnableLike<RunInput, RunOutput>\n    );\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(`condition:${i + 1}`),\n        })\n      );\n      if (conditionValue) {\n        result = await branchRunnable.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`branch:${i + 1}`),\n          })\n        );\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\"branch:default\"),\n        })\n      );\n    }\n    return result;\n  }\n\n  async invoke(\n    input: RunInput,\n    config: RunnableConfig = {}\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n\n  async *_streamIterator(input: RunInput, config?: Partial<RunnableConfig>) {\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config?.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`condition:${i + 1}`),\n          })\n        );\n        if (conditionValue) {\n          stream = await branchRunnable.stream(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`branch:${i + 1}`),\n            })\n          );\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\"branch:default\"),\n          })\n        );\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk as RunOutput);\n              } catch {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {});\n  }\n}\n"],"names":["fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }","branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>\n    ]","coercedBranches: Branch<RunInput, RunOutput>[]","input: RunInput","config?: Partial<RunnableConfig>","runManager?: CallbackManagerForChainRun","config: RunnableConfig"],"mappings":"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"}},
    {"offset": {"line": 6114, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/history.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/history.ts"],"sourcesContent":["import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../chat_history.js\";\nimport {\n  AIMessage,\n  BaseMessage,\n  HumanMessage,\n  isBaseMessage,\n} from \"../messages/index.js\";\nimport { Run } from \"../tracers/base.js\";\nimport {\n  Runnable,\n  RunnableBinding,\n  type RunnableBindingArgs,\n  RunnableLambda,\n} from \"./base.js\";\nimport { RunnableConfig } from \"./config.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n\ntype GetSessionHistoryCallable = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: Array<any>\n) =>\n  | Promise<BaseChatMessageHistory | BaseListChatMessageHistory>\n  | BaseChatMessageHistory\n  | BaseListChatMessageHistory;\n\nexport interface RunnableWithMessageHistoryInputs<RunInput, RunOutput>\n  extends Omit<RunnableBindingArgs<RunInput, RunOutput>, \"bound\" | \"config\"> {\n  runnable: Runnable<RunInput, RunOutput>;\n  getMessageHistory: GetSessionHistoryCallable;\n  inputMessagesKey?: string;\n  outputMessagesKey?: string;\n  historyMessagesKey?: string;\n  config?: RunnableConfig;\n}\n\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // pnpm install @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"@langchain/classic/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory<\n  RunInput,\n  RunOutput\n> extends RunnableBinding<RunInput, RunOutput> {\n  runnable: Runnable<RunInput, RunOutput>;\n\n  inputMessagesKey?: string;\n\n  outputMessagesKey?: string;\n\n  historyMessagesKey?: string;\n\n  getMessageHistory: GetSessionHistoryCallable;\n\n  constructor(fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>) {\n    let historyChain: Runnable = RunnableLambda.from((input, options) =>\n      this._enterHistory(input, options ?? {})\n    ).withConfig({ runName: \"loadHistory\" });\n\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain,\n      }).withConfig({ runName: \"insertHistory\" });\n    }\n\n    const bound = historyChain\n      .pipe(\n        fields.runnable.withListeners({\n          onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        })\n      )\n      .withConfig({ runName: \"RunnableWithMessageHistory\" });\n\n    const config = fields.config ?? {};\n\n    super({\n      ...fields,\n      config,\n      bound,\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n\n  _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedInputValue;\n    if (\n      typeof inputValue === \"object\" &&\n      !Array.isArray(inputValue) &&\n      !isBaseMessage(inputValue)\n    ) {\n      let key;\n      if (this.inputMessagesKey) {\n        key = this.inputMessagesKey;\n      } else if (Object.keys(inputValue).length === 1) {\n        key = Object.keys(inputValue)[0];\n      } else {\n        key = \"input\";\n      }\n      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n        parsedInputValue = inputValue[key][0];\n      } else {\n        parsedInputValue = inputValue[key];\n      }\n    } else {\n      parsedInputValue = inputValue;\n    }\n    if (typeof parsedInputValue === \"string\") {\n      return [new HumanMessage(parsedInputValue)];\n    } else if (Array.isArray(parsedInputValue)) {\n      return parsedInputValue;\n    } else if (isBaseMessage(parsedInputValue)) {\n      return [parsedInputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(\n          parsedInputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedOutputValue;\n    if (\n      !Array.isArray(outputValue) &&\n      !isBaseMessage(outputValue) &&\n      typeof outputValue !== \"string\"\n    ) {\n      let key;\n      if (this.outputMessagesKey !== undefined) {\n        key = this.outputMessagesKey;\n      } else if (Object.keys(outputValue).length === 1) {\n        key = Object.keys(outputValue)[0];\n      } else {\n        key = \"output\";\n      }\n      // If you are wrapping a chat model directly\n      // The output is actually this weird generations object\n      if (outputValue.generations !== undefined) {\n        parsedOutputValue = outputValue.generations[0][0].message;\n      } else {\n        parsedOutputValue = outputValue[key];\n      }\n    } else {\n      parsedOutputValue = outputValue;\n    }\n\n    if (typeof parsedOutputValue === \"string\") {\n      return [new AIMessage(parsedOutputValue)];\n    } else if (Array.isArray(parsedOutputValue)) {\n      return parsedOutputValue;\n    } else if (isBaseMessage(parsedOutputValue)) {\n      return [parsedOutputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(\n          parsedOutputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    kwargs?: RunnableConfig\n  ): Promise<BaseMessage[]> {\n    const history = kwargs?.configurable?.messageHistory;\n    const messages = await history.getMessages();\n    if (this.historyMessagesKey === undefined) {\n      return messages.concat(this._getInputMessages(input));\n    }\n    return messages;\n  }\n\n  async _exitHistory(run: Run, config: RunnableConfig): Promise<void> {\n    const history = config.configurable?.messageHistory;\n\n    // Get input messages\n    let inputs;\n    // Chat model inputs are nested arrays\n    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n      inputs = run.inputs[0];\n    } else {\n      inputs = run.inputs;\n    }\n    let inputMessages = this._getInputMessages(inputs);\n    // If historic messages were prepended to the input messages, remove them to\n    // avoid adding duplicate messages to history.\n    if (this.historyMessagesKey === undefined) {\n      const existingMessages = await history.getMessages();\n      inputMessages = inputMessages.slice(existingMessages.length);\n    }\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(\n        `Output values from 'Run' undefined. Run: ${JSON.stringify(\n          run,\n          null,\n          2\n        )}`\n      );\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    await history.addMessages([...inputMessages, ...outputMessages]);\n  }\n\n  async _mergeConfig(...configs: Array<RunnableConfig | undefined>) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\",\n      };\n      const exampleConfig = { configurable: { sessionId: \"123\" } };\n      throw new Error(\n        `sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n          `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(\n            exampleConfig\n          )})`\n      );\n    }\n    // attach messageHistory\n    const { sessionId } = config.configurable;\n    config.configurable.messageHistory = await this.getMessageHistory(\n      sessionId\n    );\n    return config;\n  }\n}\n"],"names":["fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>","historyChain: Runnable","config","inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>","outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>","input: any","kwargs?: RunnableConfig","run: Run","config: RunnableConfig"],"mappings":"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"}},
    {"offset": {"line": 6313, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@langchain/core/dist/runnables/index.js","sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/node_modules/%40langchain/core/src/runnables/index.ts"],"sourcesContent":["export {\n  type RunnableFunc,\n  type RunnableLike,\n  type RunnableRetryFailedAttemptHandler,\n  Runnable,\n  type RunnableBindingArgs,\n  RunnableBinding,\n  RunnableEach,\n  RunnableRetry,\n  RunnableSequence,\n  RunnableMap,\n  RunnableParallel,\n  RunnableLambda,\n  RunnableWithFallbacks,\n  RunnableAssign,\n  RunnablePick,\n  _coerceToRunnable,\n  RunnableToolLike,\n  type RunnableToolLikeArgs,\n} from \"./base.js\";\nexport {\n  type RunnableBatchOptions,\n  type RunnableInterface,\n  type RunnableIOSchema,\n} from \"./types.js\";\nexport {\n  type RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n  ensureConfig,\n  mergeConfigs,\n  pickRunnableConfigKeys,\n} from \"./config.js\";\nexport { RunnablePassthrough } from \"./passthrough.js\";\nexport { type RouterInput, RouterRunnable } from \"./router.js\";\nexport { RunnableBranch, type Branch, type BranchLike } from \"./branch.js\";\nexport {\n  type RunnableWithMessageHistoryInputs,\n  RunnableWithMessageHistory,\n} from \"./history.js\";\nexport { raceWithSignal } from \"../utils/signal.js\";\n"],"names":[],"mappings":""}}]
}