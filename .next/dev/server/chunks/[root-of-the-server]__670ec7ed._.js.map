{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/External/dev/Projects/Work%20Projects/RAG/new_rag/questions/src/lib/parsers/docling-parser.ts"],"sourcesContent":["import { pdf } from \"pdf-to-img\";\nimport type { DocumentParser, ParsedDocument, ParsedPage } from \"./index\";\n\n/**\n * Docling parser that calls a running docling-serve instance.\n * Processes documents page-by-page for better resilience and progress tracking.\n * Supports both sync and async modes.\n *\n * Env:\n * - DOCLING_SERVE_URL: base URL to docling-serve (e.g., https://docling.example.com)\n */\nexport class DoclingParser implements DocumentParser {\n  private baseUrl: string;\n  private pageTimeout: number;\n  private pollInterval: number;\n\n  constructor() {\n    // Extract base URL (remove any path like /v1/convert/file)\n    const configuredUrl =\n      process.env.DOCLING_SERVE_URL ||\n      process.env.DOCLING_ENDPOINT ||\n      \"\";\n    this.baseUrl = configuredUrl.replace(/\\/v1\\/convert\\/file\\/?$/, \"\");\n\n    // Timeout per page in seconds (default 120s for async)\n    this.pageTimeout = Number(process.env.DOCLING_PAGE_TIMEOUT) || 120;\n    // Poll interval in ms (default 2s)\n    this.pollInterval = Number(process.env.DOCLING_POLL_INTERVAL) || 2000;\n  }\n\n  async parse(file: Buffer, filename: string): Promise<ParsedDocument> {\n    if (!this.baseUrl) {\n      throw new Error(\n        \"DOCLING_SERVE_URL not set. Please configure the docling-serve endpoint.\"\n      );\n    }\n\n    const ext = filename.toLowerCase().split(\".\").pop();\n    if (ext !== \"pdf\") {\n      throw new Error(`Unsupported file type: ${ext}. Only PDF is supported.`);\n    }\n\n    // First, get the total page count using pdf-to-img\n    const pageCount = await this.getPageCount(file);\n    console.log(`Document has ${pageCount} pages. Processing page-by-page...`);\n\n    const pages: ParsedPage[] = [];\n    const errors: string[] = [];\n\n    // Process each page individually\n    for (let pageNum = 1; pageNum <= pageCount; pageNum++) {\n      try {\n        console.log(`Processing page ${pageNum}/${pageCount}...`);\n        const pageText = await this.processPage(file, filename, pageNum);\n\n        pages.push({\n          pageNumber: pageNum,\n          text: pageText,\n          imageBuffer: undefined,\n        });\n      } catch (error) {\n        const errorMsg = `Page ${pageNum}: ${(error as Error).message}`;\n        console.error(errorMsg);\n        errors.push(errorMsg);\n\n        // Add empty page with error note\n        pages.push({\n          pageNumber: pageNum,\n          text: `[Error processing page ${pageNum}]`,\n          imageBuffer: undefined,\n        });\n      }\n    }\n\n    // If all pages failed, throw an error\n    if (errors.length === pageCount) {\n      throw new Error(\n        `Failed to process all ${pageCount} pages. Errors: ${errors.join(\"; \")}`\n      );\n    }\n\n    // Log summary\n    if (errors.length > 0) {\n      console.warn(\n        `Completed with ${errors.length}/${pageCount} page errors: ${errors.join(\"; \")}`\n      );\n    } else {\n      console.log(`Successfully processed all ${pageCount} pages.`);\n    }\n\n    return {\n      pages,\n      metadata: {\n        pageCount: pages.length,\n        parserUsed: \"docling\",\n      },\n    };\n  }\n\n  /**\n   * Get the total page count using pdf-to-img\n   */\n  private async getPageCount(file: Buffer): Promise<number> {\n    let count = 0;\n    const document = await pdf(file, { scale: 0.5 }); // Low scale for speed\n    for await (const _ of document) {\n      count++;\n    }\n    return count;\n  }\n\n  /**\n   * Process a single page using docling-serve (async mode with polling)\n   */\n  private async processPage(\n    file: Buffer,\n    filename: string,\n    pageNum: number\n  ): Promise<string> {\n    // Step 1: Submit async task\n    const taskId = await this.submitTask(file, filename, pageNum);\n    console.log(`  Page ${pageNum}: Task submitted (${taskId})`);\n\n    // Step 2: Poll for completion\n    await this.waitForCompletion(taskId, pageNum);\n\n    // Step 3: Get result\n    const result = await this.getResult(taskId);\n    return this.extractText(result, pageNum);\n  }\n\n  /**\n   * Submit async conversion task\n   */\n  private async submitTask(\n    file: Buffer,\n    filename: string,\n    pageNum: number\n  ): Promise<string> {\n    const formData = new FormData();\n\n    // Add the file\n    formData.append(\"files\", new Blob([new Uint8Array(file)]), filename);\n\n    // Request only this page\n    formData.append(\"page_range\", String(pageNum));\n    formData.append(\"page_range\", String(pageNum));\n\n    // Request markdown output\n    formData.append(\"to_formats\", \"md\");\n\n    // Set timeout\n    formData.append(\"document_timeout\", String(this.pageTimeout));\n\n    const response = await fetch(`${this.baseUrl}/v1/convert/file/async`, {\n      method: \"POST\",\n      body: formData,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Submit failed: HTTP ${response.status}: ${errorText.slice(0, 200)}`);\n    }\n\n    const data = (await response.json()) as Record<string, unknown>;\n    const taskId = data.task_id as string;\n\n    if (!taskId) {\n      throw new Error(`No task_id in response: ${JSON.stringify(data).slice(0, 200)}`);\n    }\n\n    return taskId;\n  }\n\n  /**\n   * Poll until task is complete\n   */\n  private async waitForCompletion(taskId: string, pageNum: number): Promise<void> {\n    const startTime = Date.now();\n    const timeoutMs = this.pageTimeout * 1000;\n\n    while (true) {\n      // Check timeout\n      if (Date.now() - startTime > timeoutMs) {\n        throw new Error(`Timeout waiting for task ${taskId}`);\n      }\n\n      const response = await fetch(`${this.baseUrl}/v1/status/poll/${taskId}`);\n\n      if (!response.ok) {\n        // 404 might mean task is still processing\n        if (response.status === 404) {\n          await this.sleep(this.pollInterval);\n          continue;\n        }\n        throw new Error(`Poll failed: HTTP ${response.status}`);\n      }\n\n      const data = (await response.json()) as Record<string, unknown>;\n      const status = data.status as string;\n\n      if (status === \"completed\" || status === \"success\") {\n        console.log(`  Page ${pageNum}: Completed`);\n        return;\n      }\n\n      if (status === \"failed\" || status === \"error\") {\n        const error = data.error || data.message || \"Unknown error\";\n        throw new Error(`Task failed: ${error}`);\n      }\n\n      // Still processing, wait and poll again\n      await this.sleep(this.pollInterval);\n    }\n  }\n\n  /**\n   * Get task result\n   */\n  private async getResult(taskId: string): Promise<Record<string, unknown>> {\n    const response = await fetch(`${this.baseUrl}/v1/result/${taskId}`);\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Get result failed: HTTP ${response.status}: ${errorText.slice(0, 200)}`);\n    }\n\n    return (await response.json()) as Record<string, unknown>;\n  }\n\n  /**\n   * Sleep helper\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Extract text from docling-serve response\n   */\n  private extractText(data: Record<string, unknown>, pageNum: number): string {\n    // Try multiple paths to find the content\n\n    // Path 1: { document: { md_content: \"...\" } }\n    const doc = data.document as Record<string, unknown> | undefined;\n    if (doc?.md_content) {\n      return (doc.md_content as string).trim();\n    }\n\n    // Path 2: { documents: [{ md_content: \"...\" }] }\n    const docs = data.documents as Record<string, unknown>[] | undefined;\n    if (docs?.[0]?.md_content) {\n      return (docs[0].md_content as string).trim();\n    }\n\n    // Path 3: Direct md_content at root\n    if (data.md_content) {\n      return (data.md_content as string).trim();\n    }\n\n    // Path 4: Check for text or content fields\n    if (doc?.text) {\n      return (doc.text as string).trim();\n    }\n    if (doc?.content) {\n      return (doc.content as string).trim();\n    }\n\n    // Path 5: Look for output field\n    if (data.output) {\n      const output = data.output as Record<string, unknown>;\n      if (output.md) return (output.md as string).trim();\n      if (output.text) return (output.text as string).trim();\n    }\n\n    console.warn(\n      `Unexpected response structure for page ${pageNum}:`,\n      JSON.stringify(data).slice(0, 500)\n    );\n    return `[No text extracted from page ${pageNum}]`;\n  }\n}\n"],"names":[],"mappings":"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"}}]
}