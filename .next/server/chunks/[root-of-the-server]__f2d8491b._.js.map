{"version":3,"sources":["../../../node_modules/%40aws-sdk/credential-provider-env/dist-es/fromEnv.js","../../../node_modules/%40smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js","../../../node_modules/%40smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js","../../../node_modules/%40smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js","../../../node_modules/%40smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js","../../../node_modules/%40smithy/core/dist-es/submodules/protocols/RpcProtocol.js","../../../node_modules/%40smithy/property-provider/dist-es/TokenProviderError.js","../../../node_modules/%40smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js","../../../node_modules/%40smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js","../../../node_modules/%40aws-sdk/token-providers/dist-es/fromSso.js","../../../node_modules/%40aws-sdk/token-providers/dist-es/constants.js","../../../node_modules/%40aws-sdk/token-providers/dist-es/getSsoOidcClient.js","../../../node_modules/%40aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js","../../../node_modules/%40aws-sdk/token-providers/dist-es/validateTokenExpiry.js","../../../node_modules/%40aws-sdk/token-providers/dist-es/validateTokenKey.js","../../../node_modules/%40aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js","../../../src/lib/retrieval.ts","../../../src/lib/agentic-retrieval.ts"],"sourcesContent":["import { setCredentialFeature } from \"@aws-sdk/core/client\";\nimport { CredentialsProviderError } from \"@smithy/property-provider\";\nexport const ENV_KEY = \"AWS_ACCESS_KEY_ID\";\nexport const ENV_SECRET = \"AWS_SECRET_ACCESS_KEY\";\nexport const ENV_SESSION = \"AWS_SESSION_TOKEN\";\nexport const ENV_EXPIRATION = \"AWS_CREDENTIAL_EXPIRATION\";\nexport const ENV_CREDENTIAL_SCOPE = \"AWS_CREDENTIAL_SCOPE\";\nexport const ENV_ACCOUNT_ID = \"AWS_ACCOUNT_ID\";\nexport const fromEnv = (init) => async () => {\n    init?.logger?.debug(\"@aws-sdk/credential-provider-env - fromEnv\");\n    const accessKeyId = process.env[ENV_KEY];\n    const secretAccessKey = process.env[ENV_SECRET];\n    const sessionToken = process.env[ENV_SESSION];\n    const expiry = process.env[ENV_EXPIRATION];\n    const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];\n    const accountId = process.env[ENV_ACCOUNT_ID];\n    if (accessKeyId && secretAccessKey) {\n        const credentials = {\n            accessKeyId,\n            secretAccessKey,\n            ...(sessionToken && { sessionToken }),\n            ...(expiry && { expiration: new Date(expiry) }),\n            ...(credentialScope && { credentialScope }),\n            ...(accountId && { accountId }),\n        };\n        setCredentialFeature(credentials, \"CREDENTIALS_ENV_VARS\", \"g\");\n        return credentials;\n    }\n    throw new CredentialsProviderError(\"Unable to find environment variable credentials.\", { logger: init?.logger });\n};\n","import { loadSharedConfigFiles } from \"./loadSharedConfigFiles\";\nimport { mergeConfigFiles } from \"./mergeConfigFiles\";\nexport const parseKnownFiles = async (init) => {\n    const parsedFiles = await loadSharedConfigFiles(init);\n    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);\n};\n","export const mergeConfigFiles = (...files) => {\n    const merged = {};\n    for (const file of files) {\n        for (const [key, values] of Object.entries(file)) {\n            if (merged[key] !== undefined) {\n                Object.assign(merged[key], values);\n            }\n            else {\n                merged[key] = values;\n            }\n        }\n    }\n    return merged;\n};\n","import { readFile } from \"fs/promises\";\nimport { getSSOTokenFilepath } from \"./getSSOTokenFilepath\";\nexport const tokenIntercept = {};\nexport const getSSOTokenFromFile = async (id) => {\n    if (tokenIntercept[id]) {\n        return tokenIntercept[id];\n    }\n    const ssoTokenFilepath = getSSOTokenFilepath(id);\n    const ssoTokenText = await readFile(ssoTokenFilepath, \"utf8\");\n    return JSON.parse(ssoTokenText);\n};\n","import { createHash } from \"crypto\";\nimport { join } from \"path\";\nimport { getHomeDir } from \"./getHomeDir\";\nexport const getSSOTokenFilepath = (id) => {\n    const hasher = createHash(\"sha1\");\n    const cacheName = hasher.update(id).digest(\"hex\");\n    return join(getHomeDir(), \".aws\", \"sso\", \"cache\", `${cacheName}.json`);\n};\n","import { NormalizedSchema } from \"@smithy/core/schema\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class RpcProtocol extends HttpProtocol {\n    async serializeRequest(operationSchema, input, context) {\n        const serializer = this.serializer;\n        const query = {};\n        const headers = {};\n        const endpoint = await context.endpoint();\n        const ns = NormalizedSchema.of(operationSchema?.input);\n        const schema = ns.getSchema();\n        let payload;\n        const request = new HttpRequest({\n            protocol: \"\",\n            hostname: \"\",\n            port: undefined,\n            path: \"/\",\n            fragment: undefined,\n            query: query,\n            headers: headers,\n            body: undefined,\n        });\n        if (endpoint) {\n            this.updateServiceEndpoint(request, endpoint);\n            this.setHostPrefix(request, operationSchema, input);\n        }\n        const _input = {\n            ...input,\n        };\n        if (input) {\n            const eventStreamMember = ns.getEventStreamMember();\n            if (eventStreamMember) {\n                if (_input[eventStreamMember]) {\n                    const initialRequest = {};\n                    for (const [memberName, memberSchema] of ns.structIterator()) {\n                        if (memberName !== eventStreamMember && _input[memberName]) {\n                            serializer.write(memberSchema, _input[memberName]);\n                            initialRequest[memberName] = serializer.flush();\n                        }\n                    }\n                    payload = await this.serializeEventStream({\n                        eventStream: _input[eventStreamMember],\n                        requestSchema: ns,\n                        initialRequest,\n                    });\n                }\n            }\n            else {\n                serializer.write(schema, _input);\n                payload = serializer.flush();\n            }\n        }\n        request.headers = headers;\n        request.query = query;\n        request.body = payload;\n        request.method = \"POST\";\n        return request;\n    }\n    async deserializeResponse(operationSchema, context, response) {\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(operationSchema.output);\n        const dataObject = {};\n        if (response.statusCode >= 300) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                Object.assign(dataObject, await deserializer.read(15, bytes));\n            }\n            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n            throw new Error(\"@smithy/core/protocols - RPC Protocol error handler failed to throw.\");\n        }\n        for (const header in response.headers) {\n            const value = response.headers[header];\n            delete response.headers[header];\n            response.headers[header.toLowerCase()] = value;\n        }\n        const eventStreamMember = ns.getEventStreamMember();\n        if (eventStreamMember) {\n            dataObject[eventStreamMember] = await this.deserializeEventStream({\n                response,\n                responseSchema: ns,\n                initialResponseContainer: dataObject,\n            });\n        }\n        else {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                Object.assign(dataObject, await deserializer.read(ns, bytes));\n            }\n        }\n        dataObject.$metadata = this.deserializeMetadata(response);\n        return dataObject;\n    }\n}\n","import { ProviderError } from \"./ProviderError\";\nexport class TokenProviderError extends ProviderError {\n    name = \"TokenProviderError\";\n    constructor(message, options = true) {\n        super(message, options);\n        Object.setPrototypeOf(this, TokenProviderError.prototype);\n    }\n}\n","import { getConfigFilepath } from \"./getConfigFilepath\";\nimport { getSsoSessionData } from \"./getSsoSessionData\";\nimport { parseIni } from \"./parseIni\";\nimport { readFile } from \"./readFile\";\nconst swallowError = () => ({});\nexport const loadSsoSessionData = async (init = {}) => readFile(init.configFilepath ?? getConfigFilepath())\n    .then(parseIni)\n    .then(getSsoSessionData)\n    .catch(swallowError);\n","import { IniSectionType } from \"@smithy/types\";\nimport { CONFIG_PREFIX_SEPARATOR } from \"./loadSharedConfigFiles\";\nexport const getSsoSessionData = (data) => Object.entries(data)\n    .filter(([key]) => key.startsWith(IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))\n    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});\n","import { TokenProviderError } from \"@smithy/property-provider\";\nimport { getProfileName, getSSOTokenFromFile, loadSsoSessionData, parseKnownFiles, } from \"@smithy/shared-ini-file-loader\";\nimport { EXPIRE_WINDOW_MS, REFRESH_MESSAGE } from \"./constants\";\nimport { getNewSsoOidcToken } from \"./getNewSsoOidcToken\";\nimport { validateTokenExpiry } from \"./validateTokenExpiry\";\nimport { validateTokenKey } from \"./validateTokenKey\";\nimport { writeSSOTokenToFile } from \"./writeSSOTokenToFile\";\nconst lastRefreshAttemptTime = new Date(0);\nexport const fromSso = (_init = {}) => async ({ callerClientConfig } = {}) => {\n    const init = {\n        ..._init,\n        parentClientConfig: {\n            ...callerClientConfig,\n            ..._init.parentClientConfig,\n        },\n    };\n    init.logger?.debug(\"@aws-sdk/token-providers - fromSso\");\n    const profiles = await parseKnownFiles(init);\n    const profileName = getProfileName({\n        profile: init.profile ?? callerClientConfig?.profile,\n    });\n    const profile = profiles[profileName];\n    if (!profile) {\n        throw new TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);\n    }\n    else if (!profile[\"sso_session\"]) {\n        throw new TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);\n    }\n    const ssoSessionName = profile[\"sso_session\"];\n    const ssoSessions = await loadSsoSessionData(init);\n    const ssoSession = ssoSessions[ssoSessionName];\n    if (!ssoSession) {\n        throw new TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);\n    }\n    for (const ssoSessionRequiredKey of [\"sso_start_url\", \"sso_region\"]) {\n        if (!ssoSession[ssoSessionRequiredKey]) {\n            throw new TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);\n        }\n    }\n    const ssoStartUrl = ssoSession[\"sso_start_url\"];\n    const ssoRegion = ssoSession[\"sso_region\"];\n    let ssoToken;\n    try {\n        ssoToken = await getSSOTokenFromFile(ssoSessionName);\n    }\n    catch (e) {\n        throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);\n    }\n    validateTokenKey(\"accessToken\", ssoToken.accessToken);\n    validateTokenKey(\"expiresAt\", ssoToken.expiresAt);\n    const { accessToken, expiresAt } = ssoToken;\n    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };\n    if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {\n        return existingToken;\n    }\n    if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {\n        validateTokenExpiry(existingToken);\n        return existingToken;\n    }\n    validateTokenKey(\"clientId\", ssoToken.clientId, true);\n    validateTokenKey(\"clientSecret\", ssoToken.clientSecret, true);\n    validateTokenKey(\"refreshToken\", ssoToken.refreshToken, true);\n    try {\n        lastRefreshAttemptTime.setTime(Date.now());\n        const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion, init);\n        validateTokenKey(\"accessToken\", newSsoOidcToken.accessToken);\n        validateTokenKey(\"expiresIn\", newSsoOidcToken.expiresIn);\n        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);\n        try {\n            await writeSSOTokenToFile(ssoSessionName, {\n                ...ssoToken,\n                accessToken: newSsoOidcToken.accessToken,\n                expiresAt: newTokenExpiration.toISOString(),\n                refreshToken: newSsoOidcToken.refreshToken,\n            });\n        }\n        catch (error) {\n        }\n        return {\n            token: newSsoOidcToken.accessToken,\n            expiration: newTokenExpiration,\n        };\n    }\n    catch (error) {\n        validateTokenExpiry(existingToken);\n        return existingToken;\n    }\n};\n","export const EXPIRE_WINDOW_MS = 5 * 60 * 1000;\nexport const REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;\n","export const getSsoOidcClient = async (ssoRegion, init = {}) => {\n    const { SSOOIDCClient } = await import(\"@aws-sdk/nested-clients/sso-oidc\");\n    const coalesce = (prop) => init.clientConfig?.[prop] ?? init.parentClientConfig?.[prop];\n    const ssoOidcClient = new SSOOIDCClient(Object.assign({}, init.clientConfig ?? {}, {\n        region: ssoRegion ?? init.clientConfig?.region,\n        logger: coalesce(\"logger\"),\n        userAgentAppId: coalesce(\"userAgentAppId\"),\n    }));\n    return ssoOidcClient;\n};\n","import { getSsoOidcClient } from \"./getSsoOidcClient\";\nexport const getNewSsoOidcToken = async (ssoToken, ssoRegion, init = {}) => {\n    const { CreateTokenCommand } = await import(\"@aws-sdk/nested-clients/sso-oidc\");\n    const ssoOidcClient = await getSsoOidcClient(ssoRegion, init);\n    return ssoOidcClient.send(new CreateTokenCommand({\n        clientId: ssoToken.clientId,\n        clientSecret: ssoToken.clientSecret,\n        refreshToken: ssoToken.refreshToken,\n        grantType: \"refresh_token\",\n    }));\n};\n","import { TokenProviderError } from \"@smithy/property-provider\";\nimport { REFRESH_MESSAGE } from \"./constants\";\nexport const validateTokenExpiry = (token) => {\n    if (token.expiration && token.expiration.getTime() < Date.now()) {\n        throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);\n    }\n};\n","import { TokenProviderError } from \"@smithy/property-provider\";\nimport { REFRESH_MESSAGE } from \"./constants\";\nexport const validateTokenKey = (key, value, forRefresh = false) => {\n    if (typeof value === \"undefined\") {\n        throw new TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? \". Cannot refresh\" : \"\"}. ${REFRESH_MESSAGE}`, false);\n    }\n};\n","import { getSSOTokenFilepath } from \"@smithy/shared-ini-file-loader\";\nimport { promises as fsPromises } from \"fs\";\nconst { writeFile } = fsPromises;\nexport const writeSSOTokenToFile = (id, ssoToken) => {\n    const tokenFilepath = getSSOTokenFilepath(id);\n    const tokenString = JSON.stringify(ssoToken, null, 2);\n    return writeFile(tokenFilepath, tokenString);\n};\n","import { embedText } from \"./embeddings\";\nimport { searchVectors } from \"./qdrant\";\nimport { getSignedUrl } from \"./storage\";\n\nexport interface RetrievedChunk {\n  chunkId: string;\n  docId: string;\n  docName: string;\n  pageNumber: number;\n  chunkIndex: number;\n  text: string;\n  imageUrl: string;\n  score: number;\n  parserUsed: string;\n}\n\nexport interface RetrievalOptions {\n  topK?: number;\n  docId?: string; // Filter by specific document\n  status?: string; // Filter by status (default: \"ready\")\n  diversify?: boolean; // Apply MMR diversification\n  diversityWeight?: number; // MMR lambda (0-1, higher = more diverse)\n}\n\nexport interface CitationInfo {\n  docName: string;\n  pageNumber: number;\n  imageUrl?: string; // Signed URL for page image\n  snippet: string;\n}\n\n/**\n * Retrieve relevant context for a query\n */\nexport async function retrieveContext(\n  query: string,\n  options: RetrievalOptions = {}\n): Promise<RetrievedChunk[]> {\n  const {\n    topK = 10,\n    docId,\n    status = \"ready\",\n    diversify = true,\n    diversityWeight = 0.7,\n  } = options;\n\n  // Generate query embedding\n  const queryEmbedding = await embedText(query);\n\n  // Build filter\n  const filter: Record<string, unknown> = {\n    must: [{ key: \"status\", match: { value: status } }],\n  };\n\n  if (docId) {\n    (filter.must as Array<unknown>).push({\n      key: \"doc_id\",\n      match: { value: docId },\n    });\n  }\n\n  // Retrieve more candidates if we're going to diversify\n  const candidateCount = diversify ? topK * 3 : topK;\n\n  // Search Qdrant\n  const results = await searchVectors(queryEmbedding, candidateCount, filter);\n\n  // Map results to chunks\n  let chunks: RetrievedChunk[] = results.map((r) => ({\n    chunkId: r.id,\n    docId: (r.payload.doc_id as string) || \"\",\n    docName: (r.payload.doc_name as string) || \"\",\n    pageNumber: (r.payload.page_number as number) || 0,\n    chunkIndex: (r.payload.chunk_index as number) || 0,\n    text: (r.payload.text as string) || \"\",\n    imageUrl: (r.payload.image_url as string) || \"\",\n    score: r.score,\n    parserUsed: (r.payload.parser_used as string) || \"\",\n  }));\n\n  // Apply MMR diversification if enabled\n  if (diversify && chunks.length > topK) {\n    chunks = applyMMR(chunks, topK, diversityWeight);\n  }\n\n  // Deduplicate by page (keep highest scoring chunk per page)\n  chunks = deduplicateByPage(chunks);\n\n  return chunks.slice(0, topK);\n}\n\n/**\n * Apply Maximal Marginal Relevance (MMR) to diversify results\n * This balances relevance (score) with diversity (avoid redundant chunks)\n */\nfunction applyMMR(\n  chunks: RetrievedChunk[],\n  topK: number,\n  lambda: number\n): RetrievedChunk[] {\n  if (chunks.length <= topK) return chunks;\n\n  const selected: RetrievedChunk[] = [];\n  const remaining = new Set(chunks.map((_, i) => i));\n\n  // Start with the highest scoring chunk\n  const firstIdx = 0;\n  selected.push(chunks[firstIdx]);\n  remaining.delete(firstIdx);\n\n  while (selected.length < topK && remaining.size > 0) {\n    let bestIdx = -1;\n    let bestScore = -Infinity;\n\n    for (const idx of remaining) {\n      const candidate = chunks[idx];\n\n      // Calculate relevance score (normalized)\n      const relevance = candidate.score;\n\n      // Calculate max similarity to already selected chunks\n      let maxSimilarity = 0;\n      for (const sel of selected) {\n        const sim = textSimilarity(candidate.text, sel.text);\n        maxSimilarity = Math.max(maxSimilarity, sim);\n      }\n\n      // MMR score: λ * relevance - (1-λ) * max_similarity\n      const mmrScore = lambda * relevance - (1 - lambda) * maxSimilarity;\n\n      if (mmrScore > bestScore) {\n        bestScore = mmrScore;\n        bestIdx = idx;\n      }\n    }\n\n    if (bestIdx !== -1) {\n      selected.push(chunks[bestIdx]);\n      remaining.delete(bestIdx);\n    } else {\n      break;\n    }\n  }\n\n  return selected;\n}\n\n/**\n * Simple text similarity based on Jaccard coefficient of words\n */\nfunction textSimilarity(text1: string, text2: string): number {\n  const words1 = new Set(text1.toLowerCase().split(/\\s+/));\n  const words2 = new Set(text2.toLowerCase().split(/\\s+/));\n\n  const intersection = new Set([...words1].filter((w) => words2.has(w)));\n  const union = new Set([...words1, ...words2]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Deduplicate chunks by page, keeping the highest scoring chunk per page\n */\nfunction deduplicateByPage(chunks: RetrievedChunk[]): RetrievedChunk[] {\n  const pageMap = new Map<string, RetrievedChunk>();\n\n  for (const chunk of chunks) {\n    const key = `${chunk.docId}:${chunk.pageNumber}`;\n    const existing = pageMap.get(key);\n\n    if (!existing || chunk.score > existing.score) {\n      pageMap.set(key, chunk);\n    }\n  }\n\n  // Sort by original score descending\n  return Array.from(pageMap.values()).sort((a, b) => b.score - a.score);\n}\n\n/**\n * Format retrieved chunks for use in LLM context\n */\nexport function formatContextForLLM(chunks: RetrievedChunk[]): string {\n  if (chunks.length === 0) {\n    return \"No relevant context found in the knowledge base.\";\n  }\n\n  const formattedChunks = chunks.map((chunk, index) => {\n    return `[${index + 1}] Document: \"${chunk.docName}\", Page ${chunk.pageNumber}\n${chunk.text}`;\n  });\n\n  return formattedChunks.join(\"\\n\\n---\\n\\n\");\n}\n\n/**\n * Extract citation information from retrieved chunks\n */\nexport async function extractCitations(\n  chunks: RetrievedChunk[]\n): Promise<CitationInfo[]> {\n  const citations: CitationInfo[] = [];\n\n  for (const chunk of chunks) {\n    // Get signed URL for page image\n    let signedImageUrl: string | undefined;\n    if (chunk.imageUrl) {\n      try {\n        signedImageUrl = await getSignedUrl(chunk.imageUrl);\n      } catch {\n        // Image URL generation failed, continue without it\n      }\n    }\n\n    citations.push({\n      docName: chunk.docName,\n      pageNumber: chunk.pageNumber,\n      imageUrl: signedImageUrl,\n      snippet:\n        chunk.text.length > 200\n          ? chunk.text.substring(0, 200) + \"...\"\n          : chunk.text,\n    });\n  }\n\n  return citations;\n}\n\n/**\n * Check if query can be answered from the knowledge base\n */\nexport async function hasRelevantContext(\n  query: string,\n  threshold: number = 0.6\n): Promise<boolean> {\n  const chunks = await retrieveContext(query, { topK: 3 });\n  return chunks.length > 0 && chunks[0].score >= threshold;\n}\n","import { ChatOpenAI } from \"@langchain/openai\";\nimport { retrieveContext, type RetrievedChunk } from \"./retrieval\";\n\n/**\n * Agentic RAG with Self-Reflection\n *\n * Flow: Query → Analyze → Retrieve → Reflect → (Re-search if needed) → Answer\n */\n\n// Configuration\nconst MAX_ITERATIONS = 3;\nconst CONFIDENCE_THRESHOLD = 0.7;\nconst TOP_K_PER_SEARCH = 8;\n\n// LLM for agent reasoning\nconst agentLLM = new ChatOpenAI({\n  modelName: \"gpt-4o-mini\", // Fast model for agent reasoning\n  temperature: 0,\n});\n\n/**\n * Query analysis result\n */\nexport interface QueryAnalysis {\n  originalQuery: string;\n  intent: string;\n  keyEntities: string[];\n  subQuestions: string[];\n  isMultiPart: boolean;\n  searchQueries: string[];\n}\n\n/**\n * Reflection result\n */\nexport interface ReflectionResult {\n  confidence: number; // 0-1\n  isSufficient: boolean;\n  answeredAspects: string[];\n  missingInformation: string[];\n  suggestedQueries: string[];\n  reasoning: string;\n}\n\n/**\n * Agent retrieval result\n */\nexport interface AgentRetrievalResult {\n  chunks: RetrievedChunk[];\n  iterations: number;\n  queryAnalysis: QueryAnalysis;\n  reflections: ReflectionResult[];\n  finalConfidence: number;\n  searchQueries: string[];\n}\n\n/**\n * Analyze the user's query to understand intent and decompose if needed\n */\nexport async function analyzeQuery(query: string): Promise<QueryAnalysis> {\n  const prompt = `You are a query analyzer for a knowledge base search system.\n\nAnalyze this user query and provide:\n1. The user's intent (what are they trying to find/understand?)\n2. Key entities or concepts mentioned\n3. If this is a multi-part question, break it into sub-questions\n4. Generate 1-3 search queries that would help find relevant information\n\nUser Query: \"${query}\"\n\nRespond in JSON format:\n{\n  \"intent\": \"brief description of what user wants to know\",\n  \"keyEntities\": [\"entity1\", \"entity2\"],\n  \"subQuestions\": [\"sub-question 1\", \"sub-question 2\"] or [],\n  \"isMultiPart\": true/false,\n  \"searchQueries\": [\"search query 1\", \"search query 2\"]\n}\n\nOnly output valid JSON, no markdown or explanation.`;\n\n  try {\n    const response = await agentLLM.invoke(prompt);\n    const content = typeof response.content === 'string'\n      ? response.content\n      : JSON.stringify(response.content);\n\n    // Parse JSON from response (handle potential markdown code blocks)\n    const jsonStr = content.replace(/```json\\n?|\\n?```/g, '').trim();\n    const analysis = JSON.parse(jsonStr);\n\n    return {\n      originalQuery: query,\n      intent: analysis.intent || query,\n      keyEntities: analysis.keyEntities || [],\n      subQuestions: analysis.subQuestions || [],\n      isMultiPart: analysis.isMultiPart || false,\n      searchQueries: analysis.searchQueries || [query],\n    };\n  } catch (error) {\n    console.warn(\"Query analysis failed, using original query:\", error);\n    return {\n      originalQuery: query,\n      intent: query,\n      keyEntities: [],\n      subQuestions: [],\n      isMultiPart: false,\n      searchQueries: [query],\n    };\n  }\n}\n\n/**\n * Evaluate if retrieved chunks sufficiently answer the query\n */\nexport async function reflectOnResults(\n  query: string,\n  analysis: QueryAnalysis,\n  chunks: RetrievedChunk[],\n  previousReflections: ReflectionResult[] = []\n): Promise<ReflectionResult> {\n  // Format chunks for evaluation\n  const chunksText = chunks\n    .slice(0, 10) // Limit for context window\n    .map((c, i) => `[${i + 1}] ${c.docName} (Page ${c.pageNumber}): ${c.text.slice(0, 500)}...`)\n    .join(\"\\n\\n\");\n\n  const previousAttempts = previousReflections.length > 0\n    ? `\\nPrevious search attempts:\\n${previousReflections.map((r, i) =>\n        `Attempt ${i + 1}: Confidence ${r.confidence}, Missing: ${r.missingInformation.join(\", \")}`\n      ).join(\"\\n\")}\\n`\n    : \"\";\n\n  const prompt = `You are evaluating if retrieved documents answer a user's question.\n\nUser Query: \"${query}\"\nIntent: ${analysis.intent}\n${analysis.subQuestions.length > 0 ? `Sub-questions: ${analysis.subQuestions.join(\", \")}` : \"\"}\n${previousAttempts}\n\nRetrieved Documents:\n${chunksText}\n\nEvaluate:\n1. Does this information answer the user's question? (confidence 0-1)\n2. What aspects of the question are answered?\n3. What information is still missing?\n4. If missing info, what search queries would help find it?\n\nRespond in JSON:\n{\n  \"confidence\": 0.0-1.0,\n  \"isSufficient\": true/false,\n  \"answeredAspects\": [\"aspect 1\", \"aspect 2\"],\n  \"missingInformation\": [\"missing info 1\"] or [],\n  \"suggestedQueries\": [\"refined query\"] or [],\n  \"reasoning\": \"brief explanation\"\n}\n\nOnly output valid JSON.`;\n\n  try {\n    const response = await agentLLM.invoke(prompt);\n    const content = typeof response.content === 'string'\n      ? response.content\n      : JSON.stringify(response.content);\n\n    const jsonStr = content.replace(/```json\\n?|\\n?```/g, '').trim();\n    const reflection = JSON.parse(jsonStr);\n\n    return {\n      confidence: Math.min(1, Math.max(0, reflection.confidence || 0)),\n      isSufficient: reflection.isSufficient ?? (reflection.confidence >= CONFIDENCE_THRESHOLD),\n      answeredAspects: reflection.answeredAspects || [],\n      missingInformation: reflection.missingInformation || [],\n      suggestedQueries: reflection.suggestedQueries || [],\n      reasoning: reflection.reasoning || \"\",\n    };\n  } catch (error) {\n    console.warn(\"Reflection failed:\", error);\n    // Default to accepting results if reflection fails\n    return {\n      confidence: 0.6,\n      isSufficient: true,\n      answeredAspects: [],\n      missingInformation: [],\n      suggestedQueries: [],\n      reasoning: \"Reflection failed, proceeding with available results\",\n    };\n  }\n}\n\n/**\n * Merge and deduplicate chunks from multiple searches\n */\nfunction mergeChunks(\n  existingChunks: RetrievedChunk[],\n  newChunks: RetrievedChunk[]\n): RetrievedChunk[] {\n  const seen = new Set<string>();\n  const merged: RetrievedChunk[] = [];\n\n  // Add existing chunks first (they have priority)\n  for (const chunk of existingChunks) {\n    const key = `${chunk.docId}-${chunk.pageNumber}-${chunk.chunkIndex}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      merged.push(chunk);\n    }\n  }\n\n  // Add new chunks that aren't duplicates\n  for (const chunk of newChunks) {\n    const key = `${chunk.docId}-${chunk.pageNumber}-${chunk.chunkIndex}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      merged.push(chunk);\n    }\n  }\n\n  // Sort by score and limit\n  return merged\n    .sort((a, b) => b.score - a.score)\n    .slice(0, TOP_K_PER_SEARCH * 2); // Keep more for multi-search\n}\n\n/**\n * Main agentic retrieval function\n *\n * Performs iterative retrieval with self-reflection until sufficient\n * information is gathered or max iterations reached.\n */\nexport async function agenticRetrieve(\n  query: string,\n  options: {\n    docId?: string;\n    maxIterations?: number;\n    confidenceThreshold?: number;\n    verbose?: boolean;\n  } = {}\n): Promise<AgentRetrievalResult> {\n  const {\n    docId,\n    maxIterations = MAX_ITERATIONS,\n    confidenceThreshold = CONFIDENCE_THRESHOLD,\n    verbose = true,\n  } = options;\n\n  const reflections: ReflectionResult[] = [];\n  const allSearchQueries: string[] = [];\n  let allChunks: RetrievedChunk[] = [];\n  let iteration = 0;\n  let finalConfidence = 0;\n\n  // Step 1: Analyze the query\n  if (verbose) console.log(`[Agent] Analyzing query: \"${query}\"`);\n  const analysis = await analyzeQuery(query);\n  if (verbose) {\n    console.log(`[Agent] Intent: ${analysis.intent}`);\n    console.log(`[Agent] Search queries: ${analysis.searchQueries.join(\", \")}`);\n  }\n\n  // Step 2: Initial retrieval with all search queries\n  for (const searchQuery of analysis.searchQueries) {\n    allSearchQueries.push(searchQuery);\n    if (verbose) console.log(`[Agent] Searching: \"${searchQuery}\"`);\n\n    const chunks = await retrieveContext(searchQuery, {\n      topK: TOP_K_PER_SEARCH,\n      docId,\n      diversify: true,\n    });\n\n    allChunks = mergeChunks(allChunks, chunks);\n  }\n\n  if (verbose) console.log(`[Agent] Retrieved ${allChunks.length} chunks`);\n\n  // Step 3: Self-reflection loop\n  while (iteration < maxIterations) {\n    iteration++;\n    if (verbose) console.log(`[Agent] Reflection iteration ${iteration}...`);\n\n    // Reflect on current results\n    const reflection = await reflectOnResults(\n      query,\n      analysis,\n      allChunks,\n      reflections\n    );\n    reflections.push(reflection);\n    finalConfidence = reflection.confidence;\n\n    if (verbose) {\n      console.log(`[Agent] Confidence: ${reflection.confidence.toFixed(2)}`);\n      console.log(`[Agent] Sufficient: ${reflection.isSufficient}`);\n      if (reflection.missingInformation.length > 0) {\n        console.log(`[Agent] Missing: ${reflection.missingInformation.join(\", \")}`);\n      }\n    }\n\n    // Check if we should stop\n    if (reflection.isSufficient || reflection.confidence >= confidenceThreshold) {\n      if (verbose) console.log(`[Agent] Results sufficient, stopping.`);\n      break;\n    }\n\n    // Check if we have new queries to try\n    if (reflection.suggestedQueries.length === 0) {\n      if (verbose) console.log(`[Agent] No new queries suggested, stopping.`);\n      break;\n    }\n\n    // Step 4: Re-search with suggested queries\n    for (const newQuery of reflection.suggestedQueries) {\n      // Avoid repeating the same query\n      if (allSearchQueries.includes(newQuery)) continue;\n\n      allSearchQueries.push(newQuery);\n      if (verbose) console.log(`[Agent] Re-searching: \"${newQuery}\"`);\n\n      const newChunks = await retrieveContext(newQuery, {\n        topK: TOP_K_PER_SEARCH,\n        docId,\n        diversify: true,\n      });\n\n      allChunks = mergeChunks(allChunks, newChunks);\n    }\n\n    if (verbose) console.log(`[Agent] Total chunks: ${allChunks.length}`);\n  }\n\n  if (verbose) {\n    console.log(`[Agent] Completed in ${iteration} iteration(s)`);\n    console.log(`[Agent] Final confidence: ${finalConfidence.toFixed(2)}`);\n    console.log(`[Agent] Total search queries: ${allSearchQueries.length}`);\n  }\n\n  return {\n    chunks: allChunks,\n    iterations: iteration,\n    queryAnalysis: analysis,\n    reflections,\n    finalConfidence,\n    searchQueries: allSearchQueries,\n  };\n}\n\n/**\n * Format agent retrieval result for LLM context\n */\nexport function formatAgentContextForLLM(result: AgentRetrievalResult): string {\n  if (result.chunks.length === 0) {\n    return \"No relevant documents found in the knowledge base.\";\n  }\n\n  const contextBlocks = result.chunks.map((chunk, index) => {\n    return `[${index + 1}] Document: \"${chunk.docName}\", Page ${chunk.pageNumber}\n${chunk.text}`;\n  });\n\n  const searchInfo = `Search conducted with ${result.iterations} iteration(s), ${result.searchQueries.length} queries, confidence ${result.finalConfidence.toFixed(2)}`;\n\n  return `${searchInfo}\\n\\n---\\n\\n${contextBlocks.join(\"\\n\\n---\\n\\n\")}`;\n}\n\n/**\n * Get agent metadata for response\n */\nexport function getAgentMetadata(result: AgentRetrievalResult): {\n  iterations: number;\n  confidence: number;\n  searchQueries: string[];\n  intent: string;\n} {\n  return {\n    iterations: result.iterations,\n    confidence: result.finalConfidence,\n    searchQueries: result.searchQueries,\n    intent: result.queryAnalysis.intent,\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}