{"version":3,"sources":["../../../node_modules/%40smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                        break;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}